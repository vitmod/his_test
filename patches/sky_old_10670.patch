Index: Makefile
===================================================================
--- Makefile	(revision 10670)
+++ Makefile	(working copy)
@@ -2,18 +2,14 @@
 
 .SUFFIXES:
 .SUFFIXES: .o .c
-.PHONY: all tests help README.build README.config simple default debug config menuconfig allyesconfig allnoconfig defconfig clean distclean
+.PHONY: all help README.build README.config simple default debug config menuconfig allyesconfig allnoconfig defconfig clean distclean
 
 VER     := $(shell ./config.sh --oscam-version)
-SVN_REV := $(shell ./config.sh --oscam-revision)
+SVN_REVI := $(shell ./config.sh --oscam-revision)
+SVN_REV   = $(SVN_REVI)
 
 uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')
 
-# This let's us use uname_S tests to detect cygwin
-ifneq (,$(findstring CYGWIN,$(uname_S)))
-	uname_S := Cygwin
-endif
-
 LINKER_VER_OPT:=-Wl,--version
 
 # Find OSX SDK
@@ -35,7 +31,13 @@
 	override USE_LIBCRYPTO=1
 endif
 
-CONF_DIR = /usr/local/etc
+# sky
+ifeq ($(CONF_DIR),"")
+# CONF_DIR = /usr/local/etc
+# CONF_DIR = /data/oscam
+# CONF_DIR = /sdcard/Android/data/org.xbmc.xbmc/files/.xbmc/userdata/Oscam
+CONF_DIR	  = /data/oscam
+endif
 
 LIB_PTHREAD = -lpthread
 LIB_DL = -ldl
@@ -55,14 +57,19 @@
 
 # Compiler warnings
 CC_WARN = -W -Wall -Wshadow -Wredundant-decls -Wstrict-prototypes -Wold-style-definition
-
+# sky(n, -Wno-unused-but-set-variable)
+CC_WARN+= -Wno-unused-function -Wno-unused-parameter
 # Compiler optimizations
 CC_OPTS = -O2 -ggdb -pipe -ffunction-sections -fdata-sections
+# sky(PIE)
+CC_OPTS = -fPIE
 
 CC = $(CROSS_DIR)$(CROSS)gcc
 STRIP = $(CROSS_DIR)$(CROSS)strip
 
 LDFLAGS = -Wl,--gc-sections
+# sky(PIE)
+LDFLAGS = -fPIE -pie
 
 # The linker for powerpc have bug that prevents --gc-sections from working
 # Check for the linker version and if it matches disable --gc-sections
@@ -94,6 +101,10 @@
 DEFAULT_COOLAPI_LIB = -lnxp -lrt
 DEFAULT_SU980_LIB = -lentropic -lrt
 DEFAULT_AZBOX_LIB = -Lextapi/openxcas -lOpenXCASAPI
+# sky(n)
+DEFAULT_HISKY_LIB = $(HISKY_LIB)
+DEFAULT_HISKY_FLAGS = $(HISKY_FLAGS)
+
 DEFAULT_LIBCRYPTO_LIB = -lcrypto
 DEFAULT_SSL_LIB = -lssl
 ifeq ($(uname_S),Linux)
@@ -101,37 +112,14 @@
 else
 DEFAULT_LIBUSB_LIB = -lusb-1.0
 endif
-# Since FreeBSD 8 (released in 2010) they are using their own
-# libusb that is API compatible to libusb but with different soname
-ifeq ($(uname_S),FreeBSD)
-DEFAULT_LIBUSB_LIB = -lusb
-endif
 ifeq ($(uname_S),Darwin)
-DEFAULT_LIBUSB_FLAGS = -I/opt/local/include
-DEFAULT_LIBUSB_LIB = -L/opt/local/lib -lusb-1.0
-DEFAULT_PCSC_FLAGS = -isysroot $(OSX_SDK)
-DEFAULT_PCSC_LIB = -isysroot $(OSX_SDK) -framework IOKit -framework CoreFoundation -framework PCSC
+DEFAULT_PCSC_FLAGS = -isysroot $(OSX_SDK) -I/usr/local/include
+DEFAULT_PCSC_LIB   = -syslibroot,$(OSX_SDK) -framework IOKit -framework CoreFoundation -framework PCSC -L/usr/local/lib
 else
-# Get the compiler's last include PATHs. Basicaly it is /usr/include
-# but in case of cross compilation it might be something else.
-#
-# Since using -Iinc_path instructs the compiler to use inc_path
-# (without add the toolchain system root) we need to have this hack
-# to get the "real" last include path. Why we needs this?
-# Well, the PCSC headers are broken and rely on having the directory
-# that they are installed it to be in the include PATH.
-#
-# We can't just use -I/usr/include/PCSC because it won't work in
-# case of cross compilation.
-TOOLCHAIN_INC_DIR := $(strip $(shell echo | $(CC) -Wp,-v -xc - -fsyntax-only 2>&1 | grep include$ | tail -n 1))
-DEFAULT_PCSC_FLAGS = -I$(TOOLCHAIN_INC_DIR)/PCSC -I$(TOOLCHAIN_INC_DIR)/../local/include/PCSC
+DEFAULT_PCSC_FLAGS = -I/usr/include/PCSC
 DEFAULT_PCSC_LIB = -lpcsclite
 endif
 
-ifeq ($(uname_S),Cygwin)
-DEFAULT_PCSC_LIB += -lwinscard
-endif
-
 # Function to initialize USE related variables
 #   Usage: $(eval $(call prepare_use_flags,FLAG_NAME,PLUS_TARGET_TEXT))
 define prepare_use_flags
@@ -153,6 +141,7 @@
 
 # Initialize USE variables
 $(eval $(call prepare_use_flags,STAPI,stapi))
+$(eval $(call prepare_use_flags,HISKY,his))
 $(eval $(call prepare_use_flags,COOLAPI,coolapi))
 $(eval $(call prepare_use_flags,SU980,su980))
 $(eval $(call prepare_use_flags,AZBOX,azbox))
@@ -198,8 +187,9 @@
 # These variables will be used to select only needed files for compilation
 -include $(OBJDIR)/config.mak
 
-OSCAM_BIN := $(BINDIR)/oscam-$(VER)$(SVN_REV)-$(subst cygwin,cygwin.exe,$(TARGET))
-TESTS_BIN := tests.bin
+# sky(!)
+# OSCAM_BIN := $(BINDIR)/oscam-$(VER)$(SVN_REV)-$(subst cygwin,cygwin.exe,$(TARGET))
+OSCAM_BIN := $(BINDIR)/oscam-$(VER).$(SVN_REV)
 LIST_SMARGO_BIN := $(BINDIR)/list_smargo-$(VER)$(SVN_REV)-$(subst cygwin,cygwin.exe,$(TARGET))
 
 # Build list_smargo-.... only when WITH_LIBUSB build is requested.
@@ -227,12 +217,17 @@
 SRC-y += cscrypt/md5.c
 SRC-$(CONFIG_LIB_RC6) += cscrypt/rc6.c
 SRC-$(CONFIG_LIB_SHA1) += cscrypt/sha1.c
+# sky(n)
+SRC-$(CONFIG_MODULE_XCAS)  	  += cscrypt/aes_ctx.c
+SRC-$(CONFIG_MODULE_XCAS)  	  += cscrypt/des_ssl.c
 
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/atr.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/icc_async.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/io_serial.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/protocol_t0.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/protocol_t1.c
+# sky(n)
+SRC-$(CONFIG_CARDREADER_INTERNAL_HISKY) += csctapi/ifd_hisky.c
 SRC-$(CONFIG_CARDREADER_INTERNAL_AZBOX) += csctapi/ifd_azbox.c
 SRC-$(CONFIG_CARDREADER_INTERNAL_COOLAPI) += csctapi/ifd_cool.c
 SRC-$(CONFIG_CARDREADER_DB2COM) += csctapi/ifd_db2com.c
@@ -263,6 +258,8 @@
 SRC-$(CONFIG_WITH_MCA) += module-dvbapi-mca.c
 SRC-$(CONFIG_WITH_COOLAPI) += module-dvbapi-coolapi.c
 SRC-$(CONFIG_WITH_SU980) += module-dvbapi-coolapi.c
+# sky(n)
+SRC-$(CONFIG_WITH_HISILICON) += module-dvbapi-his.c
 SRC-$(CONFIG_WITH_STAPI) += module-dvbapi-stapi.c
 SRC-$(CONFIG_HAVE_DVBAPI) += module-dvbapi-chancache.c
 SRC-$(CONFIG_HAVE_DVBAPI) += module-dvbapi.c
@@ -275,6 +272,14 @@
 SRC-$(CONFIG_LEDSUPPORT) += module-led.c
 SRC-$(CONFIG_MODULE_MONITOR) += module-monitor.c
 SRC-$(CONFIG_MODULE_NEWCAMD) += module-newcamd.c
+SRC-$(CONFIG_MODULE_XCAS)	+= module-xcas.c
+SRC-$(CONFIG_MODULE_XCAS)	+= emu-key.c
+SRC-$(CONFIG_MODULE_XCAS)	+= emu-xviacess.c
+SRC-$(CONFIG_MODULE_XCAS)	+= emu-xbiss.c
+SRC-$(CONFIG_MODULE_XCAS)	+= emu-xcryptoworks.c
+SRC-$(CONFIG_MODULE_XCAS)	+= emu-xseka.c
+SRC-$(CONFIG_MODULE_XCAS)	+= emu-xpowervu.c
+
 SRC-$(CONFIG_MODULE_PANDORA) += module-pandora.c
 SRC-$(CONFIG_MODULE_GHTTP) += module-ghttp.c
 SRC-$(CONFIG_MODULE_RADEGAST) += module-radegast.c
@@ -333,10 +338,6 @@
 SRC-y += oscam.c
 # config.c is automatically generated by config.sh in OBJDIR
 SRC-y += config.c
-ifdef BUILD_TESTS
-SRC-y += tests.c
-override STD_DEFS += -DBUILD_TESTS=1
-endif
 
 SRC := $(SRC-y)
 OBJ := $(addprefix $(OBJDIR)/,$(subst .c,.o,$(SRC)))
@@ -399,13 +400,15 @@
 
 -include $(subst .o,.d,$(OBJ))
 
-tests:
-	@-$(MAKE) --no-print-directory BUILD_TESTS=1 OSCAM_BIN=$(TESTS_BIN)
-	@-touch oscam.c
-# The above is really hideous hack :-) If we don't force oscam.c recompilation
-# after we've build the tests binary, the next "normal" compilation would fail
-# because there would be no run_tests() function. So the touch is there to
-# ensure oscam.c would be recompiled.
+TESTS_SRC += oscam-array.c
+TESTS_SRC += oscam-conf-mk.c
+TESTS_SRC += oscam-conf-chk.c
+TESTS_SRC += oscam-string.c
+TESTS_SRC += oscam-llist.c
+
+tests: Makefile globals.h $(subst .c,.h,$(TESTS_SRC)) $(TESTS_SRC) tests.c
+	$(SAY) "BUILD	$@"
+	$(Q)$(CC) $(STD_DEFS) $(CC_OPTS) $(CC_WARN) $(CFLAGS) $(LDFLAGS) $(TESTS_SRC) tests.c -o $@
 
 config:
 	$(SHELL) ./config.sh --gui
@@ -425,7 +428,7 @@
 	@-$(SHELL) ./config.sh --restore
 
 clean:
-	@-for FILE in $(BUILD_DIR)/* $(TESTS_BIN) $(TESTS_BIN).debug; do \
+	@-for FILE in $(BUILD_DIR)/* tests; do \
 		echo "RM	$$FILE"; \
 		rm -rf $$FILE; \
 	done
@@ -581,6 +584,14 @@
                      In order for USE_SU980 to work you have to have libentropic.a\n\
                      library in your cross compilation toolchain.\n\
 \n\
+   USE_HISKY=1    - Request support for HISKY (android)\n\
+                    box. The variables that control the build are:\n\
+                     HISKY_FLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_CFLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_LDFLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_LIB='$(DEFAULT_HISKY_LIB)'\n\
+                     Using USE_HISKY=1 adds to '-hisky' to PLUS_TARGET.\n\
+\n\
    USE_AZBOX=1    - Request support for AZBOX (openxcas)\n\
                     box. The variables that control the build are:\n\
                          AZBOX_FLAGS='$(DEFAULT_AZBOX_FLAGS)'\n\
@@ -701,7 +712,7 @@
     make static-ssl    - Builds OSCam with SSL support linked statically\n\
 \n\
  Developer targets:\n\
-    make tests         - Builds '$(TESTS_BIN)' binary\n\
+    make tests         - Builds 'tests' binary\n\
 \n\
  Examples:\n\
    Build OSCam for SH4 (the compilers are in the path):\n\
@@ -718,6 +729,8 @@
      make CROSS=arm-cx2450x-linux-gnueabi- USE_COOLAPI=1\n\n\
    Build OSCam for MIPSEL with AZBOX support:\n\
      make CROSS=mipsel-linux-uclibc- USE_AZBOX=1\n\n\
+   Build OSCam for ARM ANDROID with HISKY support:\n\
+     make CROSS=arm-linux-android- USE_HISKY=1\n\n\
    Build OSCam for ARM with MCA support:\n\
      make CROSS=arm-none-linux-gnueabi- USE_MCA=1\n\n\
    Build OSCam with libusb and PCSC:\n\
Index: Makefile.extra
===================================================================
--- Makefile.extra	(revision 10670)
+++ Makefile.extra	(working copy)
@@ -277,6 +277,13 @@
 		EXTRA_TARGET=-static \
 		$(MAKEFLAGS)
 
+android-arm-hisky:
+	$(MAKE) --no-print-directory \
+		LIB_RT= \
+		LIB_PTHREAD= \
+		CROSS=arm-linux-androideabi- \
+		USE_HISKY=1 \
+		$(MAKEFLAGS)
 android-arm:
 	$(MAKE) --no-print-directory \
 		LIB_RT= \
Index: README.build
===================================================================
--- README.build	(revision 10670)
+++ README.build	(working copy)
@@ -84,9 +84,9 @@
 
    USE_PCSC=1      - Request linking with PCSC. The variables that control
                      USE_PCSC=1 build are:
-                         PCSC_FLAGS='-DWITH_PCSC=1 -I/usr/include/PCSC -I/usr/include/../local/include/PCSC'
-                         PCSC_CFLAGS='-DWITH_PCSC=1 -I/usr/include/PCSC -I/usr/include/../local/include/PCSC'
-                         PCSC_LDFLAGS='-DWITH_PCSC=1 -I/usr/include/PCSC -I/usr/include/../local/include/PCSC'
+                         PCSC_FLAGS='-DWITH_PCSC=1 -I/usr/include/PCSC'
+                         PCSC_CFLAGS='-DWITH_PCSC=1 -I/usr/include/PCSC'
+                         PCSC_LDFLAGS='-DWITH_PCSC=1 -I/usr/include/PCSC'
                          PCSC_LIB='-lpcsclite'
                      Using USE_PCSC=1 adds to '-pcsc' to PLUS_TARGET.
                      To build with static PCSC, set the variable PCSC_LIB
@@ -242,9 +242,6 @@
     make static-libcrypto - Builds OSCam with libcrypto linked statically
     make static-ssl    - Builds OSCam with SSL support linked statically
 
- Developer targets:
-    make tests         - Builds 'tests.bin' binary
-
  Examples:
    Build OSCam for SH4 (the compilers are in the path):
      make CROSS=sh4-linux-
Index: config.h
===================================================================
--- config.h	(revision 10670)
+++ config.h	(working copy)
@@ -1,30 +1,30 @@
 #ifndef CONFIG_H_
 #define CONFIG_H_
 
+#define WITH_DEBUG 1
 #define WEBIF 1
-#define WEBIF_LIVELOG 1
-#define WEBIF_JQUERY 1
 #define TOUCH 1
 //#define WITH_SSL 1
 #if defined(__linux__) || defined(__CYGWIN__)
 #define HAVE_DVBAPI 1
 #endif
-#define CLOCKFIX 1
 #define IRDETO_GUESSING 1
 #define CS_ANTICASC 1
-#define WITH_DEBUG 1
 #define WITH_LB 1
 #define CS_CACHEEX 1
 #define CW_CYCLE_CHECK 1
 //#define LCDSUPPORT 1
 //#define LEDSUPPORT 1
 //#define IPV6SUPPORT 1
-#define MODULE_MONITOR 1
+#define WEBIF_LIVELOG 1
+#define WEBIF_JQUERY 1
 
-//#define MODULE_CAMD33 1
+#define MODULE_MONITOR 1
+#define MODULE_CAMD33 1
 #define MODULE_CAMD35 1
 #define MODULE_CAMD35_TCP 1
 #define MODULE_NEWCAMD 1
+#define MODULE_XCAS 1
 #define MODULE_CCCAM 1
 #define MODULE_CCCSHARE 1
 #define MODULE_GBOX 1
@@ -52,13 +52,13 @@
 #define READER_GRIFFIN 1
 #define READER_DGCRYPT 1
 
-#define CARDREADER_PHOENIX 1
+//#define CARDREADER_PHOENIX 1
 #define CARDREADER_INTERNAL 1
-#define CARDREADER_MP35 1
-#define CARDREADER_SC8IN1 1
-#define CARDREADER_SMARGO 1
-#define CARDREADER_DB2COM 1
-#define CARDREADER_STINGER 1
+//#define CARDREADER_MP35 1
+//#define CARDREADER_SC8IN1 1
+//#define CARDREADER_SMARGO 1
+//#define CARDREADER_DB2COM 1
+//#define CARDREADER_STINGER 1
 
 #ifdef WITH_PCSC
 #define CARDREADER_PCSC 1
@@ -68,9 +68,11 @@
 #define CARDREADER_SMART 1
 #endif
 
-// CARDREADER_INTERNAL_{AZBOX,COOLAPI,SCI} are internal variables
+// CARDREADER_INTERNAL_{HISKY,AZBOX,COOLAPI,SCI} are internal variables
 // do not touch them
-#if   defined(CARDREADER_INTERNAL) && defined(WITH_AZBOX)
+#if defined(CARDREADER_INTERNAL) && defined(WITH_HISILICON)
+#define CARDREADER_INTERNAL_HISKY 	1
+#elif defined(CARDREADER_INTERNAL) &&  defined(WITH_AZBOX)
 #define CARDREADER_INTERNAL_AZBOX 1
 #elif defined(CARDREADER_INTERNAL) && (defined(WITH_COOLAPI) || defined(WITH_SU980))
 #define CARDREADER_INTERNAL_COOLAPI 1
@@ -79,7 +81,7 @@
 #endif
 
 #ifdef WITH_STAPI
-#define CARDREADER_STAPI 1
+//#define CARDREADER_STAPI 1
 #endif
 
 #endif // WITH_CARDREADER
Index: config.sh
===================================================================
--- config.sh	(revision 10670)
+++ config.sh	(working copy)
@@ -1,9 +1,9 @@
 #!/bin/sh
 
-addons="WEBIF WEBIF_LIVELOG WEBIF_JQUERY TOUCH WITH_SSL HAVE_DVBAPI IRDETO_GUESSING CS_ANTICASC WITH_DEBUG MODULE_MONITOR WITH_LB CS_CACHEEX CW_CYCLE_CHECK LCDSUPPORT LEDSUPPORT CLOCKFIX IPV6SUPPORT"
-protocols="MODULE_CAMD33 MODULE_CAMD35 MODULE_CAMD35_TCP MODULE_NEWCAMD MODULE_CCCAM MODULE_CCCSHARE MODULE_GBOX MODULE_RADEGAST MODULE_SCAM MODULE_SERIAL MODULE_CONSTCW MODULE_PANDORA MODULE_GHTTP"
+addons="WEBIF WEBIF_LIVELOG WEBIF_JQUERY TOUCH WITH_SSL HAVE_DVBAPI IRDETO_GUESSING CS_ANTICASC WITH_DEBUG MODULE_MONITOR WITH_SSL WITH_LB CS_CACHEEX CW_CYCLE_CHECK LCDSUPPORT LEDSUPPORT CLOCKFIX IPV6SUPPORT CLOCKFIX"
+protocols="MODULE_XCAS MODULE_CAMD33 MODULE_CAMD35 MODULE_CAMD35_TCP MODULE_NEWCAMD MODULE_CCCAM MODULE_CCCSHARE MODULE_GBOX MODULE_RADEGAST MODULE_SCAM MODULE_SERIAL MODULE_CONSTCW MODULE_PANDORA MODULE_GHTTP"
 readers="READER_NAGRA READER_IRDETO READER_CONAX READER_CRYPTOWORKS READER_SECA READER_VIACCESS READER_VIDEOGUARD READER_DRE READER_TONGFANG READER_BULCRYPT READER_GRIFFIN READER_DGCRYPT"
-card_readers="CARDREADER_PHOENIX CARDREADER_INTERNAL CARDREADER_SC8IN1 CARDREADER_MP35 CARDREADER_SMARGO CARDREADER_DB2COM CARDREADER_STAPI CARDREADER_STINGER"
+card_readers="CARDREADER_INTERNAL CARDREADER_PHOENIX CARDREADER_SC8IN1 CARDREADER_MP35 CARDREADER_SMARGO CARDREADER_DB2COM CARDREADER_STAPI CARDREADER_STINGER"
 
 defconfig="
 CONFIG_WEBIF=y
@@ -21,9 +21,10 @@
 CONFIG_CW_CYCLE_CHECK=y
 # CONFIG_LCDSUPPORT=n
 # CONFIG_LEDSUPPORT=n
-CONFIG_CLOCKFIX=y
+# CONFIG_CLOCKFIX=y
 # CONFIG_IPV6SUPPORT=n
 # CONFIG_MODULE_CAMD33=n
+CONFIG_MODULE_XCAS=y
 CONFIG_MODULE_CAMD35=y
 CONFIG_MODULE_CAMD35_TCP=y
 CONFIG_MODULE_NEWCAMD=y
@@ -300,6 +301,7 @@
 	have_flag USE_STAPI && echo "CONFIG_WITH_STAPI=y" || echo "# CONFIG_WITH_STAPI=n"
 	have_flag USE_COOLAPI && echo "CONFIG_WITH_COOLAPI=y" || echo "# CONFIG_WITH_COOLAPI=n"
 	have_flag USE_SU980 && echo "CONFIG_WITH_SU980=y" || echo "# CONFIG_WITH_SU980=n"
+	have_flag USE_HISKY && echo "CONFIG_WITH_HISILICON=y" || echo "# CONFIG_WITH_HISILICON=n"
 	have_flag USE_AZBOX && echo "CONFIG_WITH_AZBOX=y" || echo "# CONFIG_WITH_AZBOX=n"
 	have_flag USE_MCA && echo "CONFIG_WITH_MCA=y" || echo "# CONFIG_WITH_MCA=n"
 	have_flag USE_LIBCRYPTO && echo "CONFIG_WITH_LIBCRYPTO=y" || echo "# CONFIG_WITH_LIBCRYPTO=n"
@@ -312,9 +314,10 @@
 		if [ $OPT = CARDREADER_INTERNAL ]
 		then
 			# Internal card reader is actually three different readers depending on USE flags
+			enabled $OPT && have_flag USE_HISKY && echo "CONFIG_${OPT}_HISKY=y" || echo "# CONFIG_${OPT}_HISKY=n"
 			enabled $OPT && have_flag USE_AZBOX && echo "CONFIG_${OPT}_AZBOX=y" || echo "# CONFIG_${OPT}_AZBOX=n"
 			enabled $OPT && have_any_flags USE_COOLAPI USE_SU980 && echo "CONFIG_${OPT}_COOLAPI=y" || echo "# CONFIG_${OPT}_COOLAPI=n"
-			enabled $OPT && not_have_all_flags USE_AZBOX USE_COOLAPI USE_SU980 && echo "CONFIG_${OPT}_SCI=y" || echo "# CONFIG_${OPT}_SCI=n"
+			enabled $OPT && not_have_all_flags USE_HISKY USE_AZBOX USE_COOLAPI USE_SU980 && echo "CONFIG_${OPT}_SCI=y" || echo "# CONFIG_${OPT}_SCI=n"
 			continue
 		fi
 		if [ $OPT = CARDREADER_STAPI ]
@@ -330,9 +333,9 @@
 	# Extra modules/libraries
 	enabled_any MODULE_GBOX WEBIF && echo "CONFIG_LIB_MINILZO=y" || echo "# CONFIG_LIB_MINILZO=n"
 	not_have_flag USE_LIBCRYPTO && echo "CONFIG_LIB_AES=y" || echo "# CONFIG_LIB_AES=n"
-	enabled MODULE_CCCAM && echo "CONFIG_LIB_RC6=y" || echo "# CONFIG_LIB_RC6=n"
+	enabled_any MODULE_CCCAM MODULE_XCAS && echo "CONFIG_LIB_RC6=y" || echo "# CONFIG_LIB_RC6=n"
 	not_have_flag USE_LIBCRYPTO && enabled MODULE_CCCAM && echo "CONFIG_LIB_SHA1=y" || echo "# CONFIG_LIB_SHA1=n"
-	enabled_any MODULE_NEWCAMD READER_DRE MODULE_SCAM && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
+	enabled_any MODULE_NEWCAMD MODULE_XCAS READER_DRE MODULE_SCAM && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
 	enabled_any MODULE_CCCAM READER_NAGRA READER_SECA && echo "CONFIG_LIB_IDEA=y" || echo "# CONFIG_LIB_IDEA=n"
 	not_have_flag USE_LIBCRYPTO && enabled_any READER_CONAX READER_CRYPTOWORKS READER_NAGRA && echo "CONFIG_LIB_BIGNUM=y" || echo "# CONFIG_LIB_BIGNUM=n"
 }
@@ -455,6 +458,7 @@
 
 menu_protocols() {
 	${DIALOG} --checklist "\nChoose protocols:\n " $height $width $listheight \
+		MODULE_XCAS			"xcas"			$(check_test "MODULE_XCAS") \
 		MODULE_CAMD33		"camd 3.3"			$(check_test "MODULE_CAMD33") \
 		MODULE_CAMD35		"camd 3.5 UDP"		$(check_test "MODULE_CAMD35") \
 		MODULE_CAMD35_TCP	"camd 3.5 TCP"		$(check_test "MODULE_CAMD35_TCP") \
@@ -503,7 +507,7 @@
 menu_card_readers() {
 	${DIALOG} --checklist "\nChoose card reader drivers:\n " $height $width $listheight \
 		CARDREADER_PHOENIX	"Phoenix/mouse"					$(check_test "CARDREADER_PHOENIX") \
-		CARDREADER_INTERNAL	"Internal (Sci,Azbox,Cool)"		$(check_test "CARDREADER_INTERNAL") \
+		CARDREADER_INTERNAL	"Internal (Hisky,Sci,Azbox,Cool)"	$(check_test "CARDREADER_INTERNAL") \
 		CARDREADER_SC8IN1	"SC8in1"						$(check_test "CARDREADER_SC8IN1") \
 		CARDREADER_MP35		"AD-Teknik MP 3.6/USB Phoenix"	$(check_test "CARDREADER_MP35") \
 		CARDREADER_SMARGO	"Argolis Smargo Smartreader"	$(check_test "CARDREADER_SMARGO") \
@@ -584,12 +588,6 @@
 	'-s'|'--show-enabled'|'--show')
 		shift
 		list_enabled $(get_opts $1)
-		# Take special care of USE_xxx flags
-		if [ "$1" = "card_readers" ]
-		then
-			have_flag USE_LIBUSB && echo "CARDREADER_SMART"
-			have_flag USE_PCSC && echo "CARDREADER_PCSC"
-		fi
 		break
 		;;
 	'-Z'|'--show-disabled')
Index: cscrypt/aes_ctx.c
===================================================================
--- cscrypt/aes_ctx.c	(nonexistent)
+++ cscrypt/aes_ctx.c	(working copy)
@@ -0,0 +1,742 @@
+// sky(n)
+#if !defined(WITH_LIBCRYPTO)
+//FIXME Not checked on threadsafety yet; after checking please remove this line
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "aes_ctx.h"
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+// -- -AES -------------------------------------------------------------
+// uncomment the following line to use pre-computed tables
+// otherwise the tables will be generated at the first run
+
+#if !defined(AES_FIXED_TABLES)
+
+// forward S-box & tables
+static unsigned int FSb[256];
+static unsigned int FT0[256];
+static unsigned int FT1[256];
+static unsigned int FT2[256];
+static unsigned int FT3[256];
+
+// reverse S-box & tables
+static unsigned int RSb[256];
+static unsigned int RT0[256];
+static unsigned int RT1[256];
+static unsigned int RT2[256];
+static unsigned int RT3[256];
+
+// round constants
+static unsigned int RCON[10];
+
+// tables generation flag
+static int do_init = 1;
+
+// tables generation routine
+#define ROTR8(x)		(((x << 24) & 0xFFFFFFFF) | ((x & 0xFFFFFFFF) >>  8))
+#define XTIME(x)		 ((x <<  1) ^ ((x & 0x80) ? 0x1B : 0x00))
+#define AES_MUL(x,y)	 ((x &&  y) ? powK[(log[x] + logK[y]) % 255] : 0)
+
+void
+AES_gen_tables(void)
+{
+	int i;
+	unsigned char x, y, powK[256], logK[256];
+
+	/* compute pow and log tables over GF(2^8) */
+	for (i = 0, x = 1; i < 256; i++, x ^= XTIME(x))
+	{
+		powK[i] = x;
+		logK[x] = i;
+	}
+
+	/* calculate the round constants */
+	for (i = 0, x = 1; i < 10; i++, x = XTIME(x))
+		RCON[i] = (unsigned int) x << 24;
+
+	/* generate the forward and reverse S-boxes */
+	FSb[0x00] = 0x63;
+	RSb[0x63] = 0x00;
+
+	for (i = 1; i < 256; i++)
+	{
+		x = powK[255 - logK[i]];
+
+		y = x;	y = (y << 1) | (y >> 7);
+		x ^= y; y = (y << 1) | (y >> 7);
+		x ^= y; y = (y << 1) | (y >> 7);
+		x ^= y; y = (y << 1) | (y >> 7);
+		x ^= y ^ 0x63;
+
+		FSb[i] = x;
+		RSb[x] = i;
+	}
+
+	/* generate the forward and reverse tables */
+	for (i = 0; i < 256; i++)
+	{
+		x = (unsigned char) FSb[i]; y = XTIME(x);
+
+		FT0[i] =   (unsigned int) (x ^ y) ^
+				 ((unsigned int) x <<  8) ^
+				 ((unsigned int) x << 16) ^
+				 ((unsigned int) y << 24);
+
+		FT0[i] &= 0xFFFFFFFF;
+
+		FT1[i] = ROTR8(FT0[i]);
+		FT2[i] = ROTR8(FT1[i]);
+		FT3[i] = ROTR8(FT2[i]);
+
+		y = (unsigned char) RSb[i];
+
+		RT0[i] = ((unsigned int) AES_MUL(0x0B, y)	  ) ^
+				 ((unsigned int) AES_MUL(0x0D, y) <<  8) ^
+				 ((unsigned int) AES_MUL(0x09, y) << 16) ^
+				 ((unsigned int) AES_MUL(0x0E, y) << 24);
+
+		RT0[i] &= 0xFFFFFFFF;
+
+		RT1[i] = ROTR8(RT0[i]);
+		RT2[i] = ROTR8(RT1[i]);
+		RT3[i] = ROTR8(RT2[i]);
+	}
+}
+#else
+
+/* forward S-box */
+
+static const unsigned int FSb[256] =
+{
+	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
+	0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
+	0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
+	0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
+	0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
+	0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
+	0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
+	0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
+	0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
+	0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
+	0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
+	0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
+	0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
+	0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
+	0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
+	0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
+	0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+};
+
+/* forward tables */
+
+#define FT \
+\
+	V(C6,63,63,A5), V(F8,7C,7C,84), V(EE,77,77,99), V(F6,7B,7B,8D), \
+	V(FF,F2,F2,0D), V(D6,6B,6B,BD), V(DE,6F,6F,B1), V(91,C5,C5,54), \
+	V(60,30,30,50), V(02,01,01,03), V(CE,67,67,A9), V(56,2B,2B,7D), \
+	V(E7,FE,FE,19), V(B5,D7,D7,62), V(4D,AB,AB,E6), V(EC,76,76,9A), \
+	V(8F,CA,CA,45), V(1F,82,82,9D), V(89,C9,C9,40), V(FA,7D,7D,87), \
+	V(EF,FA,FA,15), V(B2,59,59,EB), V(8E,47,47,C9), V(FB,F0,F0,0B), \
+	V(41,AD,AD,EC), V(B3,D4,D4,67), V(5F,A2,A2,FD), V(45,AF,AF,EA), \
+	V(23,9C,9C,BF), V(53,A4,A4,F7), V(E4,72,72,96), V(9B,C0,C0,5B), \
+	V(75,B7,B7,C2), V(E1,FD,FD,1C), V(3D,93,93,AE), V(4C,26,26,6A), \
+	V(6C,36,36,5A), V(7E,3F,3F,41), V(F5,F7,F7,02), V(83,CC,CC,4F), \
+	V(68,34,34,5C), V(51,A5,A5,F4), V(D1,E5,E5,34), V(F9,F1,F1,08), \
+	V(E2,71,71,93), V(AB,D8,D8,73), V(62,31,31,53), V(2A,15,15,3F), \
+	V(08,04,04,0C), V(95,C7,C7,52), V(46,23,23,65), V(9D,C3,C3,5E), \
+	V(30,18,18,28), V(37,96,96,A1), V(0A,05,05,0F), V(2F,9A,9A,B5), \
+	V(0E,07,07,09), V(24,12,12,36), V(1B,80,80,9B), V(DF,E2,E2,3D), \
+	V(CD,EB,EB,26), V(4E,27,27,69), V(7F,B2,B2,CD), V(EA,75,75,9F), \
+	V(12,09,09,1B), V(1D,83,83,9E), V(58,2C,2C,74), V(34,1A,1A,2E), \
+	V(36,1B,1B,2D), V(DC,6E,6E,B2), V(B4,5A,5A,EE), V(5B,A0,A0,FB), \
+	V(A4,52,52,F6), V(76,3B,3B,4D), V(B7,D6,D6,61), V(7D,B3,B3,CE), \
+	V(52,29,29,7B), V(DD,E3,E3,3E), V(5E,2F,2F,71), V(13,84,84,97), \
+	V(A6,53,53,F5), V(B9,D1,D1,68), V(00,00,00,00), V(C1,ED,ED,2C), \
+	V(40,20,20,60), V(E3,FC,FC,1F), V(79,B1,B1,C8), V(B6,5B,5B,ED), \
+	V(D4,6A,6A,BE), V(8D,CB,CB,46), V(67,BE,BE,D9), V(72,39,39,4B), \
+	V(94,4A,4A,DE), V(98,4C,4C,D4), V(B0,58,58,E8), V(85,CF,CF,4A), \
+	V(BB,D0,D0,6B), V(C5,EF,EF,2A), V(4F,AA,AA,E5), V(ED,FB,FB,16), \
+	V(86,43,43,C5), V(9A,4D,4D,D7), V(66,33,33,55), V(11,85,85,94), \
+	V(8A,45,45,CF), V(E9,F9,F9,10), V(04,02,02,06), V(FE,7F,7F,81), \
+	V(A0,50,50,F0), V(78,3C,3C,44), V(25,9F,9F,BA), V(4B,A8,A8,E3), \
+	V(A2,51,51,F3), V(5D,A3,A3,FE), V(80,40,40,C0), V(05,8F,8F,8A), \
+	V(3F,92,92,AD), V(21,9D,9D,BC), V(70,38,38,48), V(F1,F5,F5,04), \
+	V(63,BC,BC,DF), V(77,B6,B6,C1), V(AF,DA,DA,75), V(42,21,21,63), \
+	V(20,10,10,30), V(E5,FF,FF,1A), V(FD,F3,F3,0E), V(BF,D2,D2,6D), \
+	V(81,CD,CD,4C), V(18,0C,0C,14), V(26,13,13,35), V(C3,EC,EC,2F), \
+	V(BE,5F,5F,E1), V(35,97,97,A2), V(88,44,44,CC), V(2E,17,17,39), \
+	V(93,C4,C4,57), V(55,A7,A7,F2), V(FC,7E,7E,82), V(7A,3D,3D,47), \
+	V(C8,64,64,AC), V(BA,5D,5D,E7), V(32,19,19,2B), V(E6,73,73,95), \
+	V(C0,60,60,A0), V(19,81,81,98), V(9E,4F,4F,D1), V(A3,DC,DC,7F), \
+	V(44,22,22,66), V(54,2A,2A,7E), V(3B,90,90,AB), V(0B,88,88,83), \
+	V(8C,46,46,CA), V(C7,EE,EE,29), V(6B,B8,B8,D3), V(28,14,14,3C), \
+	V(A7,DE,DE,79), V(BC,5E,5E,E2), V(16,0B,0B,1D), V(AD,DB,DB,76), \
+	V(DB,E0,E0,3B), V(64,32,32,56), V(74,3A,3A,4E), V(14,0A,0A,1E), \
+	V(92,49,49,DB), V(0C,06,06,0A), V(48,24,24,6C), V(B8,5C,5C,E4), \
+	V(9F,C2,C2,5D), V(BD,D3,D3,6E), V(43,AC,AC,EF), V(C4,62,62,A6), \
+	V(39,91,91,A8), V(31,95,95,A4), V(D3,E4,E4,37), V(F2,79,79,8B), \
+	V(D5,E7,E7,32), V(8B,C8,C8,43), V(6E,37,37,59), V(DA,6D,6D,B7), \
+	V(01,8D,8D,8C), V(B1,D5,D5,64), V(9C,4E,4E,D2), V(49,A9,A9,E0), \
+	V(D8,6C,6C,B4), V(AC,56,56,FA), V(F3,F4,F4,07), V(CF,EA,EA,25), \
+	V(CA,65,65,AF), V(F4,7A,7A,8E), V(47,AE,AE,E9), V(10,08,08,18), \
+	V(6F,BA,BA,D5), V(F0,78,78,88), V(4A,25,25,6F), V(5C,2E,2E,72), \
+	V(38,1C,1C,24), V(57,A6,A6,F1), V(73,B4,B4,C7), V(97,C6,C6,51), \
+	V(CB,E8,E8,23), V(A1,DD,DD,7C), V(E8,74,74,9C), V(3E,1F,1F,21), \
+	V(96,4B,4B,DD), V(61,BD,BD,DC), V(0D,8B,8B,86), V(0F,8A,8A,85), \
+	V(E0,70,70,90), V(7C,3E,3E,42), V(71,B5,B5,C4), V(CC,66,66,AA), \
+	V(90,48,48,D8), V(06,03,03,05), V(F7,F6,F6,01), V(1C,0E,0E,12), \
+	V(C2,61,61,A3), V(6A,35,35,5F), V(AE,57,57,F9), V(69,B9,B9,D0), \
+	V(17,86,86,91), V(99,C1,C1,58), V(3A,1D,1D,27), V(27,9E,9E,B9), \
+	V(D9,E1,E1,38), V(EB,F8,F8,13), V(2B,98,98,B3), V(22,11,11,33), \
+	V(D2,69,69,BB), V(A9,D9,D9,70), V(07,8E,8E,89), V(33,94,94,A7), \
+	V(2D,9B,9B,B6), V(3C,1E,1E,22), V(15,87,87,92), V(C9,E9,E9,20), \
+	V(87,CE,CE,49), V(AA,55,55,FF), V(50,28,28,78), V(A5,DF,DF,7A), \
+	V(03,8C,8C,8F), V(59,A1,A1,F8), V(09,89,89,80), V(1A,0D,0D,17), \
+	V(65,BF,BF,DA), V(D7,E6,E6,31), V(84,42,42,C6), V(D0,68,68,B8), \
+	V(82,41,41,C3), V(29,99,99,B0), V(5A,2D,2D,77), V(1E,0F,0F,11), \
+	V(7B,B0,B0,CB), V(A8,54,54,FC), V(6D,BB,BB,D6), V(2C,16,16,3A)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static unsigned int FT0[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static unsigned int FT1[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static unsigned int FT2[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static unsigned int FT3[256] = { FT };
+#undef V
+
+#undef FT
+
+/* reverse S-box */
+
+static const unsigned int RSb[256] =
+{
+	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
+	0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
+	0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
+	0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
+	0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
+	0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
+	0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
+	0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
+	0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
+	0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
+	0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
+	0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
+	0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
+	0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
+	0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
+	0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
+	0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
+};
+
+/* reverse tables */
+
+#define RT \
+\
+	V(51,F4,A7,50), V(7E,41,65,53), V(1A,17,A4,C3), V(3A,27,5E,96), \
+	V(3B,AB,6B,CB), V(1F,9D,45,F1), V(AC,FA,58,AB), V(4B,E3,03,93), \
+	V(20,30,FA,55), V(AD,76,6D,F6), V(88,CC,76,91), V(F5,02,4C,25), \
+	V(4F,E5,D7,FC), V(C5,2A,CB,D7), V(26,35,44,80), V(B5,62,A3,8F), \
+	V(DE,B1,5A,49), V(25,BA,1B,67), V(45,EA,0E,98), V(5D,FE,C0,E1), \
+	V(C3,2F,75,02), V(81,4C,F0,12), V(8D,46,97,A3), V(6B,D3,F9,C6), \
+	V(03,8F,5F,E7), V(15,92,9C,95), V(BF,6D,7A,EB), V(95,52,59,DA), \
+	V(D4,BE,83,2D), V(58,74,21,D3), V(49,E0,69,29), V(8E,C9,C8,44), \
+	V(75,C2,89,6A), V(F4,8E,79,78), V(99,58,3E,6B), V(27,B9,71,DD), \
+	V(BE,E1,4F,B6), V(F0,88,AD,17), V(C9,20,AC,66), V(7D,CE,3A,B4), \
+	V(63,DF,4A,18), V(E5,1A,31,82), V(97,51,33,60), V(62,53,7F,45), \
+	V(B1,64,77,E0), V(BB,6B,AE,84), V(FE,81,A0,1C), V(F9,08,2B,94), \
+	V(70,48,68,58), V(8F,45,FD,19), V(94,DE,6C,87), V(52,7B,F8,B7), \
+	V(AB,73,D3,23), V(72,4B,02,E2), V(E3,1F,8F,57), V(66,55,AB,2A), \
+	V(B2,EB,28,07), V(2F,B5,C2,03), V(86,C5,7B,9A), V(D3,37,08,A5), \
+	V(30,28,87,F2), V(23,BF,A5,B2), V(02,03,6A,BA), V(ED,16,82,5C), \
+	V(8A,CF,1C,2B), V(A7,79,B4,92), V(F3,07,F2,F0), V(4E,69,E2,A1), \
+	V(65,DA,F4,CD), V(06,05,BE,D5), V(D1,34,62,1F), V(C4,A6,FE,8A), \
+	V(34,2E,53,9D), V(A2,F3,55,A0), V(05,8A,E1,32), V(A4,F6,EB,75), \
+	V(0B,83,EC,39), V(40,60,EF,AA), V(5E,71,9F,06), V(BD,6E,10,51), \
+	V(3E,21,8A,F9), V(96,DD,06,3D), V(DD,3E,05,AE), V(4D,E6,BD,46), \
+	V(91,54,8D,B5), V(71,C4,5D,05), V(04,06,D4,6F), V(60,50,15,FF), \
+	V(19,98,FB,24), V(D6,BD,E9,97), V(89,40,43,CC), V(67,D9,9E,77), \
+	V(B0,E8,42,BD), V(07,89,8B,88), V(E7,19,5B,38), V(79,C8,EE,DB), \
+	V(A1,7C,0A,47), V(7C,42,0F,E9), V(F8,84,1E,C9), V(00,00,00,00), \
+	V(09,80,86,83), V(32,2B,ED,48), V(1E,11,70,AC), V(6C,5A,72,4E), \
+	V(FD,0E,FF,FB), V(0F,85,38,56), V(3D,AE,D5,1E), V(36,2D,39,27), \
+	V(0A,0F,D9,64), V(68,5C,A6,21), V(9B,5B,54,D1), V(24,36,2E,3A), \
+	V(0C,0A,67,B1), V(93,57,E7,0F), V(B4,EE,96,D2), V(1B,9B,91,9E), \
+	V(80,C0,C5,4F), V(61,DC,20,A2), V(5A,77,4B,69), V(1C,12,1A,16), \
+	V(E2,93,BA,0A), V(C0,A0,2A,E5), V(3C,22,E0,43), V(12,1B,17,1D), \
+	V(0E,09,0D,0B), V(F2,8B,C7,AD), V(2D,B6,A8,B9), V(14,1E,A9,C8), \
+	V(57,F1,19,85), V(AF,75,07,4C), V(EE,99,DD,BB), V(A3,7F,60,FD), \
+	V(F7,01,26,9F), V(5C,72,F5,BC), V(44,66,3B,C5), V(5B,FB,7E,34), \
+	V(8B,43,29,76), V(CB,23,C6,DC), V(B6,ED,FC,68), V(B8,E4,F1,63), \
+	V(D7,31,DC,CA), V(42,63,85,10), V(13,97,22,40), V(84,C6,11,20), \
+	V(85,4A,24,7D), V(D2,BB,3D,F8), V(AE,F9,32,11), V(C7,29,A1,6D), \
+	V(1D,9E,2F,4B), V(DC,B2,30,F3), V(0D,86,52,EC), V(77,C1,E3,D0), \
+	V(2B,B3,16,6C), V(A9,70,B9,99), V(11,94,48,FA), V(47,E9,64,22), \
+	V(A8,FC,8C,C4), V(A0,F0,3F,1A), V(56,7D,2C,D8), V(22,33,90,EF), \
+	V(87,49,4E,C7), V(D9,38,D1,C1), V(8C,CA,A2,FE), V(98,D4,0B,36), \
+	V(A6,F5,81,CF), V(A5,7A,DE,28), V(DA,B7,8E,26), V(3F,AD,BF,A4), \
+	V(2C,3A,9D,E4), V(50,78,92,0D), V(6A,5F,CC,9B), V(54,7E,46,62), \
+	V(F6,8D,13,C2), V(90,D8,B8,E8), V(2E,39,F7,5E), V(82,C3,AF,F5), \
+	V(9F,5D,80,BE), V(69,D0,93,7C), V(6F,D5,2D,A9), V(CF,25,12,B3), \
+	V(C8,AC,99,3B), V(10,18,7D,A7), V(E8,9C,63,6E), V(DB,3B,BB,7B), \
+	V(CD,26,78,09), V(6E,59,18,F4), V(EC,9A,B7,01), V(83,4F,9A,A8), \
+	V(E6,95,6E,65), V(AA,FF,E6,7E), V(21,BC,CF,08), V(EF,15,E8,E6), \
+	V(BA,E7,9B,D9), V(4A,6F,36,CE), V(EA,9F,09,D4), V(29,B0,7C,D6), \
+	V(31,A4,B2,AF), V(2A,3F,23,31), V(C6,A5,94,30), V(35,A2,66,C0), \
+	V(74,4E,BC,37), V(FC,82,CA,A6), V(E0,90,D0,B0), V(33,A7,D8,15), \
+	V(F1,04,98,4A), V(41,EC,DA,F7), V(7F,CD,50,0E), V(17,91,F6,2F), \
+	V(76,4D,D6,8D), V(43,EF,B0,4D), V(CC,AA,4D,54), V(E4,96,04,DF), \
+	V(9E,D1,B5,E3), V(4C,6A,88,1B), V(C1,2C,1F,B8), V(46,65,51,7F), \
+	V(9D,5E,EA,04), V(01,8C,35,5D), V(FA,87,74,73), V(FB,0B,41,2E), \
+	V(B3,67,1D,5A), V(92,DB,D2,52), V(E9,10,56,33), V(6D,D6,47,13), \
+	V(9A,D7,61,8C), V(37,A1,0C,7A), V(59,F8,14,8E), V(EB,13,3C,89), \
+	V(CE,A9,27,EE), V(B7,61,C9,35), V(E1,1C,E5,ED), V(7A,47,B1,3C), \
+	V(9C,D2,DF,59), V(55,F2,73,3F), V(18,14,CE,79), V(73,C7,37,BF), \
+	V(53,F7,CD,EA), V(5F,FD,AA,5B), V(DF,3D,6F,14), V(78,44,DB,86), \
+	V(CA,AF,F3,81), V(B9,68,C4,3E), V(38,24,34,2C), V(C2,A3,40,5F), \
+	V(16,1D,C3,72), V(BC,E2,25,0C), V(28,3C,49,8B), V(FF,0D,95,41), \
+	V(39,A8,01,71), V(08,0C,B3,DE), V(D8,B4,E4,9C), V(64,56,C1,90), \
+	V(7B,CB,84,61), V(D5,32,B6,70), V(48,6C,5C,74), V(D0,B8,57,42)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static unsigned int RT0[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static unsigned int RT1[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static unsigned int RT2[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static unsigned int RT3[256] = { RT };
+#undef V
+
+#undef RT
+
+/* round constants */
+
+static const unsigned int RCON[10] =
+{
+	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+	0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	0x1B000000, 0x36000000
+};
+
+int do_init = 0;
+
+void
+AES_gen_tables(void)
+{
+}
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/* platform-independant 32-bit integer manipulation macros */
+#define GET_UINT32(n,b,i) {				   \
+	(n) = ((unsigned int) (b)[(i)	] << 24)	   \
+		| ((unsigned int) (b)[(i) + 1] << 16)	   \
+		| ((unsigned int) (b)[(i) + 2] <<  8)	   \
+		| ((unsigned int) (b)[(i) + 3]	   );	   \
+}
+
+#define PUT_UINT32(n,b,i) {				   \
+	(b)[(i)    ] = (unsigned char) ((n) >> 24);	   \
+	(b)[(i) + 1] = (unsigned char) ((n) >> 16);	   \
+	(b)[(i) + 2] = (unsigned char) ((n) >>  8);	   \
+	(b)[(i) + 3] = (unsigned char) ((n)	  );	   \
+}
+
+// decryption key schedule tables
+static int KT_init = 1;
+static unsigned int KT0[256];
+static unsigned int KT1[256];
+static unsigned int KT2[256];
+static unsigned int KT3[256];
+/* AES key scheduling routine */
+static int
+x_AES_CTX_Set_key(AES_CTX_t *ctx, unsigned char *key, int nbits)
+{
+	int i;
+	unsigned int *RK, *SK;
+
+
+	if (do_init)
+	{
+		AES_gen_tables();
+		do_init = 0;
+	}
+
+	switch (nbits)
+	{
+		case 128: ctx->nr = 10; break;
+		case 192: ctx->nr = 12; break;
+		case 256: ctx->nr = 14; break;
+		default : return(1);
+	}
+
+	RK = ctx->erk;
+
+	for (i = 0; i < (nbits >> 5); i++) GET_UINT32(RK[i], key, i * 4);
+
+	/* setup encryption round keys */
+	switch (nbits)
+	{
+	case 128:
+		for (i = 0; i < 10; i++, RK += 4)
+		{
+			RK[4]  = RK[0] ^ RCON[i] ^
+						(FSb[ (unsigned char) (RK[3] >> 16) ] << 24) ^
+						(FSb[ (unsigned char) (RK[3] >>  8) ] << 16) ^
+						(FSb[ (unsigned char) (RK[3]	   ) ] <<  8) ^
+						(FSb[ (unsigned char) (RK[3] >> 24) ]		);
+
+			RK[5]  = RK[1] ^ RK[4];
+			RK[6]  = RK[2] ^ RK[5];
+			RK[7]  = RK[3] ^ RK[6];
+		}
+		break;
+
+	case 192:
+		for (i = 0; i < 8; i++, RK += 6)
+		{
+			RK[6]  = RK[0] ^ RCON[i] ^
+						(FSb[ (unsigned char) (RK[5] >> 16) ] << 24) ^
+						(FSb[ (unsigned char) (RK[5] >>  8) ] << 16) ^
+						(FSb[ (unsigned char) (RK[5]	   ) ] <<  8) ^
+						(FSb[ (unsigned char) (RK[5] >> 24) ]		);
+
+			RK[7]  = RK[1] ^ RK[6];
+			RK[8]  = RK[2] ^ RK[7];
+			RK[9]  = RK[3] ^ RK[8];
+			RK[10] = RK[4] ^ RK[9];
+			RK[11] = RK[5] ^ RK[10];
+		}
+		break;
+
+	case 256:
+		for (i = 0; i < 7; i++, RK += 8)
+		{
+			RK[8]  = RK[0] ^ RCON[i] ^
+						(FSb[ (unsigned char) (RK[7] >> 16) ] << 24) ^
+						(FSb[ (unsigned char) (RK[7] >>  8) ] << 16) ^
+						(FSb[ (unsigned char) (RK[7]	   ) ] <<  8) ^
+						(FSb[ (unsigned char) (RK[7] >> 24) ]		);
+
+			RK[9]  = RK[1] ^ RK[8];
+			RK[10] = RK[2] ^ RK[9];
+			RK[11] = RK[3] ^ RK[10];
+
+			RK[12] = RK[4] ^
+						(FSb[ (unsigned char) (RK[11] >> 24) ] << 24) ^
+						(FSb[ (unsigned char) (RK[11] >> 16) ] << 16) ^
+						(FSb[ (unsigned char) (RK[11] >>  8) ] <<	8) ^
+						(FSb[ (unsigned char) (RK[11]		) ] 	 );
+
+			RK[13] = RK[5] ^ RK[12];
+			RK[14] = RK[6] ^ RK[13];
+			RK[15] = RK[7] ^ RK[14];
+		}
+		break;
+	}
+
+	/* setup decryption round keys */
+	if (KT_init)
+	{
+		unsigned int	fsb;
+
+		for (i = 0; i < 256; i++)
+		{
+			fsb = FSb[i];
+			KT0[i] = RT0[ fsb ];
+			KT1[i] = RT1[ fsb ];
+			KT2[i] = RT2[ fsb ];
+			KT3[i] = RT3[ fsb ];
+		}
+		KT_init = 0;
+	}
+
+	SK = ctx->drk;
+
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+
+	for (i = 1; i < ctx->nr; i++)
+	{
+		RK -= 8;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+	}
+
+	RK -= 8;
+
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+
+	return(0);
+}
+
+// AES 128-bit block encryption routine
+void
+AES_CTX_Encrypt(AES_CTX_t *ctx, unsigned char *input, unsigned char *output)
+{
+	unsigned int *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+	RK = ctx->erk;
+
+	GET_UINT32(X0, input,  0); X0 ^= RK[0];
+	GET_UINT32(X1, input,  4); X1 ^= RK[1];
+	GET_UINT32(X2, input,  8); X2 ^= RK[2];
+	GET_UINT32(X3, input, 12); X3 ^= RK[3];
+
+#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3) 	\
+{												\
+	RK += 4;									\
+												\
+	X0 = RK[0] ^ FT0[ (unsigned char) (Y0 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y1 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y2 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y3		) ];   \
+												\
+	X1 = RK[1] ^ FT0[ (unsigned char) (Y1 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y2 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y3 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y0		) ];   \
+												\
+	X2 = RK[2] ^ FT0[ (unsigned char) (Y2 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y3 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y0 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y1		) ];   \
+												\
+	X3 = RK[3] ^ FT0[ (unsigned char) (Y3 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y0 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y1 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y2		) ];   \
+}
+
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+
+    if ( ctx->nr > 10 )
+    {
+        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    }
+
+    if ( ctx->nr > 12 )
+    {
+        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    }
+
+	/* last round */
+	RK += 4;
+
+	X0 = RK[0] ^ (FSb[ (unsigned char) (Y0 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y1 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y2 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y3 	 ) ]	  );
+
+	X1 = RK[1] ^ (FSb[ (unsigned char) (Y1 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y2 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y3 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y0 	 ) ]	  );
+
+	X2 = RK[2] ^ (FSb[ (unsigned char) (Y2 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y3 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y0 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y1 	 ) ]	  );
+
+	X3 = RK[3] ^ (FSb[ (unsigned char) (Y3 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y0 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y1 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y2 	 ) ]	  );
+
+	PUT_UINT32(X0, output,	0);
+	PUT_UINT32(X1, output,	4);
+	PUT_UINT32(X2, output,	8);
+	PUT_UINT32(X3, output, 12);
+}
+
+/* AES 128-bit block decryption routine */
+void
+AES_CTX_Decrypt(AES_CTX_t *ctx, unsigned char *input, unsigned char *output)
+{
+	unsigned int *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+	RK = ctx->drk;
+
+	GET_UINT32(X0, input,  0); X0 ^= RK[0];
+	GET_UINT32(X1, input,  4); X1 ^= RK[1];
+	GET_UINT32(X2, input,  8); X2 ^= RK[2];
+	GET_UINT32(X3, input, 12); X3 ^= RK[3];
+
+#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3) 	\
+{												\
+	RK += 4;									\
+												\
+	X0 = RK[0] ^ RT0[ (unsigned char) (Y0 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y3 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y2 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y1		) ];   \
+												\
+	X1 = RK[1] ^ RT0[ (unsigned char) (Y1 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y0 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y3 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y2		) ];   \
+												\
+	X2 = RK[2] ^ RT0[ (unsigned char) (Y2 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y1 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y0 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y3		) ];   \
+												\
+	X3 = RK[3] ^ RT0[ (unsigned char) (Y3 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y2 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y1 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y0		) ];   \
+}
+
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 1 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 2 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 3 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 4 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 5 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 6 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 7 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 8 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 9 */
+
+	if (ctx->nr > 10)
+	{
+		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);   /* round 10 */
+		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);   /* round 11 */
+	}
+
+	if (ctx->nr > 12)
+	{
+		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);   /* round 12 */
+		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);   /* round 13 */
+	}
+
+	/* last round */
+	RK += 4;
+
+	X0 = RK[0] ^ (RSb[ (unsigned char) (Y0 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y3 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y2 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y1 	 ) ]	  );
+
+	X1 = RK[1] ^ (RSb[ (unsigned char) (Y1 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y0 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y3 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y2 	 ) ]	  );
+
+	X2 = RK[2] ^ (RSb[ (unsigned char) (Y2 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y1 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y0 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y3 	 ) ]	  );
+
+	X3 = RK[3] ^ (RSb[ (unsigned char) (Y3 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y2 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y1 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y0 	 ) ]	  );
+
+	PUT_UINT32(X0, output,	0);
+	PUT_UINT32(X1, output,	4);
+	PUT_UINT32(X2, output,	8);
+	PUT_UINT32(X3, output, 12);
+}
+
+
+void
+AES_CTX_SetKey(AES_CTX_t *ctx_p, unsigned char *key)
+{
+	x_AES_CTX_Set_key(ctx_p, key, 128);
+}
+
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#endif	// #if !defined(WITH_LIBCRYPTO)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
Index: cscrypt/aes_ctx.h
===================================================================
--- cscrypt/aes_ctx.h	(nonexistent)
+++ cscrypt/aes_ctx.h	(working copy)
@@ -0,0 +1,19 @@
+// sky(n)
+#ifndef __AES_CTX_H
+#define __AES_CTX_H
+#if !defined(WITH_LIBCRYPTO)
+#define AES_FIXED_TABLES
+
+typedef struct
+{
+	unsigned int 	erk[64];	 /* encryption round keys */
+	unsigned int 	drk[64];	 /* decryption round keys */
+	unsigned char  	nr; 		 /* number of rounds	  */
+} AES_CTX_t;
+
+void	AES_CTX_SetKey	(AES_CTX_t *ctx_p, unsigned char *Aeskey_p);
+void	AES_CTX_Decrypt	(AES_CTX_t *ctx_p, unsigned char *In_p, unsigned char *Out_p);
+void	AES_CTX_Encrypt	(AES_CTX_t *ctx_p, unsigned char *In_p, unsigned char *Out_p);
+#endif	// #if !defined(WITH_LIBCRYPTO)
+#endif	// #ifndef __AES_CTX_H
+
Index: cscrypt/des.c
===================================================================
--- cscrypt/des.c	(revision 10670)
+++ cscrypt/des.c	(working copy)
@@ -21,6 +21,18 @@
 	{ 44, 49, 39, 56, 34, 53 },
 	{ 46, 42, 50, 36, 29, 32 }
 };
+// sky(n)
+static unsigned char PC2_seka[8][6] =
+{
+	{18, 3,21,15,42,35},
+	{37, 8,49,41,30,55},
+	{56,29,12,23,43,14},
+	{ 7,27,13, 2,11,45},
+	{ 4,34,54,51,22,40},
+	{16,25,26,48,53,28},
+	{ 1,17, 5,31,50, 6},
+	{39,24,33,47,38,32},
+};
 
 
 static unsigned char E[8][6] =
@@ -100,6 +112,18 @@
 	{30, 22, 14,  6, 61, 53, 45, 37},
 	{29, 21, 13,  5, 28, 20, 12, 4}
 };
+// sky(n)
+static unsigned char  PC1_seka[][8] =
+{
+	{42,57,29,34,41,53,30,15},
+	{19,36,23,14,43,61,12, 3},
+	{51,49, 5, 6,45,54,52,47},
+	{63,38,58,22,60,33,10,26},
+	{37,35,44, 1,20,62,28,18},
+	{46, 9,39, 4,27,11,21,50},
+	{31,25, 2, 7,13,55,59,17},
+};
+
 
 
 void doPC1(unsigned char data[])
@@ -120,6 +142,23 @@
 
 	memcpy(data, buf, 8);
 }
+// sky(n)
+void doPC1_seka(unsigned char data[])
+{
+  unsigned char buf[8];
+  unsigned char i, j;
+
+  memset(buf, 0, 8);
+
+	for (j=0; j<7; j++) {
+		for (i=0; i<8; i++) {
+			unsigned char lookup = PC1_seka[j][i];
+			buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-i);
+		}
+	}
+
+	memcpy(data, buf, 8);
+}
 
 static void doIp(unsigned char data[])
 {
@@ -207,7 +244,37 @@
 				p   = right;
 			}
 			val <<= 1;
-			if(p[bit >> 3] & (1 << (bit & 7))) { val |= 1; }
+      if ( p[bit >> 3] & (1 << (bit & 7)) ) val |= 1;
+    }
+    *K = val;
+	  K++;
+  }
+}
+// sky(n)
+static void makeK_seka(unsigned char *left, unsigned char *right, unsigned char *K)
+{
+  unsigned char i, j;
+  unsigned char bit, val;
+  unsigned char *p;
+
+  for (i=0; i<8; i++)
+  {
+    val = 0;
+    for (j=0; j<6; j++)
+    {
+      bit = PC2_seka[i][j];
+      if (bit < 29)
+      {
+        bit = 28-bit;
+        p   = left;
+      }
+      else
+      {
+        bit = 56-bit;
+        p   = right;
+      }
+      val <<= 1;
+      if ( p[bit >> 3] & (1 << (bit & 7)) ) val |= 1;
 		}
 		*K = val;
 		K++;
@@ -352,6 +415,42 @@
 	swap(data - 4, data);
 }
 
+static void desRound_seka(unsigned char left[], unsigned char right[], unsigned char data[], unsigned char mode, unsigned char k8)
+{
+  unsigned char i;
+  unsigned char K[8];
+  unsigned char r[4];
+  unsigned char tempr[4];
+  unsigned short temp;
+
+  memcpy(tempr, data+4, 4);
+
+  /* Viaccess */
+  temp = (short)k8*(short)tempr[0]+(short)k8+(short)tempr[0];
+  tempr[0] = (temp & 0xff) - ((temp>>8) & 0xff);
+  if ((temp & 0xff) - (temp>>8) < 0)
+    tempr[0]++;
+
+  makeK_seka(left, right, K);
+  desCore(tempr, K, r);
+  permut32(r);
+
+  if (mode & DES_HASH)
+  {
+    i    = r[0];
+    r[0] = r[1];
+    r[1] = i;
+  }
+
+  for (i=0; i<4; i++)
+  {
+    *data ^= r[i];
+    data++;
+  }
+
+  swap(data-4, data);
+}
+
 void des(unsigned char key[], unsigned char mode, unsigned char data[])
 {
 	unsigned char i;
@@ -372,28 +471,73 @@
 	right[2] = key[4];
 	right[3] = key[3] & 0x0f;
 
-	if(mode & DES_IP) { doIp(data); }
+  if (mode & DES_IP) doIp(data);
 
-	do
-	{
+  do {
 		if(!(mode & DES_RIGHT))
 		{
 			leftRotKeys(left, right);
-			if(!(DESShift & 0x8000)) { leftRotKeys(left, right); }
+      if (!(DESShift & 0x8000)) leftRotKeys(left, right);
 		}
 		desRound(left, right, data, mode, key[7]);
 
 		if(mode & DES_RIGHT)
 		{
 			rightRotKeys(left, right);
-			if(!(DESShift & 0x8000)) { rightRotKeys(left, right); }
+      if (!(DESShift & 0x8000)) rightRotKeys(left, right);
 		}
 		DESShift <<= 1;
+  } while (DESShift);
+
+  swap(data, data+4);
+  if (mode & DES_IP_1) doIp_1(data);
+
+}
+
+// sky(n)
+void DES_seka(unsigned char key[], unsigned char mode, unsigned char data[])
+{
+  unsigned char tkey[8];
+  unsigned char i;
+  unsigned char left[8];
+  unsigned char right[8];
+  unsigned char *p = left;
+
+  short DESShift = (mode & DES_RIGHT) ? 0x8103 : 0xc081;
+
+  memcpy(tkey, key, 8);
+  doPC1_seka(tkey);
+  for (i=3; i>0; i--)
+  {
+    *p = (tkey[i-1] << 4) | (tkey[i] >> 4);
+    p++;
 	}
-	while(DESShift);
+  left [3] = tkey[0] >> 4;
+  right[0] = tkey[6];
+  right[1] = tkey[5];
+  right[2] = tkey[4];
+  right[3] = tkey[3] & 0x0f;
+
+  if (mode & DES_IP) doIp(data);
+
+  do {
+    if (!(mode & DES_RIGHT))
+    {
+      leftRotKeys(left, right);
+      if (!(DESShift & 0x8000)) leftRotKeys(left, right);
+    }
+    desRound_seka(left, right, data, mode, tkey[7]);
+
+    if (mode & DES_RIGHT)
+    {
+      rightRotKeys(left, right);
+      if (!(DESShift & 0x8000)) rightRotKeys(left, right);
+    }
+    DESShift <<= 1;
+  } while (DESShift);
 
 	swap(data, data + 4);
-	if(mode & DES_IP_1) { doIp_1(data); }
+  if (mode & DES_IP_1) doIp_1(data);
 
 }
 
Index: cscrypt/des.h
===================================================================
--- cscrypt/des.h	(revision 10670)
+++ cscrypt/des.h	(working copy)
@@ -20,6 +20,8 @@
 	extern unsigned char *des_login_key_get(unsigned char *key1, unsigned char *key2, int len, unsigned char *des16);
 	extern void doPC1(unsigned char data[]);
 	extern void des(unsigned char key[], unsigned char mode, unsigned char data[]);
+// sky(n)
+extern void DES_seka(unsigned char key[], unsigned char mode, unsigned char data[]);
 	extern void des_cbc_encrypt(unsigned char *data, const unsigned char *iv, const unsigned char *okey, int len);
 	extern void des_cbc_decrypt(unsigned char *data, unsigned char *iv, const unsigned char *okey, int len);
 
Index: cscrypt/des_ssl.c
===================================================================
--- cscrypt/des_ssl.c	(nonexistent)
+++ cscrypt/des_ssl.c	(working copy)
@@ -0,0 +1,1440 @@
+// sky(n)
+#if !defined(WITH_LIBCRYPTO)
+//FIXME Not checked on threadsafety yet; after checking please remove this line
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "des_ssl.h"
+
+#define ITERATIONS 		16
+#define HALF_ITERATIONS 8
+
+
+#define c2l(c,l)		(l =((DES_LONG)(*((c)++)))    ,  \
+			 		 	 l|=((DES_LONG)(*((c)++)))<< 8L, \
+			 		 	 l|=((DES_LONG)(*((c)++)))<<16L, \
+					 	 l|=((DES_LONG)(*((c)++)))<<24L)
+
+/* NOTE - c is not incremented as per c2l */
+#define c2ln(c,l1,l2,n)	{ \
+							c+=n; \
+							l1=l2=0; \
+							switch (n) { \
+								case 8: l2 =((DES_LONG)(*(--(c))))<<24L; \
+								case 7: l2|=((DES_LONG)(*(--(c))))<<16L; \
+								case 6: l2|=((DES_LONG)(*(--(c))))<< 8L; \
+								case 5: l2|=((DES_LONG)(*(--(c))));      \
+								case 4: l1 =((DES_LONG)(*(--(c))))<<24L; \
+								case 3: l1|=((DES_LONG)(*(--(c))))<<16L; \
+								case 2: l1|=((DES_LONG)(*(--(c))))<< 8L; \
+								case 1: l1|=((DES_LONG)(*(--(c))));      \
+							} \
+						}
+
+#define l2c(l,c)		(*((c)++)=(unsigned char)(((l)     )&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>> 8L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>>16L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>>24L)&0xff))
+
+/* replacements for htonl and ntohl since I have no idea what to do
+* when faced with machines with 8 byte longs. */
+#define HDRSIZE 		4
+
+#define n2l(c,l)		(l =((DES_LONG)(*((c)++)))<<24L, \
+					 	 l|=((DES_LONG)(*((c)++)))<<16L, \
+					 	 l|=((DES_LONG)(*((c)++)))<< 8L, \
+					 	 l|=((DES_LONG)(*((c)++))))
+
+#define l2n(l,c)		(*((c)++)=(unsigned char)(((l)>>24L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>>16L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>> 8L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)     )&0xff))
+
+/* NOTE - c is not incremented as per l2c */
+#define l2cn(l1,l2,c,n)	{ \
+							c+=n; \
+							switch (n) { \
+								case 8: *(--(c))=(unsigned char)(((l2)>>24L)&0xff); \
+								case 7: *(--(c))=(unsigned char)(((l2)>>16L)&0xff); \
+								case 6: *(--(c))=(unsigned char)(((l2)>> 8L)&0xff); \
+								case 5: *(--(c))=(unsigned char)(((l2)     )&0xff); \
+								case 4: *(--(c))=(unsigned char)(((l1)>>24L)&0xff); \
+								case 3: *(--(c))=(unsigned char)(((l1)>>16L)&0xff); \
+								case 2: *(--(c))=(unsigned char)(((l1)>> 8L)&0xff); \
+								case 1: *(--(c))=(unsigned char)(((l1)     )&0xff); \
+							} \
+						}
+
+
+#ifndef ROTATE
+#define	ROTATE(a,n)		(((a)>>(n))+((a)<<(32-(n))))
+#endif
+
+/* Don't worry about the LOAD_DATA() stuff, that is used by
+* fcrypt() to add it's little bit to the front */
+
+#ifdef DES_FCRYPT
+
+#define LOAD_DATA_tmp(R,S,u,t,E0,E1) \
+						{ DES_LONG tmp; LOAD_DATA(R,S,u,t,E0,E1,tmp); }
+
+#define LOAD_DATA(R,S,u,t,E0,E1,tmp) \
+						t=R^(R>>16L); \
+						u=t&E0; t&=E1; \
+						tmp=(u<<16); u^=R^s[S  ]; u^=tmp; \
+						tmp=(t<<16); t^=R^s[S+1]; t^=tmp
+#else
+#define LOAD_DATA_tmp(a,b,c,d,e,f) LOAD_DATA(a,b,c,d,e,f,g)
+#define LOAD_DATA(R,S,u,t,E0,E1,tmp) \
+						u=R^s[S  ]; \
+						t=R^s[S+1]
+#endif
+
+/* The changes to this macro may help or hinder, depending on the
+* compiler and the architecture.  gcc2 always seems to do well :-).
+* Inspired by Dana How <how@isl.stanford.edu>
+* DO NOT use the alternative version on machines with 8 byte longs.
+* It does not seem to work on the Alpha, even when DES_LONG is 4
+* bytes, probably an issue of accessing non-word aligned objects :-( */
+#ifdef DES_PTR
+
+/* It recently occurred to me that 0^0^0^0^0^0^0 == 0, so there
+* is no reason to not xor all the sub items together.  This potentially
+* saves a register since things can be xored directly into L */
+
+#if defined(DES_RISC1) || defined(DES_RISC2)
+#ifdef DES_RISC1
+#define D_ENCRYPT(LL,R,S) { \
+			unsigned int u1,u2,u3; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0xfc; \
+			u2&=0xfc; \
+			t=ROTATE(t,4); \
+			u>>=16L; \
+			LL^= *(const DES_LONG *)(des_SP      +u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x200+u2); \
+			u3=(int)(u>>8L); \
+			u1=(int)u&0xfc; \
+			u3&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x400+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x600+u3); \
+			u2=(int)t>>8L; \
+			u1=(int)t&0xfc; \
+			u2&=0xfc; \
+			t>>=16L; \
+			LL^= *(const DES_LONG *)(des_SP+0x100+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x300+u2); \
+			u3=(int)t>>8L; \
+			u1=(int)t&0xfc; \
+			u3&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x500+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x700+u3); }
+#endif
+#ifdef DES_RISC2
+#define D_ENCRYPT(LL,R,S) { \
+			unsigned int u1,u2,s1,s2; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0xfc; \
+			u2&=0xfc; \
+			t=ROTATE(t,4); \
+			LL^= *(const DES_LONG *)(des_SP      +u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x200+u2); \
+			s1=(int)(u>>16L); \
+			s2=(int)(u>>24L); \
+			s1&=0xfc; \
+			s2&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x400+s1); \
+			LL^= *(const DES_LONG *)(des_SP+0x600+s2); \
+			u2=(int)t>>8L; \
+			u1=(int)t&0xfc; \
+			u2&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x100+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x300+u2); \
+			s1=(int)(t>>16L); \
+			s2=(int)(t>>24L); \
+			s1&=0xfc; \
+			s2&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x500+s1); \
+			LL^= *(const DES_LONG *)(des_SP+0x700+s2); }
+#endif
+#else
+#define D_ENCRYPT(LL,R,S) { \
+			LOAD_DATA_tmp(R,S,u,t,E0,E1); \
+			t=ROTATE(t,4); \
+			LL^= \
+			*(const DES_LONG *)(des_SP      +((u     )&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x200+((u>> 8L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x400+((u>>16L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x600+((u>>24L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x100+((t     )&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x300+((t>> 8L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x500+((t>>16L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x700+((t>>24L)&0xfc)); }
+#endif
+
+#else /* original version */
+
+#if defined(DES_RISC1) || defined(DES_RISC2)
+#ifdef DES_RISC1
+#define D_ENCRYPT(LL,R,S) {\
+			unsigned int u1,u2,u3; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u>>=2L; \
+			t=ROTATE(t,6); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0x3f; \
+			u2&=0x3f; \
+			u>>=16L; \
+			LL^=DES_SPtrans[0][u1]; \
+			LL^=DES_SPtrans[2][u2]; \
+			u3=(int)u>>8L; \
+			u1=(int)u&0x3f; \
+			u3&=0x3f; \
+			LL^=DES_SPtrans[4][u1]; \
+			LL^=DES_SPtrans[6][u3]; \
+			u2=(int)t>>8L; \
+			u1=(int)t&0x3f; \
+			u2&=0x3f; \
+			t>>=16L; \
+			LL^=DES_SPtrans[1][u1]; \
+			LL^=DES_SPtrans[3][u2]; \
+			u3=(int)t>>8L; \
+			u1=(int)t&0x3f; \
+			u3&=0x3f; \
+			LL^=DES_SPtrans[5][u1]; \
+			LL^=DES_SPtrans[7][u3]; }
+#endif
+#ifdef DES_RISC2
+#define D_ENCRYPT(LL,R,S) {\
+			unsigned int u1,u2,s1,s2; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u>>=2L; \
+			t=ROTATE(t,6); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0x3f; \
+			u2&=0x3f; \
+			LL^=DES_SPtrans[0][u1]; \
+			LL^=DES_SPtrans[2][u2]; \
+			s1=(int)u>>16L; \
+			s2=(int)u>>24L; \
+			s1&=0x3f; \
+			s2&=0x3f; \
+			LL^=DES_SPtrans[4][s1]; \
+			LL^=DES_SPtrans[6][s2]; \
+			u2=(int)t>>8L; \
+			u1=(int)t&0x3f; \
+			u2&=0x3f; \
+			LL^=DES_SPtrans[1][u1]; \
+			LL^=DES_SPtrans[3][u2]; \
+			s1=(int)t>>16; \
+			s2=(int)t>>24L; \
+			s1&=0x3f; \
+			s2&=0x3f; \
+			LL^=DES_SPtrans[5][s1]; \
+			LL^=DES_SPtrans[7][s2]; }
+#endif
+
+#else
+
+#define D_ENCRYPT(LL,R,S) {\
+			LOAD_DATA_tmp(R,S,u,t,E0,E1); \
+			t=ROTATE(t,4); \
+			LL^=\
+			DES_SPtrans[0][(u>> 2L)&0x3f]^ \
+			DES_SPtrans[2][(u>>10L)&0x3f]^ \
+			DES_SPtrans[4][(u>>18L)&0x3f]^ \
+			DES_SPtrans[6][(u>>26L)&0x3f]^ \
+			DES_SPtrans[1][(t>> 2L)&0x3f]^ \
+			DES_SPtrans[3][(t>>10L)&0x3f]^ \
+			DES_SPtrans[5][(t>>18L)&0x3f]^ \
+			DES_SPtrans[7][(t>>26L)&0x3f]; }
+#endif
+#endif
+
+/* IP and FP
+* The problem is more of a geometric problem that random bit fiddling.
+0  1  2  3  4  5  6  7      62 54 46 38 30 22 14  6
+8  9 10 11 12 13 14 15      60 52 44 36 28 20 12  4
+16 17 18 19 20 21 22 23      58 50 42 34 26 18 10  2
+24 25 26 27 28 29 30 31  to  56 48 40 32 24 16  8  0
+
+32 33 34 35 36 37 38 39      63 55 47 39 31 23 15  7
+40 41 42 43 44 45 46 47      61 53 45 37 29 21 13  5
+48 49 50 51 52 53 54 55      59 51 43 35 27 19 11  3
+56 57 58 59 60 61 62 63      57 49 41 33 25 17  9  1
+
+The output has been subject to swaps of the form
+0 1 -> 3 1 but the odd and even bits have been put into
+2 3    2 0
+different words.  The main trick is to remember that
+t=((l>>size)^r)&(mask);
+r^=t;
+l^=(t<<size);
+can be used to swap and move bits between words.
+
+So l =  0  1  2  3  r = 16 17 18 19
+4  5  6  7      20 21 22 23
+8  9 10 11      24 25 26 27
+12 13 14 15      28 29 30 31
+becomes (for size == 2 and mask == 0x3333)
+t =   2^16  3^17 -- --   l =  0  1 16 17  r =  2  3 18 19
+6^20  7^21 -- --        4  5 20 21       6  7 22 23
+10^24 11^25 -- --        8  9 24 25      10 11 24 25
+14^28 15^29 -- --       12 13 28 29      14 15 28 29
+
+Thanks for hints from Richard Outerbridge - he told me IP&FP
+could be done in 15 xor, 10 shifts and 5 ands.
+When I finally started to think of the problem in 2D
+I first got ~42 operations without xors.  When I remembered
+how to use xors :-) I got it to its final state.
+*/
+
+#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
+					(b)^=(t),\
+					(a)^=((t)<<(n)))
+
+#define IP(l,r) 	\
+					{ \
+						register DES_LONG tt; \
+						PERM_OP(r,l,tt, 4,0x0f0f0f0fL); \
+						PERM_OP(l,r,tt,16,0x0000ffffL); \
+						PERM_OP(r,l,tt, 2,0x33333333L); \
+						PERM_OP(l,r,tt, 8,0x00ff00ffL); \
+						PERM_OP(r,l,tt, 1,0x55555555L); \
+					}
+
+#define FP(l,r) 	\
+					{ \
+						register DES_LONG tt; \
+						PERM_OP(l,r,tt, 1,0x55555555L); \
+						PERM_OP(r,l,tt, 8,0x00ff00ffL); \
+						PERM_OP(l,r,tt, 2,0x33333333L); \
+						PERM_OP(r,l,tt,16,0x0000ffffL); \
+						PERM_OP(l,r,tt, 4,0x0f0f0f0fL); \
+					}
+
+static const unsigned char odd_parity[256]={
+		1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
+		16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
+		32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
+		49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
+		64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
+		81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
+		97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
+		112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
+		128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
+		145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
+		161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
+		176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
+		193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
+		208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
+		224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
+		241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254};
+
+void DES_set_odd_parity(DES_cblock *key)
+{
+	unsigned int i;
+
+	for (i=0; i<DES_KEY_SZ; i++)
+		(*key)[i]=odd_parity[(*key)[i]];
+}
+
+int DES_check_key_parity(const_DES_cblock *key)
+{
+	unsigned int i;
+
+	for (i=0; i<DES_KEY_SZ; i++)
+	{
+		if ((*key)[i] != odd_parity[(*key)[i]])
+			return(0);
+	}
+	return(1);
+}
+
+/* Weak and semi week keys as take from
+* %A D.W. Davies
+* %A W.L. Price
+* %T Security for Computer Networks
+* %I John Wiley & Sons
+* %D 1984
+* Many thanks to smb@ulysses.att.com (Steven Bellovin) for the reference
+* (and actual cblock values).
+*/
+#define NUM_WEAK_KEY	16
+static DES_cblock weak_keys[NUM_WEAK_KEY]={
+	/* weak keys */
+	{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
+	{0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE},
+	{0x1F,0x1F,0x1F,0x1F,0x0E,0x0E,0x0E,0x0E},
+	{0xE0,0xE0,0xE0,0xE0,0xF1,0xF1,0xF1,0xF1},
+	/* semi-weak keys */
+	{0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE},
+	{0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01},
+	{0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1},
+	{0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E},
+	{0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1},
+	{0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01},
+	{0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE},
+	{0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E},
+	{0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E},
+	{0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01},
+	{0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE},
+	{0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1}};
+
+int DES_is_weak_key(const_DES_cblock *key)
+{
+	int i;
+
+	for (i=0; i<NUM_WEAK_KEY; i++)
+	/* Added == 0 to comparison, I obviously don't run
+	* this section very often :-(, thanks to
+	* engineering@MorningStar.Com for the fix
+	* eay 93/06/29
+	* Another problem, I was comparing only the first 4
+	* bytes, 97/03/18 */
+	if (memcmp(weak_keys[i],key,sizeof(DES_cblock)) == 0) return(1);
+	return(0);
+}
+
+/* NOW DEFINED IN des_local.h
+* See ecb_encrypt.c for a pseudo description of these macros.
+* #define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
+* 	(b)^=(t),\
+* 	(a)=((a)^((t)<<(n))))
+*/
+
+#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
+				(a)=(a)^(t)^(t>>(16-(n))))
+
+static const DES_LONG des_skb[8][64]={
+	{
+		/* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
+		0x00000000L,0x00000010L,0x20000000L,0x20000010L,
+		0x00010000L,0x00010010L,0x20010000L,0x20010010L,
+		0x00000800L,0x00000810L,0x20000800L,0x20000810L,
+		0x00010800L,0x00010810L,0x20010800L,0x20010810L,
+		0x00000020L,0x00000030L,0x20000020L,0x20000030L,
+		0x00010020L,0x00010030L,0x20010020L,0x20010030L,
+		0x00000820L,0x00000830L,0x20000820L,0x20000830L,
+		0x00010820L,0x00010830L,0x20010820L,0x20010830L,
+		0x00080000L,0x00080010L,0x20080000L,0x20080010L,
+		0x00090000L,0x00090010L,0x20090000L,0x20090010L,
+		0x00080800L,0x00080810L,0x20080800L,0x20080810L,
+		0x00090800L,0x00090810L,0x20090800L,0x20090810L,
+		0x00080020L,0x00080030L,0x20080020L,0x20080030L,
+		0x00090020L,0x00090030L,0x20090020L,0x20090030L,
+		0x00080820L,0x00080830L,0x20080820L,0x20080830L,
+		0x00090820L,0x00090830L,0x20090820L,0x20090830L,
+	},{
+	/* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
+		0x00000000L,0x02000000L,0x00002000L,0x02002000L,
+		0x00200000L,0x02200000L,0x00202000L,0x02202000L,
+		0x00000004L,0x02000004L,0x00002004L,0x02002004L,
+		0x00200004L,0x02200004L,0x00202004L,0x02202004L,
+		0x00000400L,0x02000400L,0x00002400L,0x02002400L,
+		0x00200400L,0x02200400L,0x00202400L,0x02202400L,
+		0x00000404L,0x02000404L,0x00002404L,0x02002404L,
+		0x00200404L,0x02200404L,0x00202404L,0x02202404L,
+		0x10000000L,0x12000000L,0x10002000L,0x12002000L,
+		0x10200000L,0x12200000L,0x10202000L,0x12202000L,
+		0x10000004L,0x12000004L,0x10002004L,0x12002004L,
+		0x10200004L,0x12200004L,0x10202004L,0x12202004L,
+		0x10000400L,0x12000400L,0x10002400L,0x12002400L,
+		0x10200400L,0x12200400L,0x10202400L,0x12202400L,
+		0x10000404L,0x12000404L,0x10002404L,0x12002404L,
+		0x10200404L,0x12200404L,0x10202404L,0x12202404L,
+	},{
+		/* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
+		0x00000000L,0x00000001L,0x00040000L,0x00040001L,
+		0x01000000L,0x01000001L,0x01040000L,0x01040001L,
+		0x00000002L,0x00000003L,0x00040002L,0x00040003L,
+		0x01000002L,0x01000003L,0x01040002L,0x01040003L,
+		0x00000200L,0x00000201L,0x00040200L,0x00040201L,
+		0x01000200L,0x01000201L,0x01040200L,0x01040201L,
+		0x00000202L,0x00000203L,0x00040202L,0x00040203L,
+		0x01000202L,0x01000203L,0x01040202L,0x01040203L,
+		0x08000000L,0x08000001L,0x08040000L,0x08040001L,
+		0x09000000L,0x09000001L,0x09040000L,0x09040001L,
+		0x08000002L,0x08000003L,0x08040002L,0x08040003L,
+		0x09000002L,0x09000003L,0x09040002L,0x09040003L,
+		0x08000200L,0x08000201L,0x08040200L,0x08040201L,
+		0x09000200L,0x09000201L,0x09040200L,0x09040201L,
+		0x08000202L,0x08000203L,0x08040202L,0x08040203L,
+		0x09000202L,0x09000203L,0x09040202L,0x09040203L,
+	},{
+	/* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
+		0x00000000L,0x00100000L,0x00000100L,0x00100100L,
+		0x00000008L,0x00100008L,0x00000108L,0x00100108L,
+		0x00001000L,0x00101000L,0x00001100L,0x00101100L,
+		0x00001008L,0x00101008L,0x00001108L,0x00101108L,
+		0x04000000L,0x04100000L,0x04000100L,0x04100100L,
+		0x04000008L,0x04100008L,0x04000108L,0x04100108L,
+		0x04001000L,0x04101000L,0x04001100L,0x04101100L,
+		0x04001008L,0x04101008L,0x04001108L,0x04101108L,
+		0x00020000L,0x00120000L,0x00020100L,0x00120100L,
+		0x00020008L,0x00120008L,0x00020108L,0x00120108L,
+		0x00021000L,0x00121000L,0x00021100L,0x00121100L,
+		0x00021008L,0x00121008L,0x00021108L,0x00121108L,
+		0x04020000L,0x04120000L,0x04020100L,0x04120100L,
+		0x04020008L,0x04120008L,0x04020108L,0x04120108L,
+		0x04021000L,0x04121000L,0x04021100L,0x04121100L,
+		0x04021008L,0x04121008L,0x04021108L,0x04121108L,
+	},{
+		/* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
+		0x00000000L,0x10000000L,0x00010000L,0x10010000L,
+		0x00000004L,0x10000004L,0x00010004L,0x10010004L,
+		0x20000000L,0x30000000L,0x20010000L,0x30010000L,
+		0x20000004L,0x30000004L,0x20010004L,0x30010004L,
+		0x00100000L,0x10100000L,0x00110000L,0x10110000L,
+		0x00100004L,0x10100004L,0x00110004L,0x10110004L,
+		0x20100000L,0x30100000L,0x20110000L,0x30110000L,
+		0x20100004L,0x30100004L,0x20110004L,0x30110004L,
+		0x00001000L,0x10001000L,0x00011000L,0x10011000L,
+		0x00001004L,0x10001004L,0x00011004L,0x10011004L,
+		0x20001000L,0x30001000L,0x20011000L,0x30011000L,
+		0x20001004L,0x30001004L,0x20011004L,0x30011004L,
+		0x00101000L,0x10101000L,0x00111000L,0x10111000L,
+		0x00101004L,0x10101004L,0x00111004L,0x10111004L,
+		0x20101000L,0x30101000L,0x20111000L,0x30111000L,
+		0x20101004L,0x30101004L,0x20111004L,0x30111004L,
+	},{
+		/* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
+		0x00000000L,0x08000000L,0x00000008L,0x08000008L,
+		0x00000400L,0x08000400L,0x00000408L,0x08000408L,
+		0x00020000L,0x08020000L,0x00020008L,0x08020008L,
+		0x00020400L,0x08020400L,0x00020408L,0x08020408L,
+		0x00000001L,0x08000001L,0x00000009L,0x08000009L,
+		0x00000401L,0x08000401L,0x00000409L,0x08000409L,
+		0x00020001L,0x08020001L,0x00020009L,0x08020009L,
+		0x00020401L,0x08020401L,0x00020409L,0x08020409L,
+		0x02000000L,0x0A000000L,0x02000008L,0x0A000008L,
+		0x02000400L,0x0A000400L,0x02000408L,0x0A000408L,
+		0x02020000L,0x0A020000L,0x02020008L,0x0A020008L,
+		0x02020400L,0x0A020400L,0x02020408L,0x0A020408L,
+		0x02000001L,0x0A000001L,0x02000009L,0x0A000009L,
+		0x02000401L,0x0A000401L,0x02000409L,0x0A000409L,
+		0x02020001L,0x0A020001L,0x02020009L,0x0A020009L,
+		0x02020401L,0x0A020401L,0x02020409L,0x0A020409L,
+	},{
+		/* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
+		0x00000000L,0x00000100L,0x00080000L,0x00080100L,
+		0x01000000L,0x01000100L,0x01080000L,0x01080100L,
+		0x00000010L,0x00000110L,0x00080010L,0x00080110L,
+		0x01000010L,0x01000110L,0x01080010L,0x01080110L,
+		0x00200000L,0x00200100L,0x00280000L,0x00280100L,
+		0x01200000L,0x01200100L,0x01280000L,0x01280100L,
+		0x00200010L,0x00200110L,0x00280010L,0x00280110L,
+		0x01200010L,0x01200110L,0x01280010L,0x01280110L,
+		0x00000200L,0x00000300L,0x00080200L,0x00080300L,
+		0x01000200L,0x01000300L,0x01080200L,0x01080300L,
+		0x00000210L,0x00000310L,0x00080210L,0x00080310L,
+		0x01000210L,0x01000310L,0x01080210L,0x01080310L,
+		0x00200200L,0x00200300L,0x00280200L,0x00280300L,
+		0x01200200L,0x01200300L,0x01280200L,0x01280300L,
+		0x00200210L,0x00200310L,0x00280210L,0x00280310L,
+		0x01200210L,0x01200310L,0x01280210L,0x01280310L,
+	},{
+	/* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
+		0x00000000L,0x04000000L,0x00040000L,0x04040000L,
+		0x00000002L,0x04000002L,0x00040002L,0x04040002L,
+		0x00002000L,0x04002000L,0x00042000L,0x04042000L,
+		0x00002002L,0x04002002L,0x00042002L,0x04042002L,
+		0x00000020L,0x04000020L,0x00040020L,0x04040020L,
+		0x00000022L,0x04000022L,0x00040022L,0x04040022L,
+		0x00002020L,0x04002020L,0x00042020L,0x04042020L,
+		0x00002022L,0x04002022L,0x00042022L,0x04042022L,
+		0x00000800L,0x04000800L,0x00040800L,0x04040800L,
+		0x00000802L,0x04000802L,0x00040802L,0x04040802L,
+		0x00002800L,0x04002800L,0x00042800L,0x04042800L,
+		0x00002802L,0x04002802L,0x00042802L,0x04042802L,
+		0x00000820L,0x04000820L,0x00040820L,0x04040820L,
+		0x00000822L,0x04000822L,0x00040822L,0x04040822L,
+		0x00002820L,0x04002820L,0x00042820L,0x04042820L,
+		0x00002822L,0x04002822L,0x00042822L,0x04042822L,
+	}};
+
+
+static const DES_LONG DES_SPtrans[8][64]={
+	{
+	/* nibble 0 */
+	0x02080800L, 0x00080000L, 0x02000002L, 0x02080802L,
+	0x02000000L, 0x00080802L, 0x00080002L, 0x02000002L,
+	0x00080802L, 0x02080800L, 0x02080000L, 0x00000802L,
+	0x02000802L, 0x02000000L, 0x00000000L, 0x00080002L,
+	0x00080000L, 0x00000002L, 0x02000800L, 0x00080800L,
+	0x02080802L, 0x02080000L, 0x00000802L, 0x02000800L,
+	0x00000002L, 0x00000800L, 0x00080800L, 0x02080002L,
+	0x00000800L, 0x02000802L, 0x02080002L, 0x00000000L,
+	0x00000000L, 0x02080802L, 0x02000800L, 0x00080002L,
+	0x02080800L, 0x00080000L, 0x00000802L, 0x02000800L,
+	0x02080002L, 0x00000800L, 0x00080800L, 0x02000002L,
+	0x00080802L, 0x00000002L, 0x02000002L, 0x02080000L,
+	0x02080802L, 0x00080800L, 0x02080000L, 0x02000802L,
+	0x02000000L, 0x00000802L, 0x00080002L, 0x00000000L,
+	0x00080000L, 0x02000000L, 0x02000802L, 0x02080800L,
+	0x00000002L, 0x02080002L, 0x00000800L, 0x00080802L,
+	},{
+	/* nibble 1 */
+	0x40108010L, 0x00000000L, 0x00108000L, 0x40100000L,
+	0x40000010L, 0x00008010L, 0x40008000L, 0x00108000L,
+	0x00008000L, 0x40100010L, 0x00000010L, 0x40008000L,
+	0x00100010L, 0x40108000L, 0x40100000L, 0x00000010L,
+	0x00100000L, 0x40008010L, 0x40100010L, 0x00008000L,
+	0x00108010L, 0x40000000L, 0x00000000L, 0x00100010L,
+	0x40008010L, 0x00108010L, 0x40108000L, 0x40000010L,
+	0x40000000L, 0x00100000L, 0x00008010L, 0x40108010L,
+	0x00100010L, 0x40108000L, 0x40008000L, 0x00108010L,
+	0x40108010L, 0x00100010L, 0x40000010L, 0x00000000L,
+	0x40000000L, 0x00008010L, 0x00100000L, 0x40100010L,
+	0x00008000L, 0x40000000L, 0x00108010L, 0x40008010L,
+	0x40108000L, 0x00008000L, 0x00000000L, 0x40000010L,
+	0x00000010L, 0x40108010L, 0x00108000L, 0x40100000L,
+	0x40100010L, 0x00100000L, 0x00008010L, 0x40008000L,
+	0x40008010L, 0x00000010L, 0x40100000L, 0x00108000L,
+	},{
+	/* nibble 2 */
+	0x04000001L, 0x04040100L, 0x00000100L, 0x04000101L,
+	0x00040001L, 0x04000000L, 0x04000101L, 0x00040100L,
+	0x04000100L, 0x00040000L, 0x04040000L, 0x00000001L,
+	0x04040101L, 0x00000101L, 0x00000001L, 0x04040001L,
+	0x00000000L, 0x00040001L, 0x04040100L, 0x00000100L,
+	0x00000101L, 0x04040101L, 0x00040000L, 0x04000001L,
+	0x04040001L, 0x04000100L, 0x00040101L, 0x04040000L,
+	0x00040100L, 0x00000000L, 0x04000000L, 0x00040101L,
+	0x04040100L, 0x00000100L, 0x00000001L, 0x00040000L,
+	0x00000101L, 0x00040001L, 0x04040000L, 0x04000101L,
+	0x00000000L, 0x04040100L, 0x00040100L, 0x04040001L,
+	0x00040001L, 0x04000000L, 0x04040101L, 0x00000001L,
+	0x00040101L, 0x04000001L, 0x04000000L, 0x04040101L,
+	0x00040000L, 0x04000100L, 0x04000101L, 0x00040100L,
+	0x04000100L, 0x00000000L, 0x04040001L, 0x00000101L,
+	0x04000001L, 0x00040101L, 0x00000100L, 0x04040000L,
+	},{
+	/* nibble 3 */
+	0x00401008L, 0x10001000L, 0x00000008L, 0x10401008L,
+	0x00000000L, 0x10400000L, 0x10001008L, 0x00400008L,
+	0x10401000L, 0x10000008L, 0x10000000L, 0x00001008L,
+	0x10000008L, 0x00401008L, 0x00400000L, 0x10000000L,
+	0x10400008L, 0x00401000L, 0x00001000L, 0x00000008L,
+	0x00401000L, 0x10001008L, 0x10400000L, 0x00001000L,
+	0x00001008L, 0x00000000L, 0x00400008L, 0x10401000L,
+	0x10001000L, 0x10400008L, 0x10401008L, 0x00400000L,
+	0x10400008L, 0x00001008L, 0x00400000L, 0x10000008L,
+	0x00401000L, 0x10001000L, 0x00000008L, 0x10400000L,
+	0x10001008L, 0x00000000L, 0x00001000L, 0x00400008L,
+	0x00000000L, 0x10400008L, 0x10401000L, 0x00001000L,
+	0x10000000L, 0x10401008L, 0x00401008L, 0x00400000L,
+	0x10401008L, 0x00000008L, 0x10001000L, 0x00401008L,
+	0x00400008L, 0x00401000L, 0x10400000L, 0x10001008L,
+	0x00001008L, 0x10000000L, 0x10000008L, 0x10401000L,
+	},{
+	/* nibble 4 */
+	0x08000000L, 0x00010000L, 0x00000400L, 0x08010420L,
+	0x08010020L, 0x08000400L, 0x00010420L, 0x08010000L,
+	0x00010000L, 0x00000020L, 0x08000020L, 0x00010400L,
+	0x08000420L, 0x08010020L, 0x08010400L, 0x00000000L,
+	0x00010400L, 0x08000000L, 0x00010020L, 0x00000420L,
+	0x08000400L, 0x00010420L, 0x00000000L, 0x08000020L,
+	0x00000020L, 0x08000420L, 0x08010420L, 0x00010020L,
+	0x08010000L, 0x00000400L, 0x00000420L, 0x08010400L,
+	0x08010400L, 0x08000420L, 0x00010020L, 0x08010000L,
+	0x00010000L, 0x00000020L, 0x08000020L, 0x08000400L,
+	0x08000000L, 0x00010400L, 0x08010420L, 0x00000000L,
+	0x00010420L, 0x08000000L, 0x00000400L, 0x00010020L,
+	0x08000420L, 0x00000400L, 0x00000000L, 0x08010420L,
+	0x08010020L, 0x08010400L, 0x00000420L, 0x00010000L,
+	0x00010400L, 0x08010020L, 0x08000400L, 0x00000420L,
+	0x00000020L, 0x00010420L, 0x08010000L, 0x08000020L,
+	},{
+	/* nibble 5 */
+	0x80000040L, 0x00200040L, 0x00000000L, 0x80202000L,
+	0x00200040L, 0x00002000L, 0x80002040L, 0x00200000L,
+	0x00002040L, 0x80202040L, 0x00202000L, 0x80000000L,
+	0x80002000L, 0x80000040L, 0x80200000L, 0x00202040L,
+	0x00200000L, 0x80002040L, 0x80200040L, 0x00000000L,
+	0x00002000L, 0x00000040L, 0x80202000L, 0x80200040L,
+	0x80202040L, 0x80200000L, 0x80000000L, 0x00002040L,
+	0x00000040L, 0x00202000L, 0x00202040L, 0x80002000L,
+	0x00002040L, 0x80000000L, 0x80002000L, 0x00202040L,
+	0x80202000L, 0x00200040L, 0x00000000L, 0x80002000L,
+	0x80000000L, 0x00002000L, 0x80200040L, 0x00200000L,
+	0x00200040L, 0x80202040L, 0x00202000L, 0x00000040L,
+	0x80202040L, 0x00202000L, 0x00200000L, 0x80002040L,
+	0x80000040L, 0x80200000L, 0x00202040L, 0x00000000L,
+	0x00002000L, 0x80000040L, 0x80002040L, 0x80202000L,
+	0x80200000L, 0x00002040L, 0x00000040L, 0x80200040L,
+	},{
+	/* nibble 6 */
+	0x00004000L, 0x00000200L, 0x01000200L, 0x01000004L,
+	0x01004204L, 0x00004004L, 0x00004200L, 0x00000000L,
+	0x01000000L, 0x01000204L, 0x00000204L, 0x01004000L,
+	0x00000004L, 0x01004200L, 0x01004000L, 0x00000204L,
+	0x01000204L, 0x00004000L, 0x00004004L, 0x01004204L,
+	0x00000000L, 0x01000200L, 0x01000004L, 0x00004200L,
+	0x01004004L, 0x00004204L, 0x01004200L, 0x00000004L,
+	0x00004204L, 0x01004004L, 0x00000200L, 0x01000000L,
+	0x00004204L, 0x01004000L, 0x01004004L, 0x00000204L,
+	0x00004000L, 0x00000200L, 0x01000000L, 0x01004004L,
+	0x01000204L, 0x00004204L, 0x00004200L, 0x00000000L,
+	0x00000200L, 0x01000004L, 0x00000004L, 0x01000200L,
+	0x00000000L, 0x01000204L, 0x01000200L, 0x00004200L,
+	0x00000204L, 0x00004000L, 0x01004204L, 0x01000000L,
+	0x01004200L, 0x00000004L, 0x00004004L, 0x01004204L,
+	0x01000004L, 0x01004200L, 0x01004000L, 0x00004004L,
+	},{
+	/* nibble 7 */
+	0x20800080L, 0x20820000L, 0x00020080L, 0x00000000L,
+	0x20020000L, 0x00800080L, 0x20800000L, 0x20820080L,
+	0x00000080L, 0x20000000L, 0x00820000L, 0x00020080L,
+	0x00820080L, 0x20020080L, 0x20000080L, 0x20800000L,
+	0x00020000L, 0x00820080L, 0x00800080L, 0x20020000L,
+	0x20820080L, 0x20000080L, 0x00000000L, 0x00820000L,
+	0x20000000L, 0x00800000L, 0x20020080L, 0x20800080L,
+	0x00800000L, 0x00020000L, 0x20820000L, 0x00000080L,
+	0x00800000L, 0x00020000L, 0x20000080L, 0x20820080L,
+	0x00020080L, 0x20000000L, 0x00000000L, 0x00820000L,
+	0x20800080L, 0x20020080L, 0x20020000L, 0x00800080L,
+	0x20820000L, 0x00000080L, 0x00800080L, 0x20020000L,
+	0x20820080L, 0x00800000L, 0x20800000L, 0x20000080L,
+	0x00820000L, 0x00020080L, 0x20020080L, 0x20800000L,
+	0x00000080L, 0x20820000L, 0x00820080L, 0x00000000L,
+	0x20000000L, 0x20800080L, 0x00020000L, 0x00820080L,
+	}};
+
+int	DES_check_key = 0;
+
+
+int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	if (DES_check_key)
+	{
+		return DES_set_key_checked(key, schedule);
+	}
+	else
+	{
+		DES_set_key_unchecked(key, schedule);
+		return 0;
+	}
+}
+
+/* return 0 if key parity is odd (correct),
+* return -1 if key parity error,
+* return -2 if illegal weak key.
+*/
+int DES_set_key_checked(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	if (!DES_check_key_parity(key))
+		return(-1);
+	if (DES_is_weak_key(key))
+		return(-2);
+	DES_set_key_unchecked(key, schedule);
+	return 0;
+}
+
+void DES_set_key_unchecked(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	static int shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
+	register DES_LONG c,d,t,s,t2;
+	register const unsigned char *in;
+	register DES_LONG *k;
+	register int i;
+
+#ifdef OPENBSD_DEV_CRYPTO
+	memcpy(schedule->key,key,sizeof schedule->key);
+	schedule->session=NULL;
+#endif
+	k = &schedule->ks->deslong[0];
+	in = &(*key)[0];
+
+	c2l(in,c);
+	c2l(in,d);
+
+	/* do PC1 in 47 simple operations :-)
+	* Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
+	* for the inspiration. :-) */
+	PERM_OP (d,c,t,4,0x0f0f0f0fL);
+	HPERM_OP(c,t,-2,0xcccc0000L);
+	HPERM_OP(d,t,-2,0xcccc0000L);
+	PERM_OP (d,c,t,1,0x55555555L);
+	PERM_OP (c,d,t,8,0x00ff00ffL);
+	PERM_OP (d,c,t,1,0x55555555L);
+	d=	(((d&0x000000ffL)<<16L)| (d&0x0000ff00L)     |
+		((d&0x00ff0000L)>>16L)|((c&0xf0000000L)>>4L));
+	c&=0x0fffffffL;
+
+	for (i=0; i<ITERATIONS; i++)
+	{
+		if (shifts2[i])
+		{ c=((c>>2L)|(c<<26L)); d=((d>>2L)|(d<<26L)); }
+		else
+		{ c=((c>>1L)|(c<<27L)); d=((d>>1L)|(d<<27L)); }
+		c&=0x0fffffffL;
+		d&=0x0fffffffL;
+		/* could be a few less shifts but I am to lazy at this
+		* point in time to investigate */
+		s=	des_skb[0][ (c    )&0x3f                ]|
+			des_skb[1][((c>> 6L)&0x03)|((c>> 7L)&0x3c)]|
+			des_skb[2][((c>>13L)&0x0f)|((c>>14L)&0x30)]|
+			des_skb[3][((c>>20L)&0x01)|((c>>21L)&0x06) |
+			((c>>22L)&0x38)];
+		t=	des_skb[4][ (d    )&0x3f                ]|
+			des_skb[5][((d>> 7L)&0x03)|((d>> 8L)&0x3c)]|
+			des_skb[6][ (d>>15L)&0x3f                ]|
+			des_skb[7][((d>>21L)&0x0f)|((d>>22L)&0x30)];
+
+		/* table contained 0213 4657 */
+		t2=((t<<16L)|(s&0x0000ffffL))&0xffffffffL;
+		*(k++)=ROTATE(t2,30)&0xffffffffL;
+
+		t2=((s>>16L)|(t&0xffff0000L));
+		*(k++)=ROTATE(t2,26)&0xffffffffL;
+	}
+}
+
+int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	return(DES_set_key(key,schedule));
+}
+/*
+#undef des_fixup_key_parity
+void des_fixup_key_parity(des_cblock *key)
+{
+des_set_odd_parity(key);
+}
+*/
+
+
+
+void DES_encrypt1(DES_LONG *data, DES_key_schedule *ks, int enc)
+{
+	register DES_LONG l,r,t,u;
+#ifdef DES_PTR
+	register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
+#endif
+#ifndef DES_UNROLL
+	register int i;
+#endif
+	register DES_LONG *s;
+
+	r=data[0];
+	l=data[1];
+
+	IP(r,l);
+	/* Things have been modified so that the initial rotate is
+	* done outside the loop.  This required the
+	* DES_SPtrans values in sp.h to be rotated 1 bit to the right.
+	* One perl script later and things have a 5% speed up on a sparc2.
+	* Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+	* for pointing this out. */
+	/* clear the top bits on machines with 8byte longs */
+	/* shift left by 2 */
+	r=ROTATE(r,29)&0xffffffffL;
+	l=ROTATE(l,29)&0xffffffffL;
+
+	s=ks->ks->deslong;
+	/* I don't know if it is worth the effort of loop unrolling the
+	* inner loop */
+	if (enc)
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r, 0); /*  1 */
+		D_ENCRYPT(r,l, 2); /*  2 */
+		D_ENCRYPT(l,r, 4); /*  3 */
+		D_ENCRYPT(r,l, 6); /*  4 */
+		D_ENCRYPT(l,r, 8); /*  5 */
+		D_ENCRYPT(r,l,10); /*  6 */
+		D_ENCRYPT(l,r,12); /*  7 */
+		D_ENCRYPT(r,l,14); /*  8 */
+		D_ENCRYPT(l,r,16); /*  9 */
+		D_ENCRYPT(r,l,18); /*  10 */
+		D_ENCRYPT(l,r,20); /*  11 */
+		D_ENCRYPT(r,l,22); /*  12 */
+		D_ENCRYPT(l,r,24); /*  13 */
+		D_ENCRYPT(r,l,26); /*  14 */
+		D_ENCRYPT(l,r,28); /*  15 */
+		D_ENCRYPT(r,l,30); /*  16 */
+#else
+		for (i=0; i<32; i+=8)
+		{
+			D_ENCRYPT(l,r,i+0); /*  1 */
+			D_ENCRYPT(r,l,i+2); /*  2 */
+			D_ENCRYPT(l,r,i+4); /*  3 */
+			D_ENCRYPT(r,l,i+6); /*  4 */
+		}
+#endif
+	}
+	else
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r,30); /* 16 */
+		D_ENCRYPT(r,l,28); /* 15 */
+		D_ENCRYPT(l,r,26); /* 14 */
+		D_ENCRYPT(r,l,24); /* 13 */
+		D_ENCRYPT(l,r,22); /* 12 */
+		D_ENCRYPT(r,l,20); /* 11 */
+		D_ENCRYPT(l,r,18); /* 10 */
+		D_ENCRYPT(r,l,16); /*  9 */
+		D_ENCRYPT(l,r,14); /*  8 */
+		D_ENCRYPT(r,l,12); /*  7 */
+		D_ENCRYPT(l,r,10); /*  6 */
+		D_ENCRYPT(r,l, 8); /*  5 */
+		D_ENCRYPT(l,r, 6); /*  4 */
+		D_ENCRYPT(r,l, 4); /*  3 */
+		D_ENCRYPT(l,r, 2); /*  2 */
+		D_ENCRYPT(r,l, 0); /*  1 */
+#else
+		for (i=30; i>0; i-=8)
+		{
+			D_ENCRYPT(l,r,i-0); /* 16 */
+			D_ENCRYPT(r,l,i-2); /* 15 */
+			D_ENCRYPT(l,r,i-4); /* 14 */
+			D_ENCRYPT(r,l,i-6); /* 13 */
+		}
+#endif
+	}
+
+	/* rotate and clear the top bits on machines with 8byte longs */
+	l=ROTATE(l,3)&0xffffffffL;
+	r=ROTATE(r,3)&0xffffffffL;
+
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+	l=r=t=u=0;
+}
+
+void DES_encrypt2(DES_LONG *data, DES_key_schedule *ks, int enc)
+{
+	register DES_LONG l,r,t,u;
+#ifdef DES_PTR
+	register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
+#endif
+#ifndef DES_UNROLL
+	register int i;
+#endif
+	register DES_LONG *s;
+
+	r=data[0];
+	l=data[1];
+
+	/* Things have been modified so that the initial rotate is
+	* done outside the loop.  This required the
+	* DES_SPtrans values in sp.h to be rotated 1 bit to the right.
+	* One perl script later and things have a 5% speed up on a sparc2.
+	* Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+	* for pointing this out. */
+	/* clear the top bits on machines with 8byte longs */
+	r=ROTATE(r,29)&0xffffffffL;
+	l=ROTATE(l,29)&0xffffffffL;
+
+	s=ks->ks->deslong;
+	/* I don't know if it is worth the effort of loop unrolling the
+	* inner loop */
+	if (enc)
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r, 0); /*  1 */
+		D_ENCRYPT(r,l, 2); /*  2 */
+		D_ENCRYPT(l,r, 4); /*  3 */
+		D_ENCRYPT(r,l, 6); /*  4 */
+		D_ENCRYPT(l,r, 8); /*  5 */
+		D_ENCRYPT(r,l,10); /*  6 */
+		D_ENCRYPT(l,r,12); /*  7 */
+		D_ENCRYPT(r,l,14); /*  8 */
+		D_ENCRYPT(l,r,16); /*  9 */
+		D_ENCRYPT(r,l,18); /*  10 */
+		D_ENCRYPT(l,r,20); /*  11 */
+		D_ENCRYPT(r,l,22); /*  12 */
+		D_ENCRYPT(l,r,24); /*  13 */
+		D_ENCRYPT(r,l,26); /*  14 */
+		D_ENCRYPT(l,r,28); /*  15 */
+		D_ENCRYPT(r,l,30); /*  16 */
+#else
+		for (i=0; i<32; i+=8)
+		{
+			D_ENCRYPT(l,r,i+0); /*  1 */
+			D_ENCRYPT(r,l,i+2); /*  2 */
+			D_ENCRYPT(l,r,i+4); /*  3 */
+			D_ENCRYPT(r,l,i+6); /*  4 */
+		}
+#endif
+	}
+	else
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r,30); /* 16 */
+		D_ENCRYPT(r,l,28); /* 15 */
+		D_ENCRYPT(l,r,26); /* 14 */
+		D_ENCRYPT(r,l,24); /* 13 */
+		D_ENCRYPT(l,r,22); /* 12 */
+		D_ENCRYPT(r,l,20); /* 11 */
+		D_ENCRYPT(l,r,18); /* 10 */
+		D_ENCRYPT(r,l,16); /*  9 */
+		D_ENCRYPT(l,r,14); /*  8 */
+		D_ENCRYPT(r,l,12); /*  7 */
+		D_ENCRYPT(l,r,10); /*  6 */
+		D_ENCRYPT(r,l, 8); /*  5 */
+		D_ENCRYPT(l,r, 6); /*  4 */
+		D_ENCRYPT(r,l, 4); /*  3 */
+		D_ENCRYPT(l,r, 2); /*  2 */
+		D_ENCRYPT(r,l, 0); /*  1 */
+#else
+		for (i=30; i>0; i-=8)
+		{
+			D_ENCRYPT(l,r,i-0); /* 16 */
+			D_ENCRYPT(r,l,i-2); /* 15 */
+			D_ENCRYPT(l,r,i-4); /* 14 */
+			D_ENCRYPT(r,l,i-6); /* 13 */
+		}
+#endif
+	}
+	/* rotate and clear the top bits on machines with 8byte longs */
+	data[0]=ROTATE(l,3)&0xffffffffL;
+	data[1]=ROTATE(r,3)&0xffffffffL;
+	l=r=t=u=0;
+}
+
+void DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,
+	DES_key_schedule *ks2, DES_key_schedule *ks3)
+{
+	register DES_LONG l,r;
+
+	l=data[0];
+	r=data[1];
+	IP(l,r);
+	data[0]=l;
+	data[1]=r;
+	DES_encrypt2((DES_LONG *)data,ks1,_ENCRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks2,_DECRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks3,_ENCRYPT_);
+	l=data[0];
+	r=data[1];
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+}
+
+void DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,
+	DES_key_schedule *ks2, DES_key_schedule *ks3)
+{
+	register DES_LONG l,r;
+
+	l=data[0];
+	r=data[1];
+	IP(l,r);
+	data[0]=l;
+	data[1]=r;
+	DES_encrypt2((DES_LONG *)data,ks3,_DECRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks2,_ENCRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks1,_DECRYPT_);
+	l=data[0];
+	r=data[1];
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+}
+
+#ifndef DES_DEFAULT_OPTIONS
+
+#undef CBC_ENC_C__DONT_UPDATE_IV
+
+void DES_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,
+	long length, DES_key_schedule *ks1,
+	DES_key_schedule *ks2, DES_key_schedule *ks3,
+	DES_cblock *ivec, int enc)
+{
+	register DES_LONG tin0,tin1;
+	register DES_LONG tout0,tout1,xor0,xor1;
+	register const unsigned char *in;
+	unsigned char *out;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *iv;
+
+	in=input;
+	out=output;
+	iv = &(*ivec)[0];
+
+	if (enc)
+	{
+		c2l(iv,tout0);
+		c2l(iv,tout1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			tin0^=tout0;
+			tin1^=tout1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			l2c(tout0,out);
+			l2c(tout1,out);
+		}
+		if (l != -8)
+		{
+			c2ln(in,tin0,tin1,l+8);
+			tin0^=tout0;
+			tin1^=tout1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			l2c(tout0,out);
+			l2c(tout1,out);
+		}
+		iv = &(*ivec)[0];
+		l2c(tout0,iv);
+		l2c(tout1,iv);
+	}
+	else
+	{
+		register DES_LONG t0,t1;
+
+		c2l(iv,xor0);
+		c2l(iv,xor1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+
+			t0=tin0;
+			t1=tin1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			tout0^=xor0;
+			tout1^=xor1;
+			l2c(tout0,out);
+			l2c(tout1,out);
+			xor0=t0;
+			xor1=t1;
+		}
+		if (l != -8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+
+			t0=tin0;
+			t1=tin1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			tout0^=xor0;
+			tout1^=xor1;
+			l2cn(tout0,tout1,out,l+8);
+			xor0=t0;
+			xor1=t1;
+		}
+
+		iv = &(*ivec)[0];
+		l2c(xor0,iv);
+		l2c(xor1,iv);
+	}
+	tin0=tin1=tout0=tout1=xor0=xor1=0;
+	tin[0]=tin[1]=0;
+}
+
+#endif /* DES_DEFAULT_OPTIONS */
+
+
+
+void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output,
+	DES_key_schedule *ks, int enc)
+{
+	register DES_LONG l;
+	DES_LONG ll[2];
+	const unsigned char *in = &(*input)[0];
+	unsigned char *out = &(*output)[0];
+
+	c2l(in,l); ll[0]=l;
+	c2l(in,l); ll[1]=l;
+	DES_encrypt1(ll,ks,enc);
+	l=ll[0]; l2c(l,out);
+	l=ll[1]; l2c(l,out);
+	l=ll[0]=ll[1]=0;
+}
+
+void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,
+	DES_key_schedule *ks1, DES_key_schedule *ks2,
+	DES_key_schedule *ks3,
+	int enc)
+{
+	register DES_LONG l0,l1;
+	DES_LONG ll[2];
+	const unsigned char *in = &(*input)[0];
+	unsigned char *out = &(*output)[0];
+
+	c2l(in,l0);
+	c2l(in,l1);
+	ll[0]=l0;
+	ll[1]=l1;
+	if (enc)
+		DES_encrypt3(ll,ks1,ks2,ks3);
+	else
+		DES_decrypt3(ll,ks1,ks2,ks3);
+	l0=ll[0];
+	l1=ll[1];
+	l2c(l0,out);
+	l2c(l1,out);
+}
+
+
+
+DES_LONG DES_cbc_cksum(const unsigned char *in, DES_cblock *output,
+	long length, DES_key_schedule *schedule,
+	const_DES_cblock *ivec)
+{
+	register DES_LONG tout0,tout1,tin0,tin1;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *out = &(*output)[0];
+	const unsigned char *iv = &(*ivec)[0];
+
+	c2l(iv,tout0);
+	c2l(iv,tout1);
+	for (; l>0; l-=8)
+	{
+		if (l >= 8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+		}
+		else
+			c2ln(in,tin0,tin1,l);
+
+		tin0^=tout0; tin[0]=tin0;
+		tin1^=tout1; tin[1]=tin1;
+		DES_encrypt1((DES_LONG *)tin,schedule,_ENCRYPT_);
+		/* fix 15/10/91 eay - thanks to keithr@sco.COM */
+		tout0=tin[0];
+		tout1=tin[1];
+	}
+	if (out != NULL)
+	{
+		l2c(tout0,out);
+		l2c(tout1,out);
+	}
+	tout0=tin0=tin1=tin[0]=tin[1]=0;
+	/*
+	Transform the data in tout1 so that it will
+	match the return value that the MIT Kerberos
+	mit_des_cbc_cksum API returns.
+	*/
+	tout1 = ((tout1 >> 24L) & 0x000000FF)
+		| ((tout1 >> 8L)  & 0x0000FF00)
+		| ((tout1 << 8L)  & 0x00FF0000)
+		| ((tout1 << 24L) & 0xFF000000);
+	return(tout1);
+}
+
+
+#define	CBC_ENC_C__DONT_UPDATE_IV
+
+#ifdef CBC_ENC_C__DONT_UPDATE_IV
+void DES_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,
+	DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
+#else
+void DES_ncbc_encrypt(const unsigned char *in, unsigned char *out, long length,
+	DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
+#endif
+{
+	register DES_LONG tin0,tin1;
+	register DES_LONG tout0,tout1,xor0,xor1;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *iv;
+
+	iv = &(*ivec)[0];
+
+	if (enc)
+	{
+		c2l(iv,tout0);
+		c2l(iv,tout1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_ENCRYPT_);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+		}
+		if (l != -8)
+		{
+			c2ln(in,tin0,tin1,l+8);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_ENCRYPT_);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+		}
+#ifndef CBC_ENC_C__DONT_UPDATE_IV
+		iv = &(*ivec)[0];
+		l2c(tout0,iv);
+		l2c(tout1,iv);
+#endif
+	}
+	else
+	{
+		c2l(iv,xor0);
+		c2l(iv,xor1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_DECRYPT_);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2c(tout0,out);
+			l2c(tout1,out);
+			xor0=tin0;
+			xor1=tin1;
+		}
+		if (l != -8)
+		{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_DECRYPT_);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2cn(tout0,tout1,out,l+8);
+#ifndef CBC_ENC_C__DONT_UPDATE_IV
+			xor0=tin0;
+			xor1=tin1;
+#endif
+		}
+#ifndef CBC_ENC_C__DONT_UPDATE_IV
+		iv = &(*ivec)[0];
+		l2c(xor0,iv);
+		l2c(xor1,iv);
+#endif
+	}
+	tin0=tin1=tout0=tout1=xor0=xor1=0;
+	tin[0]=tin[1]=0;
+}
+
+
+/* HAS BUGS! DON'T USE - this is only present for use in des.c */
+void DES_3cbc_encrypt(DES_cblock *input, DES_cblock *output, int length,
+	DES_key_schedule ks1, DES_key_schedule ks2, DES_cblock *iv1,
+	DES_cblock *iv2, int enc)
+{
+	int  off=((int)length-1)/8;
+	long l8=((length+7)/8)*8;
+	DES_cblock niv1,niv2;
+
+	if (enc == _ENCRYPT_)
+	{
+		DES_cbc_encrypt((unsigned char*)input,
+			(unsigned char*)output,length,&ks1,iv1,enc);
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv1,output[off],sizeof(DES_cblock));
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,l8,&ks2,iv1,!enc);
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,l8,&ks1,iv2,enc);
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv2,output[off],sizeof(DES_cblock));
+	}
+	else
+	{
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv2,input[off],sizeof(DES_cblock));
+		DES_cbc_encrypt((unsigned char*)input,
+			(unsigned char*)output,l8,&ks1,iv2,enc);
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,l8,&ks2,iv1,!enc);
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv1,output[off],sizeof(DES_cblock));
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,length,&ks1,iv1,enc);
+	}
+	memcpy(*iv1,niv1,sizeof(DES_cblock));
+	memcpy(*iv2,niv2,sizeof(DES_cblock));
+}
+
+
+void
+DES_SSL_NA_3DES_Decrypt(unsigned char *Crypted_p, unsigned char *_3DES_KEY)
+{
+	DES_key_schedule ks0, ks1, ks2;
+
+	DES_set_key((DES_cblock *) &_3DES_KEY[ 0], &ks0);
+
+	DES_set_key((DES_cblock *) &_3DES_KEY[ 8], &ks1);
+	DES_set_key((DES_cblock *) &_3DES_KEY[16], &ks2);
+
+	DES_ecb3_encrypt((const_DES_cblock *)&Crypted_p[0], (DES_cblock *)&Crypted_p[0], &ks0, &ks1, &ks2, _DECRYPT_);
+	DES_ecb3_encrypt((const_DES_cblock *)&Crypted_p[8], (DES_cblock *)&Crypted_p[8], &ks0, &ks1, &ks2, _DECRYPT_);
+}
+
+
+
+
+void
+DES_drotate(unsigned char *out, unsigned char *in, int n)
+{
+	out += n;
+	do { *(--out)=*(in++); } while (--n);
+}
+
+void
+DES_rotate(unsigned char *in, int count)
+{
+	int j=count-1;
+	int i;
+	unsigned char temp;
+
+	count /= 2;
+	for (i=0; i<count ; i++,j--)
+	{
+		temp  = in[i];
+		in[i] = in[j];
+		in[j] = temp;
+	}
+}
+
+void
+DES_SSL_NA_CBC_Decrypt(unsigned char *Crypted_p, int Crypted_len, unsigned char *_i_KEY)
+{
+	int i;
+	unsigned char tmp[8];
+	DES_key_schedule ks0, ks1;
+
+	DES_drotate(tmp, &_i_KEY[0], 8);
+	DES_set_key((DES_cblock *)tmp, &ks0);
+
+	DES_drotate(tmp, &_i_KEY[8], 8);
+	DES_set_key((DES_cblock *)tmp, &ks1);
+
+	memset(tmp, 0, sizeof(tmp));
+
+	for (i=7; i>=0; i--) DES_rotate(Crypted_p+8*i, 8);
+
+	DES_ede2_cbc_encrypt(Crypted_p, Crypted_p, Crypted_len, &ks0, &ks1, (DES_cblock *)tmp, _DECRYPT_);
+
+	for (i=7; i>=0; i--) DES_rotate(Crypted_p+8*i, 8);
+}
+
+#endif	// #if !defined(WITH_LIBCRYPTO)
+
+
Index: cscrypt/des_ssl.h
===================================================================
--- cscrypt/des_ssl.h	(nonexistent)
+++ cscrypt/des_ssl.h	(working copy)
@@ -0,0 +1,234 @@
+// sky(n)
+/* crypto/des/des.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#if !defined(WITH_LIBCRYPTO)
+
+#ifndef __DES_SSL_H_
+#define __DES_SSL_H_
+
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+enum
+{
+	_DECRYPT_,
+	_ENCRYPT_
+};
+
+typedef unsigned long DES_LONG;
+typedef unsigned char DES_cblock[8];
+typedef unsigned char const_DES_cblock[8];
+/* With "const", gcc 2.8.1 on Solaris thinks that DES_cblock *
+ * and const_DES_cblock * are incompatible pointer types. */
+
+typedef struct DES_ks
+{
+    union
+	{
+		DES_cblock 	cblock;
+		/* make sure things are correct size on machines with
+		 * 8 byte longs */
+		DES_LONG 	deslong[2];
+	} ks[16];
+} DES_key_schedule;
+
+
+#define DES_KEY_SZ 		(sizeof(DES_cblock))
+#define DES_SCHEDULE_SZ (sizeof(DES_key_schedule))
+
+#define DES_ecb2_encrypt(i,o,k1,k2,e) \
+		DES_ecb3_encrypt((i),(o),(k1),(k2),(k1),(e))
+
+#define DES_ede2_cbc_encrypt(i,o,l,k1,k2,iv,e) \
+		DES_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(e))
+
+#define DES_ede2_cfb64_encrypt(i,o,l,k1,k2,iv,n,e) \
+		DES_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n),(e))
+
+#define DES_ede2_ofb64_encrypt(i,o,l,k1,k2,iv,n) \
+		DES_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n))
+
+
+void 	 DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,
+		      	DES_key_schedule *ks1,DES_key_schedule *ks2,
+		      	DES_key_schedule *ks3, int enc);
+DES_LONG DES_cbc_cksum(const unsigned char *input,DES_cblock *output,
+		       	long length,DES_key_schedule *schedule,
+		       	const_DES_cblock *ivec);
+/* DES_cbc_encrypt does not update the IV!  Use DES_ncbc_encrypt instead. */
+void 	 DES_cbc_encrypt(const unsigned char *input,unsigned char *output,
+		     	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		     	int enc);
+void 	 DES_ncbc_encrypt(const unsigned char *input,unsigned char *output,
+		      	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      	int enc);
+void 	 DES_xcbc_encrypt(const unsigned char *input,unsigned char *output,
+		      	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      	const_DES_cblock *inw,const_DES_cblock *outw,int enc);
+void 	 DES_cfb_encrypt(const unsigned char *in,unsigned char *out,int numbits,
+		     	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		     	int enc);
+void 	 DES_ecb_encrypt(const_DES_cblock *input,DES_cblock *output,
+		     	DES_key_schedule *ks,int enc);
+
+/* 	This is the DES encryption function that gets called by just about
+	every other DES routine in the library.  You should not use this
+	function except to implement 'modes' of DES.  I say this because the
+	functions that call this routine do the conversion from 'char *' to
+	long, and this needs to be done to make sure 'non-aligned' memory
+	access do not occur.  The characters are loaded 'little endian'.
+	Data is a pointer to 2 unsigned long's and ks is the
+	DES_key_schedule to use.  enc, is non zero specifies encryption,
+	zero if decryption. */
+void 	 DES_encrypt1(DES_LONG *data,DES_key_schedule *ks, int enc);
+
+/* 	This functions is the same as DES_encrypt1() except that the DES
+	initial permutation (IP) and final permutation (FP) have been left
+	out.  As for DES_encrypt1(), you should not use this function.
+	It is used by the routines in the library that implement triple DES.
+	IP() DES_encrypt2() DES_encrypt2() DES_encrypt2() FP() is the same
+	as DES_encrypt1() DES_encrypt1() DES_encrypt1() except faster :-). */
+void 	 DES_encrypt2(DES_LONG *data,DES_key_schedule *ks, int enc);
+
+void 	 DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,
+		  		DES_key_schedule *ks2, DES_key_schedule *ks3);
+void 	 DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,
+		  		DES_key_schedule *ks2, DES_key_schedule *ks3);
+void 	 DES_ede3_cbc_encrypt(const unsigned char *input,unsigned char *output,
+			  	long length,
+			  	DES_key_schedule *ks1,DES_key_schedule *ks2,
+			  	DES_key_schedule *ks3,DES_cblock *ivec,int enc);
+void 	 DES_ede3_cbcm_encrypt(const unsigned char *in,unsigned char *out,
+			   	long length,
+			   	DES_key_schedule *ks1,DES_key_schedule *ks2,
+			   	DES_key_schedule *ks3,
+			   	DES_cblock *ivec1,DES_cblock *ivec2,
+			   	int enc);
+void 	 DES_ede3_cfb64_encrypt(const unsigned char *in,unsigned char *out,
+			    long length,DES_key_schedule *ks1,
+			    DES_key_schedule *ks2,DES_key_schedule *ks3,
+			    DES_cblock *ivec,int *num,int enc);
+void 	 DES_ede3_cfb_encrypt(const unsigned char *in,unsigned char *out,
+			  	int numbits,long length,DES_key_schedule *ks1,
+			  	DES_key_schedule *ks2,DES_key_schedule *ks3,
+			  	DES_cblock *ivec,int enc);
+void 	 DES_ede3_ofb64_encrypt(const unsigned char *in,unsigned char *out,
+			    long length,DES_key_schedule *ks1,
+			    DES_key_schedule *ks2,DES_key_schedule *ks3,
+			    DES_cblock *ivec,int *num);
+
+void 	 DES_xwhite_in2out(const_DES_cblock *DES_key,const_DES_cblock *in_white,
+		       	DES_cblock *out_white);
+
+int 	 DES_enc_read(int fd,void *buf,int len,DES_key_schedule *sched,
+		 		DES_cblock *iv);
+int 	 DES_enc_write(int fd,const void *buf,int len,DES_key_schedule *sched,
+		  		DES_cblock *iv);
+char 	*DES_fcrypt(const char *buf,const char *salt, char *ret);
+char 	*DES_crypt(const char *buf,const char *salt);
+void 	 DES_ofb_encrypt(const unsigned char *in,unsigned char *out,int numbits,
+		     	long length,DES_key_schedule *schedule,DES_cblock *ivec);
+void 	 DES_pcbc_encrypt(const unsigned char *input,unsigned char *output,
+		      	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      	int enc);
+DES_LONG DES_quad_cksum(const unsigned char *input,DES_cblock output[],
+				long length,int out_count,DES_cblock *seed);
+int 	 DES_random_key(DES_cblock *ret);
+void 	 DES_set_odd_parity(DES_cblock *key);
+int 	 DES_check_key_parity(const_DES_cblock *key);
+int 	 DES_is_weak_key(const_DES_cblock *key);
+/* DES_set_key (= set_key = DES_key_sched = key_sched) calls
+ * DES_set_key_checked if global variable DES_check_key is set,
+ * DES_set_key_unchecked otherwise. */
+int 	 DES_set_key(const_DES_cblock *key,DES_key_schedule *schedule);
+int 	 DES_key_sched(const_DES_cblock *key,DES_key_schedule *schedule);
+int 	 DES_set_key_checked(const_DES_cblock *key,DES_key_schedule *schedule);
+void 	 DES_set_key_unchecked(const_DES_cblock *key,DES_key_schedule *schedule);
+void 	 DES_string_to_key(const char *str,DES_cblock *key);
+void 	 DES_string_to_2keys(const char *str,DES_cblock *key1,DES_cblock *key2);
+void 	 DES_cfb64_encrypt(const unsigned char *in,unsigned char *out,long length,
+		       	DES_key_schedule *schedule,DES_cblock *ivec,int *num,
+		       int enc);
+void 	 DES_ofb64_encrypt(const unsigned char *in,unsigned char *out,long length,
+		       	DES_key_schedule *schedule,DES_cblock *ivec,int *num);
+
+int 	 DES_read_password(DES_cblock *key, const char *prompt, int verify);
+int 	 DES_read_2passwords(DES_cblock *key1, DES_cblock *key2, const char *prompt,
+				int verify);
+
+#define DES_fixup_key_parity DES_set_odd_parity
+
+
+#define DES_KEY_SCHED(k,s)       				DES_key_sched(k,&s)
+#define DES_ECB_ENCRYPT(c,o,s,d) 				DES_ecb_encrypt(c,o,&s,d)
+#define DES_EDE2_CBC_ENCRYPT(i,o,l,k1,k2,iv,e) 	DES_ede2_cbc_encrypt((i),(o),(l),&k1,&k2,(iv),(e))
+#define DES_ECB2_ENCRYPT(i,o,k1,k2,e) 			DES_ecb2_encrypt((DES_cblock *)(i),(DES_cblock *)(o),&k1,&k2,(e))
+
+
+void	DES_SSL_NA_3DES_Decrypt	(unsigned char *emm_data, unsigned char *_3DES_KEY);
+void	DES_SSL_NA_CBC_Decrypt	(unsigned char *Crypted_p, int Crypted_len, unsigned char *_i_KEY);
+
+#ifdef  __cplusplus
+}
+#endif
+#endif	// __DES_SSL_H_
+#endif	// #if !defined(WITH_LIBCRYPTO)
+
Index: cscrypt/md5.c
===================================================================
--- cscrypt/md5.c	(revision 10670)
+++ cscrypt/md5.c	(working copy)
@@ -25,13 +25,6 @@
 
 #if !defined(WITH_SSL) && !defined(WITH_LIBCRYPTO)
 
-typedef struct MD5Context
-{
-	uint32_t buf[4];
-	uint32_t bits[2];
-	uint32_t in[16];
-} MD5_CTX;
-
 #ifdef __i386__
 #define byteReverse(a, b)
 #else
@@ -155,7 +148,7 @@
  * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
  * initialization constants.
  */
-static void MD5_Init(MD5_CTX *ctx)
+void MD5_Init(MD5_CTX *ctx)
 {
 	ctx->buf[0] = 0x67452301;
 	ctx->buf[1] = 0xefcdab89;
@@ -170,7 +163,7 @@
  * Update context to reflect the concatenation of another buffer full
  * of bytes.
  */
-static void MD5_Update(MD5_CTX *ctx, const unsigned char *buf, unsigned int len)
+void MD5_Update(MD5_CTX *ctx, const unsigned char *buf, unsigned int len)
 {
 	uint32_t t;
 
@@ -219,7 +209,7 @@
  * Final wrapup - pad to 64-byte boundary with the bit pattern
  * 1 0* (64-bit count of bits processed, MSB-first)
  */
-static void MD5_Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *ctx)
+void MD5_Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *ctx)
 {
 	unsigned count;
 	unsigned char *p;
Index: cscrypt/md5.h
===================================================================
--- cscrypt/md5.h	(revision 10670)
+++ cscrypt/md5.h	(working copy)
@@ -4,9 +4,21 @@
 #if defined(WITH_SSL) || defined(WITH_LIBCRYPTO)
 #  include <openssl/md5.h>
 #else
+
+
+typedef struct MD5Context
+{
+	uint32_t buf [4];
+	uint32_t bits[2];
+	uint32_t in  [16];
+} MD5_CTX;
+
 #define MD5_DIGEST_LENGTH 16
 
 unsigned char *MD5(const unsigned char *input, unsigned long len, unsigned char *output_hash);
+void MD5_Init	(MD5_CTX *ctx);
+void MD5_Update(MD5_CTX *ctx, const unsigned char *buf, unsigned int len);
+void MD5_Final	(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *ctx);
 #endif
 
 char *__md5_crypt(const char *text_pass, const char *salt, char *crypted_passwd);
Index: cscrypt/sha1.c
===================================================================
--- cscrypt/sha1.c	(revision 10670)
+++ cscrypt/sha1.c	(working copy)
@@ -82,7 +82,10 @@
 
 #include <stdio.h>
 #include <string.h>
-
+// sky(n)
+#if defined(WITH_HISILICON)
+#include <endian.h>
+#endif
 #include "sha1.h"
 
 #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
@@ -319,4 +255,155 @@
 	SHA1_Transform(context->state, context->buffer);
 #endif
 }
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+// sky(n)
+#define _sha_t32_(x)			((x) & 0xffffffff)
+// rotate left
+#define _sha_role_(x, n)	_sha_t32_(((x) << (n)) | ((x) >> (32 - (n))))
+// convert DWord to little endian format (flop bytes)
+#define _sha_fole_(x)		((((x) >> 24) & 0xFF) | (((x) >> 8) & 0xFF00) | (((x) & 0xFF) << 24) | (((x) & 0xFF00) << 8))
+/* The SHS f()-functions */
+#define _sha_f1_(x,y,z)		( ( x & y ) | ( ~(x) & z ) )		 	/* rounds  0-19 */
+#define _sha_f2_(x,y,z)		( x ^ y ^ z )			  					/* rounds 20-39 */
+#define _sha_f3_(x,y,z)		( ( x & y ) | ( x & z ) | ( y & z ) ) 	/* rounds 40-59 */
+#define _sha_f4_(x,y,z)		( x ^ y ^ z )			  				/* rounds 60-79 */
+#define _sha_swap32_(x)	 ((((x)&0xff000000)>>24) | (((x)&0x00ff0000)>> 8) | \
+                   		  (((x)&0x0000ff00)<< 8) | (((x)&0x000000ff)<< 24))
+#define _sha_swap16_(x)   (((x)&0x00ff)<<8 | ((x)&0xff00)>>8)
+
+// The SHS Mysterious Constants
+static 	uint32_t sha_Magic[4] = {0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6};
+
+
+static uint32_t
+SHA1_sekaFs(int iround, uint32_t b, uint32_t c, uint32_t d)
+{
+   if (iround < 20)  return (uint32_t)_sha_f1_(b,c,d);
+   else if (iround < 40) return (uint32_t)_sha_f2_(b,c,d);
+   else if (iround < 60) return (uint32_t)_sha_f3_(b,c,d);
+   else return (uint32_t)_sha_f4_(b,c,d);
+}
+
+void
+SHA1_sekaDes(uint8_t *src_p, int msg_len, uint8_t *digest, uint8_t shapad, uint8_t padend)
+{
+	uint32_t state[5]; 		// SHA-1 state buffer
+	uint8_t 	databuf[256];
+	uint32_t	W[80];
+	uint32_t a,b,c,d,e,t; 	// copies of state buffer
+	int i,j,blocks;
+
+	// SHA1 initialization constants
+	state[0] = 0x67452301;
+	state[1] = 0xEFCDAB89;
+	state[2] = 0x98BADCFE;
+	state[3] = 0x10325476;
+	state[4] = 0xC3D2E1F0;
+	// count the number of 512 bit blocks in message
+
+	memcpy(databuf, src_p, msg_len);
+	if (!(shapad|padend))
+	{
+		blocks = (msg_len + 63) >> 6;
+		for (i=msg_len;i<64*blocks;i++)
+		{
+			databuf[i] = 0;
+		}
+	}
+	else
+	{
+		blocks = (msg_len + 3 + 63) >> 6;
+		databuf[(64*blocks)-2]	= 0;
+		databuf[(64*blocks)-1]	= msg_len;
+		databuf[msg_len] = padend;
+		for (i=msg_len+1;i<(64*blocks)-2;i++)
+		{
+			databuf[i] = shapad;
+		}
+	}
+
+	for (i=0;i<blocks;i++)
+	{
+		memcpy(W, databuf+(64*i), 64);
+		for (j= 0;j<16;j++) W[j] = _sha_fole_(W[j]);
+
+		// expand data buffer
+		for (j=16;j<80;j++) W[j] = _sha_role_(W[j-3] ^ W[j-8] ^ W[j-14] ^ W[j-16], 1);
+		// Copy state[] to work vars
+		a = state[0];
+		b = state[1];
+		c = state[2];
+		d = state[3];
+		e = state[4];
+		// run core function
+		for (j=0; j<80;j++)
+		{
+			t = (uint32_t)(_sha_role_(a,5) + SHA1_sekaFs(j,b,c,d) + e + W[j] + sha_Magic[j/20]);
+			e = d;
+			d = c;
+			c = _sha_role_(b,30);
+			b = a;
+			a = t;
+		}
+		// Update state buffer
+		state[0] += a;
+		state[1] += b;
+		state[2] += c;
+		state[3] += d;
+		state[4] += e;
+	}
+	// convert state src_p to byte format
+	state[0] = _sha_fole_(state[0]);
+	state[1] = _sha_fole_(state[1]);
+	state[2] = _sha_fole_(state[2]);
+	state[3] = _sha_fole_(state[3]);
+	state[4] = _sha_fole_(state[4]);
+
+	memcpy(digest, state, 20);
+}
+
+
+
+void
+SHA1_sekaSignature(uint8_t *data, int n, uint8_t *signature, int PadMode, uint8_t Pad, uint8_t End)
+{
+	SHA_CTX ctx;
+	uint16_t s;
+	uint8_t SHA_pad;
+	uint8_t SHA_end;
+	int l;
+
+	SHA1_Init(&ctx);
+	SHA1_Update(&ctx,data,n);
+	if (PadMode)
+	{
+		SHA_end = End;
+		SHA1_Update(&ctx,&SHA_end,1);
+		l=(n&63)+1;
+		SHA_pad = Pad;
+		if (l>62)
+		{
+			for(; l<64; l++) SHA1_Update(&ctx,&SHA_pad,1);
+			l=0;
+		}
+		for(; l<62; l++) SHA1_Update(&ctx,&SHA_pad,1);
+		s=_sha_swap16_(n);
+		SHA1_Update(&ctx, (uint8_t*)&s, 2);
+	}
+	else
+	{
+		SHA_pad=0;
+		for(; n&63; n++) SHA1_Update(&ctx,&SHA_pad,1);
+	}
+	*((unsigned int *)(signature   ))=_sha_swap32_(ctx.state[0]);
+	*((unsigned int *)(signature+ 4))=_sha_swap32_(ctx.state[1]);
+	*((unsigned int *)(signature+ 8))=_sha_swap32_(ctx.state[2]);
+	*((unsigned int *)(signature+12))=_sha_swap32_(ctx.state[3]);
+	*((unsigned int *)(signature+16))=_sha_swap32_(ctx.state[4]);
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
 #endif
Index: cscrypt/sha1.h
===================================================================
--- cscrypt/sha1.h	(revision 10670)
+++ cscrypt/sha1.h	(working copy)
@@ -10,8 +10,7 @@
 #include <sys/types.h>
 #include <stdint.h>
 
-typedef struct
-{
+typedef struct {
 	uint32_t state[5];
 	uint32_t count[2];
 	uint8_t  buffer[64];
@@ -24,6 +23,9 @@
 void SHA1_Init(SHA_CTX *context);
 void SHA1_Update(SHA_CTX *context, const uint8_t *data, const size_t len);
 void SHA1_Final(uint8_t digest[SHA_DIGEST_LENGTH], SHA_CTX *context);
+// sky(n)
+void SHA1_sekaDes(uint8_t *src_p, int msg_len, uint8_t *digest, uint8_t pad, uint8_t end);
+void SHA1_sekaSignature(uint8_t *data, int n, uint8_t *signature, int padmode, uint8_t pad, uint8_t end);
 
 #endif /* __SHA1_H */
 
Index: csctapi/atr.c
===================================================================
--- csctapi/atr.c	(revision 10670)
+++ csctapi/atr.c	(working copy)
@@ -35,8 +35,8 @@
 /*
  * Exported variables definition
  */
-
-const uint32_t atr_f_table[16] = {372, 372, 558, 744, 1116, 1488, 1860, 0, 0, 512, 768, 1024, 1536, 2048, 0, 0};
+// sky(558->612)
+const uint32_t atr_f_table[16] = {372, 372, 612, 744, 1116, 1488, 1860, 0, 0, 512, 768, 1024, 1536, 2048, 0, 0};
 
 const double atr_d_table[16] = {0, 1, 2, 4, 8, 16, 32, 64, 12, 20, 0, 0, 0, 0, 0, 0};
 //const double atr_d_table[16] = {0, 1, 2, 4, 8, 16, 32, 64, 12, 20, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625};
Index: csctapi/cardreaders.h
===================================================================
--- csctapi/cardreaders.h	(revision 10670)
+++ csctapi/cardreaders.h	(working copy)
@@ -13,5 +13,6 @@
 extern const struct s_cardreader cardreader_smartreader;
 extern const struct s_cardreader cardreader_stapi;
 extern const struct s_cardreader cardreader_stinger;
+extern const struct s_cardreader cardreader_internal_hisky;
 
 #endif
Index: csctapi/icc_async.c
===================================================================
--- csctapi/icc_async.c	(revision 10670)
+++ csctapi/icc_async.c	(working copy)
@@ -26,11 +26,11 @@
 #ifdef WITH_CARDREADER
 #include "../oscam-lock.h"
 #include "../oscam-string.h"
+#include "../oscam-time.h"
 #include "icc_async.h"
 #include "protocol_t0.h"
 #include "io_serial.h"
 #include "ifd_phoenix.h"
-#include "../oscam-time.h"
 
 #define OK 0
 #define ERROR 1
@@ -272,6 +272,7 @@
 {
 	int32_t timeout = ETU_to_us(reader, wait_etu);
 	rdr_log_dbg(reader, D_IFD, "Setting timeout to %i ETU (%d us)", wait_etu, timeout);
+//	myprintf("Setting timeout to %i ETU (%d us)\n", wait_etu, timeout );
 	return timeout;
 }
 
@@ -348,11 +349,13 @@
 	return crdr_ops->do_reset(reader, atr, rdr_activate_card, rdr_get_cardsystem);
 }
 
-/*static uint32_t ICC_Async_GetClockRate_NewSmart(int32_t cardmhz)
+/*
+static uint32_t ICC_Async_GetClockRate_NewSmart(int32_t cardmhz)
 {
  	return (cardmhz * 10000L);
 
-}*/
+}
+*/
 
 static uint32_t ICC_Async_GetClockRate(int32_t cardmhz)
 {
@@ -531,6 +534,11 @@
 				FI = req[2] >> 4;
 				unsigned char DI = req[2] & 0x0F;
 				D = atr_d_table[DI];
+#if defined(WITH_HISILICON)
+				if (IS_CARD_READER(reader)) {
+					if ((D == 32) || (D == 12) || (D == 20)) D = 0;
+				}
+#endif
 				uint32_t F = atr_f_table[FI];
 				PPS_success = 1;
 				rdr_log_dbg(reader, D_ATR, "PTS Succesfull, selected protocol: T%i, F=%d, D=%d, N=%d",
@@ -577,7 +585,7 @@
 		D = ATR_DEFAULT_D;
 		rdr_log(reader, "Warning: D=0 is invalid, forcing D=%d", D);
 	}
-	rdr_log(reader, "Init card protocol T%i, FI=%d, F=%d, D=%d, N=%d", reader->protocol_type, FI, F, D, N);
+	rdr_log(reader, "Init{%d} card protocol T%i, FI=%d, F=%d, D=%d, N=%d", deprecated, reader->protocol_type, FI, F, D, N);
 	if(deprecated == 0)
 		{ return InitCard(reader, atr, FI, D, N, deprecated); }
 	else
@@ -751,11 +759,11 @@
 		else if(reader->mhz >= 369)  { reader->mhz =  369; }
 		else if(reader->mhz >= 357)  { reader->mhz =  369; } // 357 not suported by smartreader
 		else if(reader->mhz >= 343)  { reader->mhz =  343; }
-		else
-		{ reader->mhz =  320; }
+		      else { reader->mhz =  320; }
+	      }
 		}
+		F = reader->mhz; // all other readers
 	}	
-	F = reader->mhz; } // all other readers
         reader->worketu = (double)((double)(1 / (double)D) * ((double)Fi / (double)((double)F / 100)));
 	rdr_log(reader, "Calculated work ETU is %.2f us reader mhz = %u", reader->worketu, reader->mhz);
 
@@ -776,8 +784,8 @@
 			wi = DEFAULT_WI;
 
 		WWT = (uint32_t) 960 * D * wi; //in work ETU
-
-		/*unsigned char tmpatr[7]; // this is card atr of conax with pairingecmrotation, they need some additional WWT time but this isnt in those ATRs
+/*
+			unsigned char tmpatr[7]; // this is card atr of conax with pairingecmrotation, they need some additional WWT time but this isnt in those ATRs
 		tmpatr[0] = 0x3B;
 		tmpatr[1] = 0x24;
 		tmpatr[2] = 0x00;
@@ -790,7 +798,8 @@
 	//	WWT = (uint32_t) 960 * D * wi; //in work ETU
 		if (!memcmp(reader->card_atr, tmpatr, sizeof(tmpatr))){ // check for conax pairingecmrotation card atr.
 		    WWT = WWT * 600; // if found add some additional WWT time
-		}*/
+			}
+*/
 		GT = 2; // standard guardtime
 		GT += 1; // start bit
 		GT += 8; // databits
@@ -901,6 +910,9 @@
 //		reader->worketu *= 2.1; else // increase the worketu for v2 and tripple zigo try out
 		reader->worketu *= 2; // overclocked T14 needs this otherwise high ecm reponses
 	}
+#if defined(WITH_HISILICON)
+	reader->scideprecated = deprecated;
+#endif
 
 	struct s_cardreader_settings s = {
 		.ETU = ETU,
Index: csctapi/ifd_hisky.c
===================================================================
--- csctapi/ifd_hisky.c	(nonexistent)
+++ csctapi/ifd_hisky.c	(working copy)
@@ -0,0 +1,1336 @@
+/*
+//	sky(n)
+	ifd_hisky.c
+	This module provides IFD handling functions for SCI internal reader.
+*/
+
+#include "../globals.h"
+
+#ifdef CARDREADER_INTERNAL_HISKY
+#include "atr.h"
+#include "ifd_hisky.h"
+//
+//
+//
+#if 1
+	#define	MYSCI_TRACE		myprintf
+#else
+	#define	MYSCI_TRACE(...)
+#endif
+//
+//
+// 	future test...
+#define __HIS_PPSNEGOTIATION__
+//
+//
+//
+#define HI_DEVICE_NAME	"hi_sci"
+#define MAX_TX_TIMEOUT			5000
+#define MAX_RX_TIMEOUT			12000
+#define SUCCESS					0
+#define OK							SUCCESS
+#define ERROR						1
+#define FAILURE 					2
+#define _IS_CARD_INSERTED_(s)	(((s) <= HI_UNF_SCI_STATUS_NOCARD) ? 0 : 1)
+
+#if 0
+static pthread_mutex_t			CUR_Mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+static int							SMC_Inserted  	= 0;
+static HI_UNF_SCI_PROTOCOL_E	SMC_Protocol;
+static int							SMC_Activated 	= FALSE;
+static struct s_reader *		SMC_Readerp  	= NULL;
+
+extern char  *strtoupper(char *s);
+extern void   cs_sleep  (uint32_t msec);
+extern void   cs_sleepms(uint32_t msec);
+extern int    cs_save_cardinformation(struct s_reader *rdr);
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+uint16_t
+HISCIAPI_ChkCardstatus(struct s_reader *reader)
+{
+	uint16_t	scstatus = 0;
+
+	if (!reader) reader = SMC_Readerp;
+	if ( reader)
+	{
+//		mycs_log("CARDSTATUS:(%p) {%d, %d} {%d}", reader,
+//				reader->restarting, reader->card_status,
+//				SMC_Inserted);
+		if (reader->restarting)
+		{
+			scstatus = SMCSTATUS_RESTART;
+		}
+		else
+		{
+			switch (reader->card_status) {
+				case NO_CARD: 			scstatus = SMCSTATUS_NOCARD; 	break;
+				case CARD_NEED_INIT:	scstatus = SMCSTATUS_INIT; 	break;
+				case CARD_FAILURE:  	scstatus = SMCSTATUS_FAILURE; break;
+				case CARD_INSERTED:	scstatus = SMCSTATUS_OK;		break;
+				case UNKNOWN:
+				default:					scstatus = SMCSTATUS_RESTART;	break;
+			}
+		}
+	}
+	else
+	{
+//		mycs_log("Cardstatus:{%d}", SMC_Inserted);
+		scstatus = (SMC_Inserted) ? SMCSTATUS_DEACTIVE : SMCSTATUS_NOCARD;
+	}
+	return (scstatus);
+}
+
+char *
+HISCIAPI_ChkCardsystem(struct s_reader *reader)
+{
+	static char cards[1025] = {'\0'};
+
+	strcpy(cards, "");
+	if (!reader) reader = SMC_Readerp;
+	if (!reader) return (cards);
+	if ( reader->card_status == NO_CARD) {
+		strcpy(cards, "No smartcard");
+	}
+	else if (reader->card_status == CARD_NEED_INIT) {
+		strcpy(cards, "---");
+	}
+	else if (reader->csystem && reader->csystem->desc) {
+		strcpy(cards, reader->csystem->desc);
+		strtoupper(cards);
+	}
+	else {
+		strcpy(cards, "Unknown card");
+	}
+	return (cards);
+}
+
+bool
+HISCIAPI_SaveCardstatus(struct s_reader *reader)
+{
+	FILE *pf = NULL;
+	char szFile[256];
+
+	if (!reader) reader = SMC_Readerp;
+	strcpy(szFile,"/var/smartcard");
+	if ((pf = fopen(szFile, "w"))==NULL) return 0;
+	fprintf(pf,"status=%d\n", HISCIAPI_ChkCardstatus(reader));
+	fclose(pf);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static void
+HISCI_Msleep(int ms)
+{
+//	cs_sleepms(ms);
+	cs_sleep(ms);
+}
+
+static int
+HISCI_IsAvailable(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+
+	if (!reader) return 0;
+	if ( reader->handle < 0) return 0;
+	enSciPort = reader->scinum;
+	if (enSciPort >= HI_UNF_SCI_PORT_BUTT)
+	{
+		mycs_trace(D_ADB, "hisci:error scinum{%d}", enSciPort);
+		return 0;
+	}
+	return 1;
+}
+
+static int
+HISCI_ChkInserted(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S   SciStatus;
+	HI_S32	Ret;
+	int		bInserted;
+
+	if (!HISCI_IsAvailable(reader)) return 0;
+	enSciPort = reader->scinum;
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.i{%08X}", Ret);
+		bInserted = 0;
+	}
+	else
+	{
+	//	MYSCI_TRACE("mycard:getstatus{%d}\n", SciStatus.enSciStatus);
+		bInserted = _IS_CARD_INSERTED_(SciStatus.enSciStatus);
+	}
+	SMC_Inserted = bInserted;
+	return (bInserted);
+}
+
+
+int32_t
+HISCI_Open(struct s_reader *reader, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 uFs)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_OPEN_S	SciOpen;
+	SCI_LEVEL_S	SciLevel;
+	HI_S32	Ret;
+
+//	MYSCI_TRACE("mycard:open{%d,%d}\n", enSciProtocol, uFs);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	SciOpen.enSciPort		= enSciPort;
+	SciOpen.enSciProtocol= enSciProtocol;
+	SciOpen.Frequency		= uFs;
+	Ret = ioctl(reader->handle, CMD_SCI_OPEN, &SciOpen);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+	//
+	//
+	//
+#if defined(SDKV500) || defined(SDKV600)
+	SCI_IO_OUTPUTTYPE_S SciClk;
+
+	SciClk.enSciPort = enSciPort;
+	SciClk.enIO = SCI_IO_CLK;
+	SciClk.enOutputType = HI_UNF_SCI_MODE_CMOS;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_MODE, &SciClk);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	SCI_IO_OUTPUTTYPE_S SciVcc;
+	SciVcc.enSciPort = enSciPort;
+	SciVcc.enIO = SCI_IO_VCC_EN;
+	SciVcc.enOutputType = HI_UNF_SCI_MODE_CMOS;
+//	SciVcc.enOutputType = HI_UNF_SCI_MODE_OD;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_MODE, &SciVcc);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	SCI_IO_OUTPUTTYPE_S SciReset;
+	SciReset.enSciPort = enSciPort;
+	SciReset.enIO = SCI_IO_RESET;
+	SciReset.enOutputType = HI_UNF_SCI_MODE_CMOS;
+//	SciReset.enOutputType = HI_UNF_SCI_MODE_OD;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_MODE, &SciReset);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+#else
+	SCI_CLK_S SciClk;
+	SciClk.enSciPort = enSciPort;
+//	SciClk.enClkMode = HI_UNF_SCI_CLK_MODE_OD;
+	SciClk.enClkMode = HI_UNF_SCI_CLK_MODE_CMOS;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_CLK_MODE, &SciClk);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+#endif
+
+	SciLevel.enSciPort	= enSciPort;
+	SciLevel.enSciLevel 	= HI_UNF_SCI_LEVEL_LOW;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_VCC, &SciLevel);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	SciLevel.enSciPort	= enSciPort;
+	SciLevel.enSciLevel 	= HI_UNF_SCI_LEVEL_LOW;
+//	SciLevel.enSciLevel 	= HI_UNF_SCI_LEVEL_HIGH;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_DETECT, &SciLevel);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+	SMC_Protocol = enSciProtocol;
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCI_Close(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32 Ret;;
+
+//	MYSCI_TRACE("mycard:close\n");
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	SMC_Activated = FALSE;
+	Ret = ioctl(reader->handle, CMD_SCI_CLOSE, &enSciPort);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.c{%08X}!", Ret);
+	}
+	return (Ret == HI_SUCCESS ? SUCCESS : ERROR);
+}
+
+
+int32_t
+HISCI_Deactivate(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32 Ret;
+
+	MYSCI_TRACE("mycard:deactivate\n");
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	Ret = ioctl(reader->handle, CMD_SCI_DEACTIVE, &enSciPort);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.d{%08X}!", Ret);
+	}
+	return (Ret == HI_SUCCESS ? SUCCESS : ERROR);
+}
+
+
+#if 0
+int32_t
+HISCI_SetProtocol(struct s_reader *reader, HI_UNF_SCI_PROTOCOL_E enSciProtocol)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_PROTOCOL_S SciProtocol;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setprotocol{%d}\n", enSciProtocol);
+	enSciPort = reader->scinum;
+	SciProtocol.enSciPort = enSciPort;
+	SciProtocol.enSciProtocol = enSciProtocol;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_PROTOCOL, &SciProtocol);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.p{%08X.%d}!", Ret, SciProtocol.enSciProtocol);
+	}
+	return (Ret == HI_SUCCESS ? SUCCESS : ERROR);
+}
+#endif
+
+
+static int32_t
+HISCI_ChkAtrCompleted(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	HI_S32	uResetTime;
+	HI_S32	Ret;
+
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort  = reader->scinum;
+	uResetTime = 0;
+	HISCI_Msleep(500);
+	while (1)
+	{
+		/*get SCI card status */
+		SciStatus.enSciPort = enSciPort;
+		Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+		if (Ret != HI_SUCCESS)
+		{
+			mycs_trace(D_ADB, "hisci:io error.a{%08X}!", Ret);
+			return (ERROR);
+		}
+		if (!_IS_CARD_INSERTED_(SciStatus.enSciStatus))
+		{
+			mycs_trace(D_ADB, "hisci:no card{%d}!", SciStatus.enSciStatus);
+			SMC_Inserted = 0;
+			return (ERROR);
+		}
+		if (SciStatus.enSciStatus >= HI_UNF_SCI_STATUS_READY)
+		{
+			/*reset Success*/
+			mycs_trace(D_ADB, "hisci:Atr success");
+			break;
+		}
+//		MYSCI_TRACE("hisci:Atr waiting{%d,%d}...\n", SciStatus.enSciStatus, uResetTime);
+		uResetTime += 1;
+
+		if (uResetTime > 30)
+		{
+			mycs_trace(D_ADB, "hisci:Atr failure");
+			return (FAILURE);
+		}
+		HISCI_Msleep(50);
+	}
+	HISCI_Msleep(100);
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCI_CardReset(struct s_reader *reader, HI_BOOL bWarmReset)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_RESET_S	SciReset;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:resetcard\n");
+	enSciPort = reader->scinum;
+	SciReset.enSciPort	= enSciPort;
+	SciReset.bWarmReset 	= bWarmReset;
+	Ret = ioctl(reader->handle, CMD_SCI_RESET, &SciReset);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.r{%08X}!", Ret);
+		return (ERROR);
+	}
+	Ret = HISCI_ChkAtrCompleted(reader);
+	return (Ret);
+}
+
+
+int32_t
+HISCI_CardSwitch(struct s_reader *reader, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 uFs)
+{
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:switchcard{%d,%d}\n", enSciProtocol, uFs);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	if (HI_UNF_SCI_PROTOCOL_T14 == enSciProtocol)
+	{
+		if ((uFs < 1000) || (uFs > 6000))
+		{
+			mycs_trace(D_ADB, "hisci:error para uFs is invalid{%d}", uFs);
+			return (ERROR);
+		}
+	}
+	else
+	{
+		if ((uFs < 1000) || (uFs > 5000))
+		{
+			mycs_trace(D_ADB, "hisci:error para uFs is invalid{%d}", uFs);
+			return (ERROR);
+		}
+	}
+
+#if 0
+	//	CMD_SCI_SET_PROTOCOL
+	SCI_OPEN_S	SciSwitch;
+	HI_UNF_SCI_PORT_E enSciPort = reader->scinum;
+
+	SciSwitch.enSciPort 	= enSciPort;
+	SciSwitch.enSciProtocol = enSciProtocol;
+	SciSwitch.Frequency 	= uFs;
+	Ret = ioctl(reader->handle, CMD_SCI_SWITCH, &SciSwitch);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.s{%08X}!", Ret);
+		return (ERROR);
+	}
+	Ret = HISCI_ChkAtrCompleted(reader);
+	return (Ret);
+#else
+	Ret = HISCI_Close(reader);
+	Ret = HISCI_Open(reader, enSciProtocol, uFs);
+	if (Ret != SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:open(%d) error!", Ret);
+		return (ERROR);
+	}
+	Ret = HISCI_CardReset(reader, HI_TRUE);
+	return (Ret);
+#endif
+}
+
+
+
+int32_t
+HISCI_GetParameters(struct s_reader *reader, HI_UNF_SCI_PARAMS_S_PTR pParams)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:getparameters\n");
+	enSciPort = reader->scinum;
+	if (!pParams) return (ERROR);
+	pParams->enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_PARAM, pParams);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.g{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetBaudrates(struct s_reader *reader, HI_U32 uClkFactor, HI_U32 uBaudFactor)
+{
+	HI_UNF_SCI_PARAMS_S	SciParams;
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_EXT_BAUD_S	SciBaud;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setbaudrate\n");
+	enSciPort = reader->scinum;
+	if (uClkFactor<372 || uClkFactor>2048)
+	{
+		mycs_trace(D_ADB, "hisci:u32ClkRate(%d) is invalid", uClkFactor);
+		return (ERROR);
+	}
+	if ((uBaudFactor< 1) ||
+		(uBaudFactor>32) ||
+		(1!=uBaudFactor  && (uBaudFactor%2)!=0))
+	{
+		mycs_trace(D_ADB, "hisci:u32BitRate(%d) is invalid", uBaudFactor);
+		return (ERROR);
+	}
+
+	Ret = HISCI_GetParameters(reader, &SciParams);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:getparameters error{%d}", Ret);
+		return (ERROR);
+	}
+	if (SciParams.Fi == uClkFactor && SciParams.Di == uBaudFactor)
+	{
+		mycs_trace(D_ADB, "hisci:setparameters same");
+		return (SUCCESS);
+	}
+
+	SciBaud.enSciPort = enSciPort;
+	SciBaud.ClkRate   = uClkFactor;
+	SciBaud.BitRate   = uBaudFactor;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_BAUD, &SciBaud);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.b{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetGuardTime(struct s_reader *reader, HI_U32 u32GuardTime)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_ADD_GUARD_S   GuardTime;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setguardtime\n");
+	enSciPort = reader->scinum;
+	if (u32GuardTime > 254)
+	{
+		mycs_trace(D_ADB, "hisci:u32GuardTime(%d) is invalid", u32GuardTime);
+		return (ERROR);
+	}
+	GuardTime.enSciPort = enSciPort;
+	GuardTime.AddCharGuard = u32GuardTime;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_CHGUARD, &GuardTime);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.gu{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetCharTimeout(struct s_reader *reader, HI_U32 MaxCharTime)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_CHARTIMEOUT_S Chtimeout;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setchartimeout\n");
+	enSciPort = reader->scinum;
+	if (HI_UNF_SCI_PROTOCOL_T1 == SMC_Protocol)
+	{
+		if (MaxCharTime<12 || MaxCharTime>32779)
+		{
+			mycs_trace(D_ADB, "hisci:MaxCharTime(%d) is invalid", MaxCharTime);
+			return (ERROR);
+		}
+	}
+	else
+	{
+		if (MaxCharTime<960 || MaxCharTime>244800)
+		{
+			mycs_trace(D_ADB, "hisci:MaxCharTime(%d) is invalid", MaxCharTime);
+			return (ERROR);
+		}
+	}
+	Chtimeout.enSciPort = enSciPort;
+	Chtimeout.enSciProtocol = SMC_Protocol;
+	Chtimeout.CharTimeouts	= MaxCharTime;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_CHARTIMEOUT, &Chtimeout);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.ct{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCI_SetBlockTimeout(struct s_reader *reader, HI_U32 MaxBlockTime)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_BLOCKTIMEOUT_S BlkTimeout;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setblocktimeout\n");
+	enSciPort = reader->scinum;
+	if (MaxBlockTime<971 || MaxBlockTime>491531 )
+	{
+		mycs_trace(D_ADB, "hisci:MaxBlockTime(%d) is invalid", MaxBlockTime);
+		return (ERROR);
+	}
+	BlkTimeout.enSciPort = enSciPort;
+	BlkTimeout.BlockTimeouts = MaxBlockTime;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_BLOCKTIMEOUT, &BlkTimeout);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.bt{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetTxRetries(struct s_reader *reader, HI_U32 TxRetryTimes)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_TXRETRY_S TxRetry;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:settxretries\n");
+	enSciPort = reader->scinum;
+	if (TxRetryTimes > 7)
+	{
+		mycs_trace(D_ADB, "hisci:TxRetryTimes(%d) is invalid", TxRetryTimes);
+		return (ERROR);
+	}
+	TxRetry.enSciPort = enSciPort;
+	TxRetry.TxRetryTimes = TxRetryTimes;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_TXRETRY, &TxRetry);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.tr{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+
+int32_t
+HISCI_ReadAtr(struct s_reader *reader, ATR *pAtr) // reads ATR on the fly: reading and some low levelchecking at the same time
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32	   	Ret;
+	SCI_ATR_S  	SciAtr;
+	HI_U8 		Atrbuf[256];
+	int32_t statusreturn =0;
+
+	MYSCI_TRACE("mycard:read_atr\n");
+	enSciPort = reader->scinum;
+	SciAtr.enSciPort 	= enSciPort;
+	SciAtr.pAtrBuf	 	= Atrbuf;
+	SciAtr.BufSize	 	= 255;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_ATR, &SciAtr);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.ra{%08X}!", Ret);
+		return (ERROR);
+	}
+
+#if 0
+	statusreturn = ATR_InitFromArray(pAtr, SciAtr.pAtrBuf, SciAtr.DataLen); // n should be same as atrlength but in case of atr read error its less so do not use atrlenght here!
+	if (statusreturn == ATR_MALFORMED)
+	{
+		mycs_trace(D_ADB, "hisci:error ATR is malformed");
+	}
+	if (statusreturn == ERROR)
+	{
+		mycs_trace(D_ADB, "hisci:error ATR is invalid!");
+		return (ERROR);
+	}
+
+	HI_UNF_SCI_PARAMS_S	SciParams;
+	Ret = HISCI_GetParameters(reader, &SciParams);
+	if (Ret == HI_SUCCESS)
+	{
+		if (SciParams.enProtocolType != SMC_Protocol)
+		{
+			Ret = HISCI_SetProtocol(reader, SciParams.enProtocolType);
+		}
+	}
+#else
+	unsigned char buf[ATR_MAX_SIZE];
+	int32_t n = 0;
+	uint8_t recvlen = SciAtr.DataLen;
+	memcpy(buf, Atrbuf, ATR_MAX_SIZE);
+	rdr_log_dbg(reader, D_IFD, "received ATR length = %d", recvlen);
+
+	if (recvlen < 2)
+	{
+		rdr_log_dbg(reader, D_IFD, "ERROR: only 1 character found in ATR");
+		return ERROR;
+	}
+
+	if (buf[0] == 0x3F) // 3F: card is using inverse convention, 3B = card is using direct convention
+		rdr_log_dbg(reader, D_IFD, "This card uses inverse convention");
+	else
+		rdr_log_dbg(reader, D_IFD, "This card uses direct convention");
+	n++;
+
+	int32_t T0= buf[n];
+	int32_t historicalbytes = T0&0x0F; // num of historical bytes in lower nibble of T0 byte
+	rdr_log_dbg(reader, D_ATR, "ATR historicalbytes should be: %d", historicalbytes);
+	rdr_log_dbg(reader, D_ATR, "Fetching global interface characters for protocol T0"); // protocol T0 always aboard!
+	n++;
+
+	int32_t protocols=1, tck = 0, protocol, protocolnumber;	// protocols = total protocols on card, tck = checksum byte present, protocol = mandatory protocol
+	int32_t D = 0;												// protocolnumber = TDi uses protocolnumber
+	int32_t TDi = T0; // place T0 char into TDi for looped parsing.
+	while (n < recvlen)
+	{
+		if (TDi&0x10)
+		{  //TA Present: 							   //The value of TA(i) is always interpreted as XI || UI if i > 2 and T = 15 ='F'in TD(i?)
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;  //In this case, TA(i) contains the clock stop indicator XI, which indicates the logical
+																  //state the clockline must assume when the clock is stopped, and the class indicator UI,
+			rdr_log_dbg(reader, D_ATR, "TA%d: %02X",protocols,buf[n]);      //which specifies the supply voltage class.
+			if ((protocols >2) && ((TDi&0x0F)==0x0F)) {  // Protocol T15 does not exists, it means mandatory on all ATRs
+				if ((buf[n]&0xC0) == 0xC0) rdr_log_dbg(reader, D_ATR, "Clockline low or high on clockstop");
+				if ((buf[n]&0xC0) == 0x00) rdr_log_dbg(reader, D_ATR, "Clockline not supported on clockstop");
+				if ((buf[n]&0xC0) == 0x40) rdr_log_dbg(reader, D_ATR, "Clockline should be low on clockstop");
+				if ((buf[n]&0xC0) == 0x80) rdr_log_dbg(reader, D_ATR, "Clockline should be high on clockstop");
+				if ((buf[n]&0x3F) == 0x01) rdr_log_dbg(reader, D_ATR, "Voltage class A 4.5~5.5V");
+				if ((buf[n]&0x3F) == 0x02) rdr_log_dbg(reader, D_ATR, "Voltage class B 2.7~3.3V");
+				if ((buf[n]&0x3F) == 0x03) rdr_log_dbg(reader, D_ATR, "Voltage class A 4.5~5.5V and class B 2.7~3.3V");
+				if ((buf[n]&0x3F) == 0x04) rdr_log_dbg(reader, D_ATR, "Voltage RFU");
+			}
+			if ((protocols >2) && ((TDi&0x0F)==0x01)) {  // Protocol T1 specfic (There is always an obsolete T0 protocol!)
+				int32_t ifsc = buf[n];
+				if (ifsc == 0x00) ifsc = 32; //default is 32
+				rdr_log_dbg(reader, D_ATR, "Maximum information field length this card can receive is %d bytes (IFSC)", ifsc);
+			}
+
+			if (protocols < 2) {
+				int32_t FI = (buf[n]>>4); // FI is high nibble                  ***** work ETU = (1/D)*(Frequencydivider/cardfrequency) (in seconds!)
+				int32_t F  = atr_f_table[FI]; // lookup the frequency divider
+				float fmax = atr_fs_table[FI]; // lookup the max frequency      ***** initial ETU = 372 / initial frequency during atr  (in seconds!)
+
+				int32_t DI = (buf[n]&0x0F); // DI is low nibble
+				D = atr_d_table[DI]; // lookup the bitrate adjustment (yeah there are floats in it, but in iso only integers!?)
+				rdr_log_dbg(reader, D_ATR, "Advertised max cardfrequency is %.2f (Fmax), frequency divider is %d (F)", fmax/1000000L, F); // High nibble TA1 contains cardspeed
+				rdr_log_dbg(reader, D_ATR, "Bitrate adjustment is %d (D)", D); // Low nibble TA1 contains Bitrateadjustment
+				rdr_log_dbg(reader, D_ATR, "Work ETU = %.2f us", (double) ((1/(double)D)*((double)F/(double)fmax)*1000000)); // And display it...
+				rdr_log_dbg(reader, D_ATR, "Initial ETU = %.2f us", (double)372/(double)fmax*1000000); // And display it... since D=1 and frequency during ATR fetch might be different!
+			}
+			if (protocols > 1 && protocols <3) {
+				if ((buf[n]&0x80)==0x80) rdr_log_dbg(reader, D_ATR, "Switching between negotiable mode and specific mode is not possible");
+				else {
+					rdr_log_dbg(reader, D_ATR, "Switching between negotiable mode and specific mode is possible");
+					// int32_t PPS = 1; Stupid compiler, will need it later on eventually
+				}
+				if ((buf[n]&0x01)==0x01) rdr_log_dbg(reader, D_ATR, "Transmission parameters implicitly defined in the interface characters.");
+				else rdr_log_dbg(reader, D_ATR, "Transmission parameters explicitly defined in the interface characters.");
+
+				protocol = buf[n]&0x0F;
+				if (protocol) rdr_log_dbg(reader, D_ATR, "Protocol T = %d is to be used!", protocol);
+			}
+			n++; // next interface character
+		}
+		if (TDi&0x20)
+		{	 //TB Present
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+			rdr_log_dbg(reader, D_ATR, "TB%d: %02X",protocols,buf[n]);
+			if ((protocols >2) && ((TDi&0x0F)==0x01)) {  // Protocol T1 specfic (There is always an obsolete T0 protocol!)
+				int32_t CWI = (buf[n]&0x0F); // low nibble contains CWI code for the character waiting time CWT
+				int32_t BWI = (buf[n]>>4); // high nibble contains BWI code for the block waiting time BWT
+				int32_t CWT = (1<<CWI) + 11; // in work etu  *** 2^CWI + 11 work etu ***
+				rdr_log_dbg(reader, D_ATR, "Protocol T1: Character waiting time is %d work etu (CWT)", CWT);
+				int32_t BWT = (int) ((1<<BWI) * 960 * 372); // divided by frequency and add with 11 work etu *** 2^BWI*960*372/f + 11 work etu ***
+				rdr_log_dbg(reader, D_ATR, "Protocol T1: Block waiting time is %d divided by actual cardfrequency + 11 work etu (BWI)", BWI);
+				rdr_log_dbg(reader, D_ATR, "Protocol T1: BWT: %d", BWT);
+			}
+
+			n++; // next interface character
+		}
+		if (TDi&0x40)
+		{	 //TC Present
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+			rdr_log_dbg(reader, D_ATR, "TC%d: %02X",protocols, buf[n]);
+			if ((protocols > 1) && ((TDi&0x0F)==0x00)) {
+				int32_t WI = buf[n];
+				rdr_log_dbg(reader, D_ATR, "Protocol T0: work wait time is %d work etu (WWT)", (int) (960*D*WI));
+			}
+			if ((protocols > 1) && ((TDi&0x0F)==0x01)) {
+				if (buf[n]&0x01) rdr_log_dbg(reader, D_ATR, "Protocol T1: CRC is used to compute the error detection code");
+				else rdr_log_dbg(reader, D_ATR, "Protocol T1: LRC is used to compute the error detection code");
+			}
+			if ((protocols < 2) && (buf[n]<0xFF)) rdr_log_dbg(reader, D_ATR, "Extra guardtime of %d ETU (N)", (int) buf[n]);
+			if ((protocols < 2) && (buf[n]==0xFF)) rdr_log_dbg(reader, D_ATR, "Protocol T1: Standard 2 ETU guardtime is lowered to 1 ETU");
+
+			n++; // next interface character
+		}
+		if (TDi&0x80)
+		{	//TD Present? Get next TDi there will be a next protocol
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+			rdr_log_dbg(reader, D_ATR, "TD%d %02X",protocols,buf[n]);
+			TDi = buf[n];
+			protocolnumber = TDi&0x0F;
+			if (protocolnumber == 0x00) tck = 0; // T0 protocol do not use tck byte  (TCK = checksum byte!)
+			if (protocolnumber == 0x0E) tck = 1; // T14 protocol tck byte should be present
+			if (protocolnumber == 0x01) tck = 1; // T1 protocol tck byte is mandatory, BTW: this code doesnt calculate if the TCK is valid jet...
+			rdr_log_dbg(reader, D_ATR, "Fetching global interface characters for protocol T%d:", (TDi&0x0F)); // lower nibble contains protocol number
+			protocols++; // there is always 1 protocol T0 in every ATR as per iso defined, max is 16 (numbered 0..15)
+
+			n++; // next interface character
+		}
+		else break;
+	}
+	int32_t atrlength = 0;
+	atrlength += n;
+	atrlength += historicalbytes;
+	rdr_log_dbg(reader, D_ATR, "Total ATR Length including %d historical bytes should be %d",historicalbytes,atrlength);
+	if (T0&0x80) protocols--;	// if bit 8 set there was a TD1 and also more protocols, otherwise this is a T0 card: substract 1 from total protocols
+	rdr_log_dbg(reader, D_ATR, "Total protocols in this ATR is %d",protocols);
+
+	while (n < atrlength + tck)
+	{ // read all the rest and mandatory tck byte if other protocol than T0 is used.
+		//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+		n++;
+	}
+
+	if (n!=atrlength+tck) cs_log("Warning reader %s: Total ATR characters received is: %d instead of expected %d", reader->label, n, atrlength+tck);
+
+	if ((buf[0] != 0x3B) && (buf[0] != 0x3F) && (n>9 && !memcmp(buf+4, "IRDETO", 6))) //irdeto S02 reports FD as first byte on dreambox SCI, not sure about SH4 or phoenix
+		  buf[0]  = 0x3B;
+
+	statusreturn = ATR_InitFromArray (pAtr, buf, n); // n should be same as atrlength but in case of atr read error its less so do not use atrlenght here!
+
+	if (statusreturn == ATR_MALFORMED) cs_log("Warning reader %s: ATR is malformed, you better inspect it with a -d2 log!", reader->label);
+
+	if (statusreturn == ERROR) {
+		cs_log("Warning reader %s: ATR is invalid!", reader->label);
+		return ERROR;
+	}
+#endif
+	return (SUCCESS); // return (OK) but atr might be softfailing!
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+int32_t
+HISCIAPI_Initialize(struct s_reader *reader)
+{
+	HI_UNF_SCI_PROTOCOL_E enSciProtocol;
+	HI_U32	uFs;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:initialize(%s)\n", HI_DEVICE_NAME);
+	reader->card_status	= NO_CARD;
+	reader->use_gpio 		= 0;
+	reader->resetcounter = 0;
+	reader->mhz 			= 9600;
+	SMC_Readerp = reader;
+	HISCIAPI_SaveCardstatus(reader);
+	cs_save_cardinformation(reader);
+
+	reader->scinum = HI_UNF_SCI_PORT0;
+	reader->handle = open("/dev/"HI_DEVICE_NAME, O_RDWR, 0);
+	if (reader->handle < 0)
+	{
+		mycs_trace(D_ADB, "hisci:error:%s", HI_DEVICE_NAME);
+		return (ERROR);
+	}
+	//
+	//
+	//
+	#if 1
+	uFs = 3570;
+//	uFs = 3692;
+	enSciProtocol = HI_UNF_SCI_PROTOCOL_T0;
+	#else
+	uFs = 6000;
+	enSciProtocol = HI_UNF_SCI_PROTOCOL_T14;
+	#endif
+	Ret = HISCI_Open(reader, enSciProtocol, uFs);
+	if (Ret != SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:open(%d) error!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_Terminates(struct s_reader *reader)
+{
+	HI_S32 Ret;
+
+	MYSCI_TRACE("mycard:terminate(%s)\n", HI_DEVICE_NAME);
+	HISCIAPI_SaveCardstatus(reader);
+	cs_save_cardinformation(reader);
+	if (reader->handle < 0) return (ERROR);
+	HISCI_Close(reader);
+
+	Ret = close(reader->handle);
+//	pthread_mutex_destroy(&CUR_Mutex);
+	if (HI_SUCCESS != Ret)
+	{
+		mycs_trace(D_ADB, "hisci:close error{%d}!", Ret);
+		return (ERROR);
+	}
+	reader->handle = -1;
+	SMC_Readerp = NULL;
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_GetStatus(struct s_reader *reader, int32_t *status)
+{
+	*status = 0;
+	if (HISCI_ChkInserted(reader)) *status = 1;
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_DoReset(struct s_reader *UNUSED(reader), struct s_ATR *UNUSED(pAtr),
+	int32_t (*rdr_activate_card) (struct s_reader *, struct s_ATR *, uint16_t deprecated),
+	int32_t (*rdr_get_cardsystem)(struct s_reader *, struct s_ATR *))
+{
+	MYSCI_TRACE("mycard:doreset\n");
+	SMC_Activated = FALSE;
+	if (rdr_activate_card)
+	{
+	}
+	if (rdr_get_cardsystem)
+	{
+	}
+	return (SUCCESS);
+}
+
+#define	MAX_SWITCH_TRIES	4	// 2
+
+int32_t
+HISCIAPI_Activate(struct s_reader *reader, ATR *pAtr)
+{
+	HI_U32	uFs;
+	HI_S32	Ret;
+	HI_S32	uTries = 0;
+
+	MYSCI_TRACE("mycard:activate{%d,%d}\n", SMC_Protocol, SMC_Activated);
+	if (!HISCI_ChkInserted(reader))
+	{
+		mycs_trace(D_ADB, "hisci:card none");
+		return (ERROR);
+	}
+	if (reader->ins7e11_fast_reset)
+	{
+		rdr_log(reader, "Doing fast reset");
+		Ret = HISCI_CardReset(reader, HI_TRUE);
+		if (Ret == SUCCESS)
+		{
+			Ret = HISCI_ReadAtr(reader, pAtr);
+		}
+	}
+	else
+	if (!SMC_Activated)
+	{
+		Ret = HISCI_CardReset(reader, HI_FALSE);
+		if (Ret == FAILURE)
+		{
+			while (uTries++ < MAX_SWITCH_TRIES)
+			{
+				//	(T0,T1),T14
+				HISCI_Msleep(100);
+				SMC_Protocol = (SMC_Protocol == HI_UNF_SCI_PROTOCOL_T14) ? HI_UNF_SCI_PROTOCOL_T0 : HI_UNF_SCI_PROTOCOL_T14;
+				uFs = (SMC_Protocol == HI_UNF_SCI_PROTOCOL_T14) ? 6000 : 3570;
+				Ret = HISCI_CardSwitch(reader, SMC_Protocol, uFs);
+				if (Ret == SUCCESS) break;
+			}
+		}
+
+		if (Ret == SUCCESS)
+		{
+			Ret = HISCI_ReadAtr(reader, pAtr);
+		}
+		SMC_Activated = TRUE;
+	}
+	else
+	{
+		Ret = HISCI_CardReset(reader, HI_FALSE);
+		if (Ret == SUCCESS)
+		{
+			Ret = HISCI_ReadAtr(reader, pAtr);
+		}
+	}
+	return (Ret);
+}
+
+
+#if 0
+int32_t
+HISCIAPI_WriteSettings3(struct s_reader *reader,
+	uint32_t ETU, uint32_t WWT, uint32_t I)
+{
+	MYSCI_TRACE("mycard:write_settings3{%d,%d,%d}\n", ETU, WWT, I);
+	return (SUCCESS);
+}
+
+int32_t
+HISCIAPI_WriteSettings2(struct s_reader *reader,
+	uint16_t F, uint8_t D, uint32_t WWT, uint32_t EGT, uint32_t BGT)
+{
+	MYSCI_TRACE("mycard:write_settings2{%d,%d}\n", EGT, BGT);
+	return (SUCCESS);
+}
+#endif
+
+
+int32_t
+HISCIAPI_WriteSettings(struct s_reader *reader, struct s_cardreader_settings *s)
+{
+	if (reader->scideprecated)
+	{
+		// future test.
+		MYSCI_TRACE("mycard:writesettings(deprecated)\n");
+		return (SUCCESS);
+	}
+//	MYSCI_TRACE("mycard:writesettings{%d,%d} {%d,%d,%d, %d,%d}\n",
+//			Fi, Di, ETU, EGT, P, I, Ni);
+	mycs_trace(D_ADB, "mycard:writesettings{%d,%d}", s->Fi, s->Di);
+	if (s->Fi == 372) return (SUCCESS);
+	if (s->Fi == 612) return (SUCCESS);
+	HISCI_SetBaudrates(reader, s->Fi, s->Di);
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_Transmit(struct s_reader *reader, unsigned char *buffer, uint32_t size, uint32_t UNUSED(expectedlen), uint32_t UNUSED(delay), uint32_t timeout)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	SCI_DATA_S		SciData;
+	HI_U32	u32ActLen;
+	HI_S32	Ret;
+
+//	MYSCI_TRACE("mycard:transmit{%3d,%d}\n", size, timeout);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+   if (timeout < MAX_TX_TIMEOUT) timeout = MAX_TX_TIMEOUT;
+	enSciPort = reader->scinum;
+	if (!buffer)
+	{
+		mycs_trace(D_ADB, "hisci:error transmit buffer!");
+		return (ERROR);
+	}
+
+	if (!size)
+	{
+		mycs_trace(D_ADB, "hisci:transmit size?{%d}", size);
+		return (ERROR);
+	}
+
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.wstatus{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	if (SciStatus.enSciStatus < HI_UNF_SCI_STATUS_READY)
+	{
+		if (!_IS_CARD_INSERTED_(SciStatus.enSciStatus)) SMC_Inserted = 0;
+		mycs_trace(D_ADB, "hisci:current state cann't execute send opertaion");
+		return (ERROR);
+	}
+	SciData.enSciPort = enSciPort;
+	SciData.pDataBuf  = buffer;
+	SciData.BufSize   = size;
+	SciData.TimeoutMs = timeout;
+	Ret = ioctl(reader->handle, CMD_SCI_SEND_DATA, &SciData);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.w{%d.%08X, %d}!", size, Ret, timeout);
+		return (ERROR);
+	}
+	u32ActLen = SciData.DataLen;
+	if (u32ActLen < size)
+	{
+		mycs_trace(D_ADB, "hisci:transmit size error{%d,%d}!", u32ActLen, size);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_Receive(struct s_reader *reader, unsigned char *buffer, uint32_t size, uint32_t UNUSED(delay), uint32_t timeout)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	SCI_DATA_S		SciData;
+	HI_U32	u32ActLen;
+	HI_S32	Ret;
+
+//	MYSCI_TRACE("mycard:receive.{%3d,%d}\n", size, timeout);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	timeout = MAX_RX_TIMEOUT;
+	enSciPort = reader->scinum;
+	if (!buffer)
+	{
+		mycs_trace(D_ADB, "hisci:error receive buffer!");
+		return (ERROR);
+	}
+	if (!size)
+	{
+		mycs_trace(D_ADB, "hisci:receive size?{%d}", size);
+		return (SUCCESS);
+	}
+
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.rstatus{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	if (SciStatus.enSciStatus < HI_UNF_SCI_STATUS_READATR)
+	{
+		if (!_IS_CARD_INSERTED_(SciStatus.enSciStatus)) SMC_Inserted = 0;
+		mycs_trace(D_ADB, "hisci:current state cann't execute send opertaion");
+		return (ERROR);
+	}
+
+	SciData.enSciPort = enSciPort;
+	SciData.pDataBuf  = buffer;
+	SciData.BufSize   = size;
+	SciData.TimeoutMs = timeout;
+	Ret = ioctl(reader->handle, CMD_SCI_RECEIVE_DATA, &SciData);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.r{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	u32ActLen = SciData.DataLen;
+	if (u32ActLen < size)
+	{
+		mycs_trace(D_ADB, "hisci:error receive size{%d,%d}!", u32ActLen, size);
+		return (ERROR);
+	}
+	return Ret;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#if defined(__HIS_PPSNEGOTIATION__)
+int32_t
+HISCIAPI_PpsExchange(struct s_reader *reader, unsigned char *params, unsigned *length, uint32_t lenrequest)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	HI_S32	Ret;
+
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.e{%08X}!", Ret);
+		return (ERROR);
+	}
+	if (!params) return (ERROR);
+	if (!length) return (ERROR);
+	if (!lenrequest) return (ERROR);
+
+	#if 0
+	{
+		SCI_PPS_S	SciPPS;
+
+		MYSCI_TRACE("mycard:ppsexchange{%d}\n", lenrequest);
+		memcpy((HI_U8 *)SciPPS.Send, params, lenrequest);
+		SciPPS.enSciPort= enSciPort;
+		SciPPS.SendLen	= lenrequest;
+		SciPPS.RecTimeouts = MAX_RX_TIMEOUT;
+		Ret = ioctl(reader->handle, CMD_SCI_SEND_PPS_DATA, &SciPPS);
+		if (Ret != HI_SUCCESS)
+		{
+			mycs_trace(D_ADB, "hisci:io error.e{%08X}!", Ret);
+			return (ERROR);
+		}
+
+		SciPPS.enSciPort = enSciPort;
+		Ret = ioctl(reader->handle, CMD_SCI_GET_PPS_DATA, &SciPPS);
+		if (Ret != HI_SUCCESS)
+		{
+			mycs_trace(D_ADB, "hisci:io error.e{%08X}!", Ret);
+			return (ERROR);
+		}
+		memcpy(params,(HI_U8 *)SciPPS.Receive, SciPPS.ReceiveLen);
+		*length = SciPPS.ReceiveLen;
+		if ((lenrequest != SciPPS.ReceiveLen) || (memcmp (params, SciPPS.Receive, lenrequest)))
+		{
+			mycs_trace(D_ADB, "hisci:pps error{%d,%d}!", lenrequest, SciPPS.ReceiveLen);
+			return (ERROR);
+		}
+		mycs_trace(D_ADB, "hisci:pts succesfull:FI=%d, DI=%d", params[2] >> 4, params[2] & 0x0F);
+	}
+	#else
+		MYSCI_TRACE("mycard:ppsexchange{none}\n");
+	#endif
+	return (SUCCESS);
+}
+#endif	// defined(__HIS_PPSNEGOTIATION__)
+
+void
+HISCIAPI_DisplayMessages(struct s_reader *reader, char *messages)
+{
+	if (!HISCI_IsAvailable(reader)) return;
+	if (!messages) return;
+	myprintf("mycard:displaymessages{%d}{%04X,%s}......\n",
+				 reader->restarting,
+ 				 reader->caid,
+ 				 messages);
+	reader->restarting = 0;
+}
+
+
+#if 0
+int32_t
+HISCIAPI_InitLocks(struct s_reader *reader)
+{
+//	UNAVAILABLE
+//	pthread_mutex_init(&CUR_Mutex, NULL);
+//	MYSCI_TRACE("mycard:initlocks......\n");
+	return (SUCCESS);
+}
+
+
+void
+HISCIAPI_Lock(struct s_reader *reader)
+{
+//	UNAVAILABLE
+//	MYSCI_TRACE("mycard:lock......\n");
+//	pthread_mutex_lock(&CUR_Mutex);
+}
+
+
+void
+HISCIAPI_Unlock(struct s_reader *reader)
+{
+//	UNAVAILABLE
+//	MYSCI_TRACE("mycard:unlock......\n");
+//	pthread_mutex_unlock(&CUR_Mutex);
+}
+
+
+int32_t
+HISCIAPI_SetParity(struct s_reader *reader, uchar parity)
+{
+//	UNAVAILABLE
+	MYSCI_TRACE("mycard:setparity{%d}......\n", parity);
+	return (SUCCESS);
+}
+
+int32_t
+HISCIAPI_SetBaudrate(struct s_reader *reader, uint32_t baudrate)
+{
+//	UNAVAILABLE
+	MYSCI_TRACE("mycard:setbaudrate{%d}......\n", baudrate);
+	return (SUCCESS);
+}
+
+void
+HISCIAPI_SetTransmitTimeout(struct s_reader *reader)
+{
+//	UNAVAILABLE
+	MYSCI_TRACE("mycard:settransmittimeout......\n");
+}
+
+
+bool
+HISCIAPI_SetDtsRts(struct s_reader *reader, int32_t *dtr, int32_t *rts)
+{
+	// UNAVAILABLE
+	MYSCI_TRACE("mycard:setdtsrts{%d,%d}......\n", *dtr, *rts);
+	return (SUCCESS);
+}
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+const struct s_cardreader cardreader_internal_hisky =
+{
+//	MYSCI_TRACE("CARDREADER_INTERNAL_HISKY......\n");
+	.desc					= "internal",
+	.typ					= R_INTERNAL,
+	.flush 				= 0,
+	.max_clock_speed	= 1,
+	.need_inverse		= 0,
+//	.timings_in_etu	= 1,
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	.reader_init		= HISCIAPI_Initialize,
+	.get_status			= HISCIAPI_GetStatus,
+	.activate			= HISCIAPI_Activate,
+	.transmit			= HISCIAPI_Transmit,
+	.receive				= HISCIAPI_Receive,
+	.close 				= HISCIAPI_Terminates,
+	.write_settings	= HISCIAPI_WriteSettings,
+//	.write_settings2	= HISCIAPI_WriteSettings2,
+//	.write_settings3	= HISCIAPI_WriteSettings3,
+	.do_reset			= HISCIAPI_DoReset,
+	#if defined(__HIS_PPSNEGOTIATION__)
+	.set_protocol		= HISCIAPI_PpsExchange,
+	#endif	// defined(__HIS_PPSNEGOTIATION__)
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+//	.lock_init 			= HISCIAPI_InitLocks,
+//	.lock					= HISCIAPI_Lock,
+//	.unlock				= HISCIAPI_Unlock,
+//	.set_parity			= HISCIAPI_SetParity,
+//	.set_baudrate		= HISCIAPI_SetBaudrate,
+//	.set_transmit_timeout	= HISCIAPI_SetTransmitTimeout,
+//	.set_DTS_RTS		= HISCIAPI_SetDtsRts,
+	.display_msg		= HISCIAPI_DisplayMessages,
+};
+
+#endif
Index: csctapi/ifd_hisky.h
===================================================================
--- csctapi/ifd_hisky.h	(nonexistent)
+++ csctapi/ifd_hisky.h	(working copy)
@@ -0,0 +1,309 @@
+#ifndef _ifd_hisky_h_
+#define _ifd_hisky_h_
+
+#if defined(SDKV600)
+#define	CHIP_TYPE_hi3796mv100
+#include "drv_sci_ioctl.h"
+#elif defined(SDKV500)
+#define	CHIP_TYPE_hi3716cv200
+#include "drv_sci_ioctl.h"
+#else
+//
+//
+//	#define	__HISCI_IOCTL_AVAILABLE__
+//
+//
+// $ANDROID_BUILD_TOP/device/hisilicon/godbox/driver/sdk/msp_base
+// $ANDROID_BUILD_TOP/device/hisilicon/godbox/driver/sdk/msp_base/ecs/include
+// $ANDROID_BUILD_TOP/device/hisilicon/godbox/driver/sdk/msp_base/common/include
+typedef unsigned char       HI_U8;
+typedef unsigned char       HI_UCHAR;
+typedef unsigned short      HI_U16;
+typedef unsigned int        HI_U32;
+
+typedef char                HI_S8;
+typedef short               HI_S16;
+typedef int                 HI_S32;
+
+typedef char                HI_CHAR;
+typedef char*               HI_PCHAR;
+
+typedef float               HI_FLOAT;
+typedef double              HI_DOUBLE;
+typedef void                HI_VOID;
+typedef unsigned int	    	 HI_HANDLE;
+
+typedef unsigned long       HI_SIZE_T;
+typedef unsigned long       HI_LENGTH_T;
+
+typedef int                 STATUS;
+
+#ifndef WIN32
+typedef unsigned long long  HI_U64;
+typedef long long           HI_S64;
+typedef unsigned long long  HI_PTS_TIME;
+#else
+typedef __int64             HI_U64;
+typedef __int64             HI_S64;
+typedef __int64             HI_PTS_TIME;
+#endif
+
+#if 0
+#define _IOC_NRBITS 		8
+#define _IOC_TYPEBITS 		8
+#define _IOC_SIZEBITS 		14
+#define _IOC_DIRBITS 		2
+
+#define _IOC_NRMASK 		((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK 		((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK 		((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK 		((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT 		0
+#define _IOC_TYPESHIFT 		(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT 		(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT 		(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+#define _IOC_NONE 			0U
+#define _IOC_WRITE 			1U
+#define _IOC_READ 			2U
+
+#define _IOC(dir,type,nr,size)   (((dir) << _IOC_DIRSHIFT) | ((type) << _IOC_TYPESHIFT) | ((nr) << _IOC_NRSHIFT) |   ((size) << _IOC_SIZESHIFT))
+#define _IOC_TYPECHECK(t)   	((sizeof(t) == sizeof(t[1]) && sizeof(t) < (1 << _IOC_SIZEBITS)) ?   sizeof(t) : __invalid_size_argument_for_IOC)
+
+#define _IO(type,nr) 			_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size) 		_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOW(type,nr,size) 		_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOWR(type,nr,size) 	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOR_BAD(type,nr,size) 	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW_BAD(type,nr,size) 	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR_BAD(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+#endif
+
+typedef enum
+{
+    HI_FALSE    = 0,
+    HI_TRUE     = 1
+} HI_BOOL;
+
+#define HI_SUCCESS 			0
+#define HI_FAILURE      	(-1)
+
+
+/* constants */
+#define HI_ID_SCI				0x45
+
+/**Output configuration of the smart card interface clock (SCICLK) pin*/
+/**CNcomment:SCICLK????????????*/
+typedef enum  hiUNF_SCI_CLK_MODE_E
+{
+    HI_UNF_SCI_CLK_MODE_CMOS = 0,   /**<Complementary metal-oxide semiconductor (CMOS) output*/   /**<CNcomment:CMOS????*/
+    HI_UNF_SCI_CLK_MODE_OD,         /**<Open drain (OD) output*/                                  /**<CNcomment:OD????*/
+    HI_UNF_SCI_CLK_MODE_BUTT
+}HI_UNF_SCI_CLK_MODE_E;
+
+/**SCI port*/
+/**CNcomment:SCI ?? */
+typedef enum hiUNF_SCI_PORT_E
+{
+    HI_UNF_SCI_PORT0,      /**< SCI port 0*/  /**<CNcomment:SCI??0*/
+    HI_UNF_SCI_PORT1,      /**< SCI port 1*/  /**<CNcomment:SCI??1*/
+    HI_UNF_SCI_PORT_BUTT
+}HI_UNF_SCI_PORT_E;
+
+/**Status of the SCI card*/
+/**CNcomment:???? */
+typedef enum hiUNF_SCI_STATUS_E
+{
+    HI_UNF_SCI_STATUS_UNINIT     = 0,   /**<The SCI card is not initialized.*/               /**<CNcomment: SCI???? */
+    HI_UNF_SCI_STATUS_FIRSTINIT,        /**<The SCI card is being initialized.*/             /**<CNcomment:SCI??????????*/
+    HI_UNF_SCI_STATUS_NOCARD,           /**<There is no SCI card.*/                          /**<CNcomment:?? */
+    HI_UNF_SCI_STATUS_INACTIVECARD,     /**<The SCI card is not activated (unavailable).*/   /**<CNcomment:????????????? */
+ //   HI_UNF_SCI_STATUS_CARDFAULT,		  /**<The SCI card is faulty.*/                        /**<CNcomment:??????*/
+    HI_UNF_SCI_STATUS_WAITATR,          /**<The SCI card is waiting for the ATR data.*/      /**<CNcomment:??ATR*/
+    HI_UNF_SCI_STATUS_READATR,          /**<The SCI card is receiving the ATR data.*/        /**<CNcomment:??????ATR*/
+    HI_UNF_SCI_STATUS_READY,            /**<The SCI card is available (activated).*/         /**<CNcomment:????????????? */
+    HI_UNF_SCI_STATUS_RX,               /**<The SCI card is busy receiving data.*/           /**<CNcomment:?????????????? */
+    HI_UNF_SCI_STATUS_TX                /**<The SCI card is busy transmitting data.*/        /**<CNcomment:?????????????? */
+} HI_UNF_SCI_STATUS_E;
+
+/**SCI protocol*/
+/**CNcomment:SCI ?? */
+typedef enum hiUNF_SCI_PROTOCOL_E
+{
+    HI_UNF_SCI_PROTOCOL_T0,    /**<7816 T0 protocol*/   /**<CNcomment:7816 T0 ?? */
+    HI_UNF_SCI_PROTOCOL_T1,    /**<7816 T1 protocol*/   /**<CNcomment:7816 T1 ?? */
+    HI_UNF_SCI_PROTOCOL_T14 ,  /**<7816 T14 protocol*/  /**<CNcomment:7816 T14 ?? */
+    HI_UNF_SCI_PROTOCOL_BUTT
+}HI_UNF_SCI_PROTOCOL_E;
+
+/**SCI active level*/
+/**CNcomment:SCI????*/
+typedef enum hiUNF_SCI_LEVEL_E
+{
+    HI_UNF_SCI_LEVEL_LOW,    /**<Active low*/   /**<CNcomment:???? */
+    HI_UNF_SCI_LEVEL_HIGH,   /**<Active high*/  /**<CNcomment:???? */
+    HI_UNF_SCI_LEVEL_BUTT
+}HI_UNF_SCI_LEVEL_E ;
+
+/**SCI system parameters*/
+/**CNcomment:SCI ???? */
+typedef struct hiUNF_SCI_PARAMS_S
+{
+	HI_UNF_SCI_PORT_E enSciPort;		      /**<SCI port ID*/                                          	/**<CNcomment:SCI ?? */
+	HI_UNF_SCI_PROTOCOL_E enProtocolType; /**<Used protocol type*/                                    /**<CNcomment:???????? */
+	HI_U32 ActalClkRate;	                /**<Actual clock rate conversion factor F*/	                /**<CNcomment:??F ???????? */
+	HI_U32 ActalBitRate;                	/**<Actual bit rate conversion factor D*/	                  /**<CNcomment:??D ???????????? */
+	HI_U32 Fi;			                      /**<Clock factor returned by the answer to reset (ATR)*/  	/**<CNcomment:ATR ?????????? */
+	HI_U32 Di;			                      /**<Bit rate factor returned by the ATR*/                 	/**<CNcomment:ATR ???????????? */
+	HI_U32 GuardDelay;	                  /**<Extra guard time N*/	                                  /**<CNcomment:N ????????????*/
+	HI_U32 CharTimeouts;	                /**<Character timeout of T0 or T1*/                       	/**<CNcomment:T0 ??T1????????*/
+	HI_U32 BlockTimeouts;	                /**<Block timeout of T1 */                                  /**<CNcomment:T1???*/
+	HI_U32 TxRetries;			                /**<Number of transmission retries*/                      	/**<CNcomment:??????????*/
+}HI_UNF_SCI_PARAMS_S,*HI_UNF_SCI_PARAMS_S_PTR;
+
+
+
+typedef struct hiSCI_OPEN_S
+{
+    HI_UNF_SCI_PORT_E      enSciPort;
+    HI_UNF_SCI_PROTOCOL_E  enSciProtocol;
+    HI_U32                 Frequency;
+}SCI_OPEN_S;
+
+typedef struct hiSCI_RESET_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+    HI_BOOL              bWarmReset;
+}SCI_RESET_S;
+
+typedef struct hiSCI_ATR_S
+{
+    HI_UNF_SCI_PORT_E  enSciPort;
+	HI_U8              *pAtrBuf;
+	HI_U32             BufSize;
+	HI_U8              DataLen;
+}SCI_ATR_S;
+
+typedef struct hiSCI_STATUS_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+	HI_UNF_SCI_STATUS_E  enSciStatus;
+}SCI_STATUS_S;
+
+typedef struct hiSCI_DATA_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+	HI_U8                *pDataBuf;
+    HI_U32               BufSize;
+    HI_U32               DataLen;
+    HI_U32               TimeoutMs;
+}SCI_DATA_S;
+
+typedef struct hiSCI_LEVEL_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+	HI_UNF_SCI_LEVEL_E   enSciLevel;
+}SCI_LEVEL_S;
+
+typedef struct hiSCI_CLK_S
+{
+    HI_UNF_SCI_PORT_E      enSciPort;
+    HI_UNF_SCI_CLK_MODE_E  enClkMode;
+}SCI_CLK_S;
+
+typedef struct hiSCI_DEV_STATE_S
+{
+    HI_BOOL         bSci0;
+    HI_BOOL         bSci1;
+}SCI_DEV_STATE_S;
+
+typedef struct hiSCI_EXT_BAUD_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32 ClkRate;
+	HI_U32 BitRate;
+}SCI_EXT_BAUD_S;
+
+typedef struct hiSCI_ADD_GUARD_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32	AddCharGuard;
+}SCI_ADD_GUARD_S;
+
+typedef struct hiSCI_PPS_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U8  	Send[6];
+	HI_U8  	Receive[6];
+	HI_U32  SendLen;
+	HI_U32  ReceiveLen;
+	HI_U32	RecTimeouts;
+}SCI_PPS_S;
+
+typedef struct hiSCI_CHARTIMEOUT_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_UNF_SCI_PROTOCOL_E  enSciProtocol;
+	HI_U32	CharTimeouts;
+}SCI_CHARTIMEOUT_S;
+
+typedef struct hiSCI_BLOCKTIMEOUT_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32	BlockTimeouts;
+}SCI_BLOCKTIMEOUT_S;
+
+typedef struct hiSCI_TXRETRY_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32	TxRetryTimes;
+}SCI_TXRETRY_S;
+
+// sky(n)
+typedef struct hiSCI_PROTOCOL_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_UNF_SCI_PROTOCOL_E  enSciProtocol;
+}SCI_PROTOCOL_S;
+
+
+#define CMD_SCI_OPEN              	_IOW(HI_ID_SCI,  0x1, SCI_OPEN_S)
+#define CMD_SCI_CLOSE             	_IOW(HI_ID_SCI,  0x2, HI_UNF_SCI_PORT_E)
+#define CMD_SCI_RESET             	_IOW(HI_ID_SCI,  0x3, SCI_RESET_S)
+#define CMD_SCI_DEACTIVE         	_IOW(HI_ID_SCI,  0x4, HI_UNF_SCI_PORT_E)
+#define CMD_SCI_GET_ATR           	_IOWR(HI_ID_SCI, 0x5, SCI_ATR_S)
+#define CMD_SCI_GET_STATUS        	_IOWR(HI_ID_SCI, 0x6, SCI_STATUS_S)
+#define CMD_SCI_CONF_VCC         	_IOW(HI_ID_SCI,  0x7, SCI_LEVEL_S)
+#define CMD_SCI_CONF_DETECT       	_IOW(HI_ID_SCI,  0x8, SCI_LEVEL_S)
+#define CMD_SCI_CONF_CLK_MODE     	_IOW(HI_ID_SCI,  0x9, SCI_CLK_S)
+#define CMD_SCI_SEND_DATA         	_IOWR(HI_ID_SCI, 0xa, SCI_DATA_S)
+#define CMD_SCI_RECEIVE_DATA      	_IOWR(HI_ID_SCI, 0xb, SCI_DATA_S)
+#define CMD_SCI_SWITCH            	_IOW(HI_ID_SCI,  0xc, SCI_OPEN_S)
+#define CMD_SCI_SET_BAUD          	_IOW(HI_ID_SCI,  0xd, SCI_EXT_BAUD_S)
+#define CMD_SCI_SET_CHGUARD       	_IOW(HI_ID_SCI,  0xe, SCI_ADD_GUARD_S)
+#define CMD_SCI_SEND_PPS_DATA     	_IOW(HI_ID_SCI,  0xF, SCI_PPS_S)
+#define CMD_SCI_GET_PPS_DATA	  		_IOWR(HI_ID_SCI, 0x10, SCI_PPS_S)
+#define CMD_SCI_GET_PARAM				_IOWR(HI_ID_SCI, 0x11, HI_UNF_SCI_PARAMS_S)
+#define CMD_SCI_SET_CHARTIMEOUT     _IOW(HI_ID_SCI,  0x12, SCI_CHARTIMEOUT_S)
+#define CMD_SCI_SET_BLOCKTIMEOUT    _IOW(HI_ID_SCI,  0x13, SCI_BLOCKTIMEOUT_S)
+#define CMD_SCI_SET_TXRETRY       	_IOW(HI_ID_SCI,  0x14, SCI_TXRETRY_S)
+#define CMD_SCI_SET_PROTOCOL        _IOW(HI_ID_SCI,  0x15, SCI_PROTOCOL_S)
+
+#define HI_ERR_SCI_OPEN_ERR     			(HI_S32)(0x80450001)
+#define HI_ERR_SCI_CLOSE_ERR    			(HI_S32)(0x80450002)
+#define HI_ERR_SCI_NOT_INIT       		(HI_S32)(0x80450003)
+#define HI_ERR_SCI_INVALID_PARA     	(HI_S32)(0x80450004)
+#define HI_ERR_SCI_NULL_PTR           	(HI_S32)(0x80450005)
+#define HI_ERR_SCI_INVALID_OPT     		(HI_S32)(0x80450006)
+#define HI_ERR_SCI_SEND_ERR      		(HI_S32)(0x80450007)
+#define HI_ERR_SCI_RECEIVE_ERR        	(HI_S32)(0x80450008)
+#define HI_ERR_SCI_NO_ATR           	(HI_S32)(0x80450009)
+#define HI_ERR_SCI_PPS_PTYPE_ERR     	(HI_S32)(0x8045000A)
+#define HI_ERR_SCI_PPS_FACTOR_ERR    	(HI_S32)(0x8045000B)
+#define HI_ERR_SCI_PPS_NOTSUPPORT_ERR	(HI_S32)(0x8045000C)
+
+#endif // defined(SDKV500)
+#endif /* End of #ifndef _ifd_hisky_h_*/
+
+
Index: csctapi/protocol_t0.c
===================================================================
--- csctapi/protocol_t0.c	(revision 10670)
+++ csctapi/protocol_t0.c	(working copy)
@@ -554,6 +554,10 @@
 	memcpy(buffer + 8 + recved, buffer + 2, 2);
 	*lr = recved + 2;
 	memcpy(rsp, buffer + 8, *lr);
+
+#if defined(WITH_HISILICON)
+	cs_sleepms(100); //FIXME why wait?
+#endif
 	return OK;
 }
 #endif
Index: devtools/check_config_tables.sh
===================================================================
--- devtools/check_config_tables.sh	(revision 10670)
+++ devtools/check_config_tables.sh	(working copy)
@@ -49,3 +49,10 @@
 do
 	grep -w $VAR globals.h | grep -vw uint8_t | grep -w --color $VAR
 done
+# sky(add)
+echo "== Checking DEF_OPT_HEXA (arrays) -> Var type must be uint8_t[x]"
+for VAR in `cat $FILES | grep DEF_OPT_HEXA | grep OFS | awk '{print $3}' | sed "s|OFS(||;s|)||;s|,||"`
+do
+	grep -w $VAR globals.h | grep -vw uint8_t | grep -w --color $VAR
+done
+
Index: emu-key.c
===================================================================
--- emu-key.c	(nonexistent)
+++ emu-key.c	(working copy)
@@ -0,0 +1,819 @@
+#include "globals.h"
+#if defined(MODULE_XCAS)
+#include "oscam-array.h"
+#include "oscam-conf.h"
+#include "oscam-client.h"
+#include "oscam-ecm.h"
+#include "oscam-net.h"
+#include "oscam-chk.h"
+#include "oscam-string.h"
+#include "module-xcas.h"
+
+// oscam.keys(=SoftCam.Key)
+#define 	MAXSCAMLINESIZE 	4096
+#define	MAXCOLSEPERATES	4
+
+
+void
+emukey_colon2space(char *str)
+{
+	char *p1 = str;
+
+	if (NULL != p1)
+	{
+		while ('\0' != *p1) {
+			if (':' == *p1) *p1 = ' ';
+			p1++;
+		}
+	}
+}
+
+int
+emukey_line2useless(char *str)
+{
+	if (str    ==NULL) return 1;
+	if (str[0] == 0x0) return 1;
+	if (str[0] == '#') return 1;
+	if (str[0] == ';') return 1;
+	if (str[0] == ':') return 1;
+	if (str[0] == ' ') return 1;
+	if (str[0] == 0xA) return 1;
+	if (str[0] == 0xD) return 1;
+	return 0;
+}
+
+static bool
+emukey_RdrChkDevices(struct s_reader *rdr)
+{
+	FILE *fp;
+
+	if (!rdr) return 0;
+//	fp = fopen(rdr->device, "r");
+	fp = open_config_file(rdr->device);
+	if (!fp) return (0);
+	fclose(fp);
+	return 1;
+}
+
+
+static int
+emukey_RdrCasMakeup(struct s_reader *rdr)
+{
+	FILE 	*fp;
+	char 	*token, *seperates, *coments;
+	char	*tmp;
+	int32_t  lenn;
+	uint16_t ucaid;
+	uint32_t uppid;
+	char	sscas [64];
+	char	ssprov[64];
+	char	ssknr [64];
+	char	sskeys[1024];
+
+//	fp = fopen(rdr->device, "r");
+	fp = open_config_file(rdr->device);
+	if (!fp) return 0;
+	if (!cs_malloc(&token, MAXSCAMLINESIZE))
+	{
+		fclose(fp);
+		return 0;
+	}
+
+	int i,k;
+	int numfilts = 0;
+	int numcaids = 0;
+	CAIDTAB_DATA xcts[CS_MAXCAIDTAB];
+	FILTER xfilts[CS_MAXFILTERS];
+
+	memset(&xcts, 0, sizeof(xcts));
+	memset(&xfilts, 0, sizeof(xfilts));
+	for (i=0; i<CS_MAXCAIDTAB; xcts[i++].mask = 0xffff);
+
+	#if defined(__XCAS_BISS__)
+		xcts[numcaids++].caid = 0x2600;
+		xfilts[numfilts].caid = 0x2600;
+		numfilts++;
+	#endif
+	#if defined(__XCAS_VIACESS__)
+		xcts[numcaids++].caid = 0x0500;
+		xfilts[numfilts].caid = 0x0500;
+		xfilts[numfilts].prids[0] = 0x030B00;
+		xfilts[numfilts].nprids   = 1;
+		numfilts++;
+	#endif
+	// sky(2016.03.07)
+	#if defined(__XCAS_POWERVU__)
+		xcts[numcaids++].caid = 0x0E00;
+		xfilts[numfilts].caid = 0x0E00;
+		numfilts++;
+	#endif
+
+	while (fgets(token, MAXSCAMLINESIZE, fp))
+	{
+		tmp = trim(token);
+		if (emukey_line2useless(tmp)) continue;
+		if ((lenn=strlen(tmp)) < 9) continue;
+		coments=strchr(token, ';');
+		if (coments) *coments = 0;
+
+
+		int spacing;
+		seperates=token;
+		for (spacing=0; (spacing<MAXCOLSEPERATES) && (seperates); spacing++)
+		{
+			seperates=strchr(seperates, ' ');
+			if (!seperates) break;
+			while (*seperates == ' ') seperates++;
+		}
+		if (spacing==MAXCOLSEPERATES && seperates) *seperates = 0;
+
+
+		if (strchr(token, ':'))
+		{
+		}
+		else
+		{
+			sscanf(token, "%s %s %s %s", sscas, ssprov, ssknr, sskeys);
+		//	MYEMU_TRACE("xcaskey:%s,%s,%d,%s,%s\n", sscas, ssprov, uppid, ssknr, sskeys);
+			uppid = a2i(ssprov,8);
+			ucaid = 0;
+			if (sscas[0] == CASS_VIACCESS)   { ucaid = 0x500; 		}
+			if (sscas[0] == CASS_SEKA)       { ucaid = 0x100; 		}
+//			if (sscas[0] == CASS_CRYPTOWORKS){ ucaid = uppid>>8; uppid &= 0xfc; }
+			if (sscas[0] == CASS_CRYPTOWORKS){ ucaid = uppid>>8;	}
+			if (sscas[0] == CASS_NAGRA)      { ucaid = 0x1800; 	}
+			if (sscas[0] == CASS_POWERVU)    { ucaid = 0x0E00; uppid = 0x0000; }
+			if (sscas[0] == CASS_BISS)       { uppid = 0x0000; }
+			if (sscas[0] == CASS_CONSTANT)   { uppid = 0x0000; }
+			if (!XEMUKEY_IsAvailable(rdr, ucaid, uppid)) continue;
+			//-------------------------------------------------------------
+			//-------------------------------------------------------------
+			for (i=0; i<numcaids; i++)
+			{
+				if (xcts[i].caid == ucaid) break;
+			}
+			if (i==numcaids)
+			{
+				if (numcaids>(CS_MAXCAIDTAB-1))
+				{
+					mycs_debug(D_ADB, "xcaskey:CA{%04X} CS_MAXCAIDTAB exceed\n", ucaid);
+					break;
+				}
+				xcts[numcaids++].caid = ucaid;
+			}
+			//-------------------------------------------------------------
+			//-------------------------------------------------------------
+			for (i=0; i<numfilts; i++)
+			{
+				if (xfilts[i].caid == ucaid) break;
+			}
+			if (i==numfilts)
+			{
+			//	if (i>(CS_MAXFILTERS-1)) break;
+				if (i>(CS_MAXFILTERS-1))
+				{
+					mycs_debug(D_ADB, "xcaskey:CA{%04X.%08X} CS_MAXFILTERS exceed\n", ucaid, uppid);
+					break;
+				}
+				xfilts[i].caid = ucaid;
+				xfilts[i].prids[0] = uppid;
+				xfilts[i].nprids = 1;
+				numfilts++;
+				myprintf("xcaskey:CA{%3d: %04X.%08X}\n", xfilts[i].nprids, ucaid, uppid);
+			}
+			else
+			{
+				for (k=0; k<xfilts[i].nprids; k++)
+				{
+					if (xfilts[i].prids[k] == uppid) break;
+				}
+				if (k==xfilts[i].nprids)
+				{
+				//	if (k>(CS_MAXPRFLT-1)) continue;
+					if (k>(CS_MAXPRFLT-1))
+					{
+						mycs_debug(D_ADB, "xcaskey:CA{%04X.%08X} CS_MAXPRFLT exceed\n", ucaid, uppid);
+						continue;
+					}
+					myprintf("xcaskey:CA{%3d: %04X.%08X}\n", xfilts[i].nprids, ucaid, uppid);
+					xfilts[i].prids[k] = uppid;
+					xfilts[i].nprids++;
+				}
+			}
+		}
+	}
+	for (i=0; i<numfilts; i++) {
+		ftab_add(&rdr->ftab, &xfilts[i]);
+	}
+	for (i=0; i<numcaids; i++) {
+		caidtab_add(&rdr->ctab, &xcts[i]);
+	}
+
+	cs_free(token);
+	fclose(fp);
+	return (numfilts);
+}
+
+
+static int
+emukey_RdrFindkey(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid,
+	char 	   *kNstr,
+	uint8_t  *kBufs,
+	uint16_t  ksize,
+	int 		*pfIndex,
+	bool	   bMultiple)
+{
+	FILE 	*fp;
+	char 	*token, *seperates, *coments;
+	char	*tmp;
+	int32_t  lenn;
+	uint32_t uppid;
+	char	sscas [64];
+	char	ssprov[64];
+	char	ssknr [64];
+	char	sskeys[1024];
+	int	counter = 0;
+	int 	spacing;
+	int 	keyfound = 0;
+
+//	fp = fopen(rdr->device, "r");
+	fp = open_config_file(rdr->device);
+	if (!fp) return 0;
+	if (!cs_malloc(&token, MAXSCAMLINESIZE))
+	{
+		fclose(fp);
+		return 0;
+	}
+
+	while (fgets(token, MAXSCAMLINESIZE, fp))
+	{
+		if (keyfound) break;
+		tmp = trim(token);
+		if (emukey_line2useless(tmp)) continue;
+		if ((lenn=strlen(tmp)) < 9) continue;
+		coments = strchr(token, ';');
+		if (coments) *coments = 0;
+
+
+		seperates=token;
+		for (spacing=0; (spacing<MAXCOLSEPERATES) && (seperates); spacing++)
+		{
+			seperates=strchr(seperates, ' ');
+			if (!seperates) break;
+			while (*seperates == ' ') seperates++;
+		}
+		if (spacing==MAXCOLSEPERATES && seperates) *seperates = 0;
+
+
+		if (strchr(token, ':'))	{ }
+		else
+		{
+			sscanf(token, "%s %s %s %s", sscas, ssprov, ssknr, sskeys);
+		//	MYEMU_TRACE("xcaskey:%s,%s,%d,%s,%s\n", sscas, ssprov, uppid, ssknr, sskeys);
+			uppid = a2i(ssprov,8);
+			if (cCAS != sscas[0]) continue;
+			if (ppid != uppid) continue;
+			if (kNstr)
+			{
+				if (strcmp(kNstr,ssknr)) continue;
+			}
+			if (kBufs)
+			{
+				if (cs_atob((uchar *)kBufs, sskeys, ksize) < 0) continue;
+			//	MYEMU_TRACE("xcaskey:%5d.%5d:%02X...%02X\n",
+			//			counter,
+			//			(pfIndex) ? *pfIndex : 9999,
+			//			kBufs[0], kBufs[ksize-1]);
+			//	kBufs += ksize;
+			}
+			counter++;
+			if (pfIndex) {
+				if (*pfIndex < 0) keyfound = 1;
+				else if (counter >= *pfIndex) keyfound = 1;
+			}
+			else {
+				keyfound = 1;
+				if (!bMultiple) break;
+			}
+			if (counter>(MAXMULTIKEY-1)) break;
+		}
+	}
+
+	cs_free(token);
+	fclose(fp);
+
+	if (counter > 0 && pfIndex) *pfIndex = counter;
+	return (keyfound);
+}
+
+
+static int
+emukey_RdrPidsFindkey(struct s_reader *rdr, uint8_t cCAS, uint32_t *ppids, uint32_t ppnum,
+	char 	   *kNstr,
+	uint8_t  *kBufs,
+	uint16_t  ksize,
+	int 		*pfIndex,
+	bool	   bMultiple)
+{
+	FILE 	*fp;
+	char 	*token, *seperates, *coments;
+	char	*tmp;
+	int32_t  lenn;
+	uint32_t uppid;
+	char	sscas [64];
+	char	ssprov[64];
+	char	ssknr [64];
+	char	sskeys[1024];
+	int	counter = 0;
+	int 	spacing;
+	int 	keyfound = 0;
+	int	i;
+
+//	fp = fopen(rdr->device, "r");
+	fp = open_config_file(rdr->device);
+	if (!fp) return 0;
+	if (!cs_malloc(&token, MAXSCAMLINESIZE))
+	{
+		fclose(fp);
+		return 0;
+	}
+
+	while (fgets(token, MAXSCAMLINESIZE, fp))
+	{
+		if (keyfound) break;
+		tmp = trim(token);
+		if (emukey_line2useless(tmp)) continue;
+		if ((lenn=strlen(tmp)) < 9) continue;
+		coments = strchr(token, ';');
+		if (coments) *coments = 0;
+
+
+		seperates=token;
+		for (spacing=0; (spacing<MAXCOLSEPERATES) && (seperates); spacing++)
+		{
+			seperates=strchr(seperates, ' ');
+			if (!seperates) break;
+			while (*seperates == ' ') seperates++;
+		}
+		if (spacing==MAXCOLSEPERATES && seperates) *seperates = 0;
+
+
+		if (strchr(token, ':'))	{ }
+		else
+		{
+			sscanf(token, "%s %s %s %s", sscas, ssprov, ssknr, sskeys);
+		//	MYEMU_TRACE("xcaskey:%s,%s,%d,%s,%s\n", sscas, ssprov, uppid, ssknr, sskeys);
+			uppid = a2i(ssprov,8);
+			if (cCAS != sscas[0]) continue;
+			for (i=0; i<(int)ppnum; i++) {
+				if (ppids[i] == uppid) break;
+			}
+			if (i >= (int)ppnum) continue;
+
+			if (kNstr)
+			{
+				if (strcmp(kNstr,ssknr)) continue;
+			}
+			if (kBufs)
+			{
+				if (cs_atob((uchar *)kBufs, sskeys, ksize) < 0) continue;
+			//	MYEMU_TRACE("xcaskey:%5d.%5d:%02X...%02X\n",
+			//			counter,
+			//			(pfIndex) ? *pfIndex : 9999,
+			//			kBufs[0], kBufs[ksize-1]);
+			//	kBufs += ksize;
+			}
+			counter++;
+			if (pfIndex) {
+				if (*pfIndex < 0) keyfound = 1;
+				else if (counter >= *pfIndex) keyfound = 1;
+			}
+			else {
+				keyfound = 1;
+				if (!bMultiple) break;
+			}
+			if (counter>(MAXMULTIKEY-1)) break;
+		}
+	}
+
+	cs_free(token);
+	fclose(fp);
+
+	if (counter > 0 && pfIndex) *pfIndex = counter;
+	return (keyfound);
+}
+
+
+static int
+emukey_RdrChLfsFindkey(struct s_reader *rdr, uint8_t cCAS, uint32_t ufrequency,
+	uint32_t ufsymrate,
+	uint8_t *kBufs,
+	uint16_t ksize,
+	bool	   bMultiple)
+{
+	FILE 	*fp;
+	char 	*token, *seperates, *coments;
+	char 	*tmp;
+	int32_t  lenn;
+	char	sscas [64];
+	char	sskeys[1024];
+	int	counter = 0;
+
+//	fp = fopen(rdr->device, "r");
+	fp = open_config_file(rdr->device);
+	if (!fp) return 0;
+	if (!cs_malloc(&token, MAXSCAMLINESIZE))
+	{
+		fclose(fp);
+		return 0;
+	}
+
+	while (fgets(token, MAXSCAMLINESIZE, fp))
+	{
+		tmp = trim(token);
+		if (emukey_line2useless(tmp)) continue;
+		if ((lenn=strlen(tmp)) < 9) continue;
+		coments=strchr(token, ';');
+		if (coments) *coments = 0;
+
+
+		int	spacing;
+		seperates=token;
+		for (spacing=0; (spacing<MAXCOLSEPERATES) && (seperates); spacing++)
+		{
+			seperates=strchr(seperates, ' ');
+			if (!seperates) break;
+			while (*seperates == ' ') seperates++;
+		}
+		if (spacing==MAXCOLSEPERATES && seperates) *seperates = 0;
+
+
+		if (strchr(token, ':'))
+		{
+		//	char ssfreq[64];
+		//	char ssfsym[64];
+			char ssfpol[64];
+			uint32_t usfreq;
+			uint32_t usfsym;
+
+		//	emukey_colon2space(token);
+		//	sscanf(token, "%s %s %s %s %s", sscas, ssfreq, ssfsym, ssfpol, sskeys);
+		//	MYEMU_TRACE("xcaskey:%s,%s,%s,%s,%s\n", sscas, ssfreq, ssfsym, ssfpol, sskeys);
+
+			sscanf(token, "%s %d:%d:%s %s", sscas, &usfreq, &usfsym, ssfpol, sskeys);
+		//	MYEMU_TRACE("xcaskey:%s,%d,%d,%s,%s\n", sscas, usfreq, usfsym, ssfpol, sskeys);
+			if (cCAS  != sscas[0]) continue;
+			if (ufrequency && ufrequency != usfreq) continue;
+			if (ufsymrate && ufsymrate != usfsym) continue;
+			if (kBufs)
+			{
+				if (cs_atob((uchar *)kBufs, sskeys, ksize) < 0) continue;
+				MYEMU_TRACE("xcaskey:%5d:%02X...%02X\n", counter, kBufs[0], kBufs[ksize-1]);
+			//	kBufs += ksize;
+			}
+			counter++;
+			if (!bMultiple) break;
+			if (counter>(MAXMULTIKEY-1)) break;
+		}
+	}
+
+	cs_free(token);
+	fclose(fp);
+	return (counter);
+}
+
+
+static int
+emukey_RdrSavekey(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid,
+	char 	   *kNstr,
+	uint8_t  *kBufs,
+	uint16_t  ksize)
+{
+	FILE 	*fp;
+	char 	*token, *seperates, *coments;
+	char	*tmp;
+	int32_t  lenn;
+	uint32_t uppid;
+	char	sscas [64];
+	char	ssprov[64];
+	char	ssknr [64];
+	char	sskeys[1024];
+	int 	spacing;
+	int 	keyfound = 0;
+
+	fp = create_config_file(rdr->device);
+	if (!fp) return 0;
+	if (!cs_malloc(&token, MAXSCAMLINESIZE))
+	{
+		fclose(fp);
+		return 0;
+	}
+
+	while (fgets(token, MAXSCAMLINESIZE, fp))
+	{
+		if (keyfound) {
+			fputs(token, fp);
+			continue;
+		}
+		tmp = trim(token);
+		if (emukey_line2useless(tmp)) {
+			fputs(token, fp);
+			continue;
+		}
+		if ((lenn=strlen(tmp)) < 9) {
+			fputs(token, fp);
+			continue;
+		}
+		coments = strchr(token, ';');
+		if (coments) *coments = 0;
+
+
+		seperates=token;
+		for (spacing=0; (spacing<MAXCOLSEPERATES) && (seperates); spacing++)
+		{
+			seperates=strchr(seperates, ' ');
+			if (!seperates) break;
+			while (*seperates == ' ') seperates++;
+		}
+		if (spacing==MAXCOLSEPERATES && seperates) *seperates = 0;
+
+		if (strchr(token, ':'))	{
+			fputs(token, fp);
+			continue;
+		}
+
+		sscanf(token, "%s %s %s %s", sscas, ssprov, ssknr, sskeys);
+		uppid = a2i(ssprov,8);
+		if (cCAS != sscas[0] || ppid != uppid || strcmp(kNstr,ssknr)) {
+			fputs(token, fp);
+			continue;
+		}
+
+		char_to_hex((uchar *)kBufs, ksize, (unsigned char *)sskeys);
+		MYEMU_TRACE("xcaskey:update:%s,%s,%d,%s,%s\n", sscas, ssprov, uppid, ssknr, sskeys);
+		fprintf(fp, "%s %s %s %s", sscas, ssprov, ssknr, sskeys);
+		keyfound = 1;
+	}
+
+	if (!keyfound) {
+		char_to_hex((uchar *)kBufs, ksize, (unsigned char *)sskeys);
+		MYEMU_TRACE("xcaskey:add:%c,%08X,%s,%s\n", cCAS, ppid, kNstr, sskeys);
+		fprintf(fp, "%c %08X %s %s", cCAS, ppid, kNstr, sskeys);
+	}
+
+	cs_free(token);
+	fclose(fp);
+	return (keyfound);
+}
+
+bool
+XEMUKEY_IsExistance(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid)
+{
+	int existance;
+
+	if (!rdr) return 0;
+	existance = emukey_RdrFindkey(rdr, cCAS, ppid, NULL, NULL, 0, NULL, false);
+	if (existance)
+	{
+		MYEMU_TRACE("xcaskey:{%c}{%06X}\n", cCAS, ppid);
+	}
+	return (existance);
+}
+
+
+int
+XEMUKEY_ChLfsSearch(struct s_reader *rdr, uint8_t cCAS, uint32_t ufrequency,
+	uint32_t ufsymrate,
+	uint8_t *kBufs,
+	uint16_t ksize)
+{
+	int counter;
+
+	if (!rdr) return 0;
+	if (!kBufs) return 0;
+	MYEMU_TRACE("xcaskey:lfssearch{%c}{%05d}(%d)\n", cCAS, ufrequency, ksize);
+	counter = emukey_RdrChLfsFindkey(rdr, cCAS, ufrequency, ufsymrate, kBufs, ksize, true);
+	if (counter)
+	{
+		MYEMU_TRACE("xcaskey:lfs.key{%02X...%02X}{%d}\n", kBufs[0], kBufs[ksize-1], counter);
+	}
+	else
+	{
+		MYEMU_TRACE("xcaskey:lfs.key none\n");
+	}
+	return (counter);
+}
+
+
+int
+XEMUKEY_SpecialSearch(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid,
+	char    *kNstr,
+	uint8_t *kBufs,
+	uint16_t ksize)
+{
+	int counter;
+
+	if (!rdr) return 0;
+	if (!kBufs) return 0;
+	MYEMU_TRACE("xcaskey:specialsearch{%c}{%06X.%s}(%d)\n", cCAS, ppid, kNstr, ksize);
+	counter = emukey_RdrFindkey(rdr, cCAS, ppid, kNstr, kBufs, ksize, NULL, false);
+	if (counter)
+	{
+		MYEMU_TRACE("xcaskey:special.key{%02X...%02X}\n", kBufs[0], kBufs[ksize-1]);
+	}
+	else
+	{
+		MYEMU_TRACE("xcaskey:special.key none\n");
+	}
+	return (counter);
+}
+
+
+int
+XEMUKEY_MultiSearch(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid,
+	uint8_t	kNr,
+	uint8_t *kBufs,
+	uint16_t ksize)
+{
+	int	counter;
+	char 	cKstr[3];
+
+	if (!rdr) return 0;
+	if (!kBufs) return 0;
+	sprintf(cKstr, "%02X", kNr);
+	MYEMU_TRACE("xcaskey:multisearch{%c}{%08X.%s}(%d)\n", cCAS, ppid, cKstr, ksize);
+	counter = emukey_RdrFindkey(rdr, cCAS, ppid, cKstr, kBufs, ksize, NULL, true);
+	if (counter)
+	{
+		MYEMU_TRACE("xcaskey:multi.key{%02X...%02X}{%d}\n", kBufs[0], kBufs[ksize-1], counter);
+	}
+	else
+	{
+		MYEMU_TRACE("xcaskey:multi.key.none\n");
+	}
+	return (counter);
+}
+
+
+int
+XEMUKEY_Searchkey(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid,
+	uint8_t	kNr,
+	uint8_t *kBufs,
+	uint16_t ksize)
+{
+	char 	cKstr[3];
+	int	counter;
+
+	if (!rdr) return 0;
+	if (!kBufs) return 0;
+	sprintf(cKstr, "%02X", kNr);
+	MYEMU_TRACE("xcaskey:search{%c}{%06X.%s, %3d}\n", cCAS, ppid, cKstr, ksize);
+	counter = emukey_RdrFindkey(rdr, cCAS, ppid, cKstr, kBufs, ksize, NULL, false);
+	if (counter)
+	{
+		MYEMU_TRACE("xcaskey:key{%02X...%02X}{%d}\n", kBufs[0], kBufs[7], counter);
+	}
+	else
+	{
+		MYEMU_TRACE("xcaskey:key none\n");
+	}
+	return (counter);
+}
+
+
+int
+XEMUKEY_IndexedSearch(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid,
+	uint8_t	kNr,
+	uint8_t *kBufs,
+	uint16_t ksize,
+	int 	  *pFoundIndex)
+{
+	char 	cKstr[3];
+	int	counter;
+
+	if (!rdr) return 0;
+	if (!kBufs) return 0;
+	sprintf(cKstr, "%02X", kNr);
+	MYEMU_TRACE("xcaskey:search{%c}{%06X.%s, %3d}{%d}\n", cCAS, ppid, cKstr, ksize, (pFoundIndex) ? *pFoundIndex : 0);
+	counter = emukey_RdrFindkey(rdr, cCAS, ppid, cKstr, kBufs, ksize, pFoundIndex, false);
+	if (counter)
+	{
+		MYEMU_TRACE("xcaskey:key{%02X...%02X}{%d}\n", kBufs[0], kBufs[7], counter);
+	}
+	else
+	{
+		MYEMU_TRACE("xcaskey:key none\n");
+	}
+	return (counter);
+}
+
+
+int
+XEMUKEY_PidsSearch(struct s_reader *rdr, uint8_t cCAS, uint32_t *ppids, uint32_t ppnum,
+	uint8_t	kNr,
+	uint8_t *kBufs,
+	uint16_t ksize,
+	int 	  *pFoundIndex)
+{
+	char 	cKstr[3];
+	int	counter;
+
+	if (!rdr) return 0;
+	if (!kBufs) return 0;
+	if (!ppids) return 0;
+	if (!ppnum) return 0;
+	sprintf(cKstr, "%02X", kNr);
+	MYEMU_TRACE("xcaskey:search{%c}{%06X.%s, %3d}{%d}\n", cCAS, ppids[0], cKstr, ksize, (pFoundIndex) ? *pFoundIndex : 0);
+	counter = emukey_RdrPidsFindkey(rdr, cCAS, ppids, ppnum, cKstr, kBufs, ksize, pFoundIndex, false);
+	if (counter)
+	{
+		MYEMU_TRACE("xcaskey:key{%02X...%02X}{%d}\n", kBufs[0], kBufs[7], counter);
+	}
+	else
+	{
+		MYEMU_TRACE("xcaskey:key none\n");
+	}
+	return (counter);
+}
+
+
+int
+XEMUKEY_Savekey(struct s_reader *rdr, uint8_t cCAS, uint32_t ppid,
+	char 	  *kNstr,
+	uint8_t *kBufs,
+	uint16_t ksize)
+{
+	if (!rdr) return 0;
+	if (!kNstr) return 0;
+	if (!kBufs) return 0;
+	MYEMU_TRACE("xcaskey:save{%c}{%06X.%s, %3d}\n", cCAS, ppid, kNstr, ksize);
+	emukey_RdrSavekey(rdr, cCAS, ppid, kNstr, kBufs, ksize);
+	return 1;
+}
+
+
+int
+XEMUKEY_IsAvailable(struct s_reader *rdr, uint16_t casid, uint32_t prid)
+{
+	if (!casid) return 0;
+	#if defined(__XCAS_BISS__)
+		if (IS_BISS(casid)) return 1;
+	#endif
+	#if defined(__XCAS_CRYPTOWORKS__)
+		if (IS_CRYPTOWORKS(casid)) {
+			if (!prid) return 1;	// futures
+			return 1;
+		}
+	#endif
+	#if defined(__XCAS_VIACESS__)
+		if (IS_VIACESS(casid)) {
+			if (!prid) return 0;	// futures
+			return 1;
+		}
+	#endif
+	#if defined(__XCAS_SEKA__)
+		if (IS_SEKA(casid)) {
+			if (!prid) return 0;	// futures
+			return 1;
+		}
+	#endif
+	#if defined(__XCAS_POWERVU__)
+		if (IS_POWERVU(casid)) return 1;
+	#endif
+	return 0;
+}
+// sky(powervu)
+void
+XEMUKEY_Cleanup(struct s_reader *rdr)
+{
+	memset(rdr->powervu_ecmnb,0,sizeof(rdr->powervu_ecmnb));
+}
+
+int
+XEMUKEY_Initialize(struct s_reader *rdr)
+{
+	if (!emukey_RdrChkDevices(rdr)) return 0;
+	#if defined(__XCAS_BISS__)
+		XBISS_Cleanup();
+	#endif
+	#if defined(__XCAS_VIACESS__)
+		XVIACESS_Cleanup();
+	#endif
+	#if defined(__XCAS_SEKA__)
+		XSEKA_Cleanup();
+	#endif
+	#if defined(__XCAS_CRYPTOWORKS__)
+		XCRYPTOWORKS_Cleanup();
+	#endif
+	#if defined(__XCAS_POWERVU__)
+		XPVU_Cleanup(rdr);
+	#endif
+
+	caidtab_clear(&rdr->ctab);
+	ftab_clear(&rdr->ftab);
+	emukey_RdrCasMakeup(rdr);
+	return 1;
+}
+
+#endif	// defined(MODULE_XCAS)
+
Index: emu-xbiss.c
===================================================================
--- emu-xbiss.c	(revision 10670)
+++ emu-xbiss.c	(nonexistent)
@@ -0,0 +1,155 @@
+#include "globals.h"
+#if defined(MODULE_XCAS)
+#include "oscam-client.h"
+#include "oscam-ecm.h"
+#include "oscam-net.h"
+#include "oscam-chk.h"
+#include "oscam-string.h"
+#include "cscrypt/des_ssl.h"
+#include "cscrypt/aes_ctx.h"
+#include "module-dvbapi.h"
+#include "module-xcas.h"
+
+#if defined(__XCAS_BISS__)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+struct xbiss_keydata
+{
+	uint16_t	caid;
+	uint32_t	ppid;
+	uint32_t	freq;
+	int16_t	found;
+	uint8_t	constcw[16];
+
+	int16_t	cwidx;
+	int16_t	cwmax;
+	uint8_t	cwmulkeys[MAXMULTIKEY<<1][8];
+};
+struct xbiss_keydata g_xbiss[MAX_DEMUX];
+
+static int
+XBISS_cwChkComparison(int dmuxid, int cwMaxes)
+{
+	struct xbiss_keydata *pxbiss = &g_xbiss[dmuxid];
+	int counter = 0;
+	int ignored;
+	int i, j;
+
+	if (cwMaxes < 2) return (cwMaxes);
+	for (i=0; i<cwMaxes; i++)
+	{
+		ignored = 0;
+		if (cs_Iszero(pxbiss->cwmulkeys[i],8)) ignored = 1;
+		else {
+			for (j=0; j<i; j++)
+			{
+				if (!memcmp(pxbiss->cwmulkeys[i], pxbiss->cwmulkeys[j], 8)) {
+					ignored = 1;
+					break;
+				}
+			}
+		}
+		if (!ignored) {
+			if (i != counter) memcpy(pxbiss->cwmulkeys[counter], pxbiss->cwmulkeys[i], 8);
+			counter++;
+		}
+	}
+	return (counter);
+}
+
+
+int
+XBISS_Process(struct s_reader *rdr, ECM_REQUEST *er, uint8_t *cw)
+{
+	struct xbiss_keydata *pxbiss;
+	uint32_t srvprid;
+	uint8_t	*srvcws;
+	uint8_t	*Lfscws;
+	uint8_t  dcw[16];
+	int dmuxid;
+	int cwfound = 0;
+	int LfsMax, srpMax;
+	int cwdirection = 0;
+
+	if (!er)  return 0;
+	if (!rdr) return 0;
+	dmuxid = er->dmuxid % MAX_DEMUX;
+	pxbiss = &g_xbiss[dmuxid];
+
+	cwdirection = er->constAfterwards;
+	srvprid = (uint32_t)((er->srvid<<16)|er->pid);
+	MYEMU_TRACE("xbiss:searching{%04X,%08X,%05d}{%04X,%08X,%05d}{%d.%d}\n",
+			er->caid, srvprid,er->chSets.frequency,
+			pxbiss->caid, pxbiss->ppid, pxbiss->freq,
+			pxbiss->found,
+			cwdirection);
+
+	if (pxbiss->caid == er->caid &&
+		 pxbiss->ppid == srvprid  &&
+		 pxbiss->freq == er->chSets.frequency)
+	{
+		if (!pxbiss->found) return 0;
+		if ( pxbiss->cwmax > 1)
+		{
+			if (cwdirection<0) pxbiss->cwidx = (pxbiss->cwidx + pxbiss->cwmax-1) % pxbiss->cwmax;
+			else if (cwdirection>0) pxbiss->cwidx = (pxbiss->cwidx+1) % pxbiss->cwmax;
+			else pxbiss->cwidx = pxbiss->cwidx % pxbiss->cwmax;
+			memcpy(pxbiss->constcw, pxbiss->cwmulkeys[pxbiss->cwidx], 8);
+			memcpy(pxbiss->constcw+8, pxbiss->cwmulkeys[pxbiss->cwidx], 8);
+		}
+		memcpy(cw, pxbiss->constcw, 16);
+		MYEMU_TRACE("xbiss:cwfound{%02X...%02X}{%d/%d}\n", cw[0], cw[7], pxbiss->cwidx+1, pxbiss->cwmax);
+		return 1;
+	}
+
+	pxbiss->cwidx = 0;
+	Lfscws = pxbiss->cwmulkeys[0];
+	LfsMax = XEMUKEY_ChLfsSearch(rdr, CASS_BISS, er->chSets.frequency, 0x0, Lfscws, 8);
+	srvcws = pxbiss->cwmulkeys[LfsMax];
+	srpMax = XEMUKEY_MultiSearch(rdr, CASS_CONSTANT, srvprid, 0x0, srvcws, 8);
+
+	if (LfsMax)
+	{
+		memcpy(dcw, Lfscws, 8);
+		memcpy(dcw+8, Lfscws, 8);
+		cwfound = 1;
+	}
+	else
+	if (srpMax)
+	{
+		memcpy(dcw, srvcws, 8);
+		memcpy(dcw+8, srvcws, 8);
+		cwfound = 1;
+	}
+
+	pxbiss->caid = er->caid;
+	pxbiss->freq = er->chSets.frequency;
+	pxbiss->ppid = srvprid;
+	pxbiss->found = cwfound;
+	pxbiss->cwmax = XBISS_cwChkComparison(dmuxid, srpMax+LfsMax);
+	if (cwfound)
+	{
+		set_cw_checksum(dcw, 16);
+		memcpy(cw, dcw, 16);
+		memcpy(pxbiss->constcw, cw, 16);
+		MYEMU_TRACE("xbiss:cwfirst{%02X...%02X}(%d/%d(%d_%d))\n",
+				cw[0], cw[7], pxbiss->cwidx+1, pxbiss->cwmax, LfsMax, srpMax);
+	}
+	return (cwfound);
+}
+
+
+void
+XBISS_Cleanup(void)
+{
+	MYEMU_TRACE("xbiss:clean\n");
+	memset(&g_xbiss, 0, sizeof(g_xbiss));
+}
+
+#endif	// defined(__XCAS_BISS__)
+#endif	// defined(MODULE_XCAS)
+
Index: emu-xcryptoworks.c
===================================================================
--- emu-xcryptoworks.c	(nonexistent)
+++ emu-xcryptoworks.c	(working copy)
@@ -0,0 +1,976 @@
+#include "globals.h"
+#if defined(MODULE_XCAS)
+#include "oscam-client.h"
+#include "oscam-ecm.h"
+#include "oscam-net.h"
+#include "oscam-chk.h"
+#include "oscam-string.h"
+#include "cscrypt/bn.h"
+#include "module-xcas.h"
+#if defined(__XCAS_CRYPTOWORKS__)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+typedef struct
+{
+	uint16_t casysid;
+	uint8_t  provf[4];
+	uint8_t  systemkey[6];
+} CTW_SYSKDATA;
+
+static CTW_SYSKDATA 	ctw_systemkeys[] =
+{
+	// Digiturk Cryptoworks Eutelsat (7.0\A1\C6E)
+	{ 0x0D00,	{0xC0,0xC4,0xC8,0xCC,},		{0x01,0x56,0x12,0xE8,0xEE,0x33},},
+	// 5\A1\C6E : Kingston/Arquiva 12111H
+	{ 0x0D00,	{0x20,0x30,0x10,0x00,},		{0x23,0x90,0x91,0x78,0x1C,0x7E},},
+
+	{ 0x0D01,	{0x50,0x54,0x00,0x00,},		{0xE0,0xE6,0xB0,0xBA,0x31,0x25},},
+ 	//	13\A1\C6E : E! Europe & Jetix 10723H & JSTV 1 & 2 12597V
+	{ 0x0D01,	{0xE4,0xE8,0xEC,0xF0,},		{0xC2,0x3F,0xFA,0x92,0x19,0xAB},},
+ 	{ 0x0D02,	{0x88,0x8C,0x00,0x00,},		{0x8A,0xD8,0xBE,0x27,0x92,0x21},},
+ 	//	UXP TEST(ASTRA 10921)
+// { 0x0D02,	{0xA0,0x00,0x00,0x00,},		{0xC8,0x79,0x1A,0x66,0xBE,0x69,},
+ 	{ 0x0D02,	{0xA0,0x00,0x00,0x00,},		{0x62,0x7A,0x47,0xEE,0x58,0xA7},},
+
+ 	//	23\A1\C6E : Czech Link 12525V
+	{ 0x0D03,	{0x04,0x08,0x00,0x00,},		{0x27,0xB4,0x88,0x34,0x8D,0x54},},
+ 	//	23\A1\C6E : Slo-vak Link 12565H
+	{ 0x0D03,	{0x20,0x00,0x00,0x00,},		{0x91,0x47,0x55,0x0F,0x41,0x9C},},
+ 	//	19\A1\C6E : Turner 11778V
+ 	// 0x5C ???????????
+//	{ 0x0D03,	{0x5C,0x00,0x00,0x00,},		{0x27,0xB4,0x88,0x34,0x8D,0x54},},
+	{ 0x0D03,	{0x5C,0x00,0x00,0x00,},		{0xDE,0x20,0x34,0x14,0x54,0x55},},
+	{ 0x0D03,	{0x60,0x00,0x00,0x00,},		{0xDE,0x20,0x34,0x14,0x54,0x55},},
+ 	//	BritishTelecom 13.0\A1\C6E
+	{ 0x0D03,	{0xA0,0xCC,0x00,0x00,},		{0xC8,0x79,0x1A,0x66,0xBE,0x69},},
+ 	//	19\A1\C6E : XtraMusic
+	{ 0x0D03,	{0xB0,0x00,0x00,0x00,},		{0x5E,0x13,0x97,0xA6,0x59,0x7E},},
+	//	42\A1\C6E & 7.0\A1\C6E : Digiturk
+	{ 0x0D03,	{0xC0,0xC4,0x00,0x00,},		{0x64,0x2F,0x15,0xA3,0xBC,0x63},},
+
+	//	15\A1\C6W : DMC 11124H & 11150H.
+	{ 0x0D04,	{0x04,0x08,0x0C,0x10,},		{0x28,0xD6,0xF3,0xBF,0x1B,0x76},},
+	//	ORF/Easy TV
+	{ 0x0D05,	{0x04,0x08,0x0C,0x10,},		{0x09,0x87,0xCF,0x2A,0x61,0x1D},},
+
+	{ 0x0D08,	{0x20,0x30,0x00,0x00,},		{0x23,0x90,0x91,0x78,0x1C,0x7E},},
+	{ 0x0D22,	{0x06,0x00,0x00,0x00,},		{0x09,0x87,0xCF,0x2A,0x61,0x1D},},
+
+	//	ORF
+	{ 0x0D95,	{0x04,0x08,0x00,0x00,},		{0x34,0x65,0x29,0x96,0x7A,0xDF},},
+};
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+typedef struct
+{
+	uint16_t casysid;
+	uint16_t provf;
+	uint8_t  ab0key[16];
+	uint8_t  ab1key[16];
+	uint8_t  abRsa	[64];
+} CTW_KEYDATA;
+
+static CTW_KEYDATA 	ctw_keys[] =
+{
+	{	// Digiturk Cryptoworks Eutelsat (7.0\A1\C6E)
+		 0x0D00,   0xC8,
+		{0x22,0xEC,0xB8,0xB2,0x43,0x85,0xC3,0xB2,0x94,0x1E,0xF7,0xEC,0xC2,0xB5,0x4A,0x09,},
+		{0xC0,0xC6,0x86,0x55,0xB6,0x33,0x04,0x08,0x5B,0x5F,0x72,0x2D,0xD4,0x71,0xFE,0x27,},
+		{0x9D,0x5F,0x83,0xA2,0xD8,0x4C,0x03,0xF1,0x00,0xAA,0xF7,0x24,0x98,0xAD,0x74,0xB8,
+		 0x99,0x95,0x79,0x4D,0x8F,0x28,0x82,0xDD,0x5F,0xDE,0x26,0xEB,0xB1,0x0A,0x50,0x4E,
+		 0x78,0x76,0x5E,0x4D,0x59,0x5E,0xD4,0xD7,0x20,0x2E,0x0E,0x00,0x2F,0x41,0x02,0x8B,
+		 0xCD,0xAF,0x45,0x69,0xFE,0x27,0xB5,0x3F,0x0A,0xCF,0x2D,0x90,0x63,0x96,0x00,0x80,},
+	},
+	{	// Czech Link
+		 0x0D03,   0x04,
+	//	{0x1B,0x94,0xCA,0xED,0x06,0x00,0x01,0x54,0x1B,0x94,0xCA,0xED,0x06,0x00,0x01,0x54,},
+		{0x72,0x55,0x91,0xA1,0x9F,0x0C,0x8F,0x38,0x97,0x37,0x78,0xFF,0x7E,0x57,0x7C,0x04,},
+		{0x15,0x44,0x2A,0xF4,0xF4,0x5D,0xA4,0x5A,0x02,0xCF,0xFE,0x37,0xCE,0xC2,0xB6,0x07,},
+		{0x09,0x05,0x8B,0x5B,0xD4,0x4D,0xE7,0xDB,0x83,0x6C,0x65,0xE7,0xC1,0xA6,0x0E,0xAE,
+		 0xBF,0xD7,0x94,0xD8,0x89,0x74,0xE1,0x1F,0xB8,0x2F,0x46,0x6A,0x41,0xE6,0xC5,0x33,
+		 0x5B,0x33,0x8F,0xDF,0x11,0x46,0xC5,0xA5,0xBE,0x90,0xF8,0xA9,0x75,0x8B,0x63,0x77,
+		 0x6B,0x55,0x0E,0x9A,0x4F,0x39,0x1E,0xFF,0xCC,0x63,0xA9,0xC8,0x29,0x4E,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	{	 0x0D03,   0x20,
+		{0xD7,0x40,0x79,0xB6,0x32,0x34,0x9E,0x76,0xCA,0x84,0x03,0x21,0xAB,0x92,0x35,0x33,},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
+		{0x59,0xD7,0x52,0x4B,0x66,0xCB,0xE0,0x5F,0x2A,0x55,0x0B,0xA8,0xD1,0xE4,0x63,0x5B,
+		 0xFB,0xF8,0xCE,0xC3,0x60,0x98,0x87,0xE1,0x21,0x22,0xF6,0x6E,0xCD,0xD1,0xAA,0x1B,
+		 0xAD,0x5F,0x70,0x6A,0x2E,0xF1,0xE5,0xBB,0x6C,0x78,0x01,0xFC,0x62,0x4B,0x29,0xDC,
+		 0x64,0x4C,0xB0,0x75,0x4D,0xB7,0xF5,0x90,0xAD,0xA3,0x20,0x1D,0x9F,0x64,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	{	// turner B0 tonytr 2007-09-05 22:01:03
+		 0x0D03,   0x5C,
+		{0x9A,0x0A,0x10,0x9C,0x23,0xA5,0xC2,0x17,0x5B,0x1F,0x87,0x03,0x38,0xCD,0xCE,0xC4,},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
+		{0x7D,0xD0,0xBF,0x66,0x92,0xE9,0xD4,0x5B,0xFA,0x69,0x97,0xA6,0x59,0x2E,0x90,0xAE,
+		 0xD2,0xF9,0xA6,0x62,0x4B,0xA9,0x1D,0x1B,0xF8,0xA4,0xDC,0x16,0xEF,0x18,0x7E,0x02,
+		 0xB6,0x66,0xF1,0x77,0xA0,0x23,0x23,0xDC,0x97,0x66,0x5F,0x3C,0x61,0x97,0x0B,0xCE,
+		 0x0A,0xEF,0x63,0xE7,0x53,0x9B,0x36,0xAB,0x9B,0xF5,0x8B,0x20,0x4B,0x5D,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	{	//	19\A1\C6E : XtraMusic
+		 0x0D03,   0xB0,
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
+		{0x39,0xFA,0x13,0x22,0x59,0xC6,0x4C,0x7C,0xF5,0x5D,0x3D,0x6F,0xE8,0x32,0x0B,0x64,
+		 0x4F,0xE8,0x2B,0x96,0x68,0x1D,0x54,0x61,0x21,0xA0,0xD2,0xB6,0xD0,0x51,0xE5,0x68,
+		 0x05,0xE0,0x6E,0xB0,0x67,0x80,0x2A,0xCE,0xD1,0x72,0xF3,0xF8,0x7E,0x0D,0xE9,0x1B,
+		 0x9B,0x96,0xE8,0x46,0x38,0x30,0x15,0xC9,0xD4,0xD5,0x84,0x42,0xF5,0x9D,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	{	//	42\A1\C6E & 7.0\A1\C6E : Digiturk
+		 0x0D03,   0xC0,
+		{0xB7,0x52,0xC3,0xBE,0x0B,0xDE,0xEB,0x8A,0x32,0xA3,0xE7,0x3E,0x63,0x58,0xF0,0x44,},
+		{0x28,0xE3,0xAF,0x36,0xBB,0xC2,0xBC,0x92,0x40,0x7D,0xAA,0xC2,0x38,0xD1,0x2A,0xDF,},
+		{0x21,0x4D,0xA3,0x1E,0x63,0x5D,0x37,0xC9,0xA3,0x16,0x40,0xAE,0xC8,0xD2,0x14,0x5F,
+		 0x3E,0x5A,0xE1,0x8F,0x1E,0xDF,0x73,0x68,0x35,0xAB,0x60,0x42,0x33,0x33,0xAB,0x8C,
+		 0xEC,0x8B,0x6D,0x47,0x40,0x08,0xFB,0x50,0x31,0x20,0x0E,0x0F,0x68,0x73,0xFE,0x58,
+		 0x87,0xF1,0x95,0xC1,0xE8,0x86,0x6D,0xB2,0x81,0xF8,0x49,0xE1,0x46,0xBA,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	{	//	42\A1\C6E & 7.0\A1\C6E : Digiturk
+		 0x0D03,   0xC4,
+		{0x00,0xB5,0x34,0xFF,0x03,0x2F,0x8A,0x5E,0xAC,0x0A,0xE6,0x3E,0x99,0x70,0xEB,0x74,},
+		{0xBC,0xF2,0x15,0x87,0x22,0x0E,0x44,0xE3,0xCF,0x51,0x60,0x43,0x33,0xE2,0x5F,0x54,},
+		{0x05,0x48,0x03,0xCE,0x3D,0x7F,0x3A,0x6D,0x98,0xE1,0xAB,0x3E,0x94,0x7F,0x67,0x49,
+		 0x87,0x79,0x9B,0x17,0x26,0x23,0x8C,0xCD,0x6F,0x16,0x12,0x5C,0xB3,0x93,0xA6,0x56,
+		 0x8A,0x11,0xFC,0xA4,0xD3,0x06,0x56,0x94,0x87,0x76,0x1D,0xEF,0xD6,0x44,0xC8,0x3B,
+		 0x4C,0x36,0x81,0x46,0x0D,0x7C,0x3E,0x74,0x7A,0x01,0xAC,0x70,0x04,0xC7,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	//-------------------------------------------------------------------------------------
+	//-------------------------------------------------------------------------------------
+	{	//	(ORF 19E)
+		 0x0D05,   0x04,
+	//	{0x07,0x16,0x5D,0xF9,0xAC,0x22,0x6C,0x9A,0x38,0x46,0x0C,0x26,0xA2,0xD8,0x4F,0xBF,},
+		{0xA9,0xD7,0x32,0xF5,0xE7,0x38,0xE4,0x8A,0x91,0xC8,0x63,0x8B,0x12,0x74,0x66,0x61,},
+		{0x2D,0xF2,0x5D,0xC7,0x8D,0x09,0x88,0x60,0xB8,0xC6,0x28,0x11,0x40,0x22,0x4E,0xBD,},
+		//	EMM_G:D0B2E2DCC581F4DE71BD69845F67229B, 35F16B7AE5B2458A81D7BA6C1A86AA62
+		{0xCD,0x88,0xAC,0x49,0x94,0x57,0x7E,0x06,0x71,0xA8,0x8D,0x65,0xC4,0x24,0x76,0xB1,
+		 0x62,0xED,0xD8,0x43,0x30,0x38,0x21,0x42,0x9B,0x14,0xB0,0x5C,0xD1,0x2F,0xC9,0x2C,
+		 0xD0,0xA8,0xD3,0xDC,0xEB,0xD2,0xD2,0x67,0xD8,0x1B,0x0A,0x1A,0xD0,0x8E,0xF1,0x80,
+		 0xED,0x8A,0x4D,0x59,0xFF,0x4D,0x9C,0x61,0x93,0x05,0x09,0x5A,0xE0,0xD1,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	{	//	Alpen TVX (19E)
+		 0x0D05,   0x08,
+		{0xC3,0x5C,0xCB,0xE9,0x54,0x29,0x81,0xD8,0x97,0x9C,0x6D,0x23,0xE3,0x8C,0x71,0xE0,},
+		{0x62,0x47,0x2D,0xA7,0x3D,0xAF,0x2D,0x39,0xD8,0x78,0xB4,0x6C,0x32,0x97,0xE1,0x9D,},
+		{0xE9,0x4B,0x79,0x5C,0xC4,0x93,0xA9,0x8A,0x85,0x59,0x69,0x9E,0x3F,0xAF,0x1E,0xF2,
+		 0x09,0xD3,0x0D,0xDE,0xFA,0xDB,0x4B,0x3B,0x58,0x87,0x7B,0x8C,0x5F,0xFA,0x41,0x1D,
+		 0x88,0x39,0x08,0xC4,0xAD,0x1C,0xC0,0xA3,0xAF,0xB8,0xFE,0x58,0x90,0xE2,0x01,0xAD,
+		 0xF0,0x02,0x61,0x39,0x38,0xBB,0x82,0x0B,0x24,0xDF,0x29,0xF6,0xF0,0x6C,0x00,0x80},
+	},
+	//-------------------------------------------------------------------------------------
+	{	//	EasyTv/ORF (19E)
+		 0x0D05,   0x0C,
+		{0x65,0xD4,0xE6,0xD5,0x37,0xE3,0xAD,0x18,0x4D,0xF4,0xD5,0x79,0x6A,0x8F,0x8A,0xED,},
+		{0x7C,0x07,0xC8,0x5B,0xC1,0x26,0x22,0xB9,0x42,0x17,0x17,0x94,0x51,0x61,0x3C,0x88,},
+		//	EMM_G:F5B7E5E82B600D8216D353EDFB189B13
+		{0x9D,0x96,0x5D,0x72,0x43,0x2A,0xA5,0x11,0x86,0xBD,0x0C,0x98,0xCB,0xFE,0xB7,0x49,
+		 0xD0,0x78,0x8C,0x6F,0x37,0x93,0x3D,0xB2,0xFA,0xED,0xEF,0xCB,0x47,0x3E,0x3D,0xF3,
+		 0x09,0x34,0xDA,0x04,0x44,0x73,0x94,0xF9,0x55,0xD1,0xCA,0x47,0x3B,0x25,0x01,0xC7,
+		 0xAC,0x0A,0x7E,0xC0,0xF4,0x3A,0xFD,0xB7,0xEF,0xC2,0x0B,0x17,0xE1,0xF4,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	{	//	Sky Austria (19E)
+		 0x0D05,   0x10,
+	//	{0x2D,0xF2,0x5D,0xC7,0x8D,0x09,0x88,0x60,0xB8,0xC6,0x28,0x11,0x40,0x22,0x4E,0xBD,},
+	//	{0xB5,0x7B,0xBB,0x96,0x26,0xDA,0x9F,0xFB,0x21,0x8C,0x42,0x43,0x6E,0xD0,0xF1,0x8F,},
+		{0x00,0x00,0x6A,0xB3,0x25,0xE6,0xAB,0xF4,0xDA,0x47,0x28,0x0F,0x35,0x29,0x4B,0x5C,},
+	//	{0xC2,0x29,0xA4,0x03,0x61,0x00,0xE8,0x1A,0x42,0xBA,0xC3,0xC7,0x0E,0xBB,0xC8,0x52,},
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x7E,0x4D,0xAC,0x06,0x5B,0xA6,0x86,},
+		{0x59,0x72,0x0F,0x3F,0x1B,0x74,0xA4,0xDB,0xF7,0x26,0x44,0x6C,0xCB,0xEE,0xAB,0x49,
+		 0xA9,0x6E,0xF2,0xD2,0x08,0x40,0xA2,0x1F,0x1C,0x0B,0xD7,0x29,0x13,0xE6,0x3C,0x97,
+		 0xEA,0x3B,0xE2,0xF0,0x4D,0x3D,0x27,0xDA,0x1F,0xBF,0xC5,0xBD,0xAD,0x5D,0x98,0x49,
+		 0x50,0x1F,0x83,0xD3,0xC2,0x0C,0xF9,0x84,0xC0,0x1F,0x72,0xE0,0x38,0xA4,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	//-------------------------------------------------------------------------------------
+	//-------------------------------------------------------------------------------------
+	{	// Arena
+		 0x0D22,   0x04,
+		{0x65,0xD4,0xE6,0xD5,0x37,0xE3,0xAD,0x18,0x4D,0xF4,0xD5,0x79,0x6A,0x8F,0x8A,0xED,},
+		{0x7C,0x07,0xC8,0x5B,0xC1,0x26,0x22,0xB9,0x42,0x17,0x17,0x94,0x51,0x61,0x3C,0x88,},
+		{0x9D,0x96,0x5D,0x72,0x43,0x2A,0xA5,0x11,0x86,0xBD,0x0C,0x98,0xCB,0xFE,0xB7,0x49,
+		 0xD0,0x78,0x8C,0x6F,0x37,0x93,0x3D,0xB2,0xFA,0xED,0xEF,0xCB,0x47,0x3E,0x3D,0xF3,
+		 0x09,0x34,0xDA,0x04,0x44,0x73,0x94,0xF9,0x55,0xD1,0xCA,0x47,0x3B,0x25,0x01,0xC7,
+		 0xAC,0x0A,0x7E,0xC0,0xF4,0x3A,0xFD,0xB7,0xEF,0xC2,0x0B,0x17,0xE1,0xF4,0x00,0x80,},
+	},
+	//-------------------------------------------------------------------------------------
+	//-------------------------------------------------------------------------------------
+	//-------------------------------------------------------------------------------------
+};
+
+static int16_t		er_KFOUND;
+static uint32_t	er_KPPID;
+static uint8_t		er_KSYSKEY[6];
+static uint8_t		er_KNR;
+static uint8_t		er_KKEY[16];
+static BIGNUM 		er_RN85;
+static BIGNUM 		er_RExp;
+// reader_common.c
+extern int32_t rdr_RSA_decrypt(struct s_reader *reader, uint8_t *out, uint8_t *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int32_t LE);
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+// common Cryptoworks DES modes
+#define DESCTWLEFT		0x0
+#define DESCTWRIGHT		0x1
+#define DESMOD1			0x2
+#define DESN				0x4
+#define DESMOD3			0x8
+
+// common Cryptoworks DES modes
+#define DES2DECRYPT		(DESN|DESMOD3|DESCTWLEFT)
+#define DES2ENCRYPT		(DESN|DESMOD1|DESCTWRIGHT)
+#define DES2N				(DESN)
+
+#define _ror_1_(value) 	(((value>>1)&0x7fffffff)) | ((value&0x10)<<27);
+#define _rol_1_(value) 	(((value<<1)&0xfffffffe)) | ((value&0x08000000)>>27);
+#define _lwz_(rD,d,buf) (rD=buf[d+0]<<24|buf[d+1]<<16|buf[d+2]<<8|buf[d+3])
+
+
+static uint8_t 	tab_SBOXES[4][0x40] =
+{
+	{0xD8,0xD7,0x83,0x3D,0x1C,0x8A,0xF0,0xCF,0x72,0x4C,0x4D,0xF2,0xED,0x33,0x16,0xE0,
+	 0x8F,0x28,0x7C,0x82,0x62,0x37,0xAF,0x59,0xB7,0xE0,0x00,0x3F,0x09,0x4D,0xF3,0x94,
+	 0x16,0xA5,0x58,0x83,0xF2,0x4F,0x67,0x30,0x49,0x72,0xBF,0xCD,0xBE,0x98,0x81,0x7F,
+	 0xA5,0xDA,0xA7,0x7F,0x89,0xC8,0x78,0xA7,0x8C,0x05,0x72,0x84,0x52,0x72,0x4D,0x38,},
+	{0xD8,0x35,0x06,0xAB,0xEC,0x40,0x79,0x34,0x17,0xFE,0xEA,0x47,0xA3,0x8F,0xD5,0x48,
+	 0x0A,0xBC,0xD5,0x40,0x23,0xD7,0x9F,0xBB,0x7C,0x81,0xA1,0x7A,0x14,0x69,0x6A,0x96,
+	 0x47,0xDA,0x7B,0xE8,0xA1,0xBF,0x98,0x46,0xB8,0x41,0x45,0x9E,0x5E,0x20,0xB2,0x35,
+	 0xE4,0x2F,0x9A,0xB5,0xDE,0x01,0x65,0xF8,0x0F,0xB2,0xD2,0x45,0x21,0x4E,0x2D,0xDB,},
+	{0xDB,0x59,0xF4,0xEA,0x95,0x8E,0x25,0xD5,0x26,0xF2,0xDA,0x1A,0x4B,0xA8,0x08,0x25,
+	 0x46,0x16,0x6B,0xBF,0xAB,0xE0,0xD4,0x1B,0x89,0x05,0x34,0xE5,0x74,0x7B,0xBB,0x44,
+	 0xA9,0xC6,0x18,0xBD,0xE6,0x01,0x69,0x5A,0x99,0xE0,0x87,0x61,0x56,0x35,0x76,0x8E,
+	 0xF7,0xE8,0x84,0x13,0x04,0x7B,0x9B,0xA6,0x7A,0x1F,0x6B,0x5C,0xA9,0x86,0x54,0xF9,},
+	{0xBC,0xC1,0x41,0xFE,0x42,0xFB,0x3F,0x10,0xB5,0x1C,0xA6,0xC9,0xCF,0x26,0xD1,0x3F,
+	 0x02,0x3D,0x19,0x20,0xC1,0xA8,0xBC,0xCF,0x7E,0x92,0x4B,0x67,0xBC,0x47,0x62,0xD0,
+	 0x60,0x9A,0x9E,0x45,0x79,0x21,0x89,0xA9,0xC3,0x64,0x74,0x9A,0xBC,0xDB,0x43,0x66,
+	 0xDF,0xE3,0x21,0xBE,0x1E,0x16,0x73,0x5D,0xA2,0xCD,0x8C,0x30,0x67,0x34,0x9C,0xCB,},
+};
+static uint8_t 	tab_sb[4][8] =
+{
+	{0,0x40,4,0x80,0x21,0x10,2,8},
+	{0x80,8,1,0x40,4,0x20,0x10,2},
+	{0x82,0x40,1,0x10,0,0x20,4,8},
+	{2,0x10,4,0x40,0x80,8,1,0x20},
+};
+static uint8_t 	tab_1002D85C[0x2C]=
+{
+	1,0,3,1,2,2,3,2,1,3,1,1,3,0,1,2,3,1,3,2,2,0,
+	7,6,5,4,7,6,5,7,6,5,6,7,5,7,5,7,6,6,7,5,4,4
+};
+static uint8_t 	tab_1002D888[0x2C]=
+{
+	0x80,0x08,0x10,0x02,0x08,0x40,0x01,0x20,0x40,0x80,0x04,
+	0x10,0x04,0x01,0x01,0x02,0x20,0x20,0x02,0x01,0x80,0x04,
+	0x02,0x02,0x08,0x02,0x10,0x80,0x01,0x20,0x08,0x80,0x01,
+	0x08,0x40,0x01,0x02,0x80,0x10,0x40,0x40,0x10,0x08,0x01
+};
+static uint8_t		tab_1002D8B4[ 4]={2,0x10,4,4};
+static uint8_t		tab_1002D8E0[24]={1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1};
+static uint8_t		tab_1002D8C0[24]={4,5,6,7,7,6,5,4,7,4,5,6,4,7,6,5,0,2,4,6,7,5,3,1};
+
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+static int
+xcryptoworks_FindSystemkey(struct s_reader *reader, uint16_t casysid, uint8_t provf, uint8_t *systemkey)
+{
+	CTW_SYSKDATA *expi;
+	uint32_t	ppid;
+	int cMax;
+	int i, found;
+
+	// select suitable systemkey BYTES
+	ppid = (casysid<<8) | (provf & 0xff);
+	if (er_KPPID == ppid)
+	{
+		memcpy(systemkey, er_KSYSKEY, 6);
+		MYEMU_TRACE("xcryptoworks:sys:%06X:%02X..%02X\n", ppid, systemkey[0], systemkey[5]);
+		return 1;
+	}
+
+	found = XEMUKEY_SpecialSearch(reader, CASS_CRYPTOWORKS, ppid, "06", systemkey, 6);
+	if ( found && cs_Iszero(systemkey,6)) found = 0;
+	if (!found)
+	{
+		expi = (CTW_SYSKDATA *)ctw_systemkeys;
+		cMax = sizeof(ctw_systemkeys)/sizeof(CTW_SYSKDATA);
+		for (i=0; i<cMax; i++)
+		{
+			if (expi->casysid == casysid)
+			{
+				if (expi->provf[0] == provf) break;
+				if (expi->provf[1] == provf) break;
+				if (expi->provf[2] == provf) break;
+				if (expi->provf[3] == provf) break;
+			}
+			expi++;
+		}
+
+		if (i==cMax)
+		{
+			MYEMU_TRACE("xcryptoworks:systemkey{%06x} not found\n", ppid);
+			return 0;	// prov id not found
+		}
+		memcpy(systemkey, expi->systemkey, 6);
+	}
+	memcpy(er_KSYSKEY, systemkey, 6);
+	MYEMU_TRACE("xcryptoworks:sys:%06X:%02X..%02X\n", ppid, systemkey[0], systemkey[5]);
+	return 1;
+}
+
+
+static uint8_t *
+xcryptoworks_FindRsakey(struct s_reader *reader, uint16_t casysid, uint8_t provf)
+{
+	static uint8_t seRsa[64];
+	static uint8_t	seExp[1] = {0x2};
+	CTW_KEYDATA *provi;
+	uint32_t	ppid;
+	int cMax;
+	int i, found;
+
+	ppid = (casysid<<8) | (provf & 0xff);
+	if (er_KPPID == ppid)
+	{
+		MYEMU_TRACE("xcryptoworks:rsa:%06X:%02X..%02X\n", ppid, seRsa[0],  seRsa[63]);
+		return (seRsa);
+	}
+
+	// select suitable RSA
+	found = XEMUKEY_SpecialSearch(reader, CASS_CRYPTOWORKS, ppid, "B0", seRsa, 64);
+	if ( found && cs_Iszero(seRsa,64)) found = 0;
+	if (!found)
+	{
+		provi = (CTW_KEYDATA *)ctw_keys;
+		cMax  = sizeof(ctw_keys)/sizeof(CTW_KEYDATA);
+		for (i=0; i<cMax; i++)
+		{
+			if ((provi->casysid == casysid) && (provi->provf == provf)) break;
+			provi++;
+		}
+		if (i==cMax)
+		{
+			MYEMU_TRACE("xcryptoworks:rsakey{%06x} not found\n", ppid);
+			return 0;	// RSA not found
+		}
+		memcpy(seRsa, provi->abRsa, 64);
+	}
+	BN_bin2bn(seExp,  1, &er_RExp);
+	BN_bin2bn(seRsa, 64, &er_RN85);
+	MYEMU_TRACE("xcryptoworks:rsa:%06X:%02X..%02X\n", ppid, seRsa[0],  seRsa[63]);
+	return (seRsa);
+}
+
+
+
+static int
+xcryptoworks_FindDeskey(struct s_reader *reader, uint16_t casysid, uint8_t provf, uint8_t keyNr, uint8_t *cDeskey)
+{
+	CTW_KEYDATA *provi;
+	uint32_t ppid;
+	int cMax;
+	int i, found;
+
+	ppid = (casysid<<8) | (provf & 0xff);
+	if (er_KPPID == ppid && er_KNR == keyNr)
+	{
+		memcpy(cDeskey, er_KKEY, 0x10);
+		MYEMU_TRACE("xcryptoworks:des:%06X:%02X..%02X(%2X)\n", ppid, cDeskey[0], cDeskey[15], keyNr);
+		return 1;
+	}
+
+	found = XEMUKEY_Searchkey(reader, CASS_CRYPTOWORKS, ppid, keyNr, cDeskey, 16);
+	if ( found && cs_Iszero(cDeskey,16)) found = 0;
+	if (!found)
+	{
+		provi = (CTW_KEYDATA *)ctw_keys;
+		cMax  =	sizeof(ctw_keys)/sizeof(CTW_KEYDATA);
+		for (i=0; i<cMax; i++)
+		{
+			if ((provi->casysid == casysid) && (provi->provf == provf)) break;
+			provi++;
+		}
+		if (i==cMax)
+		{
+			MYEMU_TRACE("xcryptoworks:deskey{%06x} not found\n", ppid);
+			return 0;	// RSA not found
+		}
+		memcpy(cDeskey, (keyNr & 0x1) ? provi->ab1key : provi->ab0key, 0x10);
+	}
+	er_KNR = keyNr;
+	er_KPPID = ppid;
+	er_KFOUND = 1;
+	memcpy(er_KKEY, cDeskey, 0x10);
+	MYEMU_TRACE("xcryptoworks:des:%06X:%02X..%02X(%2X)\n", ppid, cDeskey[0], cDeskey[15], keyNr);
+	return 1;
+}
+
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+static void
+xcryptoworks_DesPrepare(uint8_t *desKey)
+{
+	uint32_t r10,r11,temp, r0;
+	uint8_t tempbuff[8];
+	int i,j,k;
+
+	memset(tempbuff,0,8);
+	desKey[7]=6;
+
+	for (i=6;i>=0;i--)
+	{
+		k=desKey[7];
+		for (j=8;j>0;j--)
+		{
+			r0  = tempbuff[k];
+			r0  = r0<<1;
+			r11 = r0|1;
+			if (!(desKey[i]&1)) r11=r0;
+			desKey[i]=desKey[i]>>1;
+			tempbuff[k]=r11;
+			k--;
+			if (k<0) k=6;
+		}
+		desKey[7]=k;
+	}
+
+	tempbuff[7]=(tempbuff[3]<<4)&0xF0;
+	temp=tempbuff[6];
+	tempbuff[6]=tempbuff[4];
+	tempbuff[4]=temp;
+
+	memcpy(desKey,tempbuff,8);
+
+	_lwz_(r10,4,desKey);
+	_lwz_(r11,0,desKey);
+	for (i=0;i<4;i++) { r11 = _ror_1_(r11); r10 = _ror_1_(r10); }
+	i2be(r11,desKey  ,4);
+	i2be(r10,desKey+4,4);
+}
+
+
+static void
+xcryptoworks_DesRound(uint8_t *buff, uint32_t left, uint32_t right)
+{
+	int r0,r3,r5,r6,r9,r10,r11,r26,r27,r30,r31;
+	uint8_t tempbuff38[8], key[8];
+
+	i2be(left, key  ,4);
+	i2be(right,key+4,4);
+
+	// step1 create tempbuff
+	for (r10=0;r10<2;r10++)
+	{
+		for (r31=0;r31<4;r31++)
+		{
+			r9 = tab_1002D8C0[(4*r10)+r31];
+			r0 = tab_1002D8C0[(4*r10)+r31+8];
+			if (r10!=0) r0 = ((buff[r9]<<1)&0x3E) | ((buff[r0]&0x80)>>7);
+			else
+			{
+				r6 = buff[r0]&1;
+				r0 = (buff[r9]>>1) | 0x80;
+				if (r6==0) r0 = buff[r9]>>1;
+			}
+			tempbuff38[tab_1002D8C0[(4*r10)+r31+0x10]]=r0&0xFF;
+		}
+	}
+	// step2
+	r26=1;	r27=0;
+	for (r31=0; r31<8; r31++)
+	{
+		r26^=1;
+		r30 =(r26^1)+6;
+
+		if (r31!=0) r11 = r31-1;
+		else r11 = 1;
+
+		if (r26!=0) r9  = ((uint32_t)(-(key[r11] & tab_1002D8B4[(r31-1)>>1]))) >> 31;
+		else r9  = tempbuff38[r11];
+
+		for (r3=1; r30>r3; r3++)
+		{
+			r6  = (r9<<1)&0xFE;
+			r5  = (r9>>1)&0x7F;
+			r10 = tab_1002D888[r27];
+			r0  = key[tab_1002D85C[r27]];
+
+			if (r26!=0)
+			{
+				r9 = (r6|1) & 0xFF;
+				if ((r0&r10)==0) r9=r6&0xFF;
+			}
+			else
+			{
+				r9 = r5|0x80;
+				if ((r0&r10)==0) r9=r5&0xFF;
+			}
+			r27++;
+		}
+
+		if (r31!=0) r11++;
+		else        r11=0;
+		if (r26!=0) tempbuff38[r11] ^= r9;
+		else        tempbuff38[r11]  = (tempbuff38[r11]^r9)/4;
+	}
+
+	for (r31=0; r31<8; r31++)
+	{
+		for (r0=0; r0<4; r0++) buff[r0] ^= (tab_sb[r0][r31] & tab_SBOXES[r0][tempbuff38[r31]]);
+	}
+
+	memcpy(tempbuff38,buff,4);
+	memcpy(buff,buff+4,4);
+	memcpy(buff+4,tempbuff38,4);
+
+	_lwz_(right,4,key);
+	_lwz_(left,0,key);
+}
+
+static void
+xcryptoworks_DesProcess(uint8_t *key, int mode, uint8_t *CW)
+{
+	uint32_t left, right, iteration;
+	int i, j, x;
+
+	// split OpKey on 2 half
+	_lwz_(left, 0,key);
+	_lwz_(right,4,key);
+
+	iteration = 16;
+	if ((mode&DESMOD1) || (mode&DESMOD3))	iteration = 2;
+
+	if (mode&DESMOD3)
+	{
+		for (i=2;i>0;i--) { left = _rol_1_(left); right = _rol_1_(right); }
+	}
+
+	if (mode&DESN)
+	{
+		for (j=iteration-1; j>=0; j--)
+		{
+			x=j;
+			if (mode&DESCTWRIGHT)
+			{
+				if (mode&DESMOD1) x=0;
+				for (i=0; i<tab_1002D8E0[x+1]; i++) {	left = _rol_1_(left); right = _rol_1_(right); }
+			}
+			xcryptoworks_DesRound(CW, left, right);
+			if (!(mode&DESCTWRIGHT))
+			{
+				if (mode&DESMOD3) x=0;
+				for (i=0; i<tab_1002D8E0[x]; i++) { left = _ror_1_(left); right = _ror_1_(right); }
+			}
+		}
+	}
+}
+
+static void
+xcryptoworks_DesAlgo(uint8_t *CW, uint8_t *key, int odd, int desmode)
+{
+	uint8_t keytemp70[0x16];
+	uint8_t desKey[8], desKey2[8];
+	int r31, dmode;
+
+	memcpy(keytemp70,key,0x16);
+	memset(keytemp70,0,0x10);
+	memcpy(keytemp70,key+0x10,6);
+
+	odd = (~odd)&7;
+	dmode = desmode&1;
+
+	for (r31=8; r31>odd; r31--) keytemp70[r31-2] = key[r31];
+	xcryptoworks_DesPrepare(keytemp70);
+	memcpy(desKey, keytemp70, 8);
+	memcpy(desKey2, key+9, 8);
+	xcryptoworks_DesPrepare(desKey2);
+	xcryptoworks_DesProcess(desKey,  DES2ENCRYPT, CW);	// DES  2 rounds encrypt
+	xcryptoworks_DesProcess(desKey2, DES2N|dmode, CW);	// DES 16 round decrypt
+	xcryptoworks_DesProcess(desKey,  DES2DECRYPT, CW);	// DES  2 rounds decrypt
+	memcpy(desKey,CW,4);
+	memcpy(CW,CW+4,4);
+	memcpy(CW+4,desKey,4);
+
+	if (desmode&2)
+	{
+		memcpy(desKey,key,8);
+		memcpy(key,key+8,8);
+		memcpy(key+8,desKey,8);
+	}
+}
+
+
+static int
+xcryptoworks_n85Decrypt(struct s_reader *reader,
+	uint8_t *Encr_p,
+	uint8_t *cDeskey,
+	int odd,
+	int casysid,
+	int provf,
+	uint8_t *Decr_p)
+{
+	static uint8_t	sePermute[16]= {0xE,3,5,8,9,4,2,0xF,0,0xD,0xB,6,7,0xA,0xC,1};
+	uint8_t var1A0[16], var280[0x80], var300[0x40];
+	int posCryptKey;
+	int i, r5, r14, nanoLenCopy, nanoLen;
+
+	nanoLen = Encr_p[1];
+	nanoLenCopy = nanoLen;
+	posCryptKey = nanoLen - 6;
+
+	memcpy(var300, Encr_p + posCryptKey, 8);	// copy last 8 bytes (cryptKey)
+	xcryptoworks_DesAlgo(var300, cDeskey, odd, 1);
+	var300[0] |= 0x80;
+	if ((odd & 0x18) < 0x18) var300[0] = (uint8_t)-1;
+	if  (odd & 0x8)          var300[1] = (uint8_t)-1;
+	for (r14=0; nanoLenCopy>r14; r14+=0x20)
+	{
+		for (i=0; i<8; i++)
+		{
+			var1A0[i*2] = (sePermute[var300[i]&0xF] | ((sePermute[var300[i]>>4]) << 4));
+			var1A0[(i*2)+1] = var300[i];
+		}
+
+		for (i=0; i<4; i++) memcpy(var300+(i*0x10), var1A0, 0x10);
+		var300[0x10] =  var300[0] ^ 1;
+		var300[0x1F] = (var300[0xF]<<4) | 6;
+		var300[0x20] = (var300[0x20] & 0x7F) | 0x40;
+		b2Ro(var300,0x20);
+		b2Ro(var300+0x20, 0x20);
+
+      rdr_RSA_decrypt(reader, var300, var300, 0x40, &er_RExp, &er_RN85, 1);
+
+		b2Ro(var300, 8);
+		r5 = nanoLen-8;
+		if (nanoLen>0x20) r5=0x20;
+		memcpy(var280+r14, var300+8, r5);
+		b2Ro(var280+r14, r5);
+
+		nanoLen-=0x20;
+	}
+
+	// nano85_end XORING
+	for (i=0; i<(nanoLenCopy); i++) Decr_p[i] = Encr_p[i+2] ^ var280[i];
+
+	return 1;
+}
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+/*
+   	0x81,0x70,0x81,0x81,0xFF,0x00,0x00,0x7C,
+   	0x80,0x60,0x57,0x75,0x75,0x9C,0x14,0xCA,0xCC,0x6B,0xFB,0x71,0x26,0xA1,0x65,0x86,0x78,0xDA,
+   			  0x95,0xDC,0x2B,0x72,0xD2,0x83,0xE7,0xF7,0xDB,0x04,0xC6,0xFD,0x63,0xA0,0xE1,0xFE,
+   			  0x33,0xD2,0xBA,0x06,0x40,0x2E,0xFF,0x91,0xA0,0xA8,0x78,0x8E,0x3D,0x00,0x8F,0x52,
+   			  0x42,0x01,0x68,0xD3,0xF1,0xCF,0x43,0x59,0xDF,0x0B,0xBB,0x16,0x80,0x37,0x17,0x6F,
+   			  0xFE,0xDE,0xEB,0x0E,0x29,0x20,0x6E,0xDD,0xBB,0x69,0x30,0xDB,0x5A,0xA6,0x79,0xA0,
+   			  0x21,0xE4,0xB2,0x8A,0x1F,0x4C,0xFE,0x33,0xA4,0x01,0x6F,0xE7,0x62,0xB1,0xAD,0x63,
+   	0x83,0x01,0xC0,
+   	0x84,0x02,0xC9,0x01,
+   	0x8C,0x03,0x0D,0xB1,0x32,
+    0x8E,0x02,0x20,0xB0,
+    0xDF,0x08,0x40,0xA9,0xEA,0x1D,0x9E,0x34,0x11,0x63,
+
+    0x81,0x70,0x6A,0x81,0xFF,0x28,0x00,0x65,
+    0x83,0x01,0xC0,
+    0x85,0x48,0xFA,0x54,0x73,0xE6,0x0D,0x3A,0x83,0x94,0x28,0x0E,0x8B,0x66,0x69,0xAB,0x85,0x9A,
+    		  0x51,0xDD,0x29,0xE4,0xC3,0x2E,0xEA,0x53,0x57,0xB0,0xE2,0xF6,0xBD,0x8B,0xCE,0x7F,
+    		  0x69,0x5C,0x31,0xB7,0xE7,0x51,0x5D,0x64,0x84,0x45,0x4C,0x04,0xF1,0xD6,0x0B,0x97,
+    		  0xCB,0x9F,0xE2,0x6B,0xC4,0x03,0xC3,0x81,0x7A,0x9F,0x51,0x69,0x1F,0xF8,0x1D,0x6E,
+    		  0xBC,0x73,0xBA,0x2A,0xA6,0x53,0x3C,0xFC,
+    0x86,0x08,0xB2,0xCE,0xC0,0x2C,0x7A,0xC2,0x58,0x18,
+    0x8E,0x02,0x20,0xB0,
+    0xDF,0x08,0xEE,0x5D,0xB6, 0xCF,0x38,0x1E,0x1C,0x8B,
+*/
+
+#if 0
+	#define	___TEST_ECM_CWS___	2
+	static uint8_t	TEST_CWS_ECMs[][256] = {
+			//	0x0D04
+			{
+				0x81,0x70,0x99,0x81,0xFF,0x00,0x00,0x94,
+				0x80,0x60,
+				     0x51,0x61,0x5A,0xDE,0x64,0x17,0x09,0xC9,0x5A,0xF0,0x66,0x8B,0xC0,0xBB,0xEF,0xF2,
+				     0x46,0x49,0x1A,0xDC,0x7C,0xA5,0xEA,0x46,0x64,0x59,0x4B,0xE2,0x85,0xED,0x03,0xDF,
+				     0xC6,0x05,0x0B,0x14,0x51,0x01,0xEA,0x73,0x37,0xC1,0xE5,0xAF,0x75,0x97,0x48,0x45,
+				     0x83,0xAB,0x08,0x37,0xCF,0x69,0x07,0x1A,0x64,0x28,0x8E,0x8C,0x8E,0xD0,0x5E,0xAB,
+				     0xCB,0x18,0x2B,0xD5,0x24,0xAE,0xB9,0xF9,0xB4,0xE1,0x09,0xD6,0xF6,0xD0,0x35,0x15,
+				     0x56,0x14,0x2A,0x76,0x8B,0x2F,0x39,0x1D,0x34,0xFF,0x2C,0x47,0x4B,0xAD,0xA1,0x6D,
+				0x83,0x01,0x04,
+				0x84,0x02,0x04,0x01,
+				0x8C,0x03,0x08,0x00,0x01,
+				0x8E,0x02,0x2A,0x25,
+				0x8F,0x01,0x01,
+				0x91,0x01,0x01,
+				0xDB,0x10,0x19,0xFC,0x6C,0xAC,0x85,0x89,0x7E,0xA5,0x25,0x95,0x98,0x1A,0x06,0xCA,0xDA,0x7D,
+				0xDF,0x08,0x5A,0x02,0xD0,0x58,0x2B,0x8B,0x97,0x13,
+			//	DCWs:60 6D 5D 2A B9 56 69 78 A3 2C 1B EA FA FF 71 6A
+			},
+			{
+				0x81,0x70,0x99,0x81,0xFF,0x00,0x00,0x94,
+				0x80,0x60,0xF9,0x38,0x36,0x6A,0xB0,0xE4,0x91,0x39,0xA3,0x18,0x89,0x2E,0x88,0xAB,0x29,0xFD,
+						  0xBA,0xB9,0xFF,0x01,0xBA,0x43,0xAC,0x0A,0x59,0xF8,0x2D,0xAA,0xAD,0x9F,0x07,0x4C,
+						  0xA6,0x82,0xB9,0x1D,0xF0,0x85,0x07,0x2E,0xF5,0x6B,0x0F,0xBF,0x8D,0x16,0x08,0x22,
+						  0x5C,0x57,0xB4,0x8B,0x51,0xB3,0x91,0x88,0xF2,0x70,0x31,0x7D,0x21,0xA8,0x09,0x42,
+						  0x41,0x59,0x6C,0xF2,0x21,0x8A,0x6E,0x40,0xF1,0xEE,0x95,0x53,0xCE,0x47,0xED,0x8F,
+						  0x1C,0x8A,0xCB,0x67,0x89,0xA5,0x84,0x20,0x07,0xAC,0x2F,0xDD,0x85,0x22,0xDB,0x80,
+				0x83,0x01,0x04,
+				0x84,0x02,0x04,0x01,
+				0x8C,0x03,0x08,0x00,0x01,
+				0x8E,0x02,0x29,0x95,
+				0x8F,0x01,0x01,
+				0x91,0x01,0x01,
+				0xDB,0x10,0x84,0x9C,0xE6,0xE4,0x3C,0xBA,0xF9,0xE2,0x41,0x56,0x7A,0x99,0xC1,0x39,0xA0,0x6D,
+				0xDF,0x08,0x07,0x14,0xDC,0x33,0xC0,0xDE,0x45,0xA4,
+			// cw: 49 4F 2F C7 8E 96 7E A2 3E 69 C4 6B 56 1A 84 F4
+			},
+			//	0x0D95
+			{
+				0x81,0x70,0xB5,0x81,0xFF,0x00,0x00,0xB0,
+				0x80,0x9D,0x00,0x29,0x30,0x06,0x80,0x30,0x52,0x90,0x8F,0xDE,0xB2,0x86,0x88,0xD2,0x9C,0x7B,
+						  0x04,0xC9,0x79,0x84,0x02,0x46,0x01,0x49,0xA1,0xD6,0x2E,0x3F,0x19,0xFC,0xC8,0x31,
+						  0xAA,0x6E,0x0D,0xEC,0x4E,0xA7,0x2B,0xD5,0xF8,0xD8,0xE3,0xBD,0xE4,0xE3,0xE2,0x6B,
+						  0x7C,0xFC,0x66,0x03,0x46,0xBD,0x00,0x2A,0x30,0x06,0x80,0x30,0xEA,0x1D,0xFC,0xD7,
+						  0x9D,0x12,0xA3,0x73,0x64,0xA9,0x95,0xE2,0x9B,0x3E,0x98,0xF5,0xFF,0x8C,0x8A,0x53,
+						  0x44,0x40,0xF8,0x48,0xE1,0x93,0xB7,0xDF,0x84,0xBB,0x6F,0x63,0x8D,0x29,0x4F,0x00,
+						  0xC7,0x3C,0x26,0x23,0x91,0x80,0x5A,0xEF,0xD6,0xB0,0x67,0xF7,0xFF,0xFF,0xFF,0xFF,
+						  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+						  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+						  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+				0x83,0x01,0x10,
+				0x84,0x02,0x00,0x00,
+				0xDF,0x08,0x20,0x8C,0x90,0x0E,0xDC,0x67,0xFD,0x30,
+			//	cw: 93 89 50 6C C9 11 4F 29 36 2A 49 A9 63 88 DF CA
+			},
+	};
+#endif	// #if 0
+
+
+#define CTW_ALGO_TYPE  		5
+#define CTW_DATA_START 		(CTW_ALGO_TYPE)
+#define CTW_NANO_LEN   		7
+#define CTW_NANO_START 		8
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+int
+XCRYPTOWORKS_Process(struct s_reader *reader, ECM_REQUEST *er, uint8_t *cw)
+{
+	uint16_t casysid;
+	uint8_t  *ECM_p;
+	uint8_t 	n85Raws 	[256];
+	uint8_t 	n85crpts [256];
+	uint8_t 	cwplain 	[0x10];
+	uint8_t 	systemkey[8];
+	uint8_t 	cDeskey	[22];
+	int keyNr = 0;
+	int provf = 0, prov85f;
+	int n83found = 0, n85found = 0, nDBfound = 0;
+	int cwAlgo;
+	int r29;
+	int i,j;
+
+	if (!er) return 0;
+	if (!reader) return 0;
+	casysid 	= er->caid;
+	ECM_p 	= er->ecm;
+	cwAlgo  	= ECM_p[CTW_ALGO_TYPE]; // 0x28 DT
+//	casysid 	= 0x0D05;
+//	ECM_p 	= TEST_CWS_ECMs[1];
+//	myprdump("ECM_p", ECM_p, SCT_LEN(ECM_p));
+	for (i=CTW_NANO_START; i<ECM_p[7];)
+	{
+		MYEMU_TRACE("xcryptoworks:NANO:%02X\n", ECM_p[i]);
+		switch (ECM_p[i])
+		{
+			case 0x83:
+				provf = ECM_p[i+2]&0xFC;
+				keyNr = ECM_p[i+2]&3;
+				n83found = i;
+				break;
+
+			case 0x84:
+				if (n83found) break;
+				provf = ECM_p[i+2]&0xFC;
+				keyNr = ECM_p[i+2]&3;
+				break;
+
+			case 0x85:
+				memset(n85Raws, 0x00, sizeof(n85Raws));
+				memcpy(n85Raws, &ECM_p[i], ECM_p[i+1]+2);
+				n85found = i;
+				MYEMU_TRACE("xcryptoworks:nano85 found\n");
+				break;
+
+			case 0xDB:
+				memcpy (cwplain,&ECM_p[i+2], 0x10);
+				nDBfound = i;
+				MYEMU_TRACE("xcryptoworks:nanoDB found\n");
+				break;
+
+			default:
+				break;
+		}
+		i = i + ECM_p[i+1] + 2;
+	}
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	if (n85found)
+	{
+		if (!xcryptoworks_FindRsakey(reader, casysid, provf)) return 0;
+	}
+	// select suitable systemkey
+	if (!xcryptoworks_FindSystemkey(reader, casysid, provf, systemkey)) return 0;	// prov id not found
+	// select suitable provider
+	if (!xcryptoworks_FindDeskey(reader, casysid, provf, keyNr, cDeskey)) return 0;
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	if (n85found)
+	{
+//		MYEMU_TRACE("xcryptoworks:NANO 85 Provider ID: %04X:%02X,%02X\n", casysid, prov85f, cwAlgo));
+		prov85f = provf;
+		memcpy(cDeskey+0x10, systemkey, 6);
+		if (!xcryptoworks_n85Decrypt(reader,
+					n85Raws,
+					cDeskey,
+					cwAlgo,
+					casysid,
+					prov85f,
+					n85crpts))
+		{
+			MYEMU_TRACE("xcryptoworks:nano85 decrypt fails.\n");
+			return 0;
+		}
+//		myprdump("n85crpts", n85crpts, n85Raws[1]-8);
+		n83found = 0;
+		for (i=0; i<n85Raws[1]-8; )
+		{
+			switch (n85crpts[i])
+			{
+				case 0x83:
+					prov85f = n85crpts[i+2] & 0xFC;
+					keyNr   = n85crpts[i+2] & 3;
+					n83found= 1;
+					break;
+
+				case 0x84:
+					if (n83found) break;
+					prov85f = n85crpts[i+2] & 0xFC;
+					keyNr   = n85crpts[i+2] & 3;
+					break;
+
+				case 0x85:
+					break;
+
+				case 0xDB:
+					memcpy (cwplain, &n85crpts[i+2], 0x10);
+					nDBfound = 1;
+					break;
+				default:
+					break;
+			}
+			i = i + n85crpts[i+1]+2;
+		}
+		if (provf != prov85f)
+		{
+			MYEMU_TRACE("xcryptoworks:provf(%02X)!=prov85f(%02X)\n", provf, prov85f);
+			if (!xcryptoworks_FindSystemkey(reader, casysid, provf, systemkey)) return 0;	// prov id not found
+		}
+	}
+
+	if (!nDBfound)
+	{
+		MYEMU_TRACE("xcryptoworks:nanoDB not found.\n");
+		return 0;
+	}
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	memcpy(cDeskey + 0x10, systemkey, 6);
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	// decrypt CW
+	for (i=0; i<2; i++)
+	{
+		r29 = 0;
+		if ((ECM_p[0x5]&7)==7)
+		{
+			for (j=0;j<3;i++)
+			{
+				r29^=1;
+				xcryptoworks_DesAlgo(cwplain+(8*i),cDeskey,cwAlgo,r29|2);
+			}
+		}
+		else
+		{
+			xcryptoworks_DesAlgo(cwplain+(8*i),cDeskey,cwAlgo,0);//normal DecryptCW
+		}
+	}
+
+	memcpy(cw, &cwplain[0], 8);
+	memcpy(cw+8, &cwplain[8], 8);
+	MYEMU_TRACE("xcryptoworks:cw{%02X...%02X,%02X...%02X}\n", cw[0], cw[7], cw[8], cw[15]);
+	return 1;
+}
+
+
+void
+XCRYPTOWORKS_Cleanup(void)
+{
+	MYEMU_TRACE("xcryptoworks:clean\n");
+	er_KFOUND = 0;
+	er_KNR 	 = 0;
+	er_KPPID	 = 0x0;
+	memset(er_KKEY, 0x0, 16);
+	memset(er_KSYSKEY, 0x0, 6);
+}
+#endif	// defined(__XCAS_CRYPTOWORKS__)
+#endif	// defined(MODULE_XCAS)
+
Index: emu-xpowervu.c
===================================================================
--- emu-xpowervu.c	(nonexistent)
+++ emu-xpowervu.c	(working copy)
@@ -0,0 +1,687 @@
+#include "globals.h"
+#if defined(MODULE_XCAS)
+#include "oscam-client.h"
+#include "oscam-ecm.h"
+#include "oscam-net.h"
+#include "oscam-chk.h"
+#include "oscam-string.h"
+#include "cscrypt/bn.h"
+#include "module-dvbapi.h"
+#include "module-xcas.h"
+/* sky(2016.03.07) */
+#if defined(__XCAS_POWERVU__)
+//	#define	WITH_EMU
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+struct xpowervu_keydata
+{
+	int16_t	found;
+	uint32_t	ppid;
+	uint8_t	knr;
+	uint8_t	keys[16];
+	int16_t	failure;
+};
+struct xpowervu_keydata g_xpowervu[MAX_DEMUX];
+
+static const uint8_t PowerVu_A0_S_1[16] = {0x33, 0xA4, 0x44, 0x3C, 0xCA, 0x2E, 0x75, 0x7B, 0xBC, 0xE6, 0xE5, 0x35, 0xA0, 0x55, 0xC9, 0xA2};
+static const uint8_t PowerVu_A0_S_2[16] = {0x5A, 0xB0, 0x2C, 0xBC, 0xDA, 0x32, 0xE6, 0x92, 0x40, 0x53, 0x6E, 0xF9, 0x69, 0x11, 0x1E, 0xFB};
+static const uint8_t PowerVu_A0_S_3[16] = {0x4E, 0x18, 0x9B, 0x19, 0x79, 0xFB, 0x01, 0xFA, 0xE3, 0xE1, 0x28, 0x3D, 0x32, 0xE4, 0x92, 0xEA};
+static const uint8_t PowerVu_A0_S_4[16] = {0x05, 0x6F, 0x37, 0x66, 0x35, 0xE1, 0x58, 0xD0, 0xB4, 0x6A, 0x97, 0xAE, 0xD8, 0x91, 0x27, 0x56};
+static const uint8_t PowerVu_A0_S_5[16] = {0x7B, 0x26, 0xAD, 0x34, 0x3D, 0x77, 0x39, 0x51, 0xE0, 0xE0, 0x48, 0x8C, 0x39, 0xF5, 0xE8, 0x47};
+static const uint8_t PowerVu_A0_S_6[16] = {0x74, 0xFA, 0x4D, 0x79, 0x42, 0x39, 0xD1, 0xA4, 0x99, 0xA3, 0x97, 0x07, 0xDF, 0x14, 0x3A, 0xC4};
+static const uint8_t PowerVu_A0_S_7[16] = {0xC6, 0x1E, 0x3C, 0x24, 0x11, 0x08, 0x5D, 0x6A, 0xEB, 0x97, 0xB9, 0x25, 0xA7, 0xFA, 0xE9, 0x1A};
+static const uint8_t PowerVu_A0_S_8[16] = {0x9A, 0xAD, 0x72, 0xD7, 0x7C, 0x68, 0x3B, 0x55, 0x1D, 0x4A, 0xA2, 0xB0, 0x38, 0xB9, 0x56, 0xD0};
+static const uint8_t PowerVu_A0_S_9[32] = {0x61, 0xDA, 0x5F, 0xB7, 0xEB, 0xC6, 0x3F, 0x6C, 0x09, 0xF3, 0x64, 0x38, 0x33, 0x08, 0xAA, 0x15,
+													    0xCC, 0xEF, 0x22, 0x64, 0x01, 0x2C, 0x12, 0xDE, 0xF4, 0x6E, 0x3C, 0xCD, 0x1A, 0x64, 0x63, 0x7C
+													  	};
+
+static const uint8_t PowerVu_00_S_1[16] = {0x97, 0x13, 0xEB, 0x6B, 0x04, 0x5E, 0x60, 0x3A, 0xD9, 0xCC, 0x91, 0xC2, 0x5A, 0xFD, 0xBA, 0x0C};
+static const uint8_t PowerVu_00_S_2[16] = {0x61, 0x3C, 0x03, 0xB0, 0xB5, 0x6F, 0xF8, 0x01, 0xED, 0xE0, 0xE5, 0xF3, 0x78, 0x0F, 0x0A, 0x73};
+static const uint8_t PowerVu_00_S_3[16] = {0xFD, 0xDF, 0xD2, 0x97, 0x06, 0x14, 0x91, 0xB5, 0x36, 0xAD, 0xBC, 0xE1, 0xB3, 0x00, 0x66, 0x41};
+static const uint8_t PowerVu_00_S_4[16] = {0x8B, 0xD9, 0x18, 0x0A, 0xED, 0xEE, 0x61, 0x34, 0x1A, 0x79, 0x80, 0x8C, 0x1E, 0x7F, 0xC5, 0x9F};
+static const uint8_t PowerVu_00_S_5[16] = {0xB0, 0xA1, 0xF2, 0xB8, 0xEA, 0x72, 0xDD, 0xD3, 0x30, 0x65, 0x2B, 0x1E, 0xE9, 0xE1, 0x45, 0x29};
+static const uint8_t PowerVu_00_S_6[16] = {0x5D, 0xCA, 0x53, 0x75, 0xB2, 0x24, 0xCE, 0xAF, 0x21, 0x54, 0x9E, 0xBE, 0x02, 0xA9, 0x4C, 0x5D};
+static const uint8_t PowerVu_00_S_7[16] = {0x42, 0x66, 0x72, 0x83, 0x1B, 0x2D, 0x22, 0xC9, 0xF8, 0x4D, 0xBA, 0xCD, 0xBB, 0x20, 0xBD, 0x6B};
+static const uint8_t PowerVu_00_S_8[16] = {0xC4, 0x0C, 0x6B, 0xD3, 0x6D, 0x94, 0x7E, 0x53, 0xCE, 0x96, 0xAC, 0x40, 0x2C, 0x7A, 0xD3, 0xA9};
+static const uint8_t PowerVu_00_S_9[32] = {0x31, 0x82, 0x4F, 0x9B, 0xCB, 0x6F, 0x9D, 0xB7, 0xAE, 0x68, 0x0B, 0xA0, 0x93, 0x15, 0x32, 0xE2,
+													    0xED, 0xE9, 0x47, 0x29, 0xC2, 0xA8, 0x92, 0xEF, 0xBA, 0x27, 0x22, 0x57, 0x76, 0x54, 0xC0, 0x59,
+													  	};
+
+
+static uint8_t _get_bit(uint8_t byte, uint8_t bitnb)
+{
+	return ((byte&(1<<bitnb)) ? 1: 0);
+}
+
+static uint8_t _set_bit(uint8_t val, uint8_t bitnb, uint8_t biton)
+{
+	return (biton ? (val | (1<<bitnb)) : (val & ~(1<<bitnb)));
+}
+
+static void xpowervu_expandDesKey(unsigned char *key)
+{
+	uint8_t i, j, parity;
+	uint8_t tmpKey[7];
+
+	memcpy(tmpKey, key, 7);
+
+	key[0] = (tmpKey[0] & 0xFE);
+	key[1] = ((tmpKey[0] << 7) | ((tmpKey[1] >> 1) & 0xFE));
+	key[2] = ((tmpKey[1] << 6) | ((tmpKey[2] >> 2) & 0xFE));
+	key[3] = ((tmpKey[2] << 5) | ((tmpKey[3] >> 3) & 0xFE));
+	key[4] = ((tmpKey[3] << 4) | ((tmpKey[4] >> 4) & 0xFE));
+	key[5] = ((tmpKey[4] << 3) | ((tmpKey[5] >> 5) & 0xFE));
+	key[6] = ((tmpKey[5] << 2) | ((tmpKey[6] >> 6) & 0xFE));
+	key[7] = (tmpKey[6] << 1);
+
+	for (i = 0; i < 8; i++)
+	{
+		parity = 1;
+		for (j = 1; j < 8; j++) if ((key[i] >> j) & 0x1) { parity = ~parity & 0x01; }
+		key[i] |= parity;
+	}
+}
+
+static uint8_t xpowervu_sbox(uint8_t *input, uint8_t mode)
+{
+	uint8_t s_index, bit, last_index, last_bit;
+	uint8_t const *Sbox1, *Sbox2, *Sbox3, *Sbox4, *Sbox5, *Sbox6, *Sbox7, *Sbox8, *Sbox9;
+
+	if (mode)
+	{
+		Sbox1 = PowerVu_A0_S_1;
+		Sbox2 = PowerVu_A0_S_2;
+		Sbox3 = PowerVu_A0_S_3;
+		Sbox4 = PowerVu_A0_S_4;
+		Sbox5 = PowerVu_A0_S_5;
+		Sbox6 = PowerVu_A0_S_6;
+		Sbox7 = PowerVu_A0_S_7;
+		Sbox8 = PowerVu_A0_S_8;
+		Sbox9 = PowerVu_A0_S_9;
+	}
+	else
+	{
+		Sbox1 = PowerVu_00_S_1;
+		Sbox2 = PowerVu_00_S_2;
+		Sbox3 = PowerVu_00_S_3;
+		Sbox4 = PowerVu_00_S_4;
+		Sbox5 = PowerVu_00_S_5;
+		Sbox6 = PowerVu_00_S_6;
+		Sbox7 = PowerVu_00_S_7;
+		Sbox8 = PowerVu_00_S_8;
+		Sbox9 = PowerVu_00_S_9;
+	}
+
+	bit = (_get_bit(input[2],0)<<2) | (_get_bit(input[3],4)<<1) | (_get_bit(input[5],3));
+	s_index = (_get_bit(input[0],0)<<3) | (_get_bit(input[2],6)<<2) | (_get_bit(input[2],4)<<1) | (_get_bit(input[5],7));
+	last_bit = _get_bit(Sbox1[s_index],7-bit);
+
+	bit = (_get_bit(input[5],0)<<2) | (_get_bit(input[4],0)<<1) | (_get_bit(input[6],2));
+	s_index = (_get_bit(input[2],1)<<3) | (_get_bit(input[2],2)<<2) | (_get_bit(input[5],5)<<1) | (_get_bit(input[5],1));
+	last_bit = last_bit | (_get_bit(Sbox2[s_index],7-bit)<<1);
+
+	bit = (_get_bit(input[6],0)<<2) | (_get_bit(input[1],7)<<1) | (_get_bit(input[6],7));
+	s_index = (_get_bit(input[1],3)<<3) | (_get_bit(input[3],7)<<2) | (_get_bit(input[1],5)<<1) | (_get_bit(input[5],2));
+	last_bit = last_bit | (_get_bit(Sbox3[s_index], 7-bit)<<2);
+
+	bit = (_get_bit(input[1],0)<<2) | (_get_bit(input[2],7)<<1) | (_get_bit(input[2],5));
+	s_index = (_get_bit(input[6],3)<<3) | (_get_bit(input[6],4)<<2) | (_get_bit(input[6],6)<<1) | (_get_bit(input[3],5));
+	last_index = _get_bit(Sbox4[s_index], 7-bit);
+
+	bit = (_get_bit(input[3],3)<<2) | (_get_bit(input[4],6)<<1) | (_get_bit(input[3],2));
+	s_index = (_get_bit(input[3],1)<<3) | (_get_bit(input[4],5)<<2) | (_get_bit(input[3],0)<<1) | (_get_bit(input[4],7));
+	last_index = last_index | (_get_bit(Sbox5[s_index], 7-bit)<<1);
+
+	bit = (_get_bit(input[5],4)<<2) | (_get_bit(input[4],4)<<1) | (_get_bit(input[1],2));
+	s_index = (_get_bit(input[2],3)<<3) | (_get_bit(input[6],5)<<2) | (_get_bit(input[1],4)<<1) | (_get_bit(input[4],1));
+	last_index = last_index | (_get_bit(Sbox6[s_index], 7-bit)<<2);
+
+	bit = (_get_bit(input[0],6)<<2) | (_get_bit(input[0],7)<<1) | (_get_bit(input[0],4));
+	s_index = (_get_bit(input[0],5)<<3) | (_get_bit(input[0],3)<<2) | (_get_bit(input[0],1)<<1) | (_get_bit(input[0],2));
+	last_index = last_index | (_get_bit(Sbox7[s_index], 7-bit)<<3);
+
+	bit = (_get_bit(input[4],2)<<2) | (_get_bit(input[4],3)<<1) | (_get_bit(input[1],1));
+	s_index = (_get_bit(input[1],6)<<3) | (_get_bit(input[6],1)<<2) | (_get_bit(input[5],6)<<1) | (_get_bit(input[3],6));
+	last_index = last_index | (_get_bit(Sbox8[s_index], 7-bit)<<4);
+
+	return (_get_bit(Sbox9[last_index&0x1f],7-last_bit)&1) ? 1: 0;
+}
+
+static void xpowervu_decrypt(uint8_t *data, uint32_t length, uint8_t *key, uint8_t sbox)
+{
+	uint32_t i;
+	int32_t j, k;
+	uint8_t curByte, tmpBit;
+
+	for(i=0; i<length; i++)
+	{
+		curByte = data[i];
+
+		for(j=7; j>=0; j--)
+		{
+			data[i] = _set_bit(data[i], j,(_get_bit(curByte,j)^xpowervu_sbox(key, sbox))^_get_bit(key[0],7));
+
+			tmpBit  = _get_bit(data[i],j)^(_get_bit(key[6],0));
+			if (tmpBit)
+			{
+				key[3] ^= 0x10;
+			}
+
+			for (k = 6; k > 0; k--)
+			{
+				key[k] = (key[k]>>1) | (key[k-1]<<7);
+			}
+			key[0] = (key[0]>>1);
+
+			key[0] = _set_bit(key[0], 7, tmpBit);
+		}
+	}
+}
+
+#define PVU_CW_VID 	0	// VIDeo
+#define PVU_CW_HSD 	1	// High Speed Data
+#define PVU_CW_A1 	2	// Audio 1
+#define PVU_CW_A2		3	// Audio 2
+#define PVU_CW_A3 	4	// Audio 3
+#define PVU_CW_A4 	5	// Audio 4
+#define PVU_CW_UTL 	6	// UTiLity
+#define PVU_CW_VBI 	7	// Vertical Blanking Interval
+
+#define PVU_CONVCW_VID_ECM	0x80	// VIDeo
+#define PVU_CONVCW_HSD_ECM 0x40 	// High Speed Data
+#define PVU_CONVCW_A1_ECM 	0x20	// Audio 1
+#define PVU_CONVCW_A2_ECM 	0x10	// Audio 2
+#define PVU_CONVCW_A3_ECM 	0x08	// Audio 3
+#define PVU_CONVCW_A4_ECM 	0x04	// Audio 4
+#define PVU_CONVCW_UTL_ECM 0x02	// UTiLity
+#define PVU_CONVCW_VBI_ECM 0x01	// Vertical Blanking Interval
+
+static uint8_t xpowervu_getConvcwIndex(uint8_t ecmTag)
+{
+	switch(ecmTag)
+	{
+	case PVU_CONVCW_VID_ECM: return PVU_CW_VID;
+	case PVU_CONVCW_HSD_ECM: return PVU_CW_HSD;
+	case PVU_CONVCW_A1_ECM:	 return PVU_CW_A1;
+	case PVU_CONVCW_A2_ECM:	 return PVU_CW_A2;
+	case PVU_CONVCW_A3_ECM:	 return PVU_CW_A3;
+	case PVU_CONVCW_A4_ECM:	 return PVU_CW_A4;
+	case PVU_CONVCW_UTL_ECM: return PVU_CW_UTL;
+	case PVU_CONVCW_VBI_ECM: return PVU_CW_VBI;
+	default:	return PVU_CW_VBI;
+	}
+}
+
+static uint16_t xpowervu_getetSeedIV(uint8_t seedType, uint8_t *ecm)
+{
+	switch(seedType)
+	{
+	case PVU_CW_VID: return ( (ecm[0x10] & 0x1F) <<3) | 0;
+	case PVU_CW_HSD: return ( (ecm[0x12] & 0x1F) <<3) | 2;
+	case PVU_CW_A1:  return ( (ecm[0x11] & 0x3F) <<3) | 1;
+	case PVU_CW_A2:  return ( (ecm[0x13] & 0x3F) <<3) | 1;
+	case PVU_CW_A3:  return ( (ecm[0x19] & 0x3F) <<3) | 1;
+	case PVU_CW_A4:  return ( (ecm[0x1A] & 0x3F) <<3) | 1;;
+	case PVU_CW_UTL: return ( (ecm[0x14] & 0x0F) <<3) | 4;
+	case PVU_CW_VBI: return (((ecm[0x15] & 0xF8) >>3)<<3) | 5;
+	default:
+		return 0;
+	}
+}
+
+static void xpowervu_expandSeed(uint8_t seedType, uint8_t *seed)
+{
+	uint8_t seedLength, i;
+
+	switch(seedType)
+	{
+	case PVU_CW_VID:
+	case PVU_CW_HSD: seedLength = 4; break;
+	case PVU_CW_A1:
+	case PVU_CW_A2:
+	case PVU_CW_A3:
+	case PVU_CW_A4:  seedLength = 3; break;
+	case PVU_CW_UTL:
+	case PVU_CW_VBI: seedLength = 2; break;
+	default:	return;
+	}
+
+	for(i=seedLength; i<7; i++)
+	{
+		seed[i] = seed[i%seedLength];
+	}
+}
+
+static void xpowervu_calculateSeed(uint8_t seedType, uint8_t *ecm, uint8_t *seedBase, uint8_t *key, uint8_t *seed, uint8_t sbox)
+{
+	uint16_t tmpSeed;
+
+	tmpSeed = xpowervu_getetSeedIV(seedType, ecm+23);
+	seed[0] = (tmpSeed>>2) & 0xFF;
+	seed[1] = ((tmpSeed&0x3)<<6) | (seedBase[0]>>2);
+	seed[2] = (seedBase[0]<<6) | (seedBase[1]>>2);
+	seed[3] = (seedBase[1]<<6) | (seedBase[2]>>2);
+	seed[4] = (seedBase[2]<<6) | (seedBase[3]>>2);
+	seed[5] = (seedBase[3]<<6);
+
+	xpowervu_decrypt(seed, 6, key, sbox);
+
+	seed[0] = (seed[1]<<2) | (seed[2]>>6);
+	seed[1] = (seed[2]<<2) | (seed[3]>>6);
+	seed[2] = (seed[3]<<2) | (seed[4]>>6);
+	seed[3] = (seed[4]<<2) | (seed[5]>>6);
+}
+
+static void xpowervu_calculateCw(uint8_t seedType, uint8_t *seed, uint8_t csaUsed,
+							   uint8_t *convolvedCw, uint8_t *cw, uint8_t *baseCw)
+{
+	int32_t k;
+
+	xpowervu_expandSeed(seedType, seed);
+
+	if (csaUsed)
+	{
+		for(k=0; k<7; k++)
+		{
+			seed[k] ^= baseCw[k];
+		}
+
+		cw[0] = seed[0] ^ convolvedCw[0];
+		cw[1] = seed[1] ^ convolvedCw[1];
+		cw[2] = seed[2] ^ convolvedCw[2];
+		cw[3] = seed[3] ^ convolvedCw[3];
+		cw[4] = seed[3] ^ convolvedCw[4];
+		cw[5] = seed[4] ^ convolvedCw[5];
+		cw[6] = seed[5] ^ convolvedCw[6];
+		cw[7] = seed[6] ^ convolvedCw[7];
+	}
+	else
+	{
+		for(k=0; k<7; k++)
+		{
+			cw[k] = seed[k] ^ baseCw[k];
+		}
+		xpowervu_expandDesKey(cw);
+	}
+}
+
+static int
+xpowervu_searchDeskey(struct s_reader *reader, uint32_t *psearchids, uint32_t searchnum, uint8_t keyNr, uint8_t *cDeskey, int *pfoundindex)
+{
+	int found;
+	found = XEMUKEY_PidsSearch(reader, CASS_POWERVU, psearchids, searchnum, keyNr, cDeskey, 7, pfoundindex);
+	if (found && cs_Iszero(cDeskey,7)) found = 0;
+	return found;
+}
+/*
+81 30 3D
+30 37
+20
+0E 00 00 00 00 74
+B0
+00
+52 C8 D8 0D 69 E9 4A AF AB EF 97 62 06 33
+00
+00 10
+00 00
+5C 9C DD 0D ED 2F 62 9A 61 02 41 B9 CC 74 30 14
+1F B4 FA 20 B1 3F 85 A4 78 11 49
+2F 59 5F 95
+*/
+static int
+xpowervu_ecmProcess(struct s_reader *rdr, ECM_REQUEST *er, uint8_t *cw, CWEXTENTION *cwEx)
+{
+	struct xpowervu_keydata *pxpowerpvu;
+	uint8_t *ecm = er->ecm;
+	uint16_t ecmLen = SCT_LEN(ecm);
+	uint32_t ecmCrc32;
+	uint8_t  nanoCmd, nanoChecksum, keyType, fixedKey, oddKey, bid, csaUsed;
+	uint16_t nanoLen;
+	uint32_t channelId, ecmSrvid, keyIndex;
+	uint32_t searchIds[5];
+	uint8_t  convolvedCw[8][8];
+	uint8_t  ecmKey[7], tmpEcmKey[7], seedBase[4], baseCw[7], seed[8][8], excw[8][8];
+	uint8_t  decrypt_ok;
+	uint8_t  ecmPart1[14], ecmPart2[27];
+	uint8_t  sbox;
+	uint8_t *dwp;
+	int 		dmuxid;
+	int      keyReference;
+	int 		i, j, k;
+
+	myascdump("powervu", ecm, ecmLen);
+	if (ecmLen < 7) return 0;
+
+	dmuxid = er->dmuxid % MAX_DEMUX;
+	pxpowerpvu = &g_xpowervu[dmuxid];
+	if ((ecm[0xb] > rdr->powervu_ecmnb[dmuxid]) ||
+		 ( rdr->powervu_ecmnb[dmuxid] == 255 && ecm[0xb] == 0) ||
+		 ((rdr->powervu_ecmnb[dmuxid] - ecm[0xb]) > 5))
+	{
+		rdr->powervu_ecmnb[dmuxid] = ecm[0xb];
+	}
+	else
+	{
+		myprintf("########## skip:%02x:%02x\n", ecm[0xb], rdr->powervu_ecmnb[dmuxid]);
+		return -1;
+	}
+	ecmCrc32 = b2i(4, ecm+ecmLen-4);
+	myprintf("crc:%04x:%04x\n", ecmCrc32, dvb_crc32(ecm, ecmLen-4));
+	if (dvb_crc32(ecm, ecmLen-4) != ecmCrc32) return 0;
+	ecmLen -= 4;
+
+	for(i=0; i<8; i++) {
+		memset(convolvedCw[i], 0, 8);
+	}
+
+	for(i=3; i+3<ecmLen; ) {
+		nanoLen = (((ecm[i] & 0x0f)<< 8) | ecm[i+1]);
+		i +=2;
+		if (nanoLen > 0)
+		{
+			nanoLen--;
+		}
+		nanoCmd = ecm[i++];
+		if (i+nanoLen > ecmLen) return 0;
+		myprintf("NANO:%02x\n", nanoCmd);
+		switch (nanoCmd) {
+			case 0x27:
+				if (nanoLen < 15) break;
+				nanoChecksum = 0;
+				for(j=4; j<15; j++)
+				{
+					nanoChecksum += ecm[i+j];
+				}
+
+				if (nanoChecksum != 0) break;
+				keyType = xpowervu_getConvcwIndex(ecm[i+4]);
+				memcpy(convolvedCw[keyType], &ecm[i+6], 8);
+				break;
+
+			default:	break;
+		}
+		i += nanoLen;
+	}
+	MYEMU_TRACE("xpowervu:muxer{%d,%d)\n", er->chSets.frequency, er->chSets.degree);
+	searchIds[1] = er->chSets.frequency | ((er->chSets.degree) << 16);
+	searchIds[2] = er->chSets.frequency | ((er->chSets.degree/10) << 16);
+
+	for(i=3; i+3<ecmLen; ) {
+		nanoLen = (((ecm[i] & 0x0f)<< 8) | ecm[i+1]);
+		i +=2;
+		if (nanoLen > 0)
+		{
+			nanoLen--;
+		}
+		nanoCmd = ecm[i++];
+		myprintf("nano:%02x\n", nanoCmd);
+		if (i+nanoLen > ecmLen) return 0;
+
+		switch (nanoCmd) {
+			case 0x20:
+				if (nanoLen < 54) break;
+				csaUsed   =  _get_bit(ecm[i+7], 7);
+				fixedKey  = !_get_bit(ecm[i+6], 5);
+				oddKey    =  _get_bit(ecm[i+6], 4);
+				bid       = (_get_bit(ecm[i+7], 1)<<1) | _get_bit(ecm[i+7], 0);
+				sbox      =  _get_bit(ecm[i+6], 3);
+
+				keyIndex  = (fixedKey<<3) | (bid<<2) | oddKey;
+				channelId = b2i(2, ecm+i+23);
+				ecmSrvid  = (channelId >> 4) | ((channelId & 0xF) << 12);
+				searchIds[0] = channelId;
+				searchIds[3] = (er->chSets.frequency << 16) | channelId;
+
+
+				memcpy(ecmPart1, ecm+i+ 8, 14);
+				memcpy(ecmPart2, ecm+i+27, 27);
+				myprintf("ecm:chid:%04x, e6:%02x,%02x, cp:%02x,%02x \n", channelId, ecm[i+6], ecm[i+7], ecm[i+8], ecm[i+27]);
+
+				decrypt_ok = 0;
+				keyReference = -1;
+				do
+				{
+
+					if (pxpowerpvu->found && pxpowerpvu->ppid == channelId && pxpowerpvu->knr == keyIndex)
+					{
+						memcpy(ecmKey, pxpowerpvu->keys, 7);
+						MYEMU_TRACE("powervu:key:%06X:%02X..%02X(%2X)\n",
+								pxpowerpvu->ppid, pxpowerpvu->keys[0], pxpowerpvu->keys[6], pxpowerpvu->knr);
+					}
+					else
+					{
+						if (!xpowervu_searchDeskey(rdr, searchIds, 4, keyIndex, ecmKey, &keyReference))
+						{
+							mycs_log("[Emu] Key not found: P %04X 0%X(%d)", ecmSrvid, keyIndex, keyReference);
+							pxpowerpvu->found = 0;
+							return -2;
+						}
+						memcpy(pxpowerpvu->keys, ecmKey, 7);
+						MYEMU_TRACE("powervu:key found{%d}\n", keyReference);
+						MYEMU_TRACE("powervu:key:%06X.%06X:%2X:%02X..%02X\n", channelId, ecmSrvid, keyIndex, ecmKey[0], ecmKey[6]);
+					}
+					xpowervu_decrypt(ecm+i+8, 14, ecmKey, sbox);
+					if ((ecm[i+6] != ecm[i+6+7]) || (ecm[i+6+8] != ecm[i+6+15]))
+					{
+						memcpy(ecm+i+8, ecmPart1, 14);
+						keyReference++;
+						continue;
+					}
+
+					memcpy(tmpEcmKey, ecmKey, 7);
+
+					xpowervu_decrypt(ecm+i+27, 27, ecmKey, sbox);
+					if ((ecm[i+23] != ecm[i+23+29]) || (ecm[i+23+1] != ecm[i+23+30]))
+					{
+						memcpy(ecm+i+ 8, ecmPart1, 14);
+						memcpy(ecm+i+27, ecmPart2, 27);
+						keyReference++;
+						continue;
+					}
+
+					decrypt_ok = 1;
+					pxpowerpvu->knr = keyIndex;
+					pxpowerpvu->ppid = channelId;
+					pxpowerpvu->found = 1;
+				}
+				while(!decrypt_ok);
+
+				memcpy(seedBase, ecm+i+6+2, 4);
+
+				// Calculate only video seed
+				//	memcpy(ecmKey, tmpEcmKey, 7);
+				//	xpowervu_calculateSeed(PVU_CW_VID, ecm+i, seedBase, ecmKey, seed[PVU_CW_VID], sbox);
+				for(j=0; j<8; j++)
+				{
+					memcpy(ecmKey, tmpEcmKey, 7);
+					xpowervu_calculateSeed(j, ecm+i, seedBase, ecmKey, seed[j], sbox);
+				}
+
+				memcpy(baseCw, ecm+i+6+8, 7);
+
+				// Calculate all cws
+				for(j=0; j<8; j++)
+				{
+					xpowervu_calculateCw(j,  seed[j], csaUsed, convolvedCw[j], excw[j], baseCw);
+					if (csaUsed)
+					{
+						for(k = 0; k < 8; k += 4) {
+							excw[j][k + 3] = ((excw[j][k] + excw[j][k + 1] + excw[j][k + 2]) & 0xff);
+						}
+					}
+				}
+
+				if (cwEx != NULL)
+				{
+					cwEx->type = CW_MULTIPLE;
+					if (csaUsed)
+					{
+						cwEx->algo = CA_ALGO_DVBCSA;
+						cwEx->cipher = CA_MODE_ECB;
+					}
+					else
+					{
+						cwEx->algo = CA_ALGO_DES;
+						cwEx->cipher = CA_MODE_ECB;
+					}
+
+					for(j=0; j<4; j++)
+					{
+						dwp = cwEx->audio[j];
+						memset(dwp, 0, 16);
+						if (ecm[0] == 0x80)
+						{
+							memcpy(dwp, excw[PVU_CW_A1+j], 8);
+							if (csaUsed)
+							{
+								for(k = 0; k < 8; k += 4)
+								{
+									dwp[k + 3] = ((dwp[k] + dwp[k + 1] + dwp[k + 2]) & 0xff);
+								}
+							}
+						}
+						else
+						{
+							memcpy(&dwp[8], excw[PVU_CW_A1+j], 8);
+							if (csaUsed)
+							{
+								for(k = 8; k < 16; k += 4)
+								{
+									dwp[k + 3] = ((dwp[k] + dwp[k + 1] + dwp[k + 2]) & 0xff);
+								}
+							}
+						}
+					}
+
+					dwp = cwEx->data;
+					memset(dwp, 0, 16);
+					if (ecm[0] == 0x80)
+					{
+						memcpy(dwp, excw[PVU_CW_HSD], 8);
+						if (csaUsed)
+						{
+							for(k = 0; k < 8; k += 4)
+							{
+								dwp[k + 3] = ((dwp[k] + dwp[k + 1] + dwp[k + 2]) & 0xff);
+							}
+						}
+					}
+					else
+					{
+						memcpy(&dwp[8], excw[PVU_CW_HSD], 8);
+						if (csaUsed)
+						{
+							for(k = 8; k < 16; k += 4)
+							{
+								dwp[k + 3] = ((dwp[k] + dwp[k + 1] + dwp[k + 2]) & 0xff);
+							}
+						}
+					}
+
+					dwp = cwEx->vbi;
+					memset(dwp, 0, 16);
+					if (ecm[0] == 0x80)
+					{
+						memcpy(dwp, excw[PVU_CW_VBI], 8);
+						if (csaUsed)
+						{
+							for(k = 0; k < 8; k += 4)
+							{
+								dwp[k + 3] = ((dwp[k] + dwp[k + 1] + dwp[k + 2]) & 0xff);
+							}
+						}
+					}
+					else
+					{
+						memcpy(&dwp[8], excw[PVU_CW_VBI], 8);
+						if (csaUsed)
+						{
+							for(k = 8; k < 16; k += 4)
+							{
+								dwp[k + 3] = ((dwp[k] + dwp[k + 1] + dwp[k + 2]) & 0xff);
+							}
+						}
+					}
+				}
+
+				memset(cw, 0, 16);
+				if (ecm[0] == 0x80)
+				{
+					memcpy(cw, excw[PVU_CW_VID], 8);
+					if (csaUsed)
+					{
+						for(k = 0; k < 8; k += 4)
+						{
+							cw[k + 3] = ((cw[k] + cw[k + 1] + cw[k + 2]) & 0xff);
+						}
+					}
+				}
+				else
+				{
+					memcpy(&cw[8], excw[PVU_CW_VID], 8);
+					if (csaUsed)
+					{
+						for(k = 8; k < 16; k += 4)
+						{
+							cw[k + 3] = ((cw[k] + cw[k + 1] + cw[k + 2]) & 0xff);
+						}
+					}
+				}
+				er->cwdesalgo = csaUsed ? 0 : 1;
+				return 1;
+
+			default:	break;
+		}
+		i += nanoLen;
+	}
+
+	return -1;
+}
+
+
+int
+XPVU_Process(struct s_reader *reader, ECM_REQUEST *er, uint8_t *cw, CWEXTENTION *cwEx)
+{
+	int dmuxid;
+	int cwfound;
+
+	if (!er) return 0;
+	if (!reader) return 0;
+	if (!IS_POWERVU(er->caid)) return 0;
+	dmuxid = er->dmuxid % MAX_DEMUX;
+	cwfound = xpowervu_ecmProcess(reader, er, cw, cwEx);
+	if (cwfound == 1)
+	{
+		g_xpowervu[dmuxid].failure = 0;
+		MYEMU_TRACE("xpowervu:cw{%d}{%02X...%02X,%02X...%02X}(%d)\n", dmuxid, cw[0], cw[7], cw[8], cw[15], er->cwdesalgo);
+		return 1;
+	}
+	if (cwfound < 0)
+	{
+		MYEMU_TRACE("xpowervu:cwfailure{%d}\n", g_xpowervu[dmuxid].failure);
+		if (++g_xpowervu[dmuxid].failure < 3) return -1;
+	}
+	g_xpowervu[dmuxid].found = 0;
+	g_xpowervu[dmuxid].failure = 0;
+	return 0;
+}
+
+
+int
+XPVU_EmmProcess(struct s_reader *rdr, unsigned char *emm, int emmLen)
+{
+	return 1;
+}
+
+
+void
+XPVU_Cleanup(struct s_reader *rdr)
+{
+	MYEMU_TRACE("xpowervu:clean\n");
+	memset(rdr->powervu_ecmnb,0,sizeof(rdr->powervu_ecmnb));
+	memset(&g_xpowervu,0,sizeof(g_xpowervu));
+}
+#endif	// defined(__XCAS_POWERVU__)
+#endif	// defined(MODULE_XCAS)
+
Index: emu-xseka.c
===================================================================
--- emu-xseka.c	(nonexistent)
+++ emu-xseka.c	(working copy)
@@ -0,0 +1,2781 @@
+#include "globals.h"
+#if defined(MODULE_XCAS)
+#include "oscam-client.h"
+#include "oscam-ecm.h"
+#include "oscam-net.h"
+#include "oscam-chk.h"
+#include "oscam-string.h"
+#include "cscrypt/bn.h"
+#include "cscrypt/sha1.h"
+#include "cscrypt/des.h"
+#include "module-xcas.h"
+#if defined(__XCAS_SEKA__)
+//
+//
+//	5101, 5102, 5105, 5109	<-- HACK
+//	5103, 5104, 5106, 5107, 5108, 510A
+enum
+{
+	#ifdef _DPLUS_SUPPORT_
+		SEKAII_PR_64,
+		SEKAII_PR_67,
+	#endif
+	#ifdef _CYFRA_SUPPORT_
+		SEKAII_PR_65,
+	#endif
+	#ifdef _CANAL_NL_SUPPORT_
+		SEKAII_PR_6A,
+	#endif
+	#ifdef _SKYITALIA_SUPPORT_
+		SEKAII_PR_70,
+		SEKAII_PR_71,
+		SEKAII_PR_72,
+	#endif
+	SEKAII_PR_NULL,
+	MAX_SEKAII_PRS
+};
+enum
+{
+	#ifdef _DPLUS_SUPPORT_
+		SEKAII_ISSUER_DPLUS,
+	#endif
+	#ifdef _CYFRA_SUPPORT_
+		SEKAII_ISSUER_CYFRA,
+	#endif
+	#ifdef _CANAL_NL_SUPPORT_
+		SEKAII_ISSUER_CANALPLUS,
+	#endif
+	#ifdef _SKYITALIA_SUPPORT_
+		SEKAII_ISSUER_SKYITALIA,
+	#endif
+	SEKAII_ISSUER_NULL,
+	MAX_SEKAII_ISSUERS
+};
+
+
+
+typedef struct
+{
+	uint8_t tid;
+	uint8_t sctlen1;
+	uint8_t sctlen2;
+	uint8_t id[2];
+	uint8_t unknown;
+	uint8_t sm;
+	uint8_t keynr;
+} SEKA_ECM;
+typedef	SEKA_ECM	SEKA_SECTION;
+/*
+84 0063
+00 70 -- 3..4 ident
+0A 2C B9 -- 5..7 shared address
+00 --  8 keyselect
+B1 --  9 P2
+10 -- 10 P3
+03 -- 11 P4
+1808AC2E1C5F488F8951575DB58C99E659D10175EF3859AA73C93A385246D8E4455C25BEE42C006CF
+88CE4507157D323ACCA0FA445BE4C2134B53DF55BB8AE07AEE75644F0C4D735A83319BE0C8DCD66DB
+0C431D235B4F884D18
+*/
+typedef struct
+{
+	uint8_t tid;
+	uint8_t sctlen1;
+	uint8_t sctlen2;
+	uint8_t id[2];
+	uint8_t sa[3];
+	uint8_t sm;
+	uint8_t keynr;
+} SEKA_EMM_S;
+/*
+82 006B
+00 00 -- 3..4 always 0000
+09 90 3F 65 -- 5..8 UA
+00 64 -- 9..A Provi id
+00	  -- 0xB keyselect
+B0	  -- 0xC P2
+10	  -- 0xD P3
+01	  -- 0xE P4
+--- 0xF - encrypted data ---
+5F1444083352D555F14D3B302481FBFDB446CA17C27B4DE12F5E116FB2A25AA8947AC5D963AF
+F90BA59E14CD558EDEDF585E476A486BF362D7D63EBE6A43013CB43F6E6B44065904F9E57B38
+3C047FD0CE8C60FBCC703D0D26B83803739855
+*/
+typedef struct
+{
+	uint8_t tid;
+	uint8_t sctlen1;
+	uint8_t sctlen2;
+	uint8_t ua[6];
+	uint8_t id[2];
+	uint8_t sm;
+	uint8_t keynr;
+} SEKA_EMM_U;
+
+#define _seka_tid_(x) 	(((SEKA_SECTION *)(x))->tid)
+#define _seka_sa_(x)  	(((SEKA_EMM_S *)(x))->sa)
+#define _seka_sid_(x) 	(((SEKA_EMM_S *)(x))->id)
+#define _seka_ua_(x)  	(((SEKA_EMM_U *)(x))->ua)
+#define _seka_uid_(x) 	(((SEKA_EMM_U *)(x))->id)
+
+#define _seka_sn8_(b) 		(((b&0xf0)>>4)+((b&0xf)<<4))
+#define _seka_w16_(buffer,idx,mask) (((buffer[(idx)]<<8) + buffer[(idx)+1]) & mask)
+#define _seka_rl16_(s,t) 	(((s)<<(t)) | (((s)&0xFFFF)>>(16-(t))))
+#define _seka_rr16_(s,t) 	((((s)&0xFFFF)>>(t)) | ((s)<<(16-(t))))
+
+#define	MAX_SEKA_PROV		4
+typedef struct
+{
+	uint8_t 	ident	 [MAX_SEKA_PROV];
+	uint8_t 	ecmMods[3][90];	// 0x10E
+	uint8_t 	ecmExps[3][6]; 	// 0x12
+	uint8_t 	emmMods[3][90];	// 0x10E
+	uint8_t 	emmExps[3][6]; 	// 0x12
+} SEKAII_PROVI;
+
+typedef struct
+{
+	uint16_t ident	[MAX_SEKA_PROV];
+	uint8_t 	shapad;
+	uint8_t 	shaend;
+
+	uint8_t 	*t19x;
+	uint8_t 	*t1Bx;
+	uint8_t 	*t1Fx;
+
+	uint8_t 	*t29x;
+	uint8_t 	*t2Bx;
+	uint8_t 	*t2Fx;
+
+	uint8_t 	*masktab;
+
+	uint8_t	*xt;
+	uint8_t	*pt;
+} SEKAII_ISSUER;
+
+//
+//
+//
+	#define	_SEKA2NEW70_MASKTABLE_
+//
+//
+//
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static uint8_t 	seka_TD[4] 	 = { 1, 3, 0, 2 };
+static uint8_t 	seka_T1[256] =
+{
+	0x2a,0xe1,0x0b,0x13,0x3e,0x6e,0x32,0x48,
+	0xd3,0x31,0x08,0x8c,0x8f,0x95,0xbd,0xd0,
+	0xe4,0x6d,0x50,0x81,0x20,0x30,0xbb,0x75,
+	0xf5,0xd4,0x7c,0x87,0x2c,0x4e,0xe8,0xf4,
+	0xbe,0x24,0x9e,0x4d,0x80,0x37,0xd2,0x5f,
+	0xdb,0x04,0x7a,0x3f,0x14,0x72,0x67,0x2d,
+	0xcd,0x15,0xa6,0x4c,0x2e,0x3b,0x0c,0x41,
+	0x62,0xfa,0xee,0x83,0x1e,0xa2,0x01,0x0e,//8
+	0x7f,0x59,0xc9,0xb9,0xc4,0x9d,0x9b,0x1b,
+	0x9c,0xca,0xaf,0x3c,0x73,0x1a,0x65,0xb1,
+	0x76,0x84,0x39,0x98,0xe9,0x53,0x94,0xba,
+	0x1d,0x29,0xcf,0xb4,0x0d,0x05,0x7d,0xd1,
+	0xd7,0x0a,0xa0,0x5c,0x91,0x71,0x92,0x88,
+	0xab,0x93,0x11,0x8a,0xd6,0x5a,0x77,0xb5,
+	0xc3,0x19,0xc1,0xc7,0x8e,0xf9,0xec,0x35,
+	0x4b,0xcc,0xd9,0x4a,0x18,0x23,0x9f,0x52,//16
+	0xdd,0xe3,0xad,0x7b,0x47,0x97,0x60,0x10,
+	0x43,0xef,0x07,0xa5,0x49,0xc6,0xb3,0x55,
+	0x28,0x51,0x5d,0x64,0x66,0xfc,0x44,0x42,
+	0xbc,0x26,0x09,0x74,0x6f,0xf7,0x6b,0x4f,
+	0x2f,0xf0,0xea,0xb8,0xae,0xf3,0x63,0x6a,
+	0x56,0xb2,0x02,0xd8,0x34,0xa4,0x00,0xe6,
+	0x58,0xeb,0xa3,0x82,0x85,0x45,0xe0,0x89,
+	0x7e,0xfd,0xf2,0x3a,0x36,0x57,0xff,0x06,//24
+	0x69,0x54,0x79,0x9a,0xb6,0x6c,0xdc,0x8b,
+	0xa7,0x1f,0x90,0x03,0x17,0x1c,0xed,0xd5,
+	0xaa,0x5e,0xfe,0xda,0x78,0xb0,0xbf,0x12,
+	0xa8,0x22,0x21,0x3d,0xc2,0xc0,0xb7,0xa9,
+	0xe7,0x33,0xfb,0xf1,0x70,0xe5,0x17,0x96,
+	0xf8,0x8d,0x46,0xa1,0x86,0xe2,0x40,0x38,
+	0xf6,0x68,0x25,0x16,0xac,0x61,0x27,0xcb,
+	0x5b,0xc8,0x2b,0x0f,0x99,0xde,0xce,0xc5
+};//32 * 8 = 256
+
+static uint8_t 	seka_T2[256] =
+{
+	0xbf,0x11,0x6d,0xfa,0x26,0x7f,0xf3,0xc8,
+	0x9e,0xdd,0x3f,0x16,0x97,0xbd,0x08,0x80,
+	0x51,0x42,0x93,0x49,0x5b,0x64,0x9b,0x25,
+	0xf5,0x0f,0x24,0x34,0x44,0xb8,0xee,0x2e,
+	0xda,0x8f,0x31,0xcc,0xc0,0x5e,0x8a,0x61,
+	0xa1,0x63,0xc7,0xb2,0x58,0x09,0x4d,0x46,
+	0x81,0x82,0x68,0x4b,0xf6,0xbc,0x9d,0x03,
+	0xac,0x91,0xe8,0x3d,0x94,0x37,0xa0,0xbb, //8
+	0xce,0xeb,0x98,0xd8,0x38,0x56,0xe9,0x6b,
+	0x28,0xfd,0x84,0xc6,0xcd,0x5f,0x6e,0xb6,
+	0x32,0xf7,0x0e,0xf1,0xf8,0x54,0xc1,0x53,
+	0xf0,0xa7,0x95,0x7b,0x19,0x21,0x23,0x7d,
+	0xe1,0xa9,0x75,0x3e,0xd6,0xed,0x8e,0x6f,
+	0xdb,0xb7,0x07,0x41,0x05,0x77,0xb4,0x2d,
+	0x45,0xdf,0x29,0x22,0x43,0x89,0x83,0xfc,
+	0xd5,0xa4,0x88,0xd1,0xf4,0x55,0x4f,0x78,//16
+	0x62,0x1e,0x1d,0xb9,0xe0,0x2f,0x01,0x13,
+	0x15,0xe6,0x17,0x6a,0x8d,0x0c,0x96,0x7e,
+	0x86,0x27,0xa6,0x0d,0xb5,0x73,0x71,0xaa,
+	0x36,0xd0,0x06,0x66,0xdc,0xb1,0x2a,0x5a,
+	0x72,0xbe,0x3a,0xc5,0x40,0x65,0x1b,0x02,
+	0x10,0x9f,0x3b,0xf9,0x2b,0x18,0x5c,0xd7,
+	0x12,0x47,0xef,0x1a,0x87,0xd2,0xc2,0x8b,
+	0x99,0x9c,0xd3,0x57,0xe4,0x76,0x67,0xca,//24
+	0x3c,0xfb,0x90,0x20,0x14,0x48,0xc9,0x60,
+	0xb0,0x70,0x4e,0xa2,0xad,0x35,0xea,0xc4,
+	0x74,0xcb,0x39,0xde,0xe7,0xd4,0xa3,0xa5,
+	0x04,0x92,0x8c,0xd9,0x7c,0x1c,0x7a,0xa8,
+	0x52,0x79,0xf2,0x33,0xba,0x1f,0x30,0x9a,
+	0x00,0x50,0x4c,0xff,0xe5,0xcf,0x59,0xc3,
+	0xe3,0x0a,0x85,0xb3,0xae,0xec,0x0b,0xfe,
+	0xe2,0xab,0x4a,0xaf,0x69,0x6c,0x2c,0x5d
+};	// 32 * 8 = 256
+
+#ifdef _DPLUS_SUPPORT_
+	#include "./emu_seka2_xxhash.h"
+	#include "./emu_seka2_64hash.h"
+	#include "./emu_seka2_64mt.h"
+#endif
+
+#ifdef _CANAL_NL_SUPPORT_
+	#include "./emu_seka2_6a.h"
+	#include "./emu_seka2_6ahash.h"
+	#include "./emu_seka2_6amt.h"
+	#include "./emu_seka2_sse.h"
+#endif
+
+#ifdef _CYFRA_SUPPORT_
+	#include "./emu_seka2_65hash.h"
+	#include "./emu_seka2_65mt.h"
+#endif
+
+#ifdef _CANAL_FR_SUPPORT_
+	#include "./emu_seka2_80.h"
+	#include "./emu_seka2_80hash.h"
+	#include "./emu_seka2_80mt.h"
+	#include "./emu_seka2_81hash.h"
+	#include "./emu_seka2_81mt.h"
+	#include "./emu_seka2_sse.h"
+#endif
+
+#ifdef _SKYITALIA_SUPPORT_
+	#include "./emu_seka2_70hash.h"
+	#include "./emu_seka2_70mt.h"
+#endif
+
+//
+// uint8_t *T1, *T2;
+/* 8 seca2 Providers allowed*/
+static uint8_t 	seka2_provi_data[] =
+{
+	#ifdef _DPLUS_SUPPORT_
+		// -----------------------------
+		// ------------- 00 64 ---------
+		0x64,0,0,0,
+		/*ECM_MOD0*/	0x35,0x9A,0x3E,0xD5,0xF5,0x1B,0x03,0xB6,0x61,0x16,0xA8,0x32,0xFC,0x32,0xB0,0xC5,
+						0x2F,0xFA,0x1A,0x51,0xB4,0x5F,0xBF,0x0E,0x00,0x7A,0xBD,0x74,0x0E,0x9F,0x14,0x87,
+						0xAC,0xF1,0xA6,0x22,0xF0,0xF0,0x03,0x70,0x64,0x29,0xD4,0x72,0x4C,0x41,0x9E,0xBE,
+						0x3F,0x31,0x95,0xE0,0x2D,0x83,0xCF,0x44,0xF3,0x27,0xCA,0xCF,0x2A,0x76,0x77,0x00,
+						0x60,0x11,0x70,0x01,0xC9,0x66,0x05,0xFC,0x4C,0xA9,0xD3,0xD7,0x1F,0x45,0x96,0x3A,
+						0x7E,0xD3,0x90,0x76,0xF2,0x3A,0xCC,0xCD,0x14,0x9F,
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x25,0x43,0xE6,0x44,0xE3,0xA0,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0x21,0xAE,0xEB,0xA4,0xDE,0x9D,0x78,0x6B,0x0A,0x28,0xBB,0x8C,0x57,0xA5,0xAD,0xA6,
+						0xD3,0x54,0xEA,0x02,0x2F,0x64,0x86,0x18,0x46,0x42,0x55,0x62,0x00,0x4E,0xE4,0x43,
+						0x2C,0x8E,0xC1,0xA6,0x65,0xD4,0x3D,0x57,0x45,0xAB,0xB6,0x3A,0x93,0x76,0xF9,0x26,
+						0x54,0xA7,0xD1,0xEE,0xF1,0xD6,0x77,0x85,0x78,0x70,0x4E,0xB7,0x8B,0x0A,0xFF,0x9A,
+						0x8E,0xC3,0xA4,0x1A,0xC6,0x52,0xEC,0x86,0x51,0x99,0xE2,0x5F,0x04,0xF7,0x74,0x9B,
+						0xBD,0x79,0x87,0x97,0xAC,0xD9,0x58,0x3A,0x9F,0x96,
+		/*EMM_MOD1*/	0x01,0x0a,0x18,0xbe,0x44,0x34,0x80,0x8a,0x04,0x31,0x94,0x5e,0x6c,0xe8,0x60,0xe7,
+						0x48,0x38,0xbb,0x07,0xd4,0x19,0xa0,0xe6,0x14,0xab,0xbb,0x57,0x6b,0xb9,0x90,0x90,
+						0xb4,0xc4,0x24,0x58,0x50,0xb5,0xc5,0x01,0x40,0x24,0x35,0xc5,0x31,0x29,0x95,0xab,
+						0x7b,0x69,0xf6,0xce,0x27,0x27,0x59,0xb9,0x54,0xbd,0x8f,0xc4,0x9f,0xec,0xa3,0x40,
+						0x78,0xa6,0xff,0xe2,0x5b,0x7b,0xf6,0x79,0xa1,0xe5,0xef,0xc7,0x0e,0xda,0x59,0x7a,
+						0x18,0xa7,0x19,0xa2,0x27,0x44,0x47,0xf0,0x34,0xe6,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0x55,0x4A,0x2F,0x64,0x4C,0x9D,
+		/*EMM_EXP1*/	0x0b,0xc0,0x92,0x0e,0x82,0xc6,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		// -----------------------------
+		// ------------- 00 67 ---------
+		0x67, 0, 0, 0,
+		/*ECM_MOD0*/	0x33,0x3F,0x3B,0x48,0xFA,0x06,0x93,0x7F,0xA9,0x71,0x25,0x19,0x2D,0xA1,0x7F,0xDB,
+						0x80,0x17,0x4D,0xDA,0x07,0x08,0x85,0xA1,0x8B,0xA5,0x2B,0x92,0x9F,0x0B,0x38,0xE8,
+						0xD7,0xDB,0x7B,0x03,0xB8,0xC9,0xE1,0xCF,0x7C,0xFF,0x0B,0x9F,0x3D,0x2B,0x89,0xDD,
+						0x2A,0x6D,0x5A,0xDD,0x61,0xF8,0x10,0xB7,0xF1,0xC4,0xE2,0xDA,0xC3,0xD4,0xFA,0x1D,
+						0x57,0xAE,0x22,0x66,0xCD,0x32,0x35,0xD7,0x24,0xF5,0x3A,0x3D,0x6F,0x01,0x0A,0x13,
+						0x7A,0xDF,0x21,0x26,0xCA,0x28,0xC1,0x17,0x6F,0xB1,
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	    /*ECM_EXP0*/	0xB3,0x67,0xAF,0xA2,0x54,0xE5,
+	 	/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+	#endif
+
+	#ifdef _CYFRA_SUPPORT_
+		// -----------------------------
+		// ------------- 00 65 ---------
+		0x65, 0, 0, 0,
+		/*ECM_MOD0*/
+						0xD7,0x2B,0xF9,0x6B,0xED,0xEA,0xE1,0xFB,0x3F,0xC9,0x1A,0x60,0xF1,0x44,0x3B,0x02,
+						0x39,0xDC,0x8F,0xF5,0x0D,0xBA,0x0A,0xA8,0xB3,0xDA,0x56,0x91,0xC1,0xA1,0xF4,0x7E,
+						0x5A,0xD8,0x9F,0x4E,0xFD,0xD4,0xBE,0x42,0x1B,0x77,0x27,0x5D,0x7D,0x0E,0xC0,0xF7,
+						0x34,0xC3,0x2F,0x75,0x1C,0x3C,0x1E,0x25,0xFD,0xC3,0x03,0x41,0x08,0xC4,0xFF,0x6D,
+						0x23,0xDF,0x6F,0x19,0x90,0xAB,0x55,0x9E,0x86,0xB6,0xFB,0xCB,0x3D,0xE6,0x09,0xA6,
+						0xDC,0xD3,0x70,0x94,0x85,0xD5,0xB5,0xD2,0xA9,0x8F,
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	    /*ECM_EXP0*/	0xF3,0xF6,0xC4,0xDB,0x90,0xEE,
+	 	/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0x5D,0x10,0x34,0xB6,0x45,0x51,0x09,0x3A,0x5D,0xAD,0x9A,0x55,0x19,0xDF,0xB1,0x14,
+						0xA5,0x17,0xBD,0x42,0x0D,0x76,0x52,0x89,0x65,0x0A,0xC8,0xB4,0x51,0x02,0x3C,0xEB,
+						0x84,0xDF,0xD2,0x29,0x14,0x9F,0x95,0x02,0xDF,0xB5,0x5A,0x4A,0xD2,0xED,0xFC,0xBD,
+						0x20,0x31,0x34,0x8A,0x63,0x3A,0x2F,0x8C,0xB8,0x0D,0x51,0x09,0xBB,0x58,0xCD,0x08,
+						0x61,0x02,0xEF,0xAF,0x0B,0x01,0x31,0x32,0xB5,0x82,0x41,0x9D,0xC3,0xAE,0xDC,0xDB,
+						0x22,0x3F,0x8A,0xFE,0x4B,0xF4,0x63,0x7D,0x34,0xAE,
+		/*EMM_MOD1*/	0xB1,0x77,0x4F,0x16,0xAC,0x5E,0x20,0x67,0x38,0x48,0xFF,0x83,0x3B,0x33,0xA7,0xA5,
+						0x8F,0xC7,0xCC,0xEE,0xC1,0x89,0x1E,0xA4,0xB1,0x2A,0xFF,0x69,0xAC,0xFA,0x74,0x4C,
+						0xA0,0x50,0x16,0x06,0x7D,0x56,0x83,0xE4,0xE6,0x94,0x75,0x2C,0xA0,0x1D,0x6D,0x43,
+						0xC2,0x16,0xBD,0x1A,0x87,0x79,0xBD,0xF1,0x1D,0x02,0xB2,0x03,0x88,0x02,0x31,0x05,
+						0x93,0x1E,0xA4,0xAB,0x52,0xC5,0xDC,0x91,0xC2,0x92,0x20,0x86,0x79,0x38,0x4D,0xDE,
+						0xD4,0x53,0x70,0xB5,0x9B,0x2E,0x0D,0xD1,0x50,0x82,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0x8B,0xFE,0x61,0xBF,0x76,0xB3,
+		/*EMM_EXP1*/	0x49,0xFE,0xA1,0x15,0xE4,0xC9,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+	#endif
+
+	#ifdef _CANAL_NL_SUPPORT_
+		// -----------------------------
+		// ------------- 00 6A ---------
+		0x6A,0x6B,0x6C,0x6D,
+		/*ECM_MOD0*/	0xD7,0xE0,0x80,0xBD,0xEA,0xA9,0xA0,0xB6,0xE7,0xE8,0x15,0x77,0xDC,0x50,0xD5,0x05,
+						0x60,0x6E,0x24,0x39,0x84,0x01,0xE9,0x23,0x8E,0xD4,0xCC,0x5F,0x6A,0x9D,0xB8,0xCB,
+						0x48,0x5A,0xC0,0x89,0x25,0xC8,0x90,0x31,0x51,0x4A,0x55,0x61,0x8E,0xDD,0x04,0x3E,
+						0xA6,0x80,0xBD,0x32,0x26,0x1A,0x1C,0x06,0x61,0xC1,0x9D,0x20,0xEC,0x18,0x9C,0x47,
+						0x35,0xAB,0x52,0x49,0xC6,0x2E,0xA4,0x37,0x7B,0x1C,0x09,0x45,0x93,0x21,0x6E,0x42,
+						0x92,0x1A,0x74,0x0F,0xEB,0xFC,0xBB,0x10,0x15,0xC5,
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x91,0xB3,0xC4,0x6D,0x03,0x86,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+	#endif
+
+	#ifdef _CANAL_FR_SUPPORT_
+		// -----------------------------
+		// ------------- 00 80 ---------
+		0x80, 0, 0, 0,
+		/*ECM_MOD0*/0x97,0x5C,0x9B,0xDD,0xF2,0x5B,0x70,0x20,0x3A,0xF1,0x7E,0x3D,0x66,0x8A,0x1D,0x23,
+						0xE1,0x8F,0x76,0xC2,0x33,0xAC,0xED,0x9C,0x79,0x64,0x0E,0x9B,0xA0,0x1E,0x83,0xAE,
+						0xAA,0x4F,0x2A,0x04,0x2D,0x82,0x18,0x84,0xBF,0xB4,0x79,0xAD,0xF0,0x71,0x81,0x0C,
+						0xAD,0x59,0xBC,0x61,0x10,0x1F,0x5B,0x6C,0x50,0xCC,0xC3,0x98,0xB7,0x7E,0x36,0x27,
+						0x3A,0xA2,0x28,0x5E,0xE0,0x3A,0xE8,0xFE,0x98,0x96,0x79,0x58,0x75,0x71,0x52,0x68,
+						0x90,0x75,0x3E,0xC1,0xB2,0xAB,0x9F,0x6D,0xEB,0xD9,
+
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x89,0xE9,0x9D,0xB5,0xC1,0xA8,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/0x79,0xD8,0x19,0x5B,0x41,0x29,0xBC,0x28,0x28,0x37,0x2A,0x37,0xD0,0xB8,0xBD,0xF4,
+						0xF9,0x31,0xE5,0xF4,0x8C,0x27,0x69,0xD4,0x95,0xAA,0x9C,0x03,0x4F,0x36,0xB4,0x8E,
+						0xB3,0xB8,0xBF,0x64,0x9E,0xCD,0xB6,0x32,0xD2,0xF7,0x8E,0xC2,0xF2,0xE3,0xEC,0xCD,
+						0x92,0xCC,0x17,0x40,0x31,0x95,0xF1,0x3B,0x62,0xAA,0xA7,0x12,0xD6,0xE6,0x72,0xA9,
+						0x73,0x81,0xCC,0x31,0x00,0xAB,0x0B,0xA1,0x1C,0xDE,0x32,0x01,0x51,0xC2,0x21,0x3F,
+						0x30,0x13,0x2B,0x8D,0xC2,0x99,0x3F,0x02,0x4A,0xB8,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0x0F,0xCC,0x79,0x1F,0xB0,0x91,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		// -----------------------------
+		// ------------- 00 81 ---------
+		0x81, 0, 0, 0,
+		/*ECM_MOD0*/0x99,0xB0,0x22,0x6C,0x68,0x00,0xB1,0x82,0x43,0x78,0xE2,0x37,0x28,0x69,0x62,0xCE,
+						0x37,0x07,0x75,0x33,0x64,0x84,0x73,0x8F,0x9A,0xBA,0x77,0x94,0x73,0xBC,0x85,0xF3,
+						0xED,0x02,0x18,0x7C,0x15,0x55,0x0E,0x29,0x20,0x66,0xAC,0x2A,0x02,0x04,0xC2,0x79,
+						0x19,0xE9,0x7F,0x7F,0xD4,0x62,0xBD,0x31,0x2F,0x6B,0x4B,0x82,0x53,0x0F,0xE5,0xAB,
+						0xCE,0x89,0xCD,0xCD,0x39,0x48,0x57,0x69,0x8B,0xA2,0x1E,0x22,0xF5,0xC4,0x4C,0xA6,
+						0xE6,0x3A,0x1D,0xB4,0xC7,0x16,0xC8,0x88,0x38,0xD0,
+
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x39,0x9E,0x66,0x5B,0x8A,0x85,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/0xCB,0x41,0x58,0xDA,0xF9,0x65,0xCC,0xF1,0x0F,0xFF,0x82,0x5C,0xBE,0xE5,0xAE,0x65,
+						0x2B,0xD7,0x53,0xAC,0x56,0x56,0xD1,0x06,0xD6,0x45,0x57,0xA2,0x09,0xDA,0xEE,0x3C,
+						0x4F,0xE2,0xA3,0xD8,0xE9,0xEC,0xF7,0xC2,0x59,0x39,0xCB,0x5D,0x51,0x76,0x37,0x13,
+						0x14,0x9F,0xA7,0xF0,0x27,0x76,0x4A,0xA0,0xFF,0x57,0x79,0xA1,0xB8,0x32,0xC4,0x2F,
+						0x59,0x07,0x5E,0x99,0x74,0xC2,0x36,0x7D,0x91,0xC1,0xBA,0xEB,0x82,0x34,0x9A,0xDB,
+						0x6D,0xEC,0xCB,0xD5,0x35,0xC8,0x72,0x5A,0x63,0x9F,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0x7D,0xEB,0xCC,0x21,0x10,0x94,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		// -----------------------------
+		// ------------- 00 82 ---------
+		0x82, 0, 0, 0,
+		/*ECM_MOD0*/0x59,0xE5,0x77,0x94,0x85,0x93,0x64,0x94,0xA1,0xF0,0xE4,0x26,0xD1,0x41,0x83,0x70,
+						0xD4,0x34,0x40,0xE6,0x15,0xF4,0x32,0x0E,0xC3,0x2B,0x78,0xCE,0xF6,0xC9,0xC0,0x73,
+						0xA5,0x52,0xD5,0xC4,0x70,0xFA,0x73,0xEB,0xEC,0xF4,0xAD,0xE1,0x64,0x84,0x52,0xD5,
+						0x2E,0x4B,0xAC,0x71,0x2F,0xE3,0x18,0x8B,0x76,0xC9,0xD4,0xFC,0x92,0xC9,0x86,0x4D,
+						0x10,0xF7,0x74,0x09,0x9A,0xA2,0xAE,0xD6,0x4F,0x22,0x44,0xAB,0x68,0xA0,0x20,0x65,
+						0xCB,0xA3,0x8D,0xB3,0xDB,0xB0,0xF7,0xDC,0x4B,0x95,
+
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x7B,0x79,0xC9,0x37,0x3E,0xA2,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/0x95,0x41,0xAD,0xE6,0x2C,0xE1,0xFF,0xEF,0xF8,0x97,0xD9,0xE9,0x67,0xC4,0x0A,0xF6,
+						0xA8,0x2F,0xB2,0x3A,0x63,0xFB,0xBA,0xA6,0xF1,0xBF,0xD4,0x80,0x74,0x1A,0x24,0x0A,
+						0x6E,0xDD,0x62,0x2A,0x5C,0xAF,0x62,0xCA,0x11,0x19,0x85,0xD9,0x5A,0x02,0xA5,0x52,
+						0xB6,0x73,0x66,0xD9,0xA6,0x45,0xC1,0xA5,0x52,0x4D,0x50,0x62,0xBA,0xFE,0x64,0x94,
+						0xB2,0x13,0x2A,0x0A,0x93,0xF8,0x52,0x51,0xF2,0x9F,0x7D,0xD9,0xB2,0x62,0x05,0x80,
+						0x93,0xD3,0x66,0x48,0x0B,0xE7,0xA9,0x94,0xFA,0xBC,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0xC3,0x12,0x54,0x65,0x9B,0xFA,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		// -----------------------------
+		// ------------- 00 84 ---------
+		0x84, 0, 0, 0,
+		/*ECM_MOD0*/0xF1,0xAF,0xF9,0xC1,0x36,0xBD,0x30,0xFA,0x2D,0xCF,0xC5,0xE4,0x26,0x54,0x5D,0x56,
+						0xA9,0x15,0xD3,0x66,0x9A,0xC4,0x09,0x29,0xDB,0x50,0x16,0xD4,0x1F,0x05,0x54,0x8B,
+						0x54,0xB1,0xB9,0xC6,0x48,0x24,0x3F,0x2C,0xD3,0xED,0x30,0x57,0x38,0x15,0xC3,0xF6,
+						0x58,0xE4,0x41,0xCA,0x66,0x72,0xFB,0x7B,0xA6,0x1F,0x10,0x40,0xBD,0x5C,0x87,0xCF,
+						0x63,0xC8,0xC0,0xA9,0xAC,0x58,0x50,0x47,0xBC,0x8B,0x17,0x1A,0xC8,0xC3,0x49,0x37,
+						0xF0,0x55,0x97,0x24,0x3D,0xE7,0xE5,0x09,0x2B,0xA7,
+
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x85,0xCC,0x7C,0xB7,0x8C,0x81,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		// -----------------------------
+		// ------------- 00 86 ---------
+		0x86, 0, 0, 0,
+		/*ECM_MOD0*/0x0B,0x34,0x8E,0x67,0xD1,0x06,0x30,0x0F,0x18,0x66,0x85,0xB0,0xF6,0x57,0x6B,0x83,
+						0x47,0xA0,0xDE,0xD7,0x6A,0xBF,0x4F,0xDA,0xDE,0x29,0xDA,0x38,0x52,0x6E,0x53,0xA4,
+						0x27,0xDE,0xA9,0x32,0x63,0x01,0x45,0x52,0xAD,0x0F,0xC9,0xB5,0x31,0xF3,0x25,0x77,
+						0x75,0x14,0x0D,0x37,0x7B,0x4D,0x5F,0x8D,0x56,0xEF,0xFD,0xD5,0xAE,0x40,0xDD,0xB1,
+						0xC5,0x21,0xF7,0xF9,0xB3,0xC9,0xD7,0xD3,0x00,0xE2,0x79,0x9C,0xC1,0x88,0xB7,0xB3,
+						0x51,0xBC,0xEF,0xC7,0x48,0x43,0x5C,0x73,0x1B,0x9C,
+
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0xAF,0x8B,0x43,0x6A,0x60,0xAE,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+	#endif
+
+	#ifdef _SKYITALIA_SUPPORT_
+		// -----------------------------
+		// ------------- 00 70 ---------
+		0x70, 0, 0, 0,
+		/*ECM_MOD0*/0x4B,0xD5,0x10,0x54,0xC7,0xA7,0xA1,0x2C,0x5E,0x47,0xFF,0x49,0xC7,0x96,0xD2,0x7B,
+						0xC7,0x1C,0x0A,0xEC,0xB0,0x56,0xE1,0xA9,0xEE,0xC0,0xCE,0xB2,0x9F,0x34,0x62,0xE4,
+						0xA2,0x11,0x6A,0x87,0xC3,0xAC,0x53,0x23,0xCF,0xA3,0x13,0xB2,0x25,0xEB,0xC4,0x1A,
+						0xD8,0x8E,0x54,0xB5,0xC8,0x05,0x39,0x87,0x9E,0x22,0x21,0xF6,0xAB,0xC8,0x0F,0x3C,
+						0x5A,0x43,0x4A,0x39,0xA8,0x54,0xB1,0x9B,0x16,0xB8,0xB1,0x58,0x6F,0x66,0x22,0x20,
+						0xFF,0x31,0x1A,0x88,0x5A,0xE4,0xCD,0x9C,0x2B,0x86,
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x0F,0x7A,0x83,0x0E,0x12,0xF8,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/0xF3,0xD3,0x54,0x7A,0x3F,0x30,0x8C,0x05,0x53,0xAA,0x24,0x6D,0x1E,0x5C,0x20,0x66,
+						0x5E,0x2B,0x61,0x8D,0xBA,0x37,0x24,0x06,0x70,0xBB,0x66,0x72,0x7E,0x50,0x83,0x8C,
+						0xBA,0x7D,0x48,0x49,0x93,0x0C,0x18,0xF4,0x35,0x5C,0x74,0x18,0xE3,0xA2,0xAD,0x14,
+						0xE9,0x60,0x18,0x6F,0x48,0x65,0xC9,0x49,0x84,0x9A,0x9D,0xEA,0x35,0xBE,0xB8,0x45,
+						0x10,0xF8,0x99,0x1F,0xF5,0x55,0x45,0x37,0x4A,0x05,0x44,0xBC,0x71,0x5F,0x30,0x51,
+						0x08,0xE8,0x91,0x61,0x75,0x3C,0x2A,0xE3,0x34,0x95,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0x4D,0x38,0x9F,0xED,0xD4,0xB6,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		// -----------------------------
+		// ------------- 00 71 ---------
+		0x71, 0, 0, 0,
+		/*ECM_MOD0*/0xDF,0x9C,0x7A,0xA8,0xD8,0x8C,0xC9,0xF8,0x24,0x78,0xA9,0x4C,0x79,0xBC,0x5F,0xBC,
+						0x34,0xB9,0x51,0xAB,0xF8,0x1E,0xED,0xCF,0xE9,0x31,0xA5,0xAA,0x72,0x58,0x32,0x1C,
+						0x4C,0x4E,0x28,0x16,0x87,0x29,0xC4,0x65,0x26,0xA6,0x92,0x83,0xAA,0x52,0xD2,0xF5,
+						0xC6,0x85,0xE2,0xEA,0x20,0x03,0x28,0x1B,0x19,0x77,0x7C,0xA2,0xD1,0x12,0x5C,0x02,
+						0xA5,0x51,0x09,0x84,0x85,0xF2,0x9A,0xD6,0x6E,0xBE,0xAE,0x8C,0xFA,0x64,0x84,0x33,
+						0xAE,0xE7,0xC4,0x5F,0x1B,0xEA,0x76,0x8C,0xE7,0x93,
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x75,0xD1,0x8A,0x7E,0x31,0x9E,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_MOD1*/0xA3,0x07,0x71,0x64,0xD6,0xDA,0x00,0x55,0xED,0xCD,0xEC,0x3C,0x40,0x06,0x72,0xAC,
+						0xD3,0xB5,0xFC,0x3A,0xA4,0x7B,0x13,0x06,0xBB,0x9F,0x0C,0xB0,0xF2,0x9C,0x7D,0x0D,
+						0x03,0xF3,0x7C,0xCD,0x95,0x06,0xCC,0x89,0xF3,0x68,0xFC,0x41,0x9A,0x69,0x25,0x4E,
+						0x65,0x71,0x05,0x0E,0xA4,0xB1,0x82,0xBD,0xD4,0x35,0x5D,0x91,0xB5,0xD2,0xB2,0x1E,
+						0x36,0x23,0xF9,0xBB,0x91,0x9E,0xB6,0x5E,0x1C,0xB5,0xC0,0x9C,0x78,0x5F,0x20,0x20,
+						0x35,0x14,0xE5,0xDA,0x94,0xA7,0x7E,0x61,0x51,0xAA,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0x03,0x64,0x94,0x7A,0x4E,0x94,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		// -----------------------------
+		// ------------- 00 72 ---------
+		0x72, 0, 0, 0,
+		/*ECM_MOD0*/0x87,0x6A,0x95,0x3C,0xA6,0x24,0x48,0x9F,0x6E,0x69,0x52,0xF6,0xE2,0xD8,0x25,0x43,
+						0xB5,0x6C,0xAA,0x70,0xC9,0x13,0x26,0xF9,0xB9,0x86,0x9D,0x7E,0x53,0xAB,0xF1,0x4D,
+						0xEA,0xBE,0xAE,0x8C,0x77,0xD2,0xDC,0x91,0x89,0x4F,0xEA,0x98,0xA7,0xF2,0xCC,0x62,
+						0xA6,0xED,0x39,0xA6,0x10,0x56,0x3B,0x8F,0x55,0x78,0x9F,0x15,0xC1,0x08,0x2D,0xC2,
+						0xE9,0x53,0xA7,0xF4,0x9C,0x82,0xA8,0xCA,0x0D,0x9E,0xB8,0xD9,0xC7,0x2F,0x03,0xDC,
+						0xDE,0xA4,0xA5,0xC7,0x6A,0xA1,0xD8,0xEC,0xB2,0xAC,
+		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*ECM_EXP0*/	0x71,0x7D,0x4A,0x88,0xEB,0xED,
+		/*ECM_EXP1*/	0,0,0,0,0,0,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		//          	0x41,0x16,0xB2,0xA8,0x3A,0x29,0xF1,0xEB,0xF3,0xB3,0x4B,0x63,0x03,0x4F,0x14,0x90,
+		/*EMM_MOD1*/0x4F,0x16,0xB2,0xA8,0x3A,0x29,0xF1,0xEB,0xF3,0xB3,0x4B,0x63,0x03,0x4F,0x14,0x90,
+						0x65,0x40,0x94,0x3B,0x51,0xB8,0xE8,0xD0,0x22,0x54,0x60,0x2B,0xE5,0xC3,0xAB,0x6F,
+						0xC9,0x33,0x8E,0x0E,0x0A,0xFE,0x73,0xC4,0x76,0xAD,0xF5,0x9B,0x0A,0xE5,0x15,0x73,
+						0xCC,0x6A,0x0B,0x79,0xA3,0x57,0xF0,0x21,0xB8,0xB3,0x39,0x4C,0x75,0x2A,0xF8,0x68,
+						0x4D,0x25,0x8F,0x74,0x16,0x0D,0x76,0xF1,0x37,0xE1,0x55,0x25,0x42,0xD9,0xC1,0xF6,
+						0x12,0xAA,0x28,0xE9,0xE8,0xEB,0xE9,0xE8,0x86,0x85,
+		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+		/*EMM_EXP0*/	0,0,0,0,0,0,
+		/*EMM_EXP1*/	0x73,0x56,0x66,0x33,0xB8,0x94,
+		/*ECM_EXP2*/	0,0,0,0,0,0,
+	#endif
+	// -----------------------------
+	// ------------- RESERVED------
+	0,0,0,0,
+	/*ECM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	/*ECM_EXP0*/	0,0,0,0,0,0,
+	/*ECM_EXP1*/	0,0,0,0,0,0,
+	/*ECM_EXP2*/	0,0,0,0,0,0,
+	/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	/*EMM_EXP0*/	0,0,0,0,0,0,
+	/*EMM_EXP1*/	0,0,0,0,0,0,
+	/*ECM_EXP2*/	0,0,0,0,0,0,
+};
+
+#ifdef _SKYITALIA_SUPPORT_
+	static uint8_t seka2_cw70XT[16] =
+		{ 0x07,0x17,0x3F,0x5E,0x6A,0xF7,0xB2,0x25, 0xA6,0x97,0x6A,0xCA,0xE2,0x2F,0xC8,0x1F };
+	static uint8_t seka2_cw70PT[16] =
+		{ 0x01,0x00,0x02,0x04,0x03,0x07,0x05,0x06, 0x0E,0x0B,0x0D,0x0A,0x0F,0x0C,0x09,0x08 };
+#endif
+
+#ifdef _CYFRA_SUPPORT_
+	static uint8_t seka2_cw65XT[16] =
+		{ 0xA0,0x12,0x23,0x35,0x46,0xB0,0xDF,0xCA, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
+	static uint8_t seka2_cw65PT[16] =
+		{ 0x05,0x04,0x06,0x07,0x03,0x00,0x01,0x02, 0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };
+#endif
+
+static SEKAII_ISSUER seka2_issuer_data[MAX_SEKAII_ISSUERS] =
+{
+	#ifdef _DPLUS_SUPPORT_
+		{
+		// --- Spain ---
+		/*Provis */		{0x64, 0x66, 0x67, 0x60,},
+		/*sha1pad*/		0x96,
+		/*sha1end*/		0x69,
+		/*T1_0 9x */	seka2_64H9x_T1,
+		/*T1_1 Bx*/		seka2_64HBx_T1,
+		/*T1_3 Fx*/		seka2_xxHFx_T1,
+		/*T2_0 9x */	seka2_64H9x_T2,
+		/*T2_1 Bx*/		seka2_64HBx_T2,
+		/*T2_3 Fx*/		seka2_xxHFx_T2,
+		/*mask table*/	(uint8_t *)seka2_64MT_BIN,
+		/*XT */			NULL,
+		/*PT */			NULL,
+		},
+	#endif
+
+	#ifdef _CYFRA_SUPPORT_
+		{
+		//---Cyfra---
+		/*Provis */		{0x65, },
+		/*sha1pad*/		0x96,	// 0xC1
+		/*sha1end*/		0x69,	// 0x1C
+		/*T1_0 9x */	seka2_65H9x_T1,
+		/*T1_1 Bx*/		seka2_65HBx_T1,
+		/*T1_3 Fx*/		seka2_65HFx_T1,
+		/*T2_0 9x */	seka2_65H9x_T2,
+		/*T2_1 Bx*/		seka2_65HBx_T2,
+		/*T2_3 Fx*/		seka2_65HFx_T2,
+		/*mask table*/	(uint8_t *)seka2_65MT_BIN,
+		/*XT*/			(uint8_t *)seka2_cw65XT,
+		/*PT */			(uint8_t *)seka2_cw65PT,
+		},
+	#endif
+
+	#ifdef _CANAL_NL_SUPPORT_
+		{
+		//---Cyfra---
+		/*Provis */		{0x6A,0x6B,0x6C,0x6D},
+		/*sha1pad*/		0xA3,	// 0xA3
+		/*sha1end*/		0x3A,	// 0x3A
+		/*T1_0 9x */	seka2_6AH9x_T1,
+		/*T1_1 Bx*/		seka2_6AHBx_T1,
+		/*T1_3 Fx*/		seka2_6AHFx_T1,
+		/*T2_0 9x */	seka2_6AH9x_T2,
+		/*T2_1 Bx*/		seka2_6AHBx_T2,
+		/*T2_3 Fx*/		seka2_6AHFx_T2,
+		/*mask table*/	(uint8_t *)seka2_6AMT_BIN,
+		/*XT*/			(uint8_t *)NULL,
+		/*PT */			(uint8_t *)NULL,
+		},
+	#endif
+
+	#ifdef _CANAL_FR_SUPPORT_
+		{
+		/*Provis */		{0x80,},
+		/*sha1pad*/		0xA1,
+		/*sha1end*/		0x1A,
+		/*T1_0 9x */	seka2_80H9x_T1,
+		/*T1_1 Bx*/		seka2_80HBx_T1,
+		/*T1_3 Fx*/		seka2_80HFx_T1,
+		/*T2_0 9x */	seka2_80H9x_T2,
+		/*T2_1 Bx*/		seka2_80HBx_T2,
+		/*T2_3 Fx*/		seka2_80HFx_T2,
+		/*mask table*/	(uint8_t *)seka2_80MT_BIN,
+		/*XT*/			(uint8_t *)NULL,
+		/*PT */			(uint8_t *)NULL,
+		},
+		{
+		/*Provis */		{0x81,},
+		/*sha1pad*/		0xA1,
+		/*sha1end*/		0x1A,
+		/*T1_0 9x */	seka2_81H9x_T1,
+		/*T1_1 Bx*/		seka2_81HBx_T1,
+		/*T1_3 Fx*/		seka2_81HFx_T1,
+		/*T2_0 9x */	seka2_81H9x_T2,
+		/*T2_1 Bx*/		seka2_81HBx_T2,
+		/*T2_3 Fx*/		seka2_81HFx_T2,
+		/*mask table*/	(uint8_t *)seka2_81MT_BIN,
+		/*XT*/			(uint8_t *)NULL,
+		/*PT */			(uint8_t *)NULL,
+		},
+	#endif
+
+
+	#ifdef _SKYITALIA_SUPPORT_
+		{
+		//---Italy---
+		/*Provis */		{0x70, 0x71, 0x72, 0x73,},
+		/*sha1pad*/		0xA1,
+		/*sha1end*/		0x1A,
+		/*T1_0 9x */	seka2_70H9x_T1,
+		/*T1_1 Bx*/		seka2_70HBx_T1,
+		/*T1_3 Fx*/		seka2_70HFx_T1,
+		/*T2_0 9x */	seka2_70H9x_T2,
+		/*T2_1 Bx*/		seka2_70HBx_T2,
+		/*T2_3 Fx*/		seka2_70HFx_T2,
+		/*mask table*/	(uint8_t *)seka2_70MT_BIN,
+		/*XT*/			(uint8_t *)seka2_cw70XT,
+		/*PT */			(uint8_t *)seka2_cw70PT,
+		},
+	#endif
+
+	{
+		// --- RESERVED ---
+		/*Provis */		{0x0, 0x0, 0x0, 0x0,},
+		/*sha1pad*/		0x0,
+		/*sha1end*/		0x0,
+		/*T1_0 9x */	NULL,
+		/*T1_1 Bx*/		NULL,
+		/*T1_3 Fx*/		NULL,
+		/*T2_0 9x */	NULL,
+		/*T2_1 Bx*/		NULL,
+		/*T2_3 Fx*/		NULL,
+		/*mask table*/	NULL,
+		/*XT */			NULL,
+		/*PT */			NULL,
+	},
+};
+//
+//
+//
+static uint16_t		seka_prid;
+static SEKAII_PROVI 	*seka2_provi;
+static SEKAII_ISSUER	*seka2_issuer;
+
+static BIGNUM 			er_ecmMod, er_ecmExp;
+static BIGNUM 			er_n51Mod, er_n51Exp;
+static int16_t			er_KFOUND;
+static uint32_t		er_KPRID;
+static uint8_t			er_KNR;
+static uint8_t			er_KKEY[16];
+// reader_common.c
+extern int32_t rdr_RSA_decrypt(struct s_reader *reader, uint8_t *out, uint8_t *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int32_t LE);
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+int
+xseka_sct_payload(uint8_t *d, uint8_t **payload)
+{
+	int l;
+
+	switch (_seka_tid_(d))
+	{
+		case 0x80:
+		case 0x81: l=sizeof(SEKA_ECM); 	break;
+		case 0x82: l=sizeof(SEKA_EMM_U); break;
+		case 0x84: l=sizeof(SEKA_EMM_S); break;
+		default: return -1;
+    }
+	if (payload) *payload=&d[l];
+	return (SCT_LEN(d)-3-l+3);
+}
+
+int
+xseka_sct_sysmode(uint8_t *d)
+{
+	switch (_seka_tid_(d))
+	{
+		case 0x80:
+		case 0x81: return ((SEKA_ECM *)  d)->sm; break;
+		case 0x82: return ((SEKA_EMM_U *)d)->sm; break;
+		case 0x84: return ((SEKA_EMM_S *)d)->sm; break;
+		default: return -1;
+	}
+}
+
+int
+xseka_sct_keynr(uint8_t *d)
+{
+	switch (_seka_tid_(d))
+	{
+		case 0x80:
+		case 0x81: return ((SEKA_ECM *)  d)->keynr; break;
+		case 0x82: return ((SEKA_EMM_U *)d)->keynr; break;
+		case 0x84: return ((SEKA_EMM_S *)d)->keynr; break;
+		default: return -1;
+	}
+}
+
+uint8_t *
+xseka_sct_provp(uint8_t *d)
+{
+	switch (_seka_tid_(d))
+	{
+		case 0x80:
+		case 0x81: return ((SEKA_ECM *)  d)->id;
+		case 0x82: return ((SEKA_EMM_U *)d)->id;
+		case 0x84: return ((SEKA_EMM_S *)d)->id;
+	}
+	return 0;
+}
+
+uint8_t *
+xseka_sct_emmaddr(uint8_t *d)
+{
+	switch (_seka_tid_(d))
+	{
+		case 0x80:
+		case 0x81: return 0;
+		case 0x82: return ((SEKA_EMM_U *)d)->ua;
+		case 0x84: return ((SEKA_EMM_S *)d)->sa;
+	}
+	return 0;
+}
+
+int
+xseka_sct_prid(uint8_t *d)
+{
+  uint8_t *id = xseka_sct_provp(d);
+
+  return (id ? (id[0] << 8) + id[1] : -1);
+}
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static void
+xseka_Fase(uint8_t *D, uint8_t *key, uint8_t *T1, uint8_t *T2)
+{
+	// Modifica 4 bytes en D con 4 bytes de clave en k
+
+	uint8_t l,dt; // paso 1
+	for (l=0;l<4;++l) D[l]^=key[l];  // paso 2
+	for (l=0;l<4;++l) D[l] =T1[D[l]];
+	for (l=6;l>3;--l)
+	{
+		D[(l+2)&3]^=D[(l+1)&3];
+		dt=(_seka_sn8_(D[(l+1)&3])+D[l&3])&0xff;
+		D[l&3]=T2[dt];
+	}
+	for (l=3;l>0;--l)
+	{
+		D[(l+2)&3]^=D[(l+1)&3];
+		D[l&3]=T1[(_seka_sn8_(D[(l+1)&3])+D[l&3])&0xff];
+	}
+	D[2]^=D[1];
+	D[1]^=D[0];
+}
+
+
+void
+xseka_Decrypt(uint8_t *d, uint8_t *key, uint8_t *T1, uint8_t *T2)
+{
+	// k = clave de 128 bits (16 bytes),
+	// d = datos de 64 bits (8 bytes)
+	uint8_t i,j,l,C,dt,D[4];
+	uint8_t kk[16];
+
+	for (i=0;i<16;++i) kk[i]=key[i]; // 16 rondas
+	// preparacion de la clave
+	C=0xff;
+	for (j=0;j<4;++j)
+	{
+		for (i=0;i<16;++i)
+		{
+			if ((i&3)==0) ++C;
+			kk[i]^=T1[kk[(15+i)&0xf]^kk[(i+1)&0xf]^C];
+		}
+	} // manipulacion de los datos
+	j=0; // 16 rondas
+	for (i=0;i<16;++i)
+	{
+		for (l=0;l<4;++l) D[l]=d[l+4]; // Copia d5..d8 a D1..D4
+		j=(j+12)&0xf; // selecciona clave apropiada
+		xseka_Fase(D,&kk[j],T1,T2); // modifica D con clave pertinente
+		// paso 3
+		for (l=0;l<4;++l)
+		{ // modifica d bajo
+			d[l]^=T2[D[seka_TD[l]]]; // paso 4
+		}
+		for (l=3;l!=0xff;--l)
+		{ // modifica k usado
+			kk[j+l]^=T1[kk[(j+l+1)&0xf]^kk[(j+l+15)&0xf]^(15-i)];
+		}
+		if (i<15)
+		{ // intercambia d altos y bajos
+			for (l=0;l<4;++l)
+			{
+				dt=d[l];d[l]=d[4+l];d[4+l]=dt;
+			}
+		}
+	}
+}
+
+
+void
+xseka_Encrypt(uint8_t *d, uint8_t *key, uint8_t *T1, uint8_t *T2)
+{
+	// Rutina de encriptacion, no modifica la clave
+	/* k=clave de 128 bits (16 bytes), d=datos de 64 bits (8 bytes) */
+	uint8_t i,j,l,dt,D[4],kk[16];
+
+	// primero hace copia de la clave
+	for (i=0;i<16;++i) kk[i]=key[i]; // 16 rondas
+
+	for (j=i=0;i<16;++i,j=(j+4)&0xf)
+	{
+		// paso 1
+		for (l=0;l<4;++l)
+		{
+			kk[j+l] ^= T1[kk[(j+l+1)&0xf]^kk[(j+l+15)&0xf]^i];
+		}
+		if (i>0)
+		{ // intercambia d altos y bajos
+			for (l=0;l<4;++l)
+			{
+				dt=d[l]; d[l]=d[4+l]; d[4+l]=dt;
+			}
+		}
+		for ( l=0; l<4; ++l) D[l]=d[l+4]; // Copia d5..d8 a D1..D4
+		xseka_Fase(D, &kk[j],T1,T2); // modifica D con clave pertinente
+		// paso 2
+		for (l=0;l<4;++l)
+		{ // modifica d bajo
+			d[l]^=T2[D[seka_TD[l]]];
+		}
+	}
+}
+
+
+void
+xseka_calc_signatures(uint8_t *buff, int len, uint8_t *signature, uint8_t *key, uint8_t *T1, uint8_t *T2)
+{
+	int i, j;
+
+	memset(signature,0,8);
+	for(i=0; i<len; i+=8)
+	{
+		for (j=0; j<8 && (i+j)<len; j++) signature[j] ^= buff[i+j];
+		xseka_Encrypt(signature,key,T1,T2);
+	}
+}
+
+
+void
+xseka_xxor(uint8_t *dst, int len, uint8_t *src1, uint8_t *src2)
+{
+	while (len-- > 0) *dst++ = (*src1++)^(*src2++);
+}
+
+
+void
+xseka_swap8_4(uint8_t *dst)
+{
+	uint8_t temp[4];
+
+	memcpy(temp,dst,4);
+	memcpy(dst,&dst[4],4);
+	memcpy(&dst[4],temp,4);
+}
+
+
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+
+static SEKAII_PROVI *
+xseka_getSeka2provi(uint16_t ident)
+{
+	SEKAII_PROVI *provi;
+	int	i, j;
+
+	// \C0\CE....
+	if (ident == 0x00) return 0;
+	if (ident == 0x60) ident = 0x64;
+
+	provi = (SEKAII_PROVI *)seka2_provi_data;
+	for (i=0; i<MAX_SEKAII_PRS; i++)
+	{
+		for (j=0; j<MAX_SEKA_PROV; j++)
+		{
+			if (provi->ident[j] == ident)
+			{
+				return (provi);
+			}
+		}
+		provi++;
+	}
+	// ident not found in provi list
+//	MYEMU_TRACE("xseka:Prov Num: %d\n", i);
+	MYEMU_TRACE("xseka:ident{%04X} not found in provi list.\n", ident);
+	return 0;
+}
+
+static SEKAII_ISSUER *
+xseka_getSeka2issuer(uint16_t ident)
+{
+	SEKAII_ISSUER *issuer_p;
+	int	i, j;
+
+	if (ident == 0x00) return 0;
+	issuer_p = (SEKAII_ISSUER *)seka2_issuer_data;
+	for (i=0; i<MAX_SEKAII_ISSUERS; i++)
+	{
+		for (j=0; j<4; j++)
+		{
+			if (issuer_p->ident[j]==ident)
+			{
+				return (issuer_p);
+			}
+
+		}
+		issuer_p++;
+	}
+	// ident not found in issuers list
+	MYEMU_TRACE("xseka:ident{%04X} not found in issuers list.\n", ident);
+	return 0;
+}
+
+
+static int
+xseka_isSeka2available(uint16_t ident)
+{
+	// _CANAL_NL_SUPPORT_
+	// _DPLUS_SUPPORT_
+	// _CYFRA_SUPPORT_
+#if defined(_CYFRA_SUPPORT_) || defined(_CANAL_NL_SUPPORT_) || defined(_DPLUS_SUPPORT_)
+	if ((ident & 0xFFF0) == 0x60) return 1;
+#endif
+#if defined(_CANAL_FR_SUPPORT_)
+	if ((ident & 0xFFF0) == 0x80) return 1;
+#endif
+
+#if defined(_SKYITALIA_SUPPORT_)
+	if ((ident & 0xFFF0) == 0x70) return 1;
+#endif
+	return 0;
+}
+
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#define _BEFORE_S_ (pos-8)
+#define _AFTER_S_  (pos+1)
+
+#ifdef _CANAL_FR_SUPPORT_
+static int
+xseka_fr_Isprovid(uint16_t ident)
+{
+	if ((ident & 0xf0) == 0x80)	return 1;
+	return 0;
+}
+
+
+static void
+xseka_fr_PRE_SSE_Core(uint8_t *buf, uint8_t *data, int i)
+{
+	uint8_t *T1 = seka2_SSE_3072;
+	uint8_t *T2 = seka2_SSE_2048;
+
+	buf[ 0]= data[0x06]^T2[i+0x0a];
+	buf[ 1]= data[0x01]^T2[i+0x00];
+	buf[ 2]= data[0x02]^T1[i+0x00];
+	buf[ 3]= data[0x03]^T2[i+0x04];
+	buf[ 4]=~data[0x04];
+	buf[ 5]= data[0x05]^T1[i+0x01];
+	buf[ 6]= data[0x00]^T2[i+0x0f];
+	buf[ 7]= data[0x07]^T1[i+0x02];
+	buf[ 8]= data[0x08]^T1[i+0x00];
+	buf[ 9]= data[0x0d]^T2[i+0x14];
+	buf[10]= data[0x0f]^T2[i+0x07];
+	buf[11]=~data[0x0b];
+	buf[12]= data[0x0c]^T1[i+0x00];
+	buf[13]= data[0x09]^T2[i+0x19];
+	buf[14]= data[0x0e]^T2[i+0x1e];
+	buf[15]= data[0x0a]^T1[i+0x01];
+}
+
+static void
+xseka_fr_POST_SSE_Core1(uint8_t *data, int pos)
+{
+	data[_BEFORE_S_+0]^=-(0x2d);
+	data[_BEFORE_S_+1]-=  0x22;
+	data[_BEFORE_S_+2]^=  0x1d;
+	data[_BEFORE_S_+3]^=-(0x68);
+	data[_BEFORE_S_+4] =~data[_BEFORE_S_ + 4];
+	data[_BEFORE_S_+5]^=  0x26;
+	data[_BEFORE_S_+6]^=  0x09;
+	data[_BEFORE_S_+7]-=  0x3e;
+	data[_AFTER_S_ +0]^=-(0x5d);
+	data[_AFTER_S_ +1]-=  0x74;
+	data[_AFTER_S_ +2]^=  0x2d;
+	data[_AFTER_S_ +3]^=-(0x2a);
+	data[_AFTER_S_ +4]+=  0x0d;
+	data[_AFTER_S_ +5]^=-(0x6c);
+	data[_AFTER_S_ +6]^=-(0x76);
+	data[_AFTER_S_ +7]+=  0x31;
+}
+
+static void
+xseka_fr_POST_SSE_Core2(uint8_t *buf, uint8_t *data, int pos)
+{
+	uint8_t *T1 = seka2_80_SSEP_256;
+
+	memcpy(buf, &T1[data[_AFTER_S_+4]+0x48], 56);
+}
+
+static void
+xseka_fr_POST_SSE_Core3(uint8_t *data, uint8_t *buf, int pos)
+{
+	data[_BEFORE_S_+4]=buf[5];
+	data[_BEFORE_S_+5]=buf[4];
+	data[_BEFORE_S_+6]=buf[7];
+	data[_BEFORE_S_+7]=buf[2];
+	data[_AFTER_S_ +0]=buf[3];
+	data[_AFTER_S_ +1]=buf[1];
+	data[_AFTER_S_ +2]=buf[0];
+	data[_AFTER_S_ +3]=buf[6];
+}
+
+static void
+xseka_fr_POST_SSE_Core4(uint8_t *data, int pos)
+{
+	data[_AFTER_S_+0]=data[_BEFORE_S_+3]^  0x3e;
+	data[_AFTER_S_+1]=data[_BEFORE_S_+1]^  0x5e;
+	data[_AFTER_S_+2]=data[_BEFORE_S_+5]^  0x2f;
+	data[_AFTER_S_+3]=data[_BEFORE_S_+0]^  0x77;
+	data[_AFTER_S_+4]=data[_BEFORE_S_+6]^-(0x4b);
+	data[_AFTER_S_+5]=data[_BEFORE_S_+2]^-(0x38);
+	data[_AFTER_S_+6]=data[_BEFORE_S_+7]^  0x29;
+	data[_AFTER_S_+7]=data[_BEFORE_S_+4]^  0x2b;
+}
+
+static void
+xseka_fr_POST_CW(uint8_t *data)
+{
+	uint8_t 	*T1 = seka2_SSE_3072;
+	uint8_t 	*T2 = seka2_SSE_2048;
+	uint8_t 	*T3 = seka2_80_SSEP_256;
+	uint8_t	*T4 = seka2_80_CW_512;
+	int	idx;
+	uint8_t 	key[8];
+
+	idx=((data[0]<<8)|data[1]);     key[0]=T3[idx & 0x3FF];
+	idx= (idx + key[0]);            key[1]=T3[idx & 0x3FF];
+	idx=((data[2]<<8)|data[3]);     key[2]=T4[idx & 0x1FF];
+	idx= idx + key[2];              key[3]=T4[idx & 0x1FF];
+	idx=((data[8+4]<<8)|data[8+5]); key[4]=T2[idx & 0x7FF];
+	idx= idx + key[4];              key[5]=T2[idx & 0x7FF];
+	idx=((data[8+6]<<8)|data[8+7]); key[6]=T1[idx & 0xBFF];
+	idx= idx + key[6];              key[7]=T1[idx & 0xBFF];
+
+	DES_seka(key, DES_ECS2_CRYPT, data+4);
+}
+
+static void
+xseka_fr_XOR_Chain(uint8_t *data, uint16_t idx)
+{
+	static uint8_t tabIdx[] = { 0x00, 0x08, 0x03, 0x1F, 0x06, 0x32, 0x12, 0x0C };
+	static uint8_t tabXor[] = { 0x77, 0x2B, 0xC8, 0xEE, 0x2F, 0xD3, 0x22, 0x29 };
+	static uint8_t tabPos[] = {    0,    2,    1,    6,    4,    5,    7,    3 };
+
+	int idx1, idx2;
+	int i;
+	uint8_t 	xorVal=0;
+	uint8_t 	*T1 = (uint8_t *)seka2_issuer->masktab;
+	uint8_t 	*T2 = seka2_SSE_3072;
+
+	idx1 = (idx ^ 0x17AC) & 0x3FFF;
+	idx2 = idx1 & 0xBFF;
+	for (i=0; i<8; i++)
+	{
+		idx1 = (idx1 + tabIdx[i]) & 0x3FFF;
+		idx2 = (idx2 + xorVal) & 0xBFF;
+		xorVal ^= T1[idx1] ^ tabXor[i];
+		data[tabPos[i]] ^= xorVal ^ T2[idx2];
+	}
+}
+
+static void
+xseka_fr_MOD_Signature(uint8_t *mod, uint8_t *pk)
+{
+	uint8_t 	*T1 = seka2_80_SSEP_256;
+	uint32_t	idx;
+
+	idx = ((mod[18] << 8) | mod[19]) & 0x3FF;
+	mod[10]  = T1[idx];
+	mod[13] ^= pk[6];
+	idx = ((mod[15] << 8) | mod[13]) & 0x3FF;
+	mod[16]  = T1[idx];
+
+	DES_seka(mod+10, DES_ECS2_CRYPT, mod);
+}
+#endif	// _CANAL_FR_SUPPORT_
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#ifdef _CANAL_NL_SUPPORT_
+static int
+xseka_nl_Isprovid(uint16_t ident)
+{
+	if (ident == 0x6A) return 1;
+	if (ident == 0x6B) return 1;
+	if (ident == 0x6C) return 1;
+	if (ident == 0x6D) return 1;
+	return 0;
+}
+
+
+static void
+xseka_nl_PRE_SSE_Core(uint8_t *buf, uint8_t *data, int i)
+{
+	uint8_t *T1 = seka2_SSE_3072;
+	uint8_t *T2 = seka2_SSE_2048;
+
+	buf[0] = data[7] ^T1[i+0x17];
+	buf[1] = data[1] ^T2[i+0x07];
+	buf[2] = data[2] ^T1[i+0x03];
+	buf[3] = data[3] ^T2[i+0x0C];
+	buf[4] =~data[4];
+	buf[5] = data[5] ^T1[i+0x1E];
+	buf[6] = data[6] ^T1[i+0x11];
+	buf[7] = data[0] ^T2[i+0x0F];
+	buf[8] = data[9] ^T1[i+0x15];
+	buf[9] = data[8] ^T2[i+0x04];
+	buf[10]= data[12]^T2[i+0x07];
+	buf[11]= data[11]^T1[i+0x16];
+	buf[12]= data[10]^T1[i+0x01];
+	buf[13]= data[13]^T1[i+0x0F];
+	buf[14]=~data[14];
+	buf[15]= data[15]^T2[i+0x0B];
+}
+
+static void
+xseka_nl_POST_SSE_Core1(uint8_t *data, int pos)
+{
+	// modify 8 bytes before signature byte (0x82)
+	data[_BEFORE_S_+0] ^= 0xd6; data[_BEFORE_S_+1] ^= 0x96;
+	data[_BEFORE_S_+2] -= 0x51; data[_BEFORE_S_+3] ^= 0x3a;
+	data[_BEFORE_S_+4] -= 0x8d; data[_BEFORE_S_+5] ^= 0xf1;
+	data[_BEFORE_S_+6] -= 0xc2; data[_BEFORE_S_+7] ^= 0xb1;
+
+	data[_AFTER_S_ +0] ^= 0x84; data[_AFTER_S_ +1] ^= 0xf8;
+	data[_AFTER_S_ +2] -= 0x7d; data[_AFTER_S_ +3]  = ~(data[_AFTER_S_+3]);
+	data[_AFTER_S_ +4] ^= 0xfd; data[_AFTER_S_ +5] ^= 0xd0;
+	data[_AFTER_S_ +6] ^= 0x77; data[_AFTER_S_ +7] ^= 0x25;
+}
+
+static void
+xseka_nl_POST_SSE_Core2(uint8_t *buf, uint8_t *data, int pos)
+{
+	uint8_t	*T1 = seka2_6A_SSEP_256;
+	memcpy(buf,&T1[(data[_AFTER_S_+6]+0x19)&0x7F],56);
+}
+
+static void
+xseka_nl_POST_SSE_Core3(uint8_t *data, uint8_t *buf, int pos)
+{
+	data[_BEFORE_S_+4]=buf[7];
+	data[_BEFORE_S_+5]=buf[0];
+	data[_BEFORE_S_+6]=buf[3];
+	data[_BEFORE_S_+7]=buf[5];
+	data[_AFTER_S_ +0]=buf[6];
+	data[_AFTER_S_ +1]=buf[2];
+	data[_AFTER_S_ +2]=buf[1];
+	data[_AFTER_S_ +3]=buf[4];
+}
+
+static void
+xseka_nl_POST_SSE_Core4(uint8_t *data, int pos)
+{
+	data[_AFTER_S_+0]=data[_BEFORE_S_+1] ^ 0x65; data[_AFTER_S_+1]=data[_BEFORE_S_+0] ^ 0x75;
+	data[_AFTER_S_+2]=data[_BEFORE_S_+5] ^ 0x35; data[_AFTER_S_+3]=data[_BEFORE_S_+3] ^ 0xd9;
+	data[_AFTER_S_+4]=data[_BEFORE_S_+6] ^ 0xb7; data[_AFTER_S_+5]=data[_BEFORE_S_+7] ^ 0x9a;
+	data[_AFTER_S_+6]=data[_BEFORE_S_+4] ^ 0xc7; data[_AFTER_S_+7]=data[_BEFORE_S_+2] ^ 0x1f;
+}
+
+static void
+xseka_nl_POST_CW(uint8_t *data)
+{
+	uint8_t 	*T1 = seka2_SSE_3072;
+	uint8_t 	*T2 = seka2_SSE_2048;
+	uint8_t 	*T3 = seka2_6A_CW_512;
+	uint8_t 	*T4 = seka2_6A_SSEP_256;
+	uint8_t 	key[8];
+	uint32_t off2;
+
+	off2  =data[2]^data[8+6];
+	key[2]=T4[off2];
+	key[5]=T4[(off2+key[2])&0xff];
+
+	off2  =(data[3]<<8)|data[8+4];
+	key[0]=T3[off2&0x1ff];
+	off2  +=key[2];
+	key[4]=T3[off2&0x1ff];
+
+	off2  =(data[0]<<8)|data[8+7];
+	key[7]=T2[off2&0x7ff];
+	off2 +=key[0];
+	key[1]=T2[off2&0x7ff];
+
+	off2  =(data[1]<<8)|data[8+5];
+	key[3]=T1[off2&0xbff];
+	off2 +=key[4];
+	key[6]=T1[off2&0xbff];
+
+	DES_seka(key, DES_ECS2_CRYPT, data+4);
+}
+
+
+static void
+xseka_nl_XOR_Chain(uint8_t *data, uint16_t idx)
+{
+	static uint16_t tabIdx [] = { 0x000, 0x4C3, 0x5D8, 0x63A, 0x471, 0x639, 0x417, 0x6CD };
+	static uint8_t  tabXor [] = {  0x84,  0xD6,  0x3A,  0x1F,  0x25,  0xB1,  0x7D,  0xF7 };
+	static uint8_t  tabPos1[] = {     2,     4,     3,     4,     5,     7,     6,     7 };
+	static uint8_t  tabPos2[] = {     3,     1,     5,     6,     0,     1,     0,     2 };
+
+	uint8_t 	*T1 = seka2_issuer->masktab;
+	uint8_t 	*T2 = seka2_SSE_3072;
+	uint8_t 	xorval = 0;
+	int idx1, idx2;
+	int i;
+
+	idx1 = (idx ^ 0x2B36) & 0x3FFF;
+	idx2 = idx1 & 0x0BFF;
+	for (i=0; i<8; i++)
+	{
+		idx1=(idx1 + tabIdx[i]) & 0x3FFF;
+		idx2=(idx2 + xorval) & 0xBFF;
+		xorval ^= T1[idx1] ^ tabXor[i];
+		data[tabPos1[i]] ^= xorval;
+		data[tabPos2[i]] ^= T2[idx2];
+	}
+}
+#endif	// _CANAL_NL_SUPPORT_
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#if 0
+void
+xseka_be_PRE_SSE_Core(uint8_t *buffer, uint8_t *data, int i, bool emm)
+{
+	uint8_t *T1 = seka2_SSE_3072;
+	uint8_t *T2 = seka2_SSE_2048;
+
+	uint8_t 	XorVal;
+	if (emm)
+		XorVal=0xB1;        // i's the same as 7.6 !
+	else
+		XorVal=0x9C;
+
+	buffer[0] = data[0] ^T1[i+0x0B];
+	buffer[1] = data[6] ^T2[i+0x07];
+	buffer[2] = data[2] ^T2[i+0x06] ^ XorVal;
+	buffer[3] = data[3] ^T1[i+0x0D];
+	buffer[4] = data[4] ^T1[i+0x15];
+	buffer[5] =~data[5];
+	buffer[6] = data[1] ^T1[i+0x13];
+	buffer[7] = data[14]^T2[i+0x0C] ^ XorVal;
+	buffer[8] = data[11]^T1[i+0x03];
+	buffer[9] = data[9] ^T1[i+0x09];
+	buffer[10]= data[10]^T2[i+0x0F];
+	buffer[11]= data[8] ^T1[i+0x0B];
+	buffer[12]= data[12]^T1[i+0x1B];
+	buffer[13]=~data[13];
+	buffer[14]= data[7] ^T1[i+0x10];
+	buffer[15]= data[15]^T2[i+0x04];
+
+}
+void
+xseka_be_POST_SSE_Core1(uint8_t *data, int pos)
+{
+	// modify 8 bytes before signature byte (0x82)
+	data[_BEFORE_S_+0] ^= 0xF4; data[_BEFORE_S_+1] ^= 0x6D;
+	data[_BEFORE_S_+2] -= 0xF5; data[_BEFORE_S_+3]  =~data[_BEFORE_S_ + 3];
+	data[_BEFORE_S_+4] ^= 0xA3; data[_BEFORE_S_+5] -= 0xC8;
+	data[_BEFORE_S_+6] ^= 0x83; data[_BEFORE_S_+7] ^= 0xD6;
+
+	data[_AFTER_S_ +0] -= 0xF1; data[_AFTER_S_ +1] ^= 0x62;
+	data[_AFTER_S_ +2] ^= 0xE0; data[_AFTER_S_ +3] -= 0x71;
+	data[_AFTER_S_ +4] ^= 0xBA; data[_AFTER_S_ +5] -= 0xd9;
+	data[_AFTER_S_ +6] ^= 0xDE; data[_AFTER_S_ +7] ^= 0x29;
+}
+
+void
+xseka_be_POST_SSE_Core2(uint8_t *buf, uint8_t *data, int pos, bool emm)
+{
+	uint8_t	*T1 = xseka_be_SSEP_256;
+	memcpy(buf,&T1[((data[_AFTER_S_+5]^0xB8)+0x0A)&0x7F],56);
+
+	if (emm)
+		buf[0x02]^=0xC4;
+	else
+		buf[0x02]^=0x41;
+}
+void
+xseka_be_POST_SSE_Core3(uint8_t *data, const uint8_t *buf, int pos)
+{
+	data[_BEFORE_S_+4]=buf[3];
+	data[_BEFORE_S_+5]=buf[1];
+	data[_BEFORE_S_+6]=buf[4];
+	data[_BEFORE_S_+7]=buf[5];
+	data[_AFTER_S_ +0]=buf[7];
+	data[_AFTER_S_ +1]=buf[0];
+	data[_AFTER_S_ +2]=buf[6];
+	data[_AFTER_S_ +3]=buf[2];
+}
+
+void
+xseka_be_POST_SSE_Core4(uint8_t *data, int pos)
+{
+	data[_AFTER_S_+0]=data[_BEFORE_S_+4] ^ 0x47; data[_AFTER_S_+1]=data[_BEFORE_S_+2] ^ 0x95;
+	data[_AFTER_S_+2]=data[_BEFORE_S_+5] ^ 0x1C; data[_AFTER_S_+3]=data[_BEFORE_S_+7] ^ 0xC3;
+	data[_AFTER_S_+4]=data[_BEFORE_S_+1] ^ 0x95; data[_AFTER_S_+5]=data[_BEFORE_S_+0] ^ 0x58;
+	data[_AFTER_S_+6]=data[_BEFORE_S_+6] ^ 0xA4; data[_AFTER_S_+7]=data[_BEFORE_S_+3] ^ 0x17;
+}
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#ifdef _CYFRA_SUPPORT_
+static int
+xseka_pl_Isprovid(uint16_t ident)
+{
+	if (ident == 0x65) return 1;
+	return 0;
+}
+
+static void
+xseka_pl_PRE_CW(uint8_t *data)
+{
+	uint8_t *XT = (uint8_t *)seka2_issuer->xt;
+	uint8_t *PT = (uint8_t *)seka2_issuer->pt;
+	uint8_t temp[16];
+	int i;
+
+	xseka_xxor(temp, 16, data, XT);
+	for (i=15; i>=0; i--) data[i] = temp[PT[i]];
+}
+
+static void
+xseka_pl_XOR_Chain(uint8_t *data, uint16_t idx)
+{
+	int i;
+	uint8_t *MT = (uint8_t *)seka2_issuer->masktab;
+
+	for(i=0; i<8; i++) data[i] ^= MT[idx++];
+}
+#endif	// _CYFRA_SUPPORT_
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+static void
+xseka_pre_sse_core(uint8_t *data, int pos)
+{
+	#ifdef _CYFRA_SUPPORT_
+		if (xseka_pl_Isprovid(seka_prid))
+		{
+
+	 	}
+	#endif	// _CYFRA_SUPPORT_
+
+	#ifdef _CANAL_NL_SUPPORT_
+		if (xseka_nl_Isprovid(seka_prid))
+		{
+			uint8_t 	tempbuf[80];
+			uint8_t 	*T1;
+			int i, j;
+
+			T1 = seka2_6A_SSEP_80;
+
+			data += pos + 5; // Start at offset 5
+			for (i=4; i>=0; i--)
+			{
+				j=i*16;
+				xseka_nl_PRE_SSE_Core(&tempbuf[j], &data[j], i);
+			}
+			for(i=79; i>=0; i--) data[i] = tempbuf[i]^T1[i];
+		}
+	#endif	// _CANAL_NL_SUPPORT_
+
+	#ifdef _CANAL_FR_SUPPORT_
+		if (xseka_fr_Isprovid(seka_prid))
+		{
+	 		uint8_t 	tempbuf[80];
+			uint8_t 	*T1;
+			int i, j;
+
+			T1 = seka2_80_SSEP_80;
+
+			data += pos + 5; // Start at offset 5
+			for (i=4; i>=0; i--)
+			{
+				j=i*16;
+				xseka_fr_PRE_SSE_Core(&tempbuf[j], &data[j], i);
+			}
+			for(i=79; i>=0; i--) data[i] = tempbuf[i] ^ T1[i];
+	 	}
+	#endif	// _CANAL_FR_SUPPORT_
+}
+
+static void
+xseka_post_sse_core(uint8_t *data, int pos)
+{
+	#ifdef _CYFRA_SUPPORT_
+		if (xseka_pl_Isprovid(seka_prid))
+		{
+
+	 	}
+	#endif	// _CYFRA_SUPPORT_
+
+	#ifdef _CANAL_NL_SUPPORT_
+		if (xseka_nl_Isprovid(seka_prid))
+		{
+			uint8_t 	digest [20];
+			uint8_t 	tempbuf[64];
+
+			xseka_nl_POST_SSE_Core1(data, pos);
+			// create the SHA hash buffer
+			memcpy(tempbuf+0,&data[_BEFORE_S_+0],4);
+			memcpy(tempbuf+4,&data[_AFTER_S_ +4],4);
+			xseka_nl_POST_SSE_Core2(tempbuf+8,data,pos);
+			// Calc Signature of the generated buffer here
+			SHA1_sekaSignature(tempbuf, sizeof(tempbuf), digest, FALSE, 0x00, 0x00);
+
+			// Prepare DES data
+			memcpy(tempbuf+0,&data[_BEFORE_S_+4],4);
+			memcpy(tempbuf+4,&data[_AFTER_S_ +0],4);
+
+			// DES Enrypt
+			DES_seka(digest, DES_ECS2_CRYPT, tempbuf);
+			// modify data with encrypted DES data
+			xseka_nl_POST_SSE_Core3(data,tempbuf,pos);
+			// save the signature
+			memcpy(tempbuf,data+_AFTER_S_,8);
+			xseka_nl_POST_SSE_Core4(data,pos);
+			// put the signature in the data
+			memcpy(data+_BEFORE_S_,tempbuf,8);
+		}
+	#endif	// _CANAL_NL_SUPPORT_
+
+	#ifdef _CANAL_FR_SUPPORT_
+		if (xseka_fr_Isprovid(seka_prid))
+		{
+			uint8_t 	digest [20];
+			uint8_t 	tempbuf[64];
+
+			xseka_fr_POST_SSE_Core1(data,pos);
+			// create the SHA hash buffer
+			memcpy(tempbuf+0,&data[_BEFORE_S_+0],4);
+			memcpy(tempbuf+4,&data[_AFTER_S_ +4],4);
+			xseka_fr_POST_SSE_Core2(tempbuf+8,data,pos);
+			// Calc Signature of the generated buffer here
+			SHA1_sekaSignature(tempbuf, sizeof(tempbuf), digest, FALSE, 0x00, 0x00);
+
+			// Prepare DES data
+			memcpy(tempbuf+0,&data[_BEFORE_S_+4],4);
+			memcpy(tempbuf+4,&data[_AFTER_S_ +0],4);
+
+			// DES Enrypt
+			DES_seka(digest, DES_ECS2_CRYPT, tempbuf);
+			// modify data with encrypted DES data
+			xseka_fr_POST_SSE_Core3(data,tempbuf,pos);
+			// save the signature
+			memcpy(tempbuf,data+_AFTER_S_,8);
+			xseka_fr_POST_SSE_Core4(data,pos);
+			// put the signature in the data
+			memcpy(data+_BEFORE_S_,tempbuf,8);
+	 	}
+	#endif	// _CANAL_FR_SUPPORT_
+}
+
+static void
+xseka_mod_signature(uint8_t *mod, uint8_t *pk)
+{
+	#ifdef _CANAL_FR_SUPPORT_
+		if (xseka_fr_Isprovid(seka_prid))
+		{
+			xseka_fr_MOD_Signature(mod, pk);
+	 	}
+	#endif	// _CANAL_FR_SUPPORT_
+}
+
+
+static void
+xseka_pre_cw(uint8_t *data)
+{
+	#ifdef _CYFRA_SUPPORT_
+		if (xseka_pl_Isprovid(seka_prid))
+		{
+			xseka_pl_PRE_CW(data);
+	 	}
+	#endif	// _CYFRA_SUPPORT_
+}
+
+static void
+xseka_post_cw(uint8_t *data)
+{
+	#ifdef _CANAL_NL_SUPPORT_
+		if (xseka_nl_Isprovid(seka_prid))
+		{
+			xseka_nl_POST_CW(data);
+		}
+	#endif	// _CANAL_NL_SUPPORT_
+
+	#ifdef _CANAL_FR_SUPPORT_
+		if (xseka_fr_Isprovid(seka_prid))
+		{
+			xseka_fr_POST_CW(data);
+	 	}
+	#endif	// _CANAL_FR_SUPPORT_
+}
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+static uint16_t
+xseka_mtab_GetIndex(uint8_t *data, int len)
+{
+	unsigned int sum = 0;
+	int i;
+
+	for (i=1; i<len; i+=2)
+	{
+		sum += ((data[i-1]<<8) + data[i]);
+	}
+	if (len&1) sum += (data[len-1]<<4);
+	return (sum & 0x3FFF);
+}
+
+
+static void
+xseka_mtab_XOR_Chain(uint8_t *data, uint16_t idx)
+{
+	#ifdef _CANAL_NL_SUPPORT_
+		if (xseka_nl_Isprovid(seka_prid))
+		{
+			xseka_nl_XOR_Chain(data, idx);
+	 	}
+	#endif	// _CANAL_NL_SUPPORT_
+
+	#ifdef _CANAL_FR_SUPPORT_
+		if (xseka_fr_Isprovid(seka_prid))
+		{
+			xseka_fr_XOR_Chain(data, idx);
+	 	}
+	#endif	// _CANAL_FR_SUPPORT_
+
+	#ifdef _CYFRA_SUPPORT_
+		if (xseka_pl_Isprovid(seka_prid))
+		{
+			xseka_pl_XOR_Chain(data, idx);
+	 	}
+	#endif	// _CYFRA_SUPPORT_
+}
+
+
+int
+xseka_sse_Decrypt(uint8_t *source, uint8_t *key, int n, int start, uint8_t *T1, uint8_t *T2)
+{
+	uint8_t 	ucLastBlock[8];
+	uint16_t	mtidx;
+	int sigStart = n-source[n-1]-9; // 82 <8 bytes> P5(sigStart)
+	int encrLen	 = sigStart-16;
+	int i;
+	int rest_bytes;
+
+	MYEMU_TRACE("xseka:encrLen = %x sigStart = %x\n", encrLen, sigStart);
+	if (encrLen >= n || encrLen < 0)
+	{
+		MYEMU_TRACE("xseka:encrLen(%d,%d) error in SE\n", encrLen, sigStart);
+		return 0;
+	}
+	if (sigStart < 16)
+	{
+		MYEMU_TRACE("xseka:sigStart(%d) error in SE\n", sigStart);
+		return 0;
+	}
+
+//	myprdump("Before xseka_sse_Decrypt", source, n);
+
+	xseka_Decrypt(source+sigStart-8, key, T1,T2);
+	mtidx = xseka_mtab_GetIndex(source+start, sigStart-8-start);
+	xseka_mtab_XOR_Chain(source+sigStart-8, mtidx);
+
+	for (i=start; i<encrLen; i+=8)
+	{
+		xseka_Decrypt(source+i,key,T1,T2);
+		mtidx = xseka_mtab_GetIndex(source+i+8, 8);
+		xseka_mtab_XOR_Chain(source+i, mtidx);
+	}
+
+	rest_bytes = sigStart & 0x07;
+	if (!rest_bytes) rest_bytes = 8;
+
+	// Last Block
+	memset(ucLastBlock, 0, 8);
+	memcpy(ucLastBlock, source+sigStart-rest_bytes, rest_bytes);
+	xseka_Decrypt(ucLastBlock,key,T1,T2);
+
+	xseka_Decrypt(source+i,key,T1,T2);
+
+	mtidx = xseka_mtab_GetIndex(ucLastBlock, 8);
+	xseka_mtab_XOR_Chain(source+i, mtidx);
+
+//	myprdump("After  xseka_sse_Decrypt", source, n);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static int
+xseka_nano0f_Process(int count, uint8_t *_Hashdw, uint8_t *pk, uint8_t *T1, uint8_t *T2)
+{
+	uint8_t 	*MT;
+	uint8_t 	buffA[8];
+	uint8_t 	buffB[16];
+	uint8_t 	buffC[16];
+	uint8_t 	buffD[16];
+	int	i;
+	int off;
+
+	if (count == 0) return 1;
+
+	MT = (uint8_t *)seka2_issuer->masktab;
+	while (count--)
+	{
+		xseka_swap8_4(_Hashdw);
+		memcpy(buffA,_Hashdw,8);
+		xseka_Decrypt(buffA,pk,seka2_issuer->t19x,seka2_issuer->t29x);
+
+		off = _seka_w16_(buffA,0,0x3FFF);
+		xseka_xxor(buffB, 8, &MT[off],&MT[0x3FFF-off]);
+		xseka_xxor(buffB, 8, buffB,&MT[(((buffA[6] ^ buffB[0])<<8) + (buffA[7] ^ buffB[ 7]))&0x3FFF]);
+
+		off = _seka_w16_(buffA,2,0x3FFF);
+		xseka_xxor(buffC,16, &MT[off],&MT[0x3FFF-off]);
+		xseka_xxor(buffC,16, buffC,&MT[(((buffA[6] ^ buffC[0])<<8) + (buffA[7] ^ buffC[15]))&0x3FFF]);
+
+		off = _seka_w16_(buffA,4,0x3FFF);
+		for (i=0; i<16; i++) off = _seka_w16_(MT,off,0x3FFF);
+
+		memcpy(buffD,buffB,8);
+		xseka_Decrypt(buffB,buffC,&MT[off],&MT[off+256]);
+
+		xseka_xxor(buffB,8,buffB,buffD);
+
+		xseka_Decrypt(buffB,pk,T1,T2);
+
+		xseka_xxor(_Hashdw,8,_Hashdw,buffB);
+	}
+
+	for (i=0; i<8; i++)
+	{
+		pk[i]   = buffB[i];
+		pk[i+8] = ~(_seka_sn8_(buffB[i]));
+	}
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static void
+xseka_nano51_AdditionalAlgo(uint8_t *data, uint8_t *key, int mode)
+{
+	static uint32_t adders[] =
+	{
+		0x0000,0xe555,0xafff,0x5ffe,0xf552,0x6ffb,0xcff9,0x154c,
+		0x3ff4,0x4ff1,0x4543,0x1fea,0xdfe6,0x8537,0x0fdd,0x7fd8
+	};
+	uint16_t *k  = (uint16_t *)key;
+	uint16_t *dd = (uint16_t *)data;
+	uint32_t	d1=dd[0], d2=dd[1], d3=dd[2], d4=dd[3];
+	int i;
+
+	if (!mode)
+	{
+		for(i=0; i<0x10; i++)
+		{
+			uint32_t adder = adders[i];
+
+			d1 += (k[0] + d3 + adder) ^ (k[1] + d4 + adder);
+			d2 += (k[2] + d3 + adder) ^ (k[3] + d4 + adder);
+			d1 = _seka_rr16_(d1,5);
+			d2 = _seka_rl16_(d2,3);
+			d3 += (k[0] + d1 + adder) ^ (k[1] + d2 + adder);
+			d4 += (k[2] + d1 + adder) ^ (k[3] + d2 + adder);
+			d3 = _seka_rl16_(d3,3);
+			d4 = _seka_rr16_(d4,5);
+		}
+	}
+	else
+	{
+		for (i=0xf; i>=0; i--)
+		{
+			uint32_t adder = adders[i];
+
+			d4 = _seka_rl16_(d4,5);
+			d3 = _seka_rr16_(d3,3);
+			d4 -= (k[2] + d1 + adder) ^ (k[3] + d2 + adder);
+			d3 -= (k[0] + d1 + adder) ^ (k[1] + d2 + adder);
+			d2 = _seka_rr16_(d2,3);
+			d1 = _seka_rl16_(d1,5);
+			d2 -= (k[2] + d3 + adder) ^ (k[3] + d4 + adder);
+			d1 -= (k[0] + d3 + adder) ^ (k[1] + d4 + adder);
+		}
+	}
+	dd[0]=d1; dd[1]=d2; dd[2]=d3; dd[3]=d4;
+}
+
+static void
+xseka_nano51_Crypto(uint8_t *data, uint8_t *key, uint8_t crypto, uint8_t mode)
+{
+	switch (crypto)
+	{
+		case 0: // Xor
+			xseka_xxor(data+0,8,key,data+0); xseka_xxor(data+8,8,key,data+8);
+			break;
+
+		case 1: // Seca crypto, with 9x table, always!
+		{
+			uint8_t pk[16];
+			uint8_t *T1 = seka2_issuer->t19x;
+			uint8_t *T2 = seka2_issuer->t29x;
+			memcpy(pk+0,key,8); memcpy(pk+8,key,8);
+
+			if (mode) { xseka_Decrypt(data,pk,T1,T2); xseka_Decrypt(data+8,pk,T1,T2); }
+			else     { xseka_Encrypt(data,pk,T1,T2); xseka_Encrypt(data+8,pk,T1,T2); }
+			break;
+		}
+
+		case 2: // DES crypto (Modified PC1,PC2)
+			// DES
+			DES_seka(key, (mode) ? DES_ECS2_DECRYPT : DES_ECS2_CRYPT, data);
+			DES_seka(key, (mode) ? DES_ECS2_DECRYPT : DES_ECS2_CRYPT, data+8);
+			break;
+
+		case 3: // Additional Algo
+			xseka_nano51_AdditionalAlgo(data,key,mode);
+			xseka_nano51_AdditionalAlgo(data+8,key,mode);
+			break;
+	}
+}
+
+
+static void
+xseka_nano51_Permute(uint8_t *data, uint8_t *pdata, uint8_t *P)
+{
+	int i;
+
+	if (!P) return;
+	for (i=7; i>=0; i--) data[i] = (P[i]) ? pdata[P[i]] : 0x0;
+}
+
+
+
+#define MAX_PERM51S	12
+typedef struct
+{
+  	uint8_t 	P1[8], P2[8], P3[8], P4[8];
+} SEKAII_PERM51;
+static SEKAII_PERM51	seka2_perm51[MAX_PERM51S] = {
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 0
+	{{2,4,4,3,2,2,4,4},{3,2,4,3,4,4,2,3},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 1
+	{{4,4,3,2,2,3,3,4},{4,2,3,4,3,2,4,2},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 2
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 3
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 4
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 5
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 6
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 7
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 8
+	{{4,4,3,2,3,4,3,2},{2,4,3,2,2,4,4,3},{2,3,4,1,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 9
+	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// A
+};
+
+
+typedef struct
+{
+	uint8_t	pl[8];
+	uint8_t	nl[8];
+} SEKAII_XOR512;
+typedef struct
+{
+	uint8_t 	pl5101[16];
+	uint8_t 	pl5102[16];
+	uint8_t 	pl5104[16];
+	uint8_t 	pl5105[16];
+	uint8_t 	pl5108[16];
+	uint8_t 	pl5109[16];
+} SEKAII_XOR51;
+
+static SEKAII_XOR512 seka2_xor512s =
+{
+//	{0, 3, 0, 5, 0, 0, 4, 3}, 	// 0065
+//	{4, 0, 0, 0, 3, 5, 4, 0}, 	// 0065
+//	{5, 0, 0, 4, 3, 0, 0, 5},  // 006A
+	{3, 0, 0, 0, 2, 4, 3, 0}, 	// 0065
+	{4, 0, 0, 3, 2, 0, 0, 4},	// 006A
+};
+static SEKAII_XOR51	seka2_xor51s  =
+{
+	{3, 5, 5, 4, 3, 3, 5, 5,	4, 3, 5, 4, 5, 5, 3, 4}, 	// 5101
+	{5, 5, 4, 3, 3, 4, 4, 5,	5, 3, 4, 5, 4, 3, 5, 3}, 	// 5102
+	{0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0}, 	// 5104
+	{0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0}, 	// 5105
+	{0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0},	// 5108
+	{5, 5, 4, 3, 4, 5, 4, 3,	3, 5, 4, 3, 3, 5, 5, 4},	// 5109
+};
+
+static uint8_t			seka2_step51[3] 	= { 3,4,5 };    	// 0065
+static uint8_t 		seka2_n51Exp[2]   = {0x11,0x00,};
+static uint8_t 		seka2_n51Mod[130] =
+{
+	0x7D, 0xD9, 0x1E, 0xB8, 0x30, 0x20, 0x73, 0x5D, 0x96, 0x1C, 0x36, 0xBD, 0x9F, 0xAA, 0xEC, 0x5C,
+	0x4B, 0x59, 0xD7, 0x23, 0xFF, 0x65, 0x8C, 0x86, 0xBB, 0x8A, 0x72, 0x88, 0x7E, 0x57, 0xF6, 0x7A,
+	0x52, 0xF8, 0xD3, 0x0B, 0x0A, 0xC6, 0x6D, 0x8B, 0x03, 0xE4, 0xCD, 0x91, 0xB6, 0xA8, 0x66, 0x94,
+	0x95, 0x64, 0x99, 0x60, 0xDA, 0xE1, 0x5C, 0x09, 0x80, 0xAD, 0xD9, 0x16, 0x4E, 0x0C, 0xA8, 0x80,
+	0xD8, 0x68, 0x12, 0x92, 0x1D, 0x15, 0xF8, 0xE5, 0x31, 0x8A, 0x81, 0x0D, 0x36, 0x3A, 0x1F, 0xF9,
+	0xA1, 0xFA, 0xAF, 0x6D, 0x54, 0x1A, 0xAF, 0x96, 0x4C, 0xB4, 0xCC, 0xF2, 0x86, 0x58, 0x18, 0xBC,
+	0x69, 0xF4, 0x54, 0x50, 0x77, 0xFB, 0x9D, 0x78, 0x86, 0xD9, 0xF0, 0x4F, 0xFF, 0x9F, 0x0A, 0xC8,
+	0x96, 0x9B, 0xC3, 0xF1, 0x3F, 0x1C, 0x97, 0x38, 0x5A, 0x26, 0x1E, 0x59, 0x63, 0x6E, 0x24, 0x05,
+	0x01, 0x00,
+};
+
+
+static int
+xseka_nano51_Process(struct s_reader *reader, uint8_t *_Dcw_p, uint8_t *_51src_p, uint8_t *_Hashdw, uint8_t *T1, uint8_t *T2)
+{
+	SEKAII_PERM51 *_51PT;
+	uint8_t 	_51Algo;
+	uint8_t 	buffF[8], buffG[16];
+	uint8_t 	buf80mask[6]={0,24,44,68,88,108};
+	uint8_t 	*xorptr_2 = 0;
+	uint8_t 	*xorptr = 0;
+	uint8_t 	xorbuf[24], xorBuf51[3];
+	uint8_t 	buf40[0x40], buf80[0x82], buf4[4], bufTMP[9], tmpHash[16];
+	uint8_t	tmpBuff[8], buffG1[8];
+	uint8_t	data5105[20], temp_sign[64], temp_swap;
+	uint16_t	*sdata5105;
+	int value,nextvalue;
+	int Hashlen = 20;	// define Hash length
+	int i,j,k;
+
+	if (!_51src_p) return 0;
+
+	_51Algo = (_51src_p[0] & 0x3F);
+	MYEMU_TRACE("xseka:51Algo = %02X {%04X}\n", _51Algo, seka_prid);
+
+	_51PT   = &seka2_perm51[_51Algo];
+	if (!_51PT)
+	{
+		MYEMU_TRACE("xseka:51Algo failed to get permutation table\n");
+		return 0;
+	}
+	//
+	//
+	// 5105.5109
+	//
+	//
+	//
+	switch (_51Algo)
+	{
+		case 0x01:
+		case 0x02:
+		case 0x05:
+		case 0x09:
+			memset(xorbuf, 0, sizeof(xorbuf));
+			switch (_51Algo)
+			{
+				case 0x01: 	xorptr = seka2_xor51s.pl5101; break;
+				case 0x02: 	xorptr = seka2_xor51s.pl5102; break;
+				case 0x04: 	xorptr = seka2_xor51s.pl5104; break;
+				case 0x05: 	xorptr = seka2_xor51s.pl5105; break;
+				case 0x08: 	xorptr = seka2_xor51s.pl5108; break;
+				case 0x09: 	xorptr = seka2_xor51s.pl5109; break;
+			}
+			switch (seka_prid)
+			{
+				case 0x80:
+				case 0x81:
+				case 0x82:
+				case 0x84:
+				case 0x86:
+				case 0x65: 	xorptr_2 = seka2_xor512s.pl; break;
+				case 0x6A:
+				case 0x6B:
+				case 0x6C:
+				case 0x6D:	xorptr_2 = seka2_xor512s.nl; break;
+				default:		xorptr_2 = 0;
+			}
+			if (!xorptr || !xorptr_2)
+			{
+				MYEMU_TRACE("xseka:51Algo failed to get xor51 table\n");
+				return 0;
+			}
+			for (i=0; i<16; i++) if (xorptr[i]) xorbuf[i] = _51src_p[(xorptr[i]-1)];
+			for (i=16;i<24; i++) if (xorptr_2[i-16]) xorbuf[i] = _51src_p[(xorptr_2[i-16])];
+
+			// special permutation seca2 V7.3
+			switch (seka_prid)
+			{
+				case 0x6A:
+				case 0x6B:
+				case 0x6C:
+				case 0x6D:
+					tmpHash[ 0] = _Hashdw[ 4];	tmpHash[ 1] = _Hashdw[11];
+					tmpHash[ 2] = _Hashdw[ 0];	tmpHash[ 3] = _Hashdw[12];
+					tmpHash[ 4] = _Hashdw[ 3];	tmpHash[ 5] = _Hashdw[10];
+					tmpHash[ 6] = _Hashdw[ 2];	tmpHash[ 7] = _Hashdw[15];
+					tmpHash[ 8] = _Hashdw[ 9];	tmpHash[ 9] = _Hashdw[ 5];
+					tmpHash[10] = _Hashdw[13];	tmpHash[11] = _Hashdw[ 6];
+					tmpHash[12] = _Hashdw[ 1];	tmpHash[13] = _Hashdw[14];
+					tmpHash[14] = _Hashdw[ 7];	tmpHash[15] = _Hashdw[ 8];
+					break;
+				default:
+					memcpy(tmpHash, _Hashdw, 8);	// copy first 8 bytes HASH to tmpHash
+					break;
+			}
+			break;
+
+		default:
+			MYEMU_TRACE("xseka:51Algo(%02X) data incorrect or proccessing not needed\n", _51Algo);
+			return 0;
+	}
+	//
+	//
+	//
+	switch (_51Algo)
+	{
+		case 0x01:
+		case 0x02:
+			{
+				int addAlgoMode;
+
+				// Permutation 1
+				xseka_nano51_Permute(buffF,_51src_p,_51PT->P1);
+
+				xseka_xxor(buffG,8,buffF,_Hashdw);
+
+				addAlgoMode=(_51src_p[0]&1)^1;
+				for (i=(_51src_p[1]&0x0f); i>0; i--) xseka_nano51_AdditionalAlgo(buffG,_Hashdw+8,addAlgoMode);
+				// Permutation 2
+				xseka_nano51_Permute(buffF,_51src_p,_51PT->P2);
+				xseka_xxor(buffG,8,buffF,buffG);
+
+				// Permutation 3
+				xseka_nano51_Permute(buffF,_51src_p,_51PT->P3);
+				xseka_xxor(buffG,8,buffF,buffG);
+				// Permutation 4
+				xseka_nano51_Permute(buffF,_51src_p,_51PT->P4);
+				xseka_xxor(buffG,8,buffF,buffG);
+				break;
+			}
+
+		case 0x05:	// nano 51 05 algo
+				//buff11 = tmpHash
+				switch (seka_prid)
+				{
+					case 0x65:
+						tmpBuff[0] = _51src_p[2] ^ tmpHash[0];
+						tmpBuff[1] =  tmpBuff[0] ^ tmpHash[1];
+						tmpBuff[2] = _51src_p[4] ^ tmpHash[2];
+						tmpBuff[3] =  tmpBuff[2] ^ tmpHash[3];
+						tmpBuff[4] = _51src_p[3] ^ tmpHash[4];
+						tmpBuff[5] =  tmpBuff[4] ^ tmpHash[5];
+						tmpBuff[6] =  tmpBuff[3] ^ tmpHash[6];
+						tmpBuff[7] =  tmpBuff[5]  ^tmpHash[7];
+						break;
+					case 0x6A:
+					case 0x6B:
+					case 0x6C:
+					case 0x6D:
+						tmpBuff[4] = _51src_p[2] ^ tmpHash[6];
+						tmpBuff[3] = _seka_sn8_((tmpBuff[4] ^ tmpHash[0]));
+						tmpBuff[2] = _51src_p[4] ^ tmpHash[5];
+						tmpBuff[0] =  tmpBuff[3] ^ tmpHash[1];
+						tmpBuff[5] = _seka_sn8_(_51src_p[3]) ^ tmpHash[7];
+						tmpBuff[6] =  tmpBuff[5] ^ tmpHash[2];
+						tmpBuff[7] =  tmpBuff[2] ^ tmpHash[4];
+						tmpBuff[1] =  tmpBuff[0] ^ tmpHash[3];
+						break;
+					default:
+						MYEMU_TRACE("xseka:51Algo(%02X) data incorrect\n", _51Algo);
+						return 0;
+				}
+
+				for (i=0; i<4; i++)
+				{
+					temp_swap = tmpBuff[7-i];
+					tmpBuff[7-i]=tmpBuff[i];
+					tmpBuff[i]=temp_swap;
+				}
+				for (i=0; i<64; i+=8) memcpy(&temp_sign[i], tmpBuff, 8);
+
+				// Calc Signature of the generated buffer here
+				SHA1_sekaSignature(temp_sign, 0x40, data5105, FALSE, 0x00, 0x00);
+
+				for (i=0; i<10; i++)
+				{
+					temp_swap 		= data5105[19-i];
+					data5105[19-i] = data5105[i];
+					data5105[i] 	= temp_swap;
+				}
+				sdata5105 = (unsigned short *)data5105;
+				sdata5105[1] = ~sdata5105[0];
+				for (i=0; i<15; i++)
+				{
+					sdata5105[9] += sdata5105[0];
+					sdata5105[8] += sdata5105[1];
+					sdata5105[7] += (sdata5105[8] + sdata5105[4]) ^ (sdata5105[9] + sdata5105[5]);
+					sdata5105[6] += ((~sdata5105[8]) + sdata5105[5]) ^ ((~sdata5105[9]) + sdata5105[4]);
+					sdata5105[5] -= (sdata5105[8]+sdata5105[6]) ^ (sdata5105[9]+sdata5105[7]);
+					sdata5105[4] -= ((~sdata5105[8])+sdata5105[7]) ^ ((~sdata5105[9])+sdata5105[6]);
+				}
+				sdata5105[0]=sdata5105[7];
+				sdata5105[1]=sdata5105[6];
+				sdata5105[2]=sdata5105[5];
+				sdata5105[3]=sdata5105[4];
+				memcpy(tmpHash, data5105, 8);
+
+				switch (seka_prid)
+				{
+					case 0x65:
+						buffG[0]=_51src_p[2]^tmpHash[0];
+						buffG[1]=_51src_p[4]^tmpHash[1];
+						buffG[2]=_51src_p[3]^tmpHash[2];
+						buffG[3]=buffG[0]^tmpHash[3];
+						buffG[4]=buffG[3]^tmpHash[4];
+						buffG[5]=buffG[2]^tmpHash[5];
+						buffG[6]=buffG[1]^tmpHash[6];
+						buffG[7]=buffG[5]^tmpHash[7];
+						break;
+					case 0x6A:
+					case 0x6B:
+					case 0x6C:
+					case 0x6D:
+						buffG[6]=_51src_p[3]^tmpHash[7];
+						buffG[3]=_seka_sn8_((_51src_p[4]^tmpHash[3]));
+						buffG[2]=_51src_p[2]^tmpHash[2];
+						buffG[1]=0-(buffG[3]^tmpHash[4]);
+						buffG[7]=buffG[6]^tmpHash[1];
+						buffG[0]=buffG[2]^tmpHash[5];
+						buffG[5]=buffG[1]^tmpHash[0];
+						buffG[4]=buffG[7]^tmpHash[6];
+						break;
+				}
+				break;
+
+		case 0x09:	// nano 51 09 algo
+			#if 0
+				{
+					uint8_t 	buff1[128], buff2[64], buff3[9];
+					uint32_t sum = 0;
+
+					// prepare buffers for rsa data
+					for (i=0; i<20; i++)
+						buff1[i]=buff2[i]=buff2[i+20]=buff2[i+40]=_Hashdw[i];
+					memcpy(buff3,_51src_p+2,3);
+					for (i=0; i< 8; i++)
+						buff1[i] = buff3[_51PT->P1[i]-2] ^= buff1[i];
+
+					for (i=0; i<20; i++)
+						buff1[i+24]=buff1[i+44]=buff1[i+68]=buff1[i+88]=buff1[i+108]=buff1[i];
+
+					for (i=0; i< 4; i++)
+					{
+						uint8_t t=_51src_p[_51PT->P3[i]];
+
+						if (_51PT->P3[i]==1) t&=0x0F;
+						buff1[i+20]=buff1[i+64]=buff2[i+60]=t;
+					}
+
+					memcpy(buff3,buff1,9);
+					for (j=0; j<64; j++)
+					{ // XOR even with buff2, odd with 0xFF
+						buff1[ j*2   ] ^= buff2[j];
+						buff1[(j*2)+1] ^= 0xFF;
+					}
+
+					// RSA decrypt
+					BN_bin2bn(seka2_n51Mod, 128, &er_n51Mod);
+					BN_bin2bn(seka2_n51Exp, 1, &er_n51Exp);
+			      rdr_RSA_decrypt(reader, buf80, buf80, 128, &er_n51Exp, &er_n51Mod, 1);
+
+					sum=0;
+					for (j=0; j<9; j++)
+					{
+						uint32_t nextSum=(buff1[j]&0x80) ? 1:0;
+						buff1[j]=(sum+2*buff1[j])^buff3[j];
+						sum=nextSum;
+					}
+
+					memcpy(buffG,buff1,8);
+					memcpy(buff3,_51src_p+2,3);
+					for (i=0; i<8; i++)
+						buffG[i] = buff3[_51PT->P2[i]-2] ^= buffG[i];
+					break;
+				}
+			#else
+				{
+					i=0;
+					for(j=0;j<3;j++) {
+					// sky(???)
+					//	k = seka2_step51[i+j-1];
+						k = seka2_step51[j];
+						buf4[j] = _51src_p[k];
+					}
+					buf4[3] = _51src_p[1] & 0x0F;
+					for(j=0;j<60;j+=20) memcpy (&buf40[j], _Hashdw, Hashlen);
+					memcpy (&buf40[60], buf4, 4);
+					memcpy(xorBuf51, &_51src_p[2], 3);
+					memcpy(tmpHash, _Hashdw,8);
+					for(i=0;i<8;i++)
+					{
+						xorBuf51[(xorptr[i]-3)] ^= _Hashdw[i];
+						_Hashdw[i] = xorBuf51[(xorptr[i]-3)];
+					}
+					for(i=0;i<6;i++) memcpy (&buf80[buf80mask[i]], _Hashdw, Hashlen);
+					memcpy (&buf80[20], buf4, 4);
+					memcpy (&buf80[64], buf4, 4);
+					memcpy(bufTMP,buf80,9);
+					for (i=0; i<0x40; i++)
+					{
+						buf80[i*2]^= buf40[i];
+						buf80[(i*2)+1]^=0xFF;
+					}
+					buf80[0x80]=0;
+					buf80[0x81]=0;
+					// RSA decrypt
+					BN_bin2bn(seka2_n51Mod, 130, &er_n51Mod);
+					BN_bin2bn(seka2_n51Exp, 1, &er_n51Exp);
+			      rdr_RSA_decrypt(reader, buf80, buf80, 130, &er_n51Exp, &er_n51Mod, 1);
+					value = 0;
+					for (i=0; i<9; i++)
+					{
+						nextvalue = (buf80[i] & 0x80) ? 1 : 0;
+						value += 2 * buf80[i];
+						buf80[i]= value ^ bufTMP[i];
+						value= nextvalue;
+					}
+					memcpy(_Hashdw, buf80, 8);
+					memcpy(xorBuf51, &_51src_p[2], 3);
+					for(i=0;i<8;i++)
+					{
+						xorBuf51[(xorptr[i+8]-3)] ^= _Hashdw[i];
+						_Hashdw[i] = xorBuf51[(xorptr[i+8]-3)];
+					}
+					memcpy(buffG, _Hashdw, 8);
+					memcpy(_Hashdw, tmpHash,8);
+					break;
+				}
+			#endif
+	}
+
+	// FINAL PERMUTATION
+	switch (_51Algo)
+	{
+		case 0x05:
+		case 0x09:
+			// special permutation seca2 V7.3+
+			switch (seka_prid)
+			{
+				case 0x6A:
+				case 0x6B:
+				case 0x6C:
+				case 0x6D:
+					memcpy(buffG1,buffG,8);
+					buffG[2]=buffG1[5];
+					buffG[6]=buffG1[4];
+					buffG[1]=buffG1[3];
+					buffG[7]=buffG1[2];
+					buffG[4]=buffG1[1];
+					buffG[5]=buffG1[6];
+					buffG[0]=buffG1[0];
+					buffG[3]=buffG1[7];
+					break;
+			}
+			break;
+	}
+
+	xseka_nano51_Crypto(_Dcw_p, buffG,  (_51src_p[1]>>6)&0x03, _51src_p[0]&0x80);
+
+	// FINAL PERMUTATION
+	xseka_nano51_Permute(buffF,_51src_p, xorptr_2);
+	xseka_xxor(_Dcw_p,  8,_Dcw_p,  buffF);
+	xseka_xxor(_Dcw_p+8,8,_Dcw_p+8,buffF);
+
+	xseka_nano51_Crypto(_Dcw_p, _Hashdw, (_51src_p[1]>>4)&0x03, _51src_p[0]&0x40);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+static int
+xseka_chkSignatures(void)
+{
+	#ifdef _CANAL_NL_SUPPORT_
+		if (xseka_nl_Isprovid(seka_prid)) return 0;
+	#endif	// _CANAL_NL_SUPPORT_
+	return 1;
+}
+
+static int
+xseka_chkDeskey(struct s_reader *reader, uint16_t seka2, uint32_t provid, uint8_t keynr, uint8_t *cDeskey)
+{
+	int ksize = (seka2) ? 16 : 8;
+
+	if (er_KPRID == provid && er_KNR == keynr)
+	{
+		memcpy(cDeskey, er_KKEY, 0x10);
+		MYEMU_TRACE("xseka:KEY.%02X:%02X:%02X..%02X\n", provid, keynr, cDeskey[0], cDeskey[ksize-1]);
+		return 1;
+	}
+
+	if (!XEMUKEY_Searchkey(reader, CASS_SEKA, provid, keynr, cDeskey, ksize))
+	{
+		MYEMU_TRACE("xseka:KEY{%04X.%02X} not found\n", provid, keynr);
+		return 0;
+	}
+	er_KNR = keynr;
+	er_KPRID = provid;
+	er_KFOUND = 1;
+	memcpy(er_KKEY, cDeskey, ksize);
+	MYEMU_TRACE("xseka:KEY.%02X:%02X:%02X..%02X\n", provid, keynr, cDeskey[0], cDeskey[ksize-1]);
+	return 1;
+}
+
+
+
+int
+XSEKA_Process(struct s_reader *reader, ECM_REQUEST *er, uint8_t *cw)
+{
+	uint8_t	*Ecm_p;
+	uint8_t	*crypt;
+	uint8_t 	*T1, *T2;
+	uint8_t 	*source = 0;
+	uint32_t	provid;
+	uint8_t 	pk[16], signatures[20];
+	uint8_t 	workbuf[256];
+	// actually 16 bytes used for processing, but SHA needs more
+	uint8_t 	_dwHAsh[28];
+	uint8_t 	*_Dcw_p   = 0;
+	uint8_t 	*_51src_p = 0;
+	int _0fMax	 = 0;
+
+	int hx;
+	int ident;
+	int p4;
+	int sMode;
+	int bSekaSE = 0;
+	int bSeka2 = 0;
+	int bSignature = 0;
+	int chkSignature = 0;
+	int msgsize, keynr;
+	int decrlen;
+	int i;
+
+	Ecm_p = er->ecm;
+//	memcpy(Ecm_p, ECM_TEST, SCT_LEN(ECM_TEST));
+	myprdump("Seka::Ecm_p", Ecm_p, SCT_LEN(Ecm_p));
+	msgsize = xseka_sct_payload(Ecm_p, (uint8_t **)&source);
+	if (!source) return 0;
+	myprdump("Seka::source", source, msgsize);
+
+	ident = xseka_sct_prid(Ecm_p);
+	keynr = xseka_sct_keynr(Ecm_p);
+	sMode = xseka_sct_sysmode(Ecm_p);
+	// RAI
+	if (ident == 0x0202) ident = 0x0030;
+	if (ident == 0x02E2) ident = 0x0030;
+	//
+	// 	SEKA_2
+	// 	PROV:006A,006C (??? source[0]:0x00, keynr:0x0E)
+	if (source[0] == 0x10) bSeka2 = 1;
+	if (xseka_isSeka2available(ident))
+	{
+		MYEMU_TRACE("xseka:SEKA2{%04X}\n", ident);
+		return 0;
+	}
+	MYEMU_TRACE("xseka:(%04X:%02X)Len=%02X\n", ident, keynr, msgsize);
+
+	seka_prid = ident;
+	provid = ident;
+
+	if (!xseka_chkDeskey(reader, bSeka2, provid, keynr&0xf, pk)) return 0;
+	if (!(sMode & 0x10)) memcpy(pk + 8, pk, 8);
+
+	if (bSeka2)
+	{
+		if (msgsize < 0x5C)
+		{
+			MYEMU_TRACE("xseka:ECM length too small (%d)\n", msgsize);
+			return 0;
+		}
+		if (keynr & 0x80)
+		{
+			MYEMU_TRACE("xseka:SE enabled\n");
+			bSekaSE = 1;
+		}
+		// select suitable provi and issuer_p
+		seka2_provi  = xseka_getSeka2provi(ident);
+		seka2_issuer = xseka_getSeka2issuer(ident);
+		if (!seka2_provi)  return 0;
+		if (!seka2_issuer) return 0;
+
+		if (bSekaSE)
+		{
+			xseka_pre_sse_core(source, msgsize - 0x5A);
+		}
+		// choose suitable RSA keys
+		p4 = source[1] & 7;
+		if (p4 == 3) p4 = 1;
+		else if (p4 == 7) p4 = 2;
+		else p4 = 0;
+
+		// RSA decrypt
+		crypt = source + (msgsize - 0x5A);
+		BN_bin2bn(seka2_provi->ecmMods[p4], 90, &er_ecmMod);
+		BN_bin2bn(seka2_provi->ecmExps[p4],  6, &er_ecmExp);
+      rdr_RSA_decrypt(reader, crypt, crypt, 90, &er_ecmExp, &er_ecmMod, 1);
+		if (bSekaSE)
+		{
+			// PostSSE needed
+			int signp = msgsize - source[msgsize - 1] - 9;
+
+			if (signp >= (msgsize - 9) || source[signp] != 0x82)
+			{
+				MYEMU_TRACE("xseka:RSA decrypt failed, signatures pointer not found\n");
+				return 0;
+			}
+			xseka_post_sse_core(source, signp);
+		}
+	}
+
+	hx = keynr >> 4;
+ 	if (hx == 0x9)
+ 	{
+		T1 = seka2_issuer->t19x;
+		T2 = seka2_issuer->t29x;
+	}
+	else
+ 	if (hx == 0xB)
+ 	{
+		T1 = seka2_issuer->t1Bx;
+		T2 = seka2_issuer->t2Bx;
+	}
+	else
+ 	if (hx == 0xF)
+ 	{
+		T1 = seka2_issuer->t1Fx;
+		T2 = seka2_issuer->t2Fx;
+	}
+	else
+	{
+		T1 = seka_T1;
+		T2 = seka_T2;
+	}
+
+//	myprdump("T1", T1, 16);
+//	myprdump("T2", T2, 16);
+//	myprdump("MT", seka2_issuer->masktab, 16);
+
+	decrlen = msgsize;
+	memcpy(workbuf, source, msgsize);
+
+	if (bSekaSE)
+	{
+		decrlen -= workbuf[msgsize - 1];
+		MYEMU_TRACE("xseka:decrlen = %d\n", decrlen);
+		if (decrlen < 8) return 0;
+
+		SHA1_sekaSignature(workbuf,
+						decrlen - 8,
+						signatures,
+						TRUE,
+						seka2_issuer->shapad,
+						seka2_issuer->shaend);
+
+		xseka_mod_signature(signatures, pk);
+
+		xseka_Encrypt(signatures, pk, T1, T2);
+//		myprdump("signatures", signatures, 8);
+
+		if (xseka_chkSignatures())
+		{
+			if (memcmp(signatures, &workbuf[decrlen-8], 8))
+			{
+				MYEMU_TRACE("xseka:signatures check failed before SE decrypt\n");
+				return 0;
+			}
+		}
+
+		if (!xseka_sse_Decrypt(workbuf + 2, pk, msgsize - 2, 8, T1, T2))
+		{
+			MYEMU_TRACE("xseka:SE decrypt failed\n");
+			return 0;
+		}
+	}
+	else
+	{
+		xseka_calc_signatures(workbuf, decrlen - 8, signatures, pk, T1, T2);
+	}
+
+	memset(_dwHAsh,0,sizeof(_dwHAsh));
+
+	for (i=0 ; i<decrlen; )
+	{
+		uint8_t 	param = workbuf[i++];
+		uint8_t 	extra = (param >> 4) & 0x0f;
+
+		switch (extra)
+		{
+			case 0x0d: extra=0x10; break;
+			case 0x0e: extra=0x18; break;
+			case 0x0f: extra=0x20; break;
+		}
+		myprintf("xseka;:nano:%02X.%d\n", param, extra);
+
+		switch (param)
+		{
+			case 0x0f:
+				if (bSekaSE) _0fMax++;
+				break;
+
+			case 0x51:
+				if (bSekaSE) _51src_p = &workbuf[i];
+				break;
+
+			case 0xd1:
+				_Dcw_p = &workbuf[i];
+				if (bSekaSE)
+				{
+					SHA1_sekaSignature(workbuf, i, _dwHAsh, FALSE, 0x00, 0x00);
+					memcpy(&_dwHAsh[20],_dwHAsh,20);
+					xseka_Decrypt(&_dwHAsh[20], pk, seka2_issuer->t19x, seka2_issuer->t29x);
+					SHA1_sekaSignature(_dwHAsh, 28, _dwHAsh, FALSE, 0x00, 0x00);
+				}
+				break;
+
+			case 0x82:
+				bSignature = 1;
+				if (!bSekaSE) chkSignature = 1;
+				if (xseka_chkSignatures()) chkSignature = 1;
+				if (!chkSignature) break;
+
+				if (memcmp(&workbuf[i],signatures,8))
+				{
+					MYEMU_TRACE("xseka:signatures check failed after decrypt\n");
+					_Dcw_p = 0;
+					bSignature = 0;
+					i = decrlen;
+				}
+				break;
+		}
+		i+=extra;
+	}
+
+	if (_Dcw_p && bSignature)
+	{
+		if (!_0fMax || xseka_nano0f_Process(_0fMax,_dwHAsh,pk,T1,T2))
+		{
+			if (bSekaSE)
+			{
+				xseka_pre_cw(_Dcw_p);
+			}
+			if (!_51src_p || xseka_nano51_Process(reader, _Dcw_p,_51src_p,_dwHAsh,T1,T2))
+			{
+				xseka_Decrypt(&_Dcw_p[0],pk,T1,T2);
+				xseka_Decrypt(&_Dcw_p[8],pk,T1,T2);
+			//	myprdump("decrypted CW", _Dcw_p, 16);
+
+				if (bSekaSE)
+				{
+					xseka_post_cw(_Dcw_p);
+				}
+				memcpy(cw, &_Dcw_p[0], 8);
+				memcpy(cw+8, &_Dcw_p[8], 8);
+				MYEMU_TRACE("xseka:cw{%02X...%02X,%02X...%02X}\n", cw[0], cw[7], cw[8], cw[15]);
+				return 1;
+			}
+		}
+	}
+	MYEMU_TRACE("xseka:cw failed.\n");
+	return 0;
+}
+
+
+void
+XSEKA_Cleanup(void)
+{
+	MYEMU_TRACE("xseka:clean\n");
+	er_KFOUND = 0;
+	er_KNR 	 = 0;
+	er_KPRID	 = 0x0;
+	memset(er_KKEY, 0x0, 16);
+}
+
+#endif	// defined(__XCAS_SEKA__)
+#endif	// defined(MODULE_XCAS)
+
Index: emu-xviacess.c
===================================================================
--- emu-xviacess.c	(nonexistent)
+++ emu-xviacess.c	(working copy)
@@ -0,0 +1,3256 @@
+#include "globals.h"
+#if defined(MODULE_XCAS)
+#include "oscam-client.h"
+#include "oscam-ecm.h"
+#include "oscam-net.h"
+#include "oscam-chk.h"
+#include "oscam-string.h"
+#include "cscrypt/des_ssl.h"
+#include "cscrypt/aes_ctx.h"
+#include "module-xcas.h"
+#if defined(__XCAS_VIACESS__)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static int16_t		er_KFOUND;
+static uint32_t	er_KPRID;
+static uint8_t		er_KNR;
+static uint8_t		er_KKEY[16];
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#define E_DIM	48
+static uint8_t via1_E[E_DIM] =
+{
+	32, 1, 2, 3, 4, 5,
+	 4, 5, 6, 7, 8, 9,
+	 8, 9,10,11,12,13,
+	12,13,14,15,16,17,
+	16,17,18,19,20,21,
+	20,21,22,23,24,25,
+	24,25,26,27,28,29,
+	28,29,30,31,32, 1
+};
+
+#define S_BOXES 8
+#define S_DIM	64
+static uint8_t via1_S[S_BOXES][S_DIM] =
+{
+	{	0xe,0x0,0x4,0xf,0xd,0x7,0x1,0x4,0x2,0xe,0xf,0x2,0xb,0xd,0x8,0x1,
+		0x3,0xa,0xa,0x6,0x6,0xc,0xc,0xb,0x5,0x9,0x9,0x5,0x0,0x3,0x7,0x8,
+		0x4,0xf,0x1,0xc,0xe,0x8,0x8,0x2,0xd,0x4,0x6,0x9,0x2,0x1,0xb,0x7,
+		0xf,0x5,0xc,0xb,0x9,0x3,0x7,0xe,0x3,0xa,0xa,0x0,0x5,0x6,0x0,0xd
+	},
+	{	0xf,0x3,0x1,0xd,0x8,0x4,0xe,0x7,0x6,0xf,0xb,0x2,0x3,0x8,0x4,0xe,
+		0x9,0xc,0x7,0x0,0x2,0x1,0xd,0xa,0xc,0x6,0x0,0x9,0x5,0xb,0xa,0x5,
+		0x0,0xd,0xe,0x8,0x7,0xa,0xb,0x1,0xa,0x3,0x4,0xf,0xd,0x4,0x1,0x2,
+		0x5,0xb,0x8,0x6,0xc,0x7,0x6,0xc,0x9,0x0,0x3,0x5,0x2,0xe,0xf,0x9
+	},
+	{	0xa,0xd,0x0,0x7,0x9,0x0,0xe,0x9,0x6,0x3,0x3,0x4,0xf,0x6,0x5,0xa,
+		0x1,0x2,0xd,0x8,0xc,0x5,0x7,0xe,0xb,0xc,0x4,0xb,0x2,0xf,0x8,0x1,
+		0xd,0x1,0x6,0xa,0x4,0xd,0x9,0x0,0x8,0x6,0xf,0x9,0x3,0x8,0x0,0x7,
+		0xb,0x4,0x1,0xf,0x2,0xe,0xc,0x3,0x5,0xb,0xa,0x5,0xe,0x2,0x7,0xc
+	},
+	{	0x7,0xd,0xd,0x8,0xe,0xb,0x3,0x5,0x0,0x6,0x6,0xf,0x9,0x0,0xa,0x3,
+		0x1,0x4,0x2,0x7,0x8,0x2,0x5,0xc,0xb,0x1,0xc,0xa,0x4,0xe,0xf,0x9,
+		0xa,0x3,0x6,0xf,0x9,0x0,0x0,0x6,0xc,0xa,0xb,0x1,0x7,0xd,0xd,0x8,
+		0xf,0x9,0x1,0x4,0x3,0x5,0xe,0xb,0x5,0xc,0x2,0x7,0x8,0x2,0x4,0xe
+	},
+	{	0x2,0xe,0xc,0xb,0x4,0x2,0x1,0xc,0x7,0x4,0xa,0x7,0xb,0xd,0x6,0x1,
+		0x8,0x5,0x5,0x0,0x3,0xf,0xf,0xa,0xd,0x3,0x0,0x9,0xe,0x8,0x9,0x6,
+		0x4,0xb,0x2,0x8,0x1,0xc,0xb,0x7,0xa,0x1,0xd,0xe,0x7,0x2,0x8,0xd,
+		0xf,0x6,0x9,0xf,0xc,0x0,0x5,0x9,0x6,0xa,0x3,0x4,0x0,0x5,0xe,0x3
+	},
+	{	0xc,0xa,0x1,0xf,0xa,0x4,0xf,0x2,0x9,0x7,0x2,0xc,0x6,0x9,0x8,0x5,
+		0x0,0x6,0xd,0x1,0x3,0xd,0x4,0xe,0xe,0x0,0x7,0xb,0x5,0x3,0xb,0x8,
+		0x9,0x4,0xe,0x3,0xf,0x2,0x5,0xc,0x2,0x9,0x8,0x5,0xc,0xf,0x3,0xa,
+		0x7,0xb,0x0,0xe,0x4,0x1,0xa,0x7,0x1,0x6,0xd,0x0,0xb,0x8,0x6,0xd
+	},
+	{	0x4,0xd,0xb,0x0,0x2,0xb,0xe,0x7,0xf,0x4,0x0,0x9,0x8,0x1,0xd,0xa,
+		0x3,0xe,0xc,0x3,0x9,0x5,0x7,0xc,0x5,0x2,0xa,0xf,0x6,0x8,0x1,0x6,
+		0x1,0x6,0x4,0xb,0xb,0xd,0xd,0x8,0xc,0x1,0x3,0x4,0x7,0xa,0xe,0x7,
+		0xa,0x9,0xf,0x5,0x6,0x0,0x8,0xf,0x0,0xe,0x5,0x2,0x9,0x3,0x2,0xc
+	},
+	{	0xd,0x1,0x2,0xf,0x8,0xd,0x4,0x8,0x6,0xa,0xf,0x3,0xb,0x7,0x1,0x4,
+		0xa,0xc,0x9,0x5,0x3,0x6,0xe,0xb,0x5,0x0,0x0,0xe,0xc,0x9,0x7,0x2,
+		0x7,0x2,0xb,0x1,0x4,0xe,0x1,0x7,0x9,0x4,0xc,0xa,0xe,0x8,0x2,0xd,
+		0x0,0xf,0x6,0xc,0xa,0x9,0xd,0x0,0xf,0x3,0x3,0x5,0x5,0x6,0x8,0xb
+	}
+};
+
+#define P_DIM	32
+static uint8_t	via1_P	[P_DIM] =
+{
+	16, 7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10,
+	 2, 8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25
+};
+
+#define PC2_DIM 48
+static uint8_t	via1_PC2	[PC2_DIM] =
+{
+	14,17,11,24, 1, 5,
+	 3,28,15, 6,21,10,
+	23,19,12, 4,26, 8,
+	16, 7,27,20,13, 2,
+	41,52,31,37,47,55,
+	30,40,51,45,33,48,
+	44,49,39,56,34,53,
+	46,42,50,36,29,32
+};
+
+#define LS_DIM	16
+static uint8_t	via1_LS	[LS_DIM] =
+{
+	1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
+};
+
+#define IP_DIM	64
+static uint8_t	via1_IP	[IP_DIM] =
+{
+	58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,
+	62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,
+	57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3,
+	61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7
+};
+
+#define IP1_DIM	64
+static uint8_t	via1_IP1	[IP1_DIM] =
+{
+	40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,
+	38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,
+	36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,
+	34,2,42,10,50,18,58,26,33,1,41,	9,49,17,57,25
+};
+
+static uint8_t	via1_BBIT[]=
+{
+	128,64,32,16,8,4,2,1,0
+};
+
+
+#define DESITER	16
+static uint8_t	via1_Hashes	[8];
+static uint8_t	via1_Ph;
+static uint8_t	via1_Hashkey[16];
+
+
+static uint8_t	via1_TPS1XOR[64] =
+{
+	0x4F,0xB4,0xFC,0x9B,0x4A,0x7F,0x44,0xFB,
+	0x05,0xFF,0xBD,0xBB,0x16,0x2D,0x6c,0xc8,
+	0xd8,0x96,0xf9,0xfe,0x3f,0xff,0x36,0x24,
+	0xb6,0xbf,0x49,0xc9,0x2d,0x36,0x5e,0xd0,
+	0x1f,0x09,0x7e,0xa9,0x7f,0xff,0x64,0xb6,
+	0x5b,0x7e,0xf8,0xfc,0x6e,0x3f,0x7f,0xbf,
+	0xdd,0x36,0x12,0xE9,0x05,0xFE,0xB4,0x6C,
+	0x6F,0xFE,0x7E,0xC8,0x25,0x90,0x6D,0x90,
+};
+
+static uint8_t	via1_TPS2XOR[64] =
+{
+	0x7E,0x6D,0x7E,0x12,0x76,0xFD,0x2F,0xFE,
+	0x6D,0xFE,0xDA,0x3F,0xDA,0x6D,0xBD,0x97,
+	0xD0,0x6D,0xD8,0x9F,0x69,0xFD,0xB6,0x37,
+	0xFE,0x7F,0x36,0x92,0xBD,0x52,0x16,0xDF,
+	0xFC,0x96,0xFF,0x92,0xFD,0x6D,0x7F,0xB5,
+	0xFB,0x4C,0xB6,0xB7,0x7E,0xD9,0xFE,0x9B,
+	0xFD,0xF4,0x6D,0x9B,0xB9,0x36,0xBF,0x7F,
+	0xD2,0x2D,0xDF,0xB7,0xD9,0xFE,0x69,0xBF,
+};
+
+
+int
+xvia1_IsTPS(uint32_t prid)
+{
+	return (prid == 0x007C00) ? 1 : 0;
+}
+
+
+#if 0
+static void
+xvia1_TPSXOR(uint8_t *DATA_p)
+{
+	int	i;
+
+	DATA_p[2] -= 5;
+	if (DATA_p[7] == 0xDF && DATA_p[8] == 0xB7)
+	{
+		for (i = 0 ; i < DATA_p[2] ; i++)
+			DATA_p[i+4] = via1_TPS1XOR[i&0x3F] ^ DATA_p[i+7];
+	}
+	else
+	{
+		for (i = 0 ; i < DATA_p[2] ; i++)
+			DATA_p[i+4] = via1_TPS2XOR[i&0x3F] ^ DATA_p[i+7];
+	}
+}
+#else
+void
+xvia1_TPSXOR(uint8_t *DATA_p, uint16_t DATA_size)
+{
+	int	i;
+
+	if (DATA_p[0] == 0xDF)
+	{
+		for (i = 0; i < (DATA_size-1); i++)
+			DATA_p[i] ^= via1_TPS1XOR[i & 0x3F];
+	}
+	else
+	{
+		for (i = 0; i < (DATA_size-1); i++)
+			DATA_p[i] ^= via1_TPS2XOR[i & 0x3F];
+	}
+}
+#endif
+
+
+static void
+xvia1_S237(int ki, int di, uint8_t *k2nd, uint8_t *data)
+{
+	int px;
+	int ax = ki ^ di;
+
+	px = 7; // a1 = 0x5F; ptr to last byte
+	if (ax & 4)
+	{
+		ax ^= 7;
+		px ^= 7;
+	}
+	ax = (ax^(ki & 3)) + (ki & 3);
+	if (ax & 4) return;  // no modifications
+	data[di] ^= (k2nd[ki] ^ ((data[ki^px] * k2nd[ki^4]) & 0xFF));
+}
+
+static void
+xvia1_S225(uint8_t *k2nd, uint8_t *data)
+{
+	int ki, di;
+	for (di=7; di>=0; di--)
+	{
+		for (ki=7;ki>3;ki--)
+		{
+			xvia1_S237(ki, di, k2nd, data);
+		}
+	}
+
+	for (di=0; di<8; di++)
+	{
+		for (ki=0; ki<4; ki++)
+		{
+			xvia1_S237(ki, di, k2nd, data);
+		}
+	}
+}
+
+
+static uint32_t
+xvia1_F(uint32_t R, uint8_t *K, uint8_t modkey)
+{
+	uint32_t ml;
+	uint32_t s = 0, result = 0;
+//	uint8_t 	temp;
+	uint8_t 	key5;
+	uint32_t /*ax, ah, */al, bx, bh;//, bl;
+	int16_t i, k;
+
+	if (modkey != 0)
+	{
+		// Get the 5th data byte (included in R)
+		key5 = (uint8_t)((R >> 24) &0xff);
+
+		// and apply the Viaccess mod to it:
+
+		ml	= (uint32_t) modkey * (uint32_t) key5;
+		ml += (uint32_t) modkey;
+		ml += (uint32_t) key5;
+
+		/* start mod */
+		bx  = ml;
+
+		al  = bx & 0xff;
+
+		bh  = (bx & 0xff00) >> 8;
+
+		al &= 0xff;
+		bh &= 0xff;
+
+		al -= bh;
+		if (al & 0x100) al++;
+
+		al &= 0xff;
+
+		key5= al;
+
+		// and represent it as (long) again:
+		R  &= 0xffffffL;
+		R  |= (( (uint32_t) key5) << 24);
+	} /* end if modkey not zero */
+
+	for (i = 0, k = 0; i < 8; i++)
+	{
+		uint8_t	v = 0;
+		int16_t j;
+
+		/* The expansion E */
+		for (j = 0; j < 6; j++, k++) v |= (uint8_t)((R >> (32 - via1_E[k])) & 1) << (5 - j);
+		v ^= K[i];
+
+		/* The S-boxes */
+		s |= (uint32_t)via1_S[i][v] << (28 - 4 * i);
+	} /* end for i */
+
+	/* The permutation P */
+	for (i = 0; i < 32; i++) result |= (s >> (32 - via1_P[i]) & 1) << (31 - i);
+
+	return result;
+} /* end function xvia1_F */
+
+
+void
+xvia1_Decode(uint8_t *iDATAs, uint8_t *pfxkey, int mode, int swap)
+{
+	uint32_t R, L, C, D, T;
+	uint32_t rl;
+	uint32_t dd;
+	uint32_t cc;
+	uint8_t  *key = pfxkey;
+	uint8_t  cPin[8];
+	uint8_t  K[8];
+	uint8_t  modkey;
+	uint8_t  swap1, swap2;
+	int i;
+	int j, k, l;
+	int t;
+
+	modkey = key[7];
+
+	/* split OpKey on 2 half */
+	C =  (uint32_t) key[0] << 20
+		^ (uint32_t) key[1] << 12
+		^ (uint32_t) key[2] << 4
+		^ (uint32_t)((uint32_t)key[3] >> 4);
+
+	D =  (uint32_t)((uint32_t)key[3] & 0x0f) << 24
+		^ (uint32_t) key[4] << 16
+		^ (uint32_t) key[5] << 8
+		^ (uint32_t) key[6];
+
+	/* split CW on 2 half */
+
+	if (mode == 2)	// Eurocrypt S2
+	{
+		for (i = 0; i < 8; i++) cPin[i]=0;
+
+		for (i = 0; i < 64; i++)
+		{
+			if (iDATAs[(via1_IP[i] - 1) / 8] & via1_BBIT[(via1_IP[i] - 1) % 8] )
+				cPin[i / 8] |= via1_BBIT[i % 8];
+		}
+
+		for (i = 0; i < 8; i++) iDATAs[i] = cPin[i];
+	}
+
+	L =  ((uint32_t)iDATAs[0] << 24)
+		^ ((uint32_t)iDATAs[1] << 16)
+		^ ((uint32_t)iDATAs[2] << 8)
+		^  (uint32_t)iDATAs[3];
+	R =  ((uint32_t)iDATAs[4] << 24)
+		^ ((uint32_t)iDATAs[5] << 16)
+		^ ((uint32_t)iDATAs[6] << 8)
+		^  (uint32_t)iDATAs[7];
+
+//	STTBXCAS_TRACE("myxviacess:via"" mode = %d\n", mode);
+	if (mode != 2)
+	{
+		for (i = 0; i < DESITER; i++)
+		{
+			/* Key schedule */
+			for (j = 0; j < via1_LS[i]; j++)
+			{
+				C = (C << 1 ^ C >> 27) & 0xfffffffL;
+				D = (D << 1 ^ D >> 27) & 0xfffffffL;
+			}
+
+			for (j = 0, k = 0; j < 8; j++ )
+			{
+				K[j] = 0;
+				for (t = 0; t < 6; t++, k++)
+				{
+					if (via1_PC2[k] < 29)
+						K[j] |= (uint8_t)((C >> (28 - via1_PC2[k])) & 1) << (5 - t);
+					else
+						K[j] |= (uint8_t)((D >> (56 - via1_PC2[k])) & 1) << (5 - t);
+				}
+			}
+
+			T = xvia1_F(R, K, modkey);
+			if (swap)
+			{
+				swap1 = (uint8_t)((T >> 24) & 0xffL);
+				swap2 = (uint8_t)((T >> 16) & 0xffL);
+
+				T = (T & 0x0000ffffL) |
+					(( (uint32_t) swap1) << 16) |
+					(( (uint32_t) swap2) << 24);
+			}
+
+			rl = L ^ T;
+			L  = R;
+			R  = rl;
+		}
+	} /* end if mode != 2 */
+	else
+	{
+		for (i = DESITER - 1; i >= 0;	i--)
+		{
+			cc = C;
+			dd = D;
+			/* Key schedule */
+			for (l = 0; l <= i; l++)
+			{
+				for (j = 0; j < via1_LS[l]; j++ )
+				{
+					cc = (cc << 1 ^ cc >> 27) & 0xfffffffL;
+					dd = (dd << 1 ^ dd >> 27) & 0xfffffffL;
+				}
+			}
+			for (j = 0, k = 0; j < 8; j++ )
+			{
+				K[j] = 0;
+				for (t = 0; t < 6; t++, k++)
+				{
+					if (via1_PC2[k] < 29)
+						K[j] |= (uint8_t)((cc >> (28 - via1_PC2[k])) & 1) << (5 - t);
+					else
+						K[j] |= (uint8_t)((dd >> (56 - via1_PC2[k])) & 1) << (5 - t);
+				}
+			}
+
+			/* One decryption round */
+			rl = L ^ xvia1_F(R, K, modkey);
+			L  = R;
+			R  = rl;
+		}
+	} /* end else mode is 2 */
+
+	iDATAs[0] = (uint8_t)(R >> 24);
+	iDATAs[1] = (uint8_t)(R >> 16);
+	iDATAs[2] = (uint8_t)(R >> 8);
+	iDATAs[3] = (uint8_t)(R);
+	iDATAs[4] = (uint8_t)(L >> 24);
+	iDATAs[5] = (uint8_t)(L >> 16);
+	iDATAs[6] = (uint8_t)(L >> 8);
+	iDATAs[7] = (uint8_t)(L);
+
+	if (mode == 2)
+	{
+		for (i = 0; i < 8; i++) cPin[i] = 0;
+
+		for (i = 0; i < 64; i++)
+		{
+			if (iDATAs[(via1_IP1[i] - 1) / 8] & via1_BBIT[(via1_IP1[i] - 1) % 8])
+			cPin[i / 8] |= via1_BBIT[i % 8];
+		}
+
+		for (i = 0; i < 8; i++) iDATAs[i] = cPin[i];
+	} /* end if mode == 2 */
+} /* end function decode */
+
+
+
+void
+xvia1_KeyDecode(uint8_t mode)
+{
+	uint8_t *iDATAs = via1_Hashes;
+	uint8_t *cHsKey = via1_Hashkey;
+
+	xvia1_S225(cHsKey + 8, iDATAs);
+	xvia1_Decode(iDATAs, cHsKey, mode, 1);
+	xvia1_S225(cHsKey + 8, iDATAs);
+}
+
+
+void
+xvia1_cwDecode(uint8_t *iDATAs, uint8_t *pfxkey, int mode)
+{
+	uint8_t *v1key_p = pfxkey;
+	uint8_t *v2key_p = pfxkey + 8;
+
+	if (!cs_Iszero(v2key_p, 8))
+	{
+		// viaccess 2
+		xvia1_S225(v2key_p, iDATAs);
+	}
+	xvia1_Decode(iDATAs, v1key_p, mode, 0);
+
+	if (!cs_Iszero(v2key_p, 8))
+	{
+		// viaccess 2
+		xvia1_S225(v2key_p, iDATAs);
+	}
+}
+
+
+static void
+xvia1_HAshNew(void)
+{
+	via1_Ph = 0;
+	memset(via1_Hashes, 0x0, sizeof(via1_Hashes));
+}
+
+static void
+xvia1_HAshSetKey(uint8_t *hkey)
+{
+	memcpy(via1_Hashkey, hkey, sizeof(via1_Hashkey));
+}
+
+
+static void
+xvia1_HAshDecode(uint8_t c)
+{
+	via1_Hashes[via1_Ph] ^= c;
+	via1_Ph++;
+	if (via1_Ph == 8)
+	{
+		via1_Ph = 0;
+		xvia1_KeyDecode(0);
+	}
+}
+
+static void
+xvia1_NAnoDecode(uint8_t *data, int endpos)
+{
+	int	i, j;
+
+	//8th key-byte = 0 then like Eurocrypt-M but with viaccess mods
+	via1_Ph = i = 0;
+	if (data[0] == 0x9f)
+	{
+		xvia1_HAshDecode(data[i++]);	// hash '9f'
+		xvia1_HAshDecode(data[i++]);	// hash nano length
+		for (j = 0 ; j < data[1]; j++)
+		{
+			xvia1_HAshDecode(data[i++]);
+		}
+		while (via1_Ph != 0)
+		{
+			xvia1_HAshDecode(0);
+		}
+	}
+
+	/* calculate hash */
+	for (; i < endpos; i++)
+	{
+		xvia1_HAshDecode(data[i]);
+	}
+}
+
+
+int
+xvia1_Algo(uint8_t *pfxkey,
+	uint8_t	*source,
+	int 	 	 source_size,
+	uint8_t	*cw1,
+	uint8_t	*cw2)
+{
+	uint8_t	nanoTYPE, nanoLEN;
+	uint8_t	signature[8];
+	uint8_t	prepared [16];
+	int i, px, piEA;
+
+	MYEMU_TRACE("myxviacess:1x\n");
+	px = 0;
+	piEA = 0;
+	while (px < source_size)
+	{
+		nanoTYPE = source[px];
+		nanoLEN  = source[px + 1];
+
+	//	X_DTRACE(("[VIA] NANO_TYPE = %02X[%02X]\n", nanoTYPE, nanoLEN));
+		switch (nanoTYPE)
+		{
+			case 0xEA:	/* encrypted bytes */
+				piEA = px + 2;
+				memcpy(cw1, &source[px + 2], 8);
+				memcpy(cw2, &source[px + 2 + 8], 8);
+				break;
+
+			case 0xF0:	/* checksum */
+				memcpy(signature, &source[px + 2], 8);
+				break;
+
+			case 0xE2:	/* date & class */
+				break;
+
+			case 0x9F:
+				break;
+
+			case 0xDF:
+			default:
+				break;
+		}
+		px += nanoLEN + 2;
+	}
+
+	/* init hash (sets via1_Hashes to all zeros) */
+	xvia1_HAshNew();
+	xvia1_HAshSetKey(pfxkey);
+
+	/* key preparation */
+	memcpy(prepared, pfxkey, 16);
+	if (pfxkey[7] == 0)
+	{
+		xvia1_NAnoDecode(source, piEA + 16);
+	}
+	else
+	{ 	/* key8 not zero */
+		uint8_t tmp, k;
+
+		/* rotate the key 2x left */
+		prepared[0] = pfxkey[2];
+		prepared[1] = pfxkey[3];
+		prepared[2] = pfxkey[4];
+		prepared[3] = pfxkey[5];
+		prepared[4] = pfxkey[6];
+		prepared[5] = pfxkey[0];
+		prepared[6] = pfxkey[1];
+		prepared[7] = pfxkey[7];
+
+		/* test if key8 odd */
+		if (pfxkey[7] & 1)
+		{
+			xvia1_NAnoDecode(source, piEA);
+
+			/* test if low nibble zero */
+			k = ((pfxkey[7] & 0xf0) == 0) ? 0x5A : 0xA5;
+
+			for (i = 0; i < 8; i++)
+			{
+				tmp = cw1[i];
+				cw1[i] = (k & via1_Hashes[via1_Ph] ) ^ tmp;
+				xvia1_HAshDecode(tmp);
+			}
+
+			for (i = 0; i < 8; i++)
+			{
+				tmp = cw2[i];
+				cw2[i] = (k & via1_Hashes[via1_Ph] ) ^ tmp;
+				xvia1_HAshDecode(tmp);
+			}
+		}
+		else
+		{
+			xvia1_NAnoDecode(source, piEA + 16);
+		}
+	}
+
+	xvia1_KeyDecode(0);
+	if (memcmp(signature, via1_Hashes, 8)) return 0;
+
+	xvia1_cwDecode(cw1, prepared, 0);
+	xvia1_cwDecode(cw2, prepared, 0);
+
+	return (piEA);
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//======================================================================
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/*
+#define MASKTABLE 	3 		// a1 + 4 0x004 is the MT T1 256
+#define TRIPLEDES 	259 	// a1 + 260 0x104 is the 3DES key 16
+#define DES1 			275 	// a1 + 276 D1 8
+#define XORTABLE 		283 	// a1 + 284 0x11C is the XORArray X1 8
+#define PERMTABLE 	291 	// a1 + 292 P1 8
+#define CW1XOR 		299 	// a1 + 300 C1 8
+*/
+typedef struct
+{
+	uint32_t prid;
+	uint8_t	serviceK	 [128];
+	uint8_t	des1K		 [8];
+	uint8_t	xorArray	 [8];
+	uint8_t	permArray [8];
+	uint8_t	chainArray[8];
+	uint8_t	tMAsk		 [256];
+} PC26_TAB;
+
+/*
+	0472C2625A75D2B4 446DCD4793833E9B key08 BIS TV ENCRYPT IOTA
+	697409FA34F2BD7B 23B48926637F380E key08 BIS TV CLEAR
+
+	1A646D5E3A181960 F550C585AC418F96 key0A BIS TV ENCRYPT IOTA
+	AC20DA198FD86EF0 38FE6AAB26B64B0E key0A BIS TV CLEAR
+	V 023800 T1 3A0A36B2BA8A09635A9CB6F25DAAE188
+    				CF664A657CFA48083675342286EC771F
+    				EBF7E3ADB8D4BA9BE68AD5C9C7DDF473
+    				87C8E9E0C2553F748FD9317E596DFC25
+    				BE19EEFB43ABE74F6042C18230C61C50
+    				D1CB85DA92DC7DCDD23D243561F0CA07
+    				909EC497ED8D5212D6F10D3754B0704D
+    				45999AF53AA6B5162C205896322D040E
+
+    				B2560C03A0A36B2BA8A44B2E445EB479
+    				2AC5BF15AE0B68BBDBB3D74910EAEF89
+    				288E3E13396EA91B76B9381E0F574E47
+    				9FB1FE9498FFF923A1005C95806A78C3
+    				6784D8272FC00AF87A51626C7BBDF321
+    				D35BA246E4AF53CE1A26E2411D029383
+    				0133BCD0724CE86905CC7FFDE518A5DE
+    				171471B7819D293CAC40A7DF11065F3B ; TransformTable
+	V 023800 08 A57FF844BCCDECC6ABFB46713FA67BC5 ; Service key
+	V 023800 D1 44FAB54EEB94CDCE ; Des1_Key
+	V 023800 X1 7AA685B4B45F9876 ; XORArray
+	V 023800 P1 3FD4020305001432 ; PermArray
+	V 023800 C1 6653768A351745B7 ; ChainArray
+*/
+// 023b00, 020810, 020820, 021110, 021120
+static PC26_TAB	PC26_Lst;
+static PC26_TAB 	PC26_Issuers[] =
+{	//	Canalsat Viaccess Astra 19.2\A1\C6E
+	//  11739V27500/ - 11778V27500/ - 11973V27500/ - 12663H22000
+	{	 0x022610,
+		{0xDF,0xB6,0x1C,0x95,0x1A,0xE2,0xC5,0x7B,0xDE,0x0D,0x48,0x87,0xB9,0x61,0x42,0x95,
+		 0xB4,0xBF,0xE2,0xCD,0xD4,0xCC,0x72,0x6B,0x7F,0x9E,0xAB,0x76,0x8A,0x86,0xE2,0x15,
+		 0x38,0x71,0xF7,0x77,0xC4,0x2C,0xFB,0x6D,0x94,0x6A,0x50,0x6D,0x78,0xFF,0x52,0x84,
+		 0x29,0x42,0xED,0xF7,0x04,0xB6,0xFD,0x8A,0xD5,0x3B,0xA2,0x11,0xCF,0xA0,0x60,0xB7,
+		 0xE3,0x9A,0x2F,0xD7,0xF8,0x6C,0xD3,0xAC,0xD3,0x8F,0x6E,0xBA,0x87,0xB9,0x8C,0xDB,
+		 0xEA,0x33,0x0A,0xF2,0x52,0x11,0x22,0x63,0x48,0x1C,0xB0,0xF2,0x05,0x9B,0x81,0x78,
+		 0x38,0xE2,0x7A,0x64,0x7C,0x1B,0xC3,0xCB,0x4C,0x05,0x9F,0x64,0x95,0xFF,0x1C,0x6C,
+		 0xFA,0x68,0xF9,0x8A,0x53,0xEF,0x00,0x77,0x90,0x0B,0xCF,0x59,0xC0,0x67,0x3E,0x2B,
+		},
+
+		{0x53,0x6D,0x1D,0x0D,0xC0,0x41,0xD4,0x68},
+		{0x8D,0xE3,0x66,0x6B,0x8C,0xB0,0xB0,0x0B},
+		{0x01,0x06,0x00,0x02,0x03,0x05,0x04,0x07},
+		{0x13,0x32,0xDB,0x1E,0x67,0x75,0x56,0x1E},
+		{
+		 0xD6,0xB4,0x56,0x12,0x7B,0x10,0x32,0xD8,0x60,0x67,0xDF,0x48,0x28,0x4A,0x9C,0x6C,
+		 0x05,0xE4,0x03,0x6D,0xBC,0x33,0xD4,0x8E,0x53,0x65,0x4B,0xAA,0x6A,0x57,0xC2,0x63,
+		 0xC0,0x43,0x4F,0x5E,0x69,0xF4,0x34,0xB8,0x0C,0x6F,0xE5,0x7C,0x58,0xCF,0x96,0x97,
+		 0xC8,0x6E,0x06,0x15,0x26,0x3C,0xBB,0x7F,0x9D,0x81,0x94,0x55,0x35,0xE6,0xB9,0x86,
+		 0x5B,0xD5,0xE0,0x21,0x68,0xD7,0xB0,0xA8,0x0B,0xBD,0x0D,0x1A,0xC6,0x80,0xCA,0x22,
+		 0x90,0xA5,0xAE,0x18,0x89,0x3B,0x02,0x1D,0x2C,0xC1,0x85,0x40,0x77,0x8A,0x23,0x61,
+		 0x08,0x5F,0x75,0x1F,0x82,0x19,0xB3,0x09,0x44,0x24,0x1C,0xBA,0x0F,0x13,0x31,0x29,
+		 0xE3,0x8F,0xD1,0xDE,0xF0,0x62,0xF2,0x5C,0x93,0xEB,0xEC,0x04,0x2B,0x83,0xD9,0x37,
+		 0x4D,0x39,0x64,0x7D,0x8D,0x5A,0x3F,0xD3,0xF8,0x54,0x5D,0xDD,0xF7,0x84,0x17,0x71,
+		 0x50,0xDC,0x9E,0x78,0x3A,0xEA,0x2E,0x2F,0xE8,0xCB,0xE9,0xB1,0x0E,0x38,0x92,0xE2,
+		 0xBF,0xC5,0xBE,0xE7,0xB2,0x51,0xDA,0xB6,0x47,0xD2,0x1B,0xFD,0xEE,0xC9,0x52,0xFB,
+		 0x46,0x9B,0xA4,0x66,0x01,0xE1,0xA7,0xCE,0x27,0x3E,0x6B,0x36,0x14,0x49,0xA2,0xA0,
+		 0x20,0x59,0x1E,0xEF,0xFE,0xA1,0x4C,0xDB,0x30,0xAD,0x4E,0x99,0xFF,0xED,0xB7,0x2D,
+		 0xFC,0x72,0xA9,0x87,0x16,0x41,0x00,0x45,0x07,0x7E,0xA6,0xC7,0x91,0x8B,0x73,0x0A,
+		 0x42,0xB5,0x9F,0x70,0x11,0x2A,0x3D,0xA3,0x98,0x9A,0x95,0x79,0x7A,0xCD,0xAC,0xC3,
+		 0x74,0xF6,0x76,0xF5,0x25,0xF3,0xF1,0x8C,0x88,0xFA,0xF9,0xAF,0xD0,0xAB,0xC4,0xCC,
+		},
+	},
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//	DIED.
+	{	 0x023b00,
+		{0x94,0xFB,0xD7,0x05,0xB7,0x19,0xA4,0x86,0x10,0x1E,0x19,0xA6,0x00,0x5A,0x25,0x15,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		},
+
+		{0x13,0xCE,0x62,0x7A,0xF7,0x1A,0x53,0x1A},
+		{0xD3,0xBE,0x5F,0x43,0x29,0xDA,0xFF,0xC9},
+		{0x06,0x04,0x00,0x01,0x03,0x07,0x02,0x05},
+		{0xB6,0x67,0x8B,0x8C,0x82,0xA2,0x6B,0x4E},
+		{
+		 0xCB,0x90,0xB6,0xF5,0x44,0xB4,0x3A,0x32,0x66,0x48,0x1D,0xB5,0xAC,0xA1,0x12,0x9F,
+		 0xB9,0xF7,0x0E,0x34,0xEF,0xE1,0x68,0xD3,0x83,0x2D,0x41,0xCF,0xBC,0x0A,0x55,0xBD,
+		 0xA3,0x99,0xC3,0xD2,0x85,0xC4,0xE8,0x74,0xC5,0x51,0x82,0x58,0x70,0x19,0x9E,0x3B,
+		 0x39,0xAD,0x07,0x9A,0x13,0xC7,0xD0,0xAF,0x92,0x30,0x06,0x2F,0xC8,0x5B,0x42,0xC1,
+		 0x94,0x1A,0x3E,0x86,0x04,0xA0,0xB2,0x9D,0x09,0xF8,0x8E,0x84,0xED,0x6E,0x87,0xFC,
+		 0x7B,0x29,0x59,0x77,0x9C,0x1E,0xDC,0xF3,0x2B,0x52,0xF9,0x3D,0xF4,0xA9,0xD8,0xDB,
+		 0x7D,0xCC,0x78,0xDE,0xA2,0xA5,0x08,0xCD,0x16,0x71,0x80,0xB8,0x7F,0xFD,0x4D,0xF6,
+		 0x2C,0x69,0xDF,0xF1,0x27,0x8B,0xFB,0x53,0x62,0x9B,0xE5,0x50,0x96,0x60,0xB0,0x6C,
+		 0x6A,0xEE,0x2A,0x18,0x4B,0x24,0x43,0x4E,0xE6,0xAE,0xF2,0x75,0xE2,0xD7,0x4A,0xEA,
+		 0x01,0xEC,0x38,0xFA,0x40,0xEB,0x7C,0xE0,0xA6,0x21,0x33,0x79,0x54,0x47,0x2E,0x0F,
+		 0x45,0x0D,0x64,0x20,0xD4,0x65,0x98,0xBA,0xD6,0x5D,0xBB,0xB7,0x0C,0x31,0x89,0x37,
+		 0x7E,0xD1,0x46,0xC6,0x05,0x0B,0x02,0xAB,0x6B,0x10,0xA7,0xAA,0x1C,0x1F,0xE3,0xF0,
+		 0xFE,0x3F,0xE4,0x22,0x25,0x28,0xB3,0x35,0x3C,0xCE,0xE9,0x00,0x61,0x67,0xC9,0x1B,
+		 0x36,0xB1,0x23,0x17,0xA4,0xDD,0xA8,0x8D,0x5E,0xFF,0xE7,0x5F,0x56,0xD5,0x63,0x72,
+		 0x97,0x15,0x8C,0xBE,0xC2,0x7A,0x88,0xDA,0x26,0xCA,0x8F,0x95,0x91,0x4C,0x81,0x14,
+		 0xBF,0x73,0x8A,0x57,0x5C,0x03,0x6F,0x11,0x49,0x5A,0x93,0x76,0x4F,0x6D,0xC0,0xD9,
+		},
+	},
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	{	 0x020810,
+		{0x69,0x74,0x09,0xFA,0x34,0xF2,0xBD,0x7B,0x23,0xB4,0x89,0x26,0x63,0x7F,0x38,0x0E,
+	//	 0x76,0xA4,0x4B,0x1A,0x1D,0x3A,0xF6,0x59,0x26,0x11,0xCD,0xBC,0xEE,0x6D,0x0B,0xCE,	// 0x9(?)
+	//	 0x45,0xf4,0xa7,0xd9,0x8b,0x61,0xe5,0xc0,0xa1,0x8c,0x93,0xdd,0xfe,0xdb,0x52,0x3a,	// 0x9(?)
+		 0x55,0x03,0x58,0x9A,0x45,0x10,0x44,0x7C,0x50,0x15,0xB3,0xDF,0x31,0xA7,0x66,0x66,	// 0x9(?)
+		 0xAC,0x20,0xDA,0x19,0x8F,0xD8,0x6E,0xF0,0x38,0xFE,0x6A,0xAB,0x26,0xB6,0x4B,0x0E, 	// 0xA
+		 0x9D,0x5D,0xE6,0xB3,0x76,0xFF,0x3C,0x12,0x37,0xC9,0x28,0x9D,0x88,0x76,0xB6,0x65,	// 0xB
+		 0xC9,0x80,0x40,0x0A,0xD9,0x73,0x18,0x2F,0xDA,0x30,0xC1,0x09,0xEC,0xA8,0x33,0xFC,	// 0xC
+	//	 0x98,0x04,0x00,0xAD,0x97,0x31,0x82,0xFD,0xA3,0x0C,0x10,0x9E,0xCA,0x83,0x3F,0xC0,	// 0xC(?)
+		 0xA9,0x21,0x57,0x0C,0x30,0x96,0x1B,0x42,0x80,0x74,0xA7,0x45,0x1B,0xEA,0xCC,0x9D,	// 0xD
+		 0xFD,0xAE,0x85,0x42,0x55,0x15,0xBF,0x5D,0xEA,0xAB,0xFF,0xCA,0xFD,0x46,0x95,0xA6,	// 0xE
+		 0x7F,0xE9,0x40,0xF4,0x16,0xDA,0x5F,0x49,0x2F,0x5A,0x01,0x76,0xE9,0xC7,0x97,0xFC,	// 0xF
+		},
+
+		{0x13,0xCE,0x62,0x7A,0xF7,0x1A,0x53,0x1A,},
+	//	{0x12,0xCE,0x62,0x7A,0xF6,0x1A,0x52,0x1A,},
+		{0xD3,0xBE,0x5F,0x43,0x29,0xDA,0xFF,0xC9,},
+		{0x06,0x04,0x00,0x01,0x03,0x07,0x02,0x05,},
+		{0xB6,0x67,0x8B,0x8C,0x82,0xA2,0x6B,0x4E,},
+		{
+		 0xCB,0x90,0xB6,0xF5,0x44,0xB4,0x3A,0x32,0x66,0x48,0x1D,0xB5,0xAC,0xA1,0x12,0x9F,
+		 0xB9,0xF7,0x0E,0x34,0xEF,0xE1,0x68,0xD3,0x83,0x2D,0x41,0xCF,0xBC,0x0A,0x55,0xBD,
+		 0xA3,0x99,0xC3,0xD2,0x85,0xC4,0xE8,0x74,0xC5,0x51,0x82,0x58,0x70,0x19,0x9E,0x3B,
+		 0x39,0xAD,0x07,0x9A,0x13,0xC7,0xD0,0xAF,0x92,0x30,0x06,0x2F,0xC8,0x5B,0x42,0xC1,
+		 0x94,0x1A,0x3E,0x86,0x04,0xA0,0xB2,0x9D,0x09,0xF8,0x8E,0x84,0xED,0x6E,0x87,0xFC,
+		 0x7B,0x29,0x59,0x77,0x9C,0x1E,0xDC,0xF3,0x2B,0x52,0xF9,0x3D,0xF4,0xA9,0xD8,0xDB,
+		 0x7D,0xCC,0x78,0xDE,0xA2,0xA5,0x08,0xCD,0x16,0x71,0x80,0xB8,0x7F,0xFD,0x4D,0xF6,
+		 0x2C,0x69,0xDF,0xF1,0x27,0x8B,0xFB,0x53,0x62,0x9B,0xE5,0x50,0x96,0x60,0xB0,0x6C,
+		 0x6A,0xEE,0x2A,0x18,0x4B,0x24,0x43,0x4E,0xE6,0xAE,0xF2,0x75,0xE2,0xD7,0x4A,0xEA,
+		 0x01,0xEC,0x38,0xFA,0x40,0xEB,0x7C,0xE0,0xA6,0x21,0x33,0x79,0x54,0x47,0x2E,0x0F,
+		 0x45,0x0D,0x64,0x20,0xD4,0x65,0x98,0xBA,0xD6,0x5D,0xBB,0xB7,0x0C,0x31,0x89,0x37,
+		 0x7E,0xD1,0x46,0xC6,0x05,0x0B,0x02,0xAB,0x6B,0x10,0xA7,0xAA,0x1C,0x1F,0xE3,0xF0,
+		 0xFE,0x3F,0xE4,0x22,0x25,0x28,0xB3,0x35,0x3C,0xCE,0xE9,0x00,0x61,0x67,0xC9,0x1B,
+		 0x36,0xB1,0x23,0x17,0xA4,0xDD,0xA8,0x8D,0x5E,0xFF,0xE7,0x5F,0x56,0xD5,0x63,0x72,
+		 0x97,0x15,0x8C,0xBE,0xC2,0x7A,0x88,0xDA,0x26,0xCA,0x8F,0x95,0x91,0x4C,0x81,0x14,
+		 0xBF,0x73,0x8A,0x57,0x5C,0x03,0x6F,0x11,0x49,0x5A,0x93,0x76,0x4F,0x6D,0xC0,0xD9,
+		},
+	},
+	{	 0x020820,
+		{0xE3,0x04,0xCE,0x15,0x82,0x28,0x01,0xD6,0x43,0xAC,0xDD,0x54,0xE5,0x41,0xBC,0x02,
+	//	 0x76,0xA4,0x4B,0x1A,0x1D,0x3A,0xF6,0x59,0x26,0x11,0xCD,0xBC,0xEE,0x6D,0x0B,0xCE,	// 0x9(???)
+		 0xE7,0x55,0xCC,0x7F,0xDA,0x59,0xCE,0x6D,0x73,0xFB,0xEA,0x60,0x8C,0x52,0xF6,0x6F,	// 0x9(???)
+		 0x80,0x7E,0x19,0x48,0xA2,0xC1,0xDA,0x4E,0x3A,0x1E,0x9A,0x3C,0x0D,0xD9,0xBC,0xD9, 	// 0xA
+		 0xCB,0x66,0x4C,0xD6,0x3A,0x08,0x7D,0x32,0x2D,0x36,0xF5,0xAC,0x9D,0x92,0xE3,0xB9,	// 0xB
+		 0xCF,0xB4,0x6F,0x22,0x71,0xE6,0x47,0x5D,0xFC,0x55,0xB3,0x30,0x57,0x86,0xD5,0x0A,	// 0xC
+		 0x08,0xE0,0xB8,0x4B,0x40,0x16,0x78,0x54,0x7A,0xCB,0x62,0x81,0xD4,0x15,0x8F,0x94,	// 0xD
+		 0xC0,0x8A,0x6B,0x9D,0xEC,0x35,0x01,0x74,0x70,0xD6,0xC9,0x1E,0x31,0x0D,0x31,0xF5,	// 0xE
+		 0x68,0x1C,0x5B,0xA0,0x23,0x39,0xB7,0xB8,0xBC,0xCF,0x87,0x93,0x29,0x47,0xF8,0x9E,	// 0xF
+		},
+
+		{0x13,0xCE,0x62,0x7A,0xF7,0x1A,0x53,0x1A,},
+		{0xD3,0xBE,0x5F,0x43,0x29,0xDA,0xFF,0xC9,},
+		{0x06,0x04,0x00,0x01,0x03,0x07,0x02,0x05,},
+		{0xB6,0x67,0x8B,0x8C,0x82,0xA2,0x6B,0x4E,},
+		{
+		 0xCB,0x90,0xB6,0xF5,0x44,0xB4,0x3A,0x32,0x66,0x48,0x1D,0xB5,0xAC,0xA1,0x12,0x9F,
+		 0xB9,0xF7,0x0E,0x34,0xEF,0xE1,0x68,0xD3,0x83,0x2D,0x41,0xCF,0xBC,0x0A,0x55,0xBD,
+		 0xA3,0x99,0xC3,0xD2,0x85,0xC4,0xE8,0x74,0xC5,0x51,0x82,0x58,0x70,0x19,0x9E,0x3B,
+		 0x39,0xAD,0x07,0x9A,0x13,0xC7,0xD0,0xAF,0x92,0x30,0x06,0x2F,0xC8,0x5B,0x42,0xC1,
+		 0x94,0x1A,0x3E,0x86,0x04,0xA0,0xB2,0x9D,0x09,0xF8,0x8E,0x84,0xED,0x6E,0x87,0xFC,
+		 0x7B,0x29,0x59,0x77,0x9C,0x1E,0xDC,0xF3,0x2B,0x52,0xF9,0x3D,0xF4,0xA9,0xD8,0xDB,
+		 0x7D,0xCC,0x78,0xDE,0xA2,0xA5,0x08,0xCD,0x16,0x71,0x80,0xB8,0x7F,0xFD,0x4D,0xF6,
+		 0x2C,0x69,0xDF,0xF1,0x27,0x8B,0xFB,0x53,0x62,0x9B,0xE5,0x50,0x96,0x60,0xB0,0x6C,
+		 0x6A,0xEE,0x2A,0x18,0x4B,0x24,0x43,0x4E,0xE6,0xAE,0xF2,0x75,0xE2,0xD7,0x4A,0xEA,
+		 0x01,0xEC,0x38,0xFA,0x40,0xEB,0x7C,0xE0,0xA6,0x21,0x33,0x79,0x54,0x47,0x2E,0x0F,
+		 0x45,0x0D,0x64,0x20,0xD4,0x65,0x98,0xBA,0xD6,0x5D,0xBB,0xB7,0x0C,0x31,0x89,0x37,
+		 0x7E,0xD1,0x46,0xC6,0x05,0x0B,0x02,0xAB,0x6B,0x10,0xA7,0xAA,0x1C,0x1F,0xE3,0xF0,
+		 0xFE,0x3F,0xE4,0x22,0x25,0x28,0xB3,0x35,0x3C,0xCE,0xE9,0x00,0x61,0x67,0xC9,0x1B,
+		 0x36,0xB1,0x23,0x17,0xA4,0xDD,0xA8,0x8D,0x5E,0xFF,0xE7,0x5F,0x56,0xD5,0x63,0x72,
+		 0x97,0x15,0x8C,0xBE,0xC2,0x7A,0x88,0xDA,0x26,0xCA,0x8F,0x95,0x91,0x4C,0x81,0x14,
+		 0xBF,0x73,0x8A,0x57,0x5C,0x03,0x6F,0x11,0x49,0x5A,0x93,0x76,0x4F,0x6D,0xC0,0xD9,
+		},
+	},
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//	ENCODED_KEY(8FB80213BFF04F55)->DECODED_KEY(35F6B9217C2BA83F)
+	{	 0x021110,
+		{0x35,0xF6,0xB9,0x21,0x7C,0x2B,0xA8,0x3F,0x38,0xC3,0xC1,0xFD,0x23,0xA5,0xD3,0x21,
+		 0x94,0x00,0x79,0x10,0xE1,0xB4,0x64,0xB8,0x32,0x99,0x8F,0x70,0xFA,0x41,0x6C,0x7E,	// ???
+		 0x66,0xFD,0x32,0xE1,0xB3,0xCA,0x7A,0x74,0x42,0xD3,0x2A,0x9F,0x65,0xEF,0x5B,0x49,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		},
+
+		{0x89,0xCB,0xB5,0x4E,0xEB,0x94,0xE3,0x50,},
+		{0x12,0xBF,0x4D,0x2F,0x2A,0x10,0xF5,0x90,},
+		{0x07,0x04,0x02,0x03,0x05,0x00,0x06,0x01,},
+		{0xE9,0x6B,0x9F,0xD4,0x4D,0x3D,0x33,0x5E,},
+		{
+		 0x94,0x53,0x84,0x7E,0xEE,0x73,0x45,0xCF,0xD1,0xD4,0x82,0xD3,0x60,0x30,0x36,0xEC,
+		 0xD6,0xCD,0x9A,0xF5,0xDA,0x1F,0xE5,0x24,0x3E,0x71,0x5C,0xEA,0x86,0x41,0xBA,0x15,
+		 0x28,0xA7,0x47,0xC2,0x17,0x2E,0xDC,0xD9,0x20,0x96,0x8E,0x75,0x2F,0x4A,0x25,0x2C,
+		 0x0D,0x38,0xAB,0x4C,0xA5,0x6E,0x0E,0x8D,0x31,0x64,0x4E,0x5E,0x77,0x61,0x18,0x9F,
+		 0x78,0x1D,0xFA,0x85,0xFD,0x06,0x59,0x22,0xF7,0xE9,0x2D,0x95,0x33,0xA9,0x3A,0xE8,
+		 0xF1,0xE7,0x88,0x01,0x5D,0xE3,0xD2,0x92,0x62,0x46,0x5F,0xF2,0x1A,0x54,0x3B,0x5A,
+		 0x0C,0x3D,0x58,0xC9,0x39,0xD8,0xAE,0x7F,0x87,0x6C,0xBF,0xD5,0x69,0xCE,0x35,0xC4,
+		 0x9B,0x19,0xC1,0x05,0xC8,0x2B,0xAC,0x3C,0x40,0xED,0xB1,0xFC,0xBC,0x99,0x03,0x67,
+		 0xA4,0xB8,0x0A,0xA1,0x02,0x43,0x1C,0x68,0x52,0xF8,0xBE,0xFF,0xB6,0x37,0x2A,0xEF,
+		 0xB9,0xA6,0x57,0xBB,0x00,0x4B,0x29,0xB4,0xDB,0x7D,0x12,0x70,0xE1,0xAA,0xB5,0x3F,
+		 0xD0,0x83,0xB7,0xE2,0x80,0x34,0x91,0x21,0xE4,0x4D,0x9D,0x32,0x76,0xF0,0x66,0xDF,
+		 0xDE,0x7A,0xCC,0xC7,0x97,0x9E,0x8C,0xA2,0x81,0x90,0x1E,0x93,0x7C,0xC3,0x8A,0x6A,
+		 0xE6,0x72,0x23,0xBD,0x6F,0xF6,0xCA,0xB3,0x74,0x63,0xC6,0xFE,0xB2,0x11,0x6D,0x07,
+		 0xA0,0x08,0x56,0x0B,0x09,0x6B,0x10,0xE0,0x65,0x27,0x14,0x98,0x26,0xEB,0xB0,0xAF,
+		 0xD7,0x9C,0xA3,0x55,0xA8,0x16,0xC0,0x51,0x4F,0x49,0x1B,0xDD,0x0F,0x79,0x04,0x8F,
+		 0xAD,0x50,0x5B,0xF4,0xF3,0x13,0xC5,0x48,0x89,0xFB,0x42,0xF9,0x7B,0x44,0xCB,0x8B,
+		},
+	},
+
+	{	 0x021120,
+		{0x35,0xF6,0xB9,0x21,0x7C,0x2B,0xA8,0x3F,0x38,0xC3,0xC1,0xFD,0x23,0xA5,0xD3,0x21,
+		 0x94,0x00,0x79,0x10,0xE1,0xB4,0x64,0xB8,0x32,0x99,0x8F,0x70,0xFA,0x41,0x6C,0x7E,	// ???
+		 0x66,0xFD,0x32,0xE1,0xB3,0xCA,0x7A,0x74,0x42,0xD3,0x2A,0x9F,0x65,0xEF,0x5B,0x49,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		},
+
+		{0x89,0xCB,0xB5,0x4E,0xEB,0x94,0xE3,0x50,},
+		{0x12,0xBF,0x4D,0x2F,0x2A,0x10,0xF5,0x90,},
+		{0x07,0x04,0x02,0x03,0x05,0x00,0x06,0x01,},
+		{0xE9,0x6B,0x9F,0xD4,0x4D,0x3D,0x33,0x5E,},
+		{
+		 0x94,0x53,0x84,0x7E,0xEE,0x73,0x45,0xCF,0xD1,0xD4,0x82,0xD3,0x60,0x30,0x36,0xEC,
+		 0xD6,0xCD,0x9A,0xF5,0xDA,0x1F,0xE5,0x24,0x3E,0x71,0x5C,0xEA,0x86,0x41,0xBA,0x15,
+		 0x28,0xA7,0x47,0xC2,0x17,0x2E,0xDC,0xD9,0x20,0x96,0x8E,0x75,0x2F,0x4A,0x25,0x2C,
+		 0x0D,0x38,0xAB,0x4C,0xA5,0x6E,0x0E,0x8D,0x31,0x64,0x4E,0x5E,0x77,0x61,0x18,0x9F,
+		 0x78,0x1D,0xFA,0x85,0xFD,0x06,0x59,0x22,0xF7,0xE9,0x2D,0x95,0x33,0xA9,0x3A,0xE8,
+		 0xF1,0xE7,0x88,0x01,0x5D,0xE3,0xD2,0x92,0x62,0x46,0x5F,0xF2,0x1A,0x54,0x3B,0x5A,
+		 0x0C,0x3D,0x58,0xC9,0x39,0xD8,0xAE,0x7F,0x87,0x6C,0xBF,0xD5,0x69,0xCE,0x35,0xC4,
+		 0x9B,0x19,0xC1,0x05,0xC8,0x2B,0xAC,0x3C,0x40,0xED,0xB1,0xFC,0xBC,0x99,0x03,0x67,
+		 0xA4,0xB8,0x0A,0xA1,0x02,0x43,0x1C,0x68,0x52,0xF8,0xBE,0xFF,0xB6,0x37,0x2A,0xEF,
+		 0xB9,0xA6,0x57,0xBB,0x00,0x4B,0x29,0xB4,0xDB,0x7D,0x12,0x70,0xE1,0xAA,0xB5,0x3F,
+		 0xD0,0x83,0xB7,0xE2,0x80,0x34,0x91,0x21,0xE4,0x4D,0x9D,0x32,0x76,0xF0,0x66,0xDF,
+		 0xDE,0x7A,0xCC,0xC7,0x97,0x9E,0x8C,0xA2,0x81,0x90,0x1E,0x93,0x7C,0xC3,0x8A,0x6A,
+		 0xE6,0x72,0x23,0xBD,0x6F,0xF6,0xCA,0xB3,0x74,0x63,0xC6,0xFE,0xB2,0x11,0x6D,0x07,
+		 0xA0,0x08,0x56,0x0B,0x09,0x6B,0x10,0xE0,0x65,0x27,0x14,0x98,0x26,0xEB,0xB0,0xAF,
+		 0xD7,0x9C,0xA3,0x55,0xA8,0x16,0xC0,0x51,0x4F,0x49,0x1B,0xDD,0x0F,0x79,0x04,0x8F,
+		 0xAD,0x50,0x5B,0xF4,0xF3,0x13,0xC5,0x48,0x89,0xFB,0x42,0xF9,0x7B,0x44,0xCB,0x8B,
+		},
+	},
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	{	 0x023800,
+	//	{0x8B,0xE8,0xE0,0xA4,0x01,0x04,0x98,0xB6,0x87,0x7D,0x6F,0xEE,0xAE,0xF5,0xBB,0xEF,	// 	NOK
+	//	{0xEC,0x8F,0xA7,0xBB,0x2A,0xDA,0x69,0xE9,0xF1,0x7A,0x6A,0xA9,0xB6,0x64,0x30,0x8F,	// 	NOK
+	//	{0xF9,0x19,0xAB,0x6A,0xF7,0x04,0x46,0xAC,0x8B,0xF0,0xA0,0xDA,0xB1,0x2E,0x53,0x85,	// 	???
+		{0x95,0x5C,0xF3,0xC9,0x28,0x00,0xF3,0x9F,0x54,0xB9,0x30,0x05,0xDF,0x82,0x6D,0xBF,
+	//	{0x0B,0x31,0x89,0xC9,0xC3,0x44,0xC7,0x3D,0x8B,0x87,0x24,0xF8,0x9E,0xE8,0xE0,0xB6,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		},
+
+		{0x0B,0x55,0x2C,0x11,0xAF,0x0A,0x2F,0xB8,},	//	???
+		{0x3D,0x12,0x29,0xC2,0xED,0x29,0xC1,0x30,},	//	xor
+		{0x03,0x04,0x00,0x02,0x07,0x05,0x01,0x06,},	//	xorpos
+		{0xDA,0x4E,0x0B,0x42,0x13,0x4F,0x43,0x3B,},	//	iv
+		{
+		 0x49,0x5E,0xE3,0x83,0x9D,0xD6,0x54,0x4A,0xF2,0x3F,0xC1,0xEC,0x7C,0x68,0x4D,0x97,
+		 0x3C,0xF8,0x73,0x92,0x6F,0x1C,0xF0,0xF5,0x86,0xDA,0x31,0xA1,0x15,0x6B,0xA6,0x9A,
+		 0x34,0x61,0xA2,0x8A,0x96,0x5D,0xCB,0x2A,0x5B,0x93,0x27,0x57,0xB3,0xD3,0x46,0x40,
+		 0xCF,0x1A,0x65,0x4C,0x20,0xA5,0x48,0xC3,0xE6,0xB9,0x7D,0xBD,0x10,0x43,0x63,0x09,
+		 0x2F,0xC8,0x9C,0x3D,0x67,0xD8,0x2E,0xAE,0x36,0x00,0x07,0x5C,0x33,0x0E,0x8D,0x94,
+		 0x6A,0xE8,0xAD,0x5F,0x06,0xE7,0xF4,0x2B,0xB7,0x9F,0xAC,0x28,0x4B,0x25,0x01,0x53,
+		 0xBE,0x21,0x7A,0x3E,0xFD,0x32,0x91,0x44,0x0D,0x8F,0x50,0x1D,0xC5,0xA8,0xA7,0x14,
+		 0x7B,0xBB,0xED,0x12,0xC4,0xBF,0x89,0xDB,0xDC,0xD1,0x62,0x70,0x0C,0x3A,0x95,0xAF,
+		 0xB4,0xF6,0xB1,0x03,0xC6,0xFB,0x18,0xDD,0xC7,0x76,0x23,0xE4,0xFC,0x4E,0xF1,0x69,
+		 0xAA,0x66,0x13,0x29,0x4F,0x7E,0x24,0x0F,0xB5,0x9E,0x1F,0xAB,0x42,0x04,0x99,0x59,
+		 0xD9,0x1B,0x22,0xB6,0xF9,0x35,0x1E,0x6E,0x6D,0xC2,0x90,0x9B,0x5A,0x52,0x47,0x7F,
+		 0xC0,0x82,0xFE,0x2C,0x80,0x98,0xA3,0x58,0xD7,0x39,0xDE,0x71,0xD2,0x3B,0x60,0x75,
+		 0xB0,0x0A,0xA9,0x37,0x74,0x6C,0x84,0x88,0x41,0xCA,0xC9,0x26,0xF7,0xEA,0xE2,0x30,
+		 0xDF,0x79,0xBC,0x2D,0xEE,0xF3,0x05,0xB8,0x45,0xA0,0x19,0x77,0x78,0x87,0xBA,0xD0,
+		 0xFA,0xE5,0xCE,0x02,0x8B,0xE1,0x38,0x55,0x51,0xEF,0xCD,0xFF,0x0B,0x72,0xD4,0xE9,
+		 0x16,0x8E,0x08,0xD5,0x56,0x17,0x81,0xCC,0x11,0xA4,0xE0,0x85,0x8C,0x64,0xB2,0xEB,
+		},
+	},
+/*
+495EE3839DD6544AF23FC1EC7C684D97
+3CF873926F1CF0F586DA31A1156BA69A
+3461A28A965DCB2A5B932757B3D34640
+CF1A654C20A548C3E6B97DBD10436309
+2FC89C3D67D82EAE3600075C330E8D94
+6AE8AD5F06E7F42BB79FAC284B250153
+BE217A3EFD3291440D8F501DC5A8A714
+7BBBED12C4BF89DBDCD162700C3A95AF
+B4F6B103C6FB18DDC77623E4FC4EF169
+AA6613294F7E240FB59E1FAB42049959
+D91B22B6F9351E6E6DC2909B5A52477F
+C082FE2C8098A358D739DE71D23B6075
+B00AA937746C848841CAC926F7EAE230
+DF79BC2DEEF305B845A019777887BAD0
+FAE5CE028BE1385551EFCDFF0B72D4E9
+168E08D5561781CC11A4E0858C64B2EB
+1E84CC47F20C8155
+*/
+	#if 0
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	{	 0x024400,
+		{0x85,0x3B,0xDA,0x19,0xEE,0x78,0x08,0x9B,0xDD,0xE3,0x92,0xF3,0x80,0xA1,0x47,0xD4,	// 	???
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		},
+
+		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},	//	???
+		{0x3D,0x12,0x29,0xC2,0xED,0x29,0xC1,0x30,},	//	xor
+		{0x03,0x04,0x02,0x02,0x07,0x05,0x01,0x06,},	//	xorpos
+		{0xDA,0x4E,0x0B,0x42,0x13,0x4F,0x43,0x3B,},	//	iv
+		{
+		 0x3A,0x0A,0x36,0xB2,0xBA,0x8A,0x09,0x63,0x5A,0x9C,0xB6,0xF2,0x5D,0xAA,0xE1,0x88,
+		 0xCF,0x66,0x4A,0x65,0x7C,0xFA,0x48,0x08,0x36,0x75,0x34,0x22,0x86,0xEC,0x77,0x1F,
+		 0xEB,0xF7,0xE3,0xAD,0xB8,0xD4,0xBA,0x9B,0xE6,0x8A,0xD5,0xC9,0xC7,0xDD,0xF4,0x73,
+		 0x87,0xC8,0xE9,0xE0,0xC2,0x55,0x3F,0x74,0x8F,0xD9,0x31,0x7E,0x59,0x6D,0xFC,0x25,
+		 0xBE,0x19,0xEE,0xFB,0x43,0xAB,0xE7,0x4F,0x60,0x42,0xC1,0x82,0x30,0xC6,0x1C,0x50,
+		 0xD1,0xCB,0x85,0xDA,0x92,0xDC,0x7D,0xCD,0xD2,0x3D,0x24,0x35,0x61,0xF0,0xCA,0x07,
+		 0x90,0x9E,0xC4,0x97,0xED,0x8D,0x52,0x12,0xD6,0xF1,0x0D,0x37,0x54,0xB0,0x70,0x4D,
+		 0x45,0x99,0x9A,0xF5,0x3A,0xA6,0xB5,0x16,0x2C,0x20,0x58,0x96,0x32,0x2D,0x04,0x0E,
+		 0xB2,0x56,0x0C,0x03,0xA0,0xA3,0x6B,0x2B,0xA8,0xA4,0x4B,0x2E,0x44,0x5E,0xB4,0x79,
+		 0x2A,0xC5,0xBF,0x15,0xAE,0x0B,0x68,0xBB,0xDB,0xB3,0xD7,0x49,0x10,0xEA,0xEF,0x89,
+		 0x28,0x8E,0x3E,0x13,0x39,0x6E,0xA9,0x1B,0x76,0xB9,0x38,0x1E,0x0F,0x57,0x4E,0x47,
+		 0x9F,0xB1,0xFE,0x94,0x98,0xFF,0xF9,0x23,0xA1,0x00,0x5C,0x95,0x80,0x6A,0x78,0xC3,
+		 0x67,0x84,0xD8,0x27,0x2F,0xC0,0x0A,0xF8,0x7A,0x51,0x62,0x6C,0x7B,0xBD,0xF3,0x21,
+		 0xD3,0x5B,0xA2,0x46,0xE4,0xAF,0x53,0xCE,0x1A,0x26,0xE2,0x41,0x1D,0x02,0x93,0x83,
+		 0x01,0x33,0xBC,0xD0,0x72,0x4C,0xE8,0x69,0x05,0xCC,0x7F,0xFD,0xE5,0x18,0xA5,0xDE,
+		 0x17,0x14,0x71,0xB7,0x81,0x9D,0x29,0x3C,0xAC,0x40,0xA7,0xDF,0x11,0x06,0x5F,0x3B,	// TransformTable
+		},
+	},
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	{	 0x023100,
+		{0x79,0xB9,0xA2,0x8C,0x76,0x1A,0x54,0xCA,0x80,0xBF,0xD8,0x4A,0x3E,0x6A,0xD2,0x83,	// TRK Ukraina
+		 0x79,0xB9,0xA2,0x8C,0x76,0x1A,0x54,0xCA,0x80,0xBF,0xD8,0x4A,0x3E,0x6A,0xD2,0x83,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		},
+
+		{0x34,0x05,0x36,0xC9,0x21,0xF7,0x09,0x03,},	//	???
+		{0x51,0x9C,0x9D,0x67,0xC8,0x5E,0x88,0x64,},	//	xor
+		{0x06,0x04,0x00,0x01,0x03,0x07,0x02,0x05,},	//	xorpos
+		{0x3F,0x48,0x16,0xDA,0xCD,0x43,0xA0,0x45,},	//	iv
+		{
+		 0xCB,0x90,0xB6,0xF5,0x44,0xB4,0x3A,0x32,0x66,0x48,0x1D,0xB5,0xAC,0xA1,0x12,0x9F,
+		 0xB9,0xF7,0x0E,0x34,0xEF,0xE1,0x68,0xD3,0x83,0x2D,0x41,0xCF,0xBC,0x0A,0x55,0xBD,
+		 0xA3,0x99,0xC3,0xD2,0x85,0xC4,0xE8,0x74,0xC5,0x51,0x82,0x58,0x70,0x19,0x9E,0x3B,
+		 0x39,0xAD,0x07,0x9A,0x13,0xC7,0xD0,0xAF,0x92,0x30,0x06,0x2F,0xC8,0x5B,0x42,0xC1,
+		 0x94,0x1A,0x3E,0x86,0x04,0xA0,0xB2,0x9D,0x09,0xF8,0x8E,0x84,0xED,0x6E,0x87,0xFC,
+		 0x7B,0x29,0x59,0x77,0x9C,0x1E,0xDC,0xF3,0x2B,0x52,0xF9,0x3D,0xF4,0xA9,0xD8,0xDB,
+		 0x7D,0xCC,0x78,0xDE,0xA2,0xA5,0x08,0xCD,0x16,0x71,0x80,0xB8,0x7F,0xFD,0x4D,0xF6,
+		 0x2C,0x69,0xDF,0xF1,0x27,0x8B,0xFB,0x53,0x62,0x9B,0xE5,0x50,0x96,0x60,0xB0,0x6C,
+
+		 0x6A,0xEE,0x2A,0x18,0x4B,0x24,0x43,0x4E,0xE6,0xAE,0xF2,0x75,0xE2,0xD7,0x4A,0xEA,
+		 0x01,0xEC,0x38,0xFA,0x40,0xEB,0x7C,0xE0,0xA6,0x21,0x33,0x79,0x54,0x47,0x2E,0x0F,
+		 0x45,0x0D,0x64,0x20,0xD4,0x65,0x98,0xBA,0xD6,0x5D,0xBB,0xB7,0x0C,0x31,0x89,0x37,
+		 0x7E,0xD1,0x46,0xC6,0x05,0x0B,0x02,0xAB,0x6B,0x10,0xA7,0xAA,0x1C,0x1F,0xE3,0xF0,
+		 0xFE,0x3F,0xE4,0x22,0x25,0x28,0xB3,0x35,0x3C,0xCE,0xE9,0x00,0x61,0x67,0xC9,0x1B,
+		 0x36,0xB1,0x23,0x17,0xA4,0xDD,0xA8,0x8D,0x5E,0xFF,0xE7,0x5F,0x56,0xD5,0x63,0x72,
+		 0x97,0x15,0x8C,0xBE,0xC2,0x7A,0x88,0xDA,0x26,0xCA,0x8F,0x95,0x91,0x4C,0x81,0x14,
+		 0xBF,0x73,0x8A,0x57,0x5C,0x03,0x6F,0x11,0x49,0x5A,0x93,0x76,0x4F,0x6D,0xC0,0xD9,
+		},
+	},
+	#endif
+};
+
+
+static void
+xvia2_EcmCore(PC26_TAB *vkp, uint8_t *c3DESK, uint8_t *cwDATAs)
+{
+	DES_key_schedule K1s;
+	DES_key_schedule K2s;
+	DES_key_schedule KAs;
+	DES_cblock 		 result;
+	uint8_t	perm_data[8];
+	uint8_t	*cwArray;
+	uint8_t	*des1Key;
+	uint8_t	*permArray;
+	uint8_t	*xorArray;
+	uint8_t	*pMkTABLE;
+	int16_t	ix, i;
+
+	des1Key   = vkp->des1K;
+	permArray = vkp->permArray;
+	xorArray  = vkp->xorArray;
+	pMkTABLE  = vkp->tMAsk;
+
+	DES_set_key((const_DES_cblock *)&c3DESK[0], &K1s);
+	DES_set_key((const_DES_cblock *)&c3DESK[8], &K2s);
+	DES_set_key((const_DES_cblock *) des1Key,   &KAs);
+
+	for (ix = 0; ix < 2; ix++)
+	{
+		cwArray = &cwDATAs[ix * 8];
+
+		for (i=0;i<8;i++) cwArray[i] = pMkTABLE[cwArray[i]];
+		for (i=0;i<8;i++) perm_data[i] = cwArray[permArray[i]];
+		memcpy(cwArray, perm_data, 8);
+		DES_ecb_encrypt ((const_DES_cblock *)cwArray, &result, &KAs, _ENCRYPT_);
+
+		for (i=0;i<8;i++) cwArray[i] = result[i] ^ xorArray[i];
+		DES_ecb3_encrypt((const_DES_cblock *)cwArray, &result, &K1s, &K2s, &K1s, _DECRYPT_);
+
+		for (i=0;i<8;i++) cwArray[i] = result[i] ^ xorArray[i];
+		DES_ecb_encrypt ((const_DES_cblock *)cwArray, &result, &KAs, _DECRYPT_);
+
+		memcpy(cwArray, result, 8);
+		for (i=0;i<8;i++) perm_data[permArray[i]] = cwArray[i];
+
+		memcpy(cwArray, perm_data, 8);
+		for (i=0;i<8;i++) cwArray[i] = pMkTABLE[cwArray[i]];
+	}
+}
+
+
+static int
+xvia2_Algo(PC26_TAB *vk2p, uint8_t kNr, uint8_t *cwDATAs)
+{
+	uint8_t *pfxkey;
+	uint8_t	*cw1xor;
+	uint8_t	cwMake[16];
+	uint8_t	c3DESK[16];
+	int16_t	ki,i;
+
+	ki = (kNr&0x07) * 16;
+	pfxkey = &(vk2p->serviceK[ki]);
+	if (!cs_Isxx(pfxkey,16)) return 0;
+
+	memcpy(c3DESK, pfxkey,  16);
+	memcpy(cwMake, cwDATAs, 16);
+	xvia2_EcmCore(vk2p, c3DESK, cwMake);
+
+	cw1xor = vk2p->chainArray;
+	for (i=0;i<8;i++) cwMake[i]   ^= cw1xor[i];
+	for (i=0;i<8;i++) cwMake[i+8] ^= cwDATAs[i];
+//	myprdump("VIA26_cw", cwMake, 16);
+
+	if (chk_cw_violation(cwMake))
+	{
+		MYEMU_TRACE("myxviacess:... PC2.5 chksum fail.\n");
+		return 0;
+	}
+
+	memcpy(cwDATAs, cwMake, 16);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/*
+V 030B00 T1 7F308A9B0B803C4B6BBFEFB041F03B58E3BCAFBEE583B415A53571952BABE9A17964A8BA8BE4E053DB6AD5511C063739D8
+            1786DD92871BD7B718E7312DDC77F3DE1AD4FC60932909703D97B9688F2C5B6221F501D0894F995028A9FD4A3F9861F71F20
+            AD030846CF546C44DF76C18D0078F607A0F17A2E32119FF4852F4913C2599E9623EB1924EDDA25FECAF894226533579DC3A39
+            C0E56044882BD755AACFA26A6B3E80567ECB136E6FF4D107E8CB8AAE1EE8E5FC42A9A525DC702CD72B20F88D9437D16D65
+            ECB406D144CF9745C127CC0C9A7A49069BB0DEAC8C563AE664ED26FB57B271D6E3ECEC645D3D142E238A2B63A340AFB739
+            11E84CC47F20C8155; TransformTable
+V 030B00 08 D92A82E3111C9AFDED4626AD0B542E5B ; Service key
+V 030B00 09 CC72AAFE5265D6D04608E832CEB9EC4D ; TNTSat
+V 030B00 D1 89CBB54EEB94E350; Des1_Key
+V 030B00 X1 8B2908AE39B0101A; XORArray
+V 030B00 P1 0704020305000601; PermArray
+V 030B00 C1 FC3C5F15D7A0B437; ChainArray
+V 030B00 0A 439726EBB6A939A456C05FF6AA606C43 ; TNT Sat
+V 030B00 0B 7C6A2428C020023B163E4FE024FF5D9D ; TNTSat
+V 030B00 E1 A79AC0DBEC9C9251D1915F058862AF26 ; SurEncryption Key
+V 030B00 E2 EF3CB8D36A862097A33FC47101041BE3 ; HD SurEncryption Key
+V 030B00 EC 9A3EAB0203EBFFCA85B4F18280749F56 ; NEW TNTSAT AES
+
+V 030B00 EC 43681CC7E46C9D9D4F7491204DA88B4F ; TNTSat new
+*/
+
+typedef struct
+{
+	uint32_t	prid;
+	uint8_t	serviceK		[128];
+	uint8_t	xorArray		[8];
+	uint8_t	chainArray	[8];
+/* UNAVAILABLE */
+//	uint8_t	des1K		 	[8];
+//	uint8_t	permArray 	[8];
+	uint8_t	tMAsk			[256];
+	uint8_t	cAesK			[512];
+} PC30_TAB;
+
+static PC30_TAB	PC30_Lst;
+static PC30_TAB 	PC30_Issuers[] =
+{
+	//------------------------------------------------------------------
+	//	TNTSAT(MULTI ECM).
+	{	 0x030B00,
+		{
+		 #if 0
+		 0xFB,0x9A,0x38,0xCE,0x69,0x97,0x55,0xF6,0x96,0xFF,0xFC,0xDA,0x6E,0xF8,0xD2,0x37,	// 0x08(ENCRYPT)
+		 0xBF,0xDF,0x66,0xB9,0x0B,0x4D,0xA6,0xE4,0xB0,0x6E,0xFE,0x85,0x0A,0x6B,0x93,0x5F,	// 0x09(ENCRYPT)
+		 0xD5,0xFF,0x29,0x10,0xD8,0xA6,0x8C,0x44,0xE4,0xE1,0xB1,0x6C,0x2B,0xD1,0xA1,0x04,	// 0x0A(ENCRYPT)
+		 0x9F,0x59,0xAF,0x7B,0x9A,0xA1,0x6E,0xEC,0x3C,0xDA,0xA9,0x5B,0xA4,0x3D,0x87,0x6D,	// 0x0B(ENCRYPT)
+		 0xC5,0x28,0x18,0x39,0x8D,0x9F,0xDA,0x0B,0xD4,0xF8,0xA5,0x53,0x1C,0xE1,0x84,0x12,	// 0x0C(ENCRYPT)
+		 0x1B,0xCA,0x9E,0x88,0x6D,0x4E,0xBD,0x52,0xDA,0x16,0x10,0x61,0x3C,0x48,0x05,0xC1,	// 0x0D(ENCRYPT)
+		 0xE7,0x86,0x4D,0xC3,0x51,0x4F,0xC3,0x9E,0x88,0x19,0xBE,0x69,0x1B,0xD5,0x07,0xC2,	// 0x0E(ENCRYPT)
+		 0x29,0x09,0x1E,0x70,0xA9,0x39,0x2C,0x67,0xA3,0x94,0xDB,0x9B,0x70,0x7F,0x1E,0x7C,	// 0x0F(ENCRYPT)
+		 #else
+		 // DECRYPT.....................................................
+		 0xD9,0x2A,0x82,0xE3,0x11,0x1C,0x9A,0xFD,0xED,0x46,0x26,0xAD,0x0B,0x54,0x2E,0x5B, 	// 08(DECRYPT)
+		 0xCC,0x72,0xAA,0xFE,0x52,0x65,0xD6,0xD0,0x46,0x08,0xE8,0x32,0xCE,0xB9,0xEC,0x4D, 	// 09(DECRYPT)
+//		 0x43,0x97,0x26,0xEB,0xB6,0xA9,0x39,0xA4,0x56,0xC0,0x5F,0xF6,0xAA,0x60,0x6C,0x43, 	// 0A(DECRYPT)
+//		 0x15,0x73,0x59,0x6C,0xFC,0x67,0x21,0xF8,0xE2,0xF7,0xA2,0x90,0xDA,0x57,0x50,0x5C,
+		 0xEE,0x26,0x79,0x60,0x4A,0x7D,0xDD,0x32,0xE4,0xF8,0xCB,0x91,0x35,0x00,0xD3,0x8E,
+		 0x7C,0x6A,0x24,0x28,0xC0,0x20,0x02,0x3B,0x16,0x3E,0x4F,0xE0,0x24,0xFF,0x5D,0x9D, 	// 0B(DECRYPT)
+		 0x9A,0xEF,0x82,0x13,0x13,0x06,0xB6,0xA5,0xDD,0x06,0xC3,0xF1,0xAB,0xEB,0x22,0x6D, 	// 0C(DECRYPT)
+//		 0xA2,0x62,0xE3,0x54,0x7B,0xBD,0x16,0xF1,0x1C,0xEE,0x12,0xB0,0x01,0x8F,0x5C,0xDA,	// 0D(DECRYPT)
+		 0x36,0x54,0xE8,0xEF,0x09,0x6B,0x6F,0x04,0xD9,0x4F,0x83,0xD6,0x3E,0x9E,0x33,0xE1,
+		 0x3B,0x57,0x38,0xE5,0xE7,0x7A,0x06,0xCC,0x6F,0x97,0xD7,0x4A,0xAA,0x3F,0x80,0x38, 	// 0E(DECRYPT)
+		 0x00,0x18,0x8F,0xA8,0x0A,0xE1,0xEA,0x8D,0x00,0xE7,0x2C,0xB6,0xDC,0x57,0x5D,0x55,	// 0F(DECRYPT)
+		 #endif
+		},
+
+		{0x8B,0x29,0x08,0xAE,0x39,0xB0,0x10,0x1A,},
+		{0xFC,0x3C,0x5F,0x15,0xD7,0xA0,0xB4,0x37,},
+//		{0x89,0xCB,0xB5,0x4E,0xEB,0x94,0xE3,0x50,},	/* des1K */
+//		{0x07,0x04,0x02,0x03,0x05,0x00,0x06,0x01,},	/* permArray */
+		{
+		 0x7F,0x30,0x8A,0x9B,0x0B,0x80,0x3C,0x4B,0x6B,0xBF,0xEF,0xB0,0x41,0xF0,0x3B,0x58,
+		 0xE3,0xBC,0xAF,0xBE,0xE5,0x83,0xB4,0x15,0xA5,0x35,0x71,0x95,0x2B,0xAB,0xE9,0xA1,
+		 0x79,0x64,0xA8,0xBA,0x8B,0xE4,0xE0,0x53,0xDB,0x6A,0xD5,0x51,0x1C,0x06,0x37,0x39,
+		 0xD8,0x17,0x86,0xDD,0x92,0x87,0x1B,0xD7,0xB7,0x18,0xE7,0x31,0x2D,0xDC,0x77,0xF3,
+		 0xDE,0x1A,0xD4,0xFC,0x60,0x93,0x29,0x09,0x70,0x3D,0x97,0xB9,0x68,0x8F,0x2C,0x5B,
+		 0x62,0x21,0xF5,0x01,0xD0,0x89,0x4F,0x99,0x50,0x28,0xA9,0xFD,0x4A,0x3F,0x98,0x61,
+		 0xF7,0x1F,0x20,0xAD,0x03,0x08,0x46,0xCF,0x54,0x6C,0x44,0xDF,0x76,0xC1,0x8D,0x00,
+		 0x78,0xF6,0x07,0xA0,0xF1,0x7A,0x2E,0x32,0x11,0x9F,0xF4,0x85,0x2F,0x49,0x13,0xC2,
+		 0x59,0x9E,0x96,0x23,0xEB,0x19,0x24,0xED,0xDA,0x25,0xFE,0xCA,0xF8,0x94,0x22,0x65,
+		 0x33,0x57,0x9D,0xC3,0xA3,0x9C,0x0E,0x56,0x04,0x48,0x82,0xBD,0x75,0x5A,0xAC,0xFA,
+		 0x26,0xA6,0xB3,0xE8,0x05,0x67,0xEC,0xB1,0x36,0xE6,0xFF,0x4D,0x10,0x7E,0x8C,0xB8,
+		 0xAA,0xE1,0xEE,0x8E,0x5F,0xC4,0x2A,0x9A,0x52,0x5D,0xC7,0x02,0xCD,0x72,0xB2,0x0F,
+		 0x88,0xD9,0x43,0x7D,0x16,0xD6,0x5E,0xCB,0x40,0x6D,0x14,0x4C,0xF9,0x74,0x5C,0x12,
+		 0x7C,0xC0,0xC9,0xA7,0xA4,0x90,0x69,0xBB,0x0D,0xEA,0xC8,0xC5,0x63,0xAE,0x66,0x4E,
+		 0xD2,0x6F,0xB5,0x7B,0x27,0x1D,0x6E,0x3E,0xCE,0xC6,0x45,0xD3,0xD1,0x42,0xE2,0x38,
+		 0xA2,0xB6,0x3A,0x34,0x0A,0xFB,0x73,0x91,0x1E,0x84,0xCC,0x47,0xF2,0x0C,0x81,0x55,
+		},
+
+		{0x28,0x44,0x25,0x87,0x92,0xF6,0xD9,0x52,0x9A,0x32,0x8B,0x3E,0x8C,0xD2,0xFD,0x0E,	// E0
+//		 0xA7,0x9A,0xC0,0xDB,0xEC,0x9C,0x92,0x51,0xD1,0x91,0x5F,0x05,0x88,0x62,0xAF,0x26,	// E1
+//		 0x82,0x1F,0x45,0x56,0x23,0x8D,0xDE,0x0F,0xA0,0xBD,0x31,0x8F,0x08,0x3E,0x84,0xBC,	// E1  /* 2014.06.12 */
+//		 0xF1,0xDC,0xB1,0x5A,0x3D,0xE3,0xFA,0x1D,0x7E,0x29,0x98,0xDA,0x7D,0xD4,0x89,0x8A,	// E1  /* 2014.06.30 */
+		 0xF7,0x86,0xE2,0x1F,0x17,0x82,0xBE,0x09,0x75,0x53,0xB0,0xD3,0x49,0xE0,0x36,0x2A,	// E1  /* 2014.07.09 */
+//		 0xEF,0x3C,0xB8,0xD3,0x6A,0x86,0x20,0x97,0xA3,0x3F,0xC4,0x71,0x01,0x04,0x1B,0xE3,	// E2
+//		 0x9B,0x63,0xA9,0x7D,0xA5,0xC8,0x0A,0x87,0xA8,0x7E,0xF1,0x6C,0xB2,0x8E,0xF1,0xAB,	// E2  /* 2014.06.17 */
+ 		 0x48,0xC1,0x9B,0x86,0xA4,0xE2,0xEB,0x72,0x88,0xDF,0xDC,0xE7,0xC2,0xBB,0x75,0x77,	// E2  /* 2014.06.30 */
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E3
+		 0x6B,0x1B,0x02,0x4D,0x36,0xF6,0x09,0x74,0x97,0x3C,0xB8,0x1F,0xA5,0xE8,0xF0,0x1C,	// E4
+		 0x12,0x70,0x03,0xF8,0xE9,0x51,0x00,0x36,0x7A,0x55,0x61,0x21,0xC7,0x79,0xFB,0x6E,	// E5
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E6
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E7
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E8
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E9
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EA
+ 		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EB
+		 0x9A,0x3E,0xAB,0x02,0x03,0xEB,0xFF,0xCA,0x85,0xB4,0xF1,0x82,0x80,0x74,0x9F,0x56,	// EC
+		 0x25,0x04,0xB3,0x82,0xB1,0x6D,0x8C,0x67,0x58,0xDB,0x96,0x0E,0x31,0x1E,0x93,0x51,	// ED
+		 0x34,0x98,0x83,0xE5,0x4D,0x58,0x33,0x6D,0xCA,0x75,0x0A,0x87,0x8A,0xCC,0x5C,0xD5,	// EE
+//		 0x12,0x70,0x03,0xF8,0xE9,0x51,0x00,0x36,0x7A,0x55,0x61,0x21,0xC7,0x79,0xFB,0x6E,	// EF
+		 0x4A,0x26,0xAD,0x25,0x17,0x95,0xA5,0x8A,0x11,0xBB,0xC0,0x7B,0x53,0xC4,0x43,0x48,	// EF  /* 2014.06.23 */
+
+		 0x28,0x44,0x25,0x87,0x92,0xF6,0xD9,0x52,0x9A,0x32,0x8B,0x3E,0x8C,0xD2,0xFD,0x0E,	// E10 /* 2014.06.26 */
+		 0xF6,0x2C,0x3B,0xE3,0x00,0xE9,0x8B,0xBB,0x37,0x8D,0xFA,0x38,0xBB,0x6E,0xEE,0xF1,   // E11 /* 2014.06.26 */
+ 		 0xDD,0x39,0x0F,0xED,0x21,0x91,0xD2,0x82,0x01,0x60,0x25,0x09,0x3E,0xE0,0x91,0xBA,	// E12 /* 2014.06.26 */
+		 0x8C,0x61,0x99,0xE0,0xB8,0x87,0x7F,0x4B,0xD2,0x13,0x6E,0xF6,0xD1,0x14,0x2D,0x15,	// E13
+		 0x6B,0x1B,0x02,0x4D,0x36,0xF6,0x09,0x74,0x97,0x3C,0xB8,0x1F,0xA5,0xE8,0xF0,0x1C,	// E14
+		 0x12,0x70,0x03,0xF8,0xE9,0x51,0x00,0x36,0x7A,0x55,0x61,0x21,0xC7,0x79,0xFB,0x6E,	// E15
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E16
+		 0x1D,0xE0,0xC4,0x62,0x3A,0x8C,0x79,0x8B,0xD7,0x69,0x3C,0xCB,0xE6,0x4C,0x9A,0xC0,	// E17
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E18
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E19
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E1A
+ 		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E1B
+		 0x9A,0x3E,0xAB,0x02,0x03,0xEB,0xFF,0xCA,0x85,0xB4,0xF1,0x82,0x80,0x74,0x9F,0x56,	// E1C
+		 0x25,0x04,0xB3,0x82,0xB1,0x6D,0x8C,0x67,0x58,0xDB,0x96,0x0E,0x31,0x1E,0x93,0x51,	// E1D
+		 0x34,0x98,0x83,0xE5,0x4D,0x58,0x33,0x6D,0xCA,0x75,0x0A,0x87,0x8A,0xCC,0x5C,0xD5,	// E1E
+		 0x4A,0x26,0xAD,0x25,0x17,0x95,0xA5,0x8A,0x11,0xBB,0xC0,0x7B,0x53,0xC4,0x43,0x48,	// E1F
+		},
+	},
+	//------------------------------------------------------------------
+	//	Astra19 CANAL France.
+	{	 0x032820,
+		{0x84,0x84,0xF3,0x2D,0x0A,0x83,0x96,0x8B,0x1D,0x9C,0xD5,0x92,0xC2,0x72,0x07,0x47,	// 0x8
+		 0xD9,0x0D,0x97,0xE7,0xF2,0xA1,0xA9,0xC7,0x98,0x6C,0xC7,0x1D,0xE1,0x6C,0x9F,0xE6,	// 0x9(?)
+		 0x00,0x64,0x57,0x1D,0x97,0xD8,0x3A,0x8A,0xA7,0x0A,0x78,0x21,0xFF,0x75,0x40,0xE9,	// 0xA(?)
+		 0xA4,0xA9,0x40,0x27,0x1F,0xD3,0x11,0x8F,0x45,0x3D,0xA0,0x7A,0x48,0xA3,0xA3,0x36,	// 0xB(?)
+		 0xD2,0xE2,0xEB,0xB4,0x30,0x70,0x26,0x43,0x80,0xF7,0x02,0xF0,0x8B,0x7C,0x43,0xE3,	// 0xC(?)
+		 0x5C,0xEE,0xBF,0x5F,0xE8,0x0F,0xD6,0x08,0x89,0x14,0x7E,0x4E,0xD4,0xF0,0x28,0x98,	// 0xD(?)
+		 0xBC,0x98,0x78,0xEB,0xF0,0xBD,0xF3,0x4D,0x0C,0x0D,0x55,0x66,0x77,0x86,0xDD,0xF3,	// 0xE(?)
+		 0x1D,0x5A,0x2D,0xA5,0xBF,0x4F,0x71,0xDB,0xB6,0x86,0xDA,0x16,0x01,0x16,0xDB,0xAF,	// 0xF(?)
+		},
+
+		{0x46,0x8A,0x85,0xB4,0xB4,0x5F,0x4D,0x4A,},
+		{0x87,0x00,0x76,0x8A,0x35,0x17,0x29,0xD5,},
+//		{0x89,0xCB,0xB5,0x4E,0xEB,0x94,0xE3,0x50,},	/* des1K */
+//		{0x07,0x04,0x02,0x03,0x05,0x00,0x06,0x01,},	/* permArray */
+		{
+		 /* MASKTABLE T1 256 */
+		 0x6F,0x64,0x8B,0x8C,0x91,0xF6,0x09,0x63,0x5A,0x9C,0xB6,0xF2,0x5D,0xAA,0xE1,0x88,
+		 0xCF,0x66,0x4A,0x65,0x7C,0xFA,0x48,0x08,0x36,0x75,0x34,0x22,0x86,0xEC,0x77,0x1F,
+		 0xEB,0xF7,0xE3,0xAD,0xB8,0xD4,0xBA,0x9B,0xE6,0x8A,0xD5,0xC9,0xC7,0xDD,0xF4,0x73,
+		 0x87,0xC8,0xE9,0xE0,0xC2,0x55,0x3F,0x74,0x8F,0xD9,0x31,0x7E,0x59,0x6D,0xFC,0x25,
+		 0xBE,0x19,0xEE,0xFB,0x43,0xAB,0xE7,0x4F,0x60,0x42,0xC1,0x82,0x30,0xC6,0x1C,0x50,
+		 0xD1,0xCB,0x85,0xDA,0x92,0xDC,0x7D,0xCD,0xD2,0x3D,0x24,0x35,0x61,0xF0,0xCA,0x07,
+		 0x90,0x9E,0xC4,0x97,0xED,0x8D,0x52,0x12,0xD6,0xF1,0x0D,0x37,0x54,0xB0,0x70,0x4D,
+		 0x45,0x99,0x9A,0xF5,0x3A,0xA6,0xB5,0x16,0x2C,0x20,0x58,0x96,0x32,0x2D,0x04,0x0E,
+
+		 0xB2,0x56,0x0C,0x03,0xA0,0xA3,0x6B,0x2B,0xA8,0xA4,0x4B,0x2E,0x44,0x5E,0xB4,0x79,
+		 0x2A,0xC5,0xBF,0x15,0xAE,0x0B,0x68,0xBB,0xDB,0xB3,0xD7,0x49,0x10,0xEA,0xEF,0x89,
+		 0x28,0x8E,0x3E,0x13,0x39,0x6E,0xA9,0x1B,0x76,0xB9,0x38,0x1E,0x0F,0x57,0x4E,0x47,
+		 0x9F,0xB1,0xFE,0x94,0x98,0xFF,0xF9,0x23,0xA1,0x00,0x5C,0x95,0x80,0x6A,0x78,0xC3,
+		 0x67,0x84,0xD8,0x27,0x2F,0xC0,0x0A,0xF8,0x7A,0x51,0x62,0x6C,0x7B,0xBD,0xF3,0x21,
+		 0xD3,0x5B,0xA2,0x46,0xE4,0xAF,0x53,0xCE,0x1A,0x26,0xE2,0x41,0x1D,0x02,0x93,0x83,
+		 0x01,0x33,0xBC,0xD0,0x72,0x4C,0xE8,0x69,0x05,0xCC,0x7F,0xFD,0xE5,0x18,0xA5,0xDE,
+		 0x17,0x14,0x71,0xB7,0x81,0x9D,0x29,0x3C,0xAC,0x40,0xA7,0xDF,0x11,0x06,0x5F,0x3B,
+		},
+
+		{0xB1,0x0E,0x22,0x76,0x55,0x5C,0x12,0x73,0x61,0x81,0x8C,0xE2,0xB9,0xF1,0xE7,0xD4,
+		 0xB1,0x0E,0x22,0x76,0x55,0x5C,0x12,0x73,0x61,0x81,0x8C,0xE2,0xB9,0xF1,0xE7,0xD4,
+		 0xB1,0x0E,0x22,0x76,0x55,0x5C,0x12,0x73,0x61,0x81,0x8C,0xE2,0xB9,0xF1,0xE7,0xD4,
+		 0xB1,0x0E,0x22,0x76,0x55,0x5C,0x12,0x73,0x61,0x81,0x8C,0xE2,0xB9,0xF1,0xE7,0xD4,
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E4
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E5
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E6
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E7
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E8
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E9
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EA
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EB
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EC
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// ED
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EE
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EF
+		},
+	},
+};
+
+
+static int32_t
+xvia3_N0F11_EncBasis(int32_t Value, int32_t XorVal)
+{
+	// LSB
+	int32_t i = (Value << 13) - Value + 0x1B59;
+	i = (i * Value) + 0x07CF;
+	return (i ^ XorVal);
+}
+
+static int32_t
+xvia3_N0F11_EncLookup(uint8_t Value, uint8_t AddrInd)
+{
+	static const uint8_t lookup[] = {
+		0x94,0xB2,0xA9,0x79,0xC4,0xC7,0x0D,0x36,0x6F,0x24,0x11,0xD1,0xDB,0x59,0xD2,0xA5,
+		0xE1,0x00,0xD4,0x97,0xA3,0x2B,0x11,0xFA,0x5F,0xF1,0xC1,0x44,0xBF,0x9B,0x5A,0xC8,
+		0xF1,0xE1,0x99,0x82,0x0E,0xB2,0x01,0x09,0x0C,0xC8,0xB3,0x3B,0xD1,0x80,0x50,0xE8,
+		0xF5,0x52,0x4C,0xE6,0x82,0xAC,0x58,0x40,0xD4,0x71,0x87,0x52,0x06,0xEA,0xA6,0x27,
+		0xB7,0xFE,0x6C,0x49,0x47,0x3B,0x70,0x6C,0xEB,0xCD,0xC5,0x0B,0x8C,0x31,0x29,0x42,
+		0x4E,0x10,0x2B,0x2D,0x46,0xEC,0x39,0xA3,0x90,0x4B,0x25,0x60,0x9C,0x62,0xD4,0x20,
+		0xF6,0x16,0xA8,0x9C,0xE4,0x20,0xED,0xC7,0xBA,0x5E,0xB6,0x4E,0x03,0x15,0xA6,0xF6,
+		0x23,0x98,0x32,0xC0,0xAE,0xA3,0xFD,0xD3,0x7F,0xF8,0xED,0xF0,0x29,0x29,0x12,0xB3,
+		0xB7,0x58,0xAD,0xA2,0x58,0x2C,0x70,0x1B,0xA4,0x25,0xE8,0xA5,0x43,0xF1,0xB9,0x8F,
+		0x1E,0x3B,0x10,0xDF,0x52,0xFE,0x58,0x29,0xAD,0x3F,0x99,0x4D,0xDF,0xD2,0x08,0x06,
+		0xA1,0x1C,0x66,0x29,0x26,0x80,0x52,0x8A,0x5A,0x73,0xE7,0xDF,0xC1,0xC4,0x47,0x82,
+		0xAB,0x5C,0x32,0xAE,0x96,0x04,0x2B,0xC3,0x2D,0x5A,0xD2,0xB0,0x64,0x88,0x97,0xBF,
+		0x7E,0x99,0x60,0xCC,0x63,0x76,0x66,0xE9,0x9A,0x3D,0xBB,0xF7,0x7F,0xE4,0x7C,0x3F,
+		0xB8,0x4D,0x10,0x8D,0x2A,0xEA,0x3C,0xD3,0x03,0x74,0xE6,0x46,0xC0,0x29,0xAE,0xB0,
+		0x79,0xBE,0xCB,0x18,0x34,0xBE,0x5A,0xE9,0x19,0x8F,0xA3,0x8F,0xD6,0x6A,0x6C,0x88,
+		0x1E,0x21,0x08,0x15,0xC4,0xE7,0xE6,0xBA,0x97,0x9C,0x4F,0x89,0x9F,0x1A,0x67,0x4F,
+		0xC0,0xD5,0x72,0x51,0x16,0xB4,0xD3,0x8A,0x1F,0xE3,0x92,0x02,0x7F,0x59,0x56,0x8F,
+		0x07,0x8D,0xC1,0xC2,0x42,0x69,0x3C,0xA6,0xBF,0x3D,0xDF,0x0D,0xAA,0x4F,0x7E,0x80,
+		0x07,0x11,0xE2,0x94,0x19,0x9B,0x16,0x26,0x1A,0x46,0x09,0x0D,0xB5,0xB8,0x8E,0x01,
+		0x9C,0xFE,0x09,0xB3,0x60,0xC2,0xAE,0x50,0x3C,0x68,0x75,0x4A,0x57,0xD8,0x4F,0xD7,
+		0xA2,0x76,0x2C,0xC1,0xA2,0x23,0xBC,0x54,0x2A,0xDD,0xF3,0xDD,0xA7,0x34,0xF7,0x5C,
+		0xF4,0x86,0x23,0x48,0x7C,0x3F,0x05,0x40,0x0E,0xB0,0xE5,0xEB,0x3E,0xDF,0x6A,0x83,
+		0x65,0xA0,0xB2,0x06,0xD1,0x40,0x79,0x0D,0xDE,0x95,0x84,0x96,0x87,0x6F,0xCE,0x48,
+		0x24,0x13,0x0B,0xF5,0xC7,0xF5,0xA8,0x7F,0x2E,0xC7,0xE1,0xBA,0xAE,0x2B,0xF7,0xF0,
+		0x8E,0xF7,0x54,0x0B,0xF0,0xD2,0x41,0x81,0x68,0x3B,0x1E,0x35,0xAB,0xD9,0x2B,0x46,
+		0x57,0xE8,0x53,0xDF,0xDE,0x10,0xEF,0xCB,0x4C,0xE0,0x52,0x18,0x2C,0x4E,0xB9,0x20,
+		0xE9,0x7E,0x85,0xDF,0x75,0x32,0xE6,0x10,0xE9,0x9C,0x7B,0x2E,0x4C,0xDA,0x46,0xE6,
+		0xCC,0x77,0x36,0x1D,0x4A,0x15,0xF5,0x32,0x18,0x6B,0x7E,0xAA,0xCC,0x97,0xCC,0xD1,
+		0x2F,0xE5,0x58,0x03,0x35,0x35,0x3D,0xA0,0x2B,0x13,0x3A,0x65,0xFF,0x24,0x72,0xCF,
+		0xA7,0x6D,0x52,0x55,0xF6,0xC2,0x30,0x23,0x7D,0x9B,0x9E,0xB0,0x94,0x02,0xAD,0x60,
+		0x8A,0x9F,0xBC,0xC8,0xE4,0x2B,0x92,0x96,0xF5,0xAE,0x04,0xA4,0x33,0x0C,0x90,0x67,
+		0xF0,0xB9,0x1E,0x7E,0xBE,0x02,0x18,0xB2,0x03,0xB6,0x40,0xBF,0x05,0xE3,0x76,0x98,
+		0x21,0x38,0xC9,0x5F,0xD3,0x51,0x8B,0x43,0x0B,0x1A,0x0B,0xF9,0x3C,0x21,0x6C,0x3D,
+		0xB8,0xA0,0x57,0xCA,0x68,0xCD,0x1E,0xD2,0x2C,0x50,0xEE,0xC0,0xDF,0x25,0x88,0x52,
+		0x37,0xE1,0x44,0xC6,0x76,0x3B,0x91,0x95,0x86,0x76,0x87,0x49,0x21,0x93,0x44,0x0A,
+		0x52,0xB9,0x2D,0x2B,0xE3,0x1D,0xB0,0xE4,0x98,0xC6,0xEE,0x3D,0x96,0x53,0x4B,0xFF,
+		0x39,0x00,0xD5,0x42,0x7E,0xE1,0x4C,0x6F,0xD5,0xB7,0xE6,0x99,0x2A,0x5B,0x67,0xEE,
+		0x3E,0xBA,0xF7,0xEC,0x43,0x2A,0x1C,0xB6,0xB5,0x04,0x26,0x59,0xB1,0x4C,0x17,0xCC,
+		0x83,0xB9,0x00,0x3E,0x36,0x91,0x90,0xF7,0x5E,0x38,0xDC,0xE4,0x15,0xC7,0x67,0xF0,
+		0xCA,0xC8,0xD2,0x91,0x5D,0x74,0xAC,0x97,0x56,0x36,0x1A,0x82,0x0A,0xAA,0xB4,0x4E,
+		0xBF,0x29,0x5C,0xBF,0x58,0xB3,0x97,0xF9,0xEB,0x7C,0x85,0xB4,0xA5,0x13,0x2F,0xD1,
+		0xDE,0x1C,0xEC,0x97,0xDD,0xE2,0x39,0xE4,0xFB,0x0A,0x02,0xE0,0xC3,0xBA,0x39,0x79,
+		0xAA,0x1C,0x37,0x75,0x25,0x54,0xBE,0x85,0x74,0x2C,0xFA,0x0C,0xFA,0x50,0xF6,0xBE,
+		0x9F,0x2A,0x53,0x7C,0x27,0x46,0x68,0x2D,0x74,0x2B,0x46,0xDA,0xF5,0x07,0x95,0x09,
+		0x6A,0x91,0xB7,0xB1,0x34,0x07,0x5F,0xEA,0xBE,0x0F,0x87,0x28,0x68,0x97,0x43,0x77,
+		0xD5,0x38,0x2B,0x11,0x11,0x4F,0xD9,0x75,0x5E,0xE1,0x06,0xA0,0x3B,0xAC,0x32,0xFE,
+		0xBF,0x73,0x59,0x5B,0xA2,0xA8,0x7E,0x10,0x4C,0x6E,0x78,0xF0,0x4A,0x4E,0x95,0xD6,
+		0xDD,0x05,0x7A,0xBB,0xF1,0xEB,0xA8,0xA4,0x5D,0x91,0xF0,0xED,0xDB,0xB8,0x01,0x41,
+		0xF8,0x97,0x7F,0xC3,0x91,0x53,0xBF,0xE9,0xEA,0x33,0x1F,0xDC,0xA6,0xE6,0x8D,0xCB,
+		0x75,0xD0,0x69,0xD0,0xA4,0x59,0xA5,0x02,0xFC,0x60,0x0D,0x6A,0xA0,0x05,0x1A,0x54,
+		0x8A,0xA7,0x57,0xA3,0xF0,0x90,0x8A,0xD5,0x6F,0x1E,0x2E,0x10,0x9A,0x93,0x2B,0x51,
+		0x2C,0xFD,0x99,0xE5,0x9B,0x5D,0xB2,0xA7,0x37,0x99,0x26,0x35,0xCA,0xDD,0x22,0x19,
+		0x59,0x2A,0xB0,0x99,0x23,0xDF,0xA7,0xA9,0x85,0x12,0xCF,0xBF,0xFC,0x74,0x80,0x87,
+		0xE1,0x97,0xD0,0xF9,0xEF,0x5F,0x1B,0x45,0xF7,0x76,0xDB,0x66,0x39,0x05,0x43,0x06,
+		0xA9,0x9F,0x2E,0x14,0x9F,0x1C,0x0C,0x1F,0xD5,0xD9,0xA4,0x8D,0x18,0x6F,0x08,0x53,
+		0x0B,0x92,0x9A,0x0C,0xEA,0x4C,0xE4,0x1D,0x9E,0x9A,0x51,0xB8,0x7E,0x2D,0xE7,0x3C,
+		0xFF,0x84,0x5C,0xBF,0x8F,0x8C,0x89,0x09,0x1B,0x7E,0x4B,0xE7,0x85,0xEC,0x04,0xB5,
+		0x20,0x18,0x1E,0x55,0xD5,0x5B,0xAC,0xC6,0x25,0x5A,0xA1,0x81,0xC1,0x31,0x9C,0xF5,
+		0xB5,0x54,0x07,0x65,0x0A,0x5B,0x90,0x06,0x4F,0x84,0xB2,0x7F,0xD1,0xAD,0x16,0x81,
+		0x25,0xAF,0xAF,0xE2,0x03,0xA9,0x1F,0x13,0x02,0x5D,0x54,0x89,0xCD,0x44,0x51,0xEB,
+		0xA4,0x2B,0xBD,0x47,0xB0,0xB6,0x27,0x1D,0x9B,0x14,0x6F,0xBF,0xCD,0x59,0xBC,0x0A,
+		0x37,0xA8,0x74,0x7D,0x16,0x90,0x28,0xD5,0x94,0xC3,0xE4,0x23,0xC4,0x98,0x91,0xCE,
+		0x55,0xBD,0x21,0x3B,0x84,0xBD,0x44,0x3C,0xF9,0xCD,0x37,0x43,0x4A,0xC6,0x8C,0x23,
+		0x04,0x28,0x63,0x7A,0x03,0x85,0xD2,0x46,0x93,0xCA,0xFE,0xC3,0x83,0x0B,0x13,0xCC,
+		0x5D,0xCB,0xBA,0xCA,0x68,0xAB,0x05,0xF7,0xEC,0x4A,0x9C,0x0F,0xD5,0xC4,0x5A,0xA5,
+		0xA0,0x04,0x41,0x6A,0xF6,0xEF,0x16,0x9B,0x69,0x38,0xF6,0x2D,0xAA,0xEB,0x2D,0xE2,
+		0x82,0xA2,0x9F,0x6F,0xBD,0x2A,0xE3,0x66,0x6B,0x21,0xDA,0x56,0xAD,0x82,0x2B,0x93,
+		0xF3,0x25,0xEA,0xFC,0xFD,0xFD,0x1B,0xA9,0xFC,0xB8,0xC6,0x98,0x45,0xF2,0x70,0x03,
+		0x4A,0x9C,0x60,0x82,0x65,0xB6,0x68,0x4C,0xE7,0x41,0x10,0x9D,0x59,0x40,0x03,0x02,
+		0x07,0x12,0x33,0xAF,0x79,0xE1,0xC4,0xEB,0xB8,0xCE,0x6A,0x90,0x72,0x61,0x5D,0x56,
+		0xC7,0x59,0x31,0xCB,0x45,0x2D,0x42,0x9F,0x10,0x1D,0x09,0x63,0x59,0x8C,0x6C,0xDB,
+		0x11,0xCF,0xA1,0xDF,0x5F,0x4D,0xDF,0xB4,0xC3,0x82,0xEE,0x58,0x16,0xB4,0x74,0xFA,
+		0xBE,0x11,0x9C,0x1E,0x98,0x29,0xDE,0xE3,0xE5,0x9E,0xCF,0xD7,0x91,0x0A,0xA3,0xA4,
+		0x42,0xA1,0x95,0x09,0x9E,0x16,0xD5,0xA8,0x24,0x56,0x5B,0x23,0xC8,0x56,0x4C,0xCB,
+		0x89,0x18,0x69,0xEB,0x0C,0x1F,0xC0,0x41,0x5C,0x63,0x04,0x68,0xB2,0x0F,0x3F,0x88,
+		0x36,0xDD,0x23,0x4D,0x4C,0xC0,0x81,0xE3,0xE9,0xAD,0xE0,0x27,0xD5,0xE5,0x46,0xEB,
+		0xFF,0x32,0xA2,0xB7,0x14,0x64,0x0B,0x6D,0x1B,0xE5,0xD8,0xAE,0x9D,0xE8,0x55,0xB9,
+		0x52,0x70,0x59,0xB8,0x72,0x92,0x69,0x37,0x95,0x61,0x0A,0xE5,0xF6,0x55,0x97,0x1D,
+		0xBF,0xF7,0x29,0x77,0x0F,0x72,0x80,0xB2,0x7E,0x56,0xBF,0xFD,0xE9,0xF5,0x9B,0x62,
+		0xE9,0xBD,0x0B,0xC2,0x07,0x55,0x31,0x4C,0x57,0x3A,0x05,0xB9,0x27,0x41,0x4A,0xC3,
+		0xEC,0x72,0x20,0xB3,0x0C,0xF9,0xD9,0x3A,0x14,0x6A,0x03,0x44,0x6A,0xF1,0x41,0x55,
+		0x7F,0x81,0xC2,0x04,0xA8,0x05,0xB9,0x49,0x2E,0x43,0xC4,0x00,0x87,0x86,0x04,0xAC,
+		0xAF,0x73,0x78,0x0E,0xA4,0x43,0x5B,0x36,0xA2,0x8F,0x9C,0xF7,0x66,0x4A,0x5A,0x09,
+		0x6B,0xAA,0x69,0x6F,0xB1,0x20,0x0D,0x56,0x85,0x0A,0x5E,0x06,0xBF,0xE2,0x32,0xB4,
+		0x5C,0x46,0x33,0x0D,0x27,0xA3,0x6B,0xE1,0xB2,0x6A,0x7D,0x4A,0xA7,0x81,0x0F,0x2B,
+		0x16,0x7C,0x51,0xD6,0xC0,0x3D,0xB9,0xFE,0xB4,0x66,0xC4,0xB6,0x54,0x53,0x67,0xDA,
+		0x70,0x96,0x9A,0x0A,0x07,0x1A,0x26,0xBA,0x85,0x50,0xF5,0x27,0x53,0x9C,0x3A,0x94,
+		0x0A,0x7D,0xDB,0xE1,0xC3,0xE3,0x6A,0x3E,0x9E,0xD5,0x13,0x0A,0xA3,0xD2,0x21,0x75,
+		0x79,0x17,0x26,0xAC,0x48,0x5F,0x3D,0xE1,0x7D,0xA4,0xB1,0x56,0x0F,0x92,0x2C,0x60,
+		0xE6,0xCB,0x87,0x35,0xB8,0x75,0xC3,0xA2,0x03,0x50,0x4B,0xA2,0x6E,0x01,0xE1,0xDD,
+		0x87,0xA5,0x33,0xC6,0x2F,0xA2,0x41,0xFC,0x72,0x98,0xA2,0x69,0x4C,0x3F,0xF0,0x53,
+		0xF5,0x41,0x2B,0x23,0x24,0x3B,0xCE,0x9D,0x39,0x31,0x17,0x08,0xE1,0x3F,0x5F,0xFB,
+		0x00,0xFA,0xF1,0xE3,0xE1,0x7B,0x0C,0xDF,0x8D,0xA2,0xC4,0xCD,0x62,0x3D,0xAE,0xC7,
+		0x48,0x09,0x1C,0x66,0xCB,0x0E,0x23,0xE8,0x1B,0x9F,0x1B,0xCB,0xF8,0x14,0xC3,0x34,
+		0x91,0x32,0x2B,0x39,0x1C,0xBA,0x1C,0xA0,0x19,0xF2,0x57,0x9D,0x78,0x00,0x55,0x1F,
+		0x15,0x12,0x9A,0xA2,0xF2,0xC2,0xB7,0x4E,0xEA,0x46,0x01,0xC2,0xE9,0x76,0xBF,0xDE,
+		0xCF,0x8B,0xC7,0x50,0x80,0xEE,0x46,0x91,0x93,0x1E,0x5C,0x48,0x5D,0xC8,0xC8,0x63,
+		0xD1,0x89,0x02,0x29,0xE9,0x90,0x9F,0x0B,0x0A,0x1A,0x44,0x17,0xE7,0x4E,0xAD,0x58,
+		0x55,0xF8,0x38,0xF6,0x4F,0xD8,0x1C,0x7E,0x25,0x9B,0x59,0x16,0xBC,0x65,0x24,0xC5,
+		0xA7,0x56,0xE5,0x20,0x3F,0xD9,0x27,0xE0,0x32,0x24,0xE1,0x7B,0xE1,0x32,0xEA,0xF4,
+		0xFE,0xD9,0xA5,0xFF,0x35,0xAE,0xA9,0x1B,0x38,0x28,0x6A,0xC0,0x1A,0x42,0xD9,0x5E,
+		0x14,0x2C,0xC2,0x2D,0x9B,0x94,0x5B,0xCF,0x83,0x30,0xB9,0x06,0xAF,0x4B,0xD7,0xF6,
+		0x38,0x7C,0xFF,0xB4,0xA5,0x1A,0xA0,0xE9,0xF3,0x01,0xE3,0x97,0xC4,0xA9,0x57,0xF5,
+		0xB9,0x96,0xA7,0xA3,0xB8,0x10,0x0E,0xFB,0x1D,0x39,0x44,0x16,0x97,0x94,0x3E,0x5F,
+		0xAF,0x0F,0xE3,0x99,0xDC,0xA0,0xE9,0x8D,0x26,0x2B,0xD9,0xAE,0xEC,0x4C,0x4F,0x09,
+		0x86,0x7E,0x7B,0xC3,0xE3,0xC6,0x17,0xAE,0x30,0x9C,0x31,0xD1,0x84,0x47,0xAF,0xCB,
+		0xEA,0x69,0x2A,0x08,0x3E,0x13,0x00,0xDE,0xF6,0x4A,0x42,0xD3,0xBE,0x33,0xD9,0x50,
+		0x6B,0x8D,0x59,0x12,0x1A,0xD3,0xA7,0x7C,0x0A,0xE7,0x87,0x47,0xCA,0xAA,0x33,0xFD,
+		0xC1,0xF6,0x28,0xC1,0x62,0xA2,0x4C,0x79,0x83,0x48,0x86,0x0E,0xA4,0x67,0x34,0x95,
+		0xAE,0x7D,0xD6,0xEE,0x91,0x05,0x35,0x91,0xE8,0x34,0x39,0xA3,0xE5,0xE6,0x80,0x53,
+		0x76,0x1F,0x94,0xA0,0xF6,0xA5,0x41,0x79,0x82,0xD3,0xB0,0x1F,0xCE,0xE1,0x86,0x64,
+		0x65,0x0C,0x8D,0xD6,0xFA,0xC1,0x10,0x6C,0x07,0xD5,0xF0,0x77,0x65,0xB9,0x0C,0xBD,
+		0xAE,0x2D,0x62,0x6C,0x42,0x7E,0x2A,0xBE,0x5F,0xC1,0x17,0x3B,0x07,0xFF,0x5E,0xD7,
+		0x31,0x52,0x26,0x2F,0x9F,0x12,0xD8,0x2E,0xA3,0xF5,0xB5,0xD2,0xFC,0x6E,0x08,0x1F,
+		0xC8,0x93,0xA1,0xEB,0xF9,0x13,0x1D,0x1F,0x98,0x5E,0xB0,0x0C,0x65,0x6C,0xAE,0x07,
+		0x78,0xF8,0x12,0xD2,0xD1,0x1E,0x77,0x5C,0x24,0x62,0xE5,0x94,0xD6,0x6A,0x8E,0xD0,
+		0x72,0x59,0xDA,0x48,0x38,0x2F,0x31,0x75,0x0C,0x52,0xF0,0x0C,0x8F,0x5C,0xE9,0x5E,
+		0x5A,0x94,0xE8,0xD2,0x80,0xF8,0x4F,0xE7,0xAA,0x6C,0xBE,0x47,0xFB,0xDD,0x57,0x0A,
+		0xD8,0x5E,0xCC,0x0D,0x8F,0x42,0x5E,0xDC,0x5D,0x95,0x95,0x60,0x9B,0x6F,0x05,0x5E,
+		0x08,0x45,0x91,0xE4,0xB8,0x06,0xB1,0xF2,0xC0,0xD7,0xE3,0x47,0xB7,0x38,0x08,0xA8,
+		0x58,0xE4,0x55,0xFC,0xE2,0x37,0x1F,0x38,0xA2,0x18,0x9E,0xC2,0x0F,0x90,0x14,0x20,
+		0x50,0xD1,0xD0,0xAB,0x36,0x7F,0xAA,0x03,0x1C,0xE6,0x0A,0xF9,0x8E,0x41,0xDB,0x32,
+		0x1C,0x68,0xA0,0xA0,0xED,0x4A,0xF4,0x4B,0x09,0xD0,0xF0,0x01,0x8B,0x17,0x44,0xE1,
+		0xEA,0xC5,0x9D,0x3B,0x37,0x7A,0x68,0xF1,0x78,0x46,0xCF,0xB6,0x57,0xDB,0x4B,0x5C,
+		0x03,0xE1,0x9D,0xC0,0x37,0x55,0x8D,0x03,0xFB,0x6A,0x00,0x82,0x19,0xD1,0xC0,0x76,
+		0x97,0xEE,0xC9,0xAD,0x0D,0x72,0x0B,0xE9,0xA8,0x09,0x92,0x03,0xA4,0xAA,0x2C,0xCF,
+		0xFD,0xDE,0x86,0xD0,0x06,0x4A,0xAE,0x7E,0xC1,0xB8,0x2A,0x4E,0x9F,0xA3,0x5E,0x8C,
+		0x12,0x40,0x74,0x38,0xE7,0xEA,0xB0,0x51,0xC2,0xB9,0x6D,0x4A,0x50,0xBF,0x59,0x9C,
+		0x05,0xB2,0x42,0xE2,0x0F,0x71,0x44,0xDB,0x97,0x0B,0xD0,0xDB,0x44,0x1F,0x9A,0x3B,
+		0x18,0x2A,0x7B,0xD9,0x03,0x83,0x0B,0xCF,0x27,0x20,0x43,0xA6,0x42,0xED,0x89,0x63,
+		0xDB,0x2D,0x27,0xC2,0x3B,0xE6,0x0D,0x3E,0xB6,0x96,0x33,0x70,0xA6,0xF3,0xF5,0x56,
+		0xEA,0xEB,0xF1,0xE7,0xD8,0xCB,0x04,0x48,0x99,0x4C,0x00,0xA4,0x2A,0xA5,0x8A,0xF1,
+		0x58,0xD5,0x17,0x4C,0xC5,0x88,0x06,0x8F,0xA6,0x67,0xA6,0x14,0xC7,0xB9,0xE0,0x86,
+		0xAC,0x67,0xFD,0xB3,0x5B,0x3E,0xDF,0x03,0xFD,0xC8,0xC4,0x4A,0x32,0x78,0x6B,0xD1,
+		0xC1,0xE2,0x36,0x9D,0x0B,0xF2,0x54,0x25,0xB8,0xB7,0xB2,0x10,0x7A,0xA6,0x79,0x52,
+		0xC2,0xEE,0x98,0xA5,0x3D,0xF0,0x07,0x8D,0x25,0xC3,0xAC,0xFD,0xCF,0x83,0x98,0x80,
+		0x56,0x95,0xC4,0x14,0xA2,0xA5,0x93,0xFE,0x24,0x59,0x44,0x73,0xDF,0xD6,0x47,0xDA,
+		0x22,0x3A,0x82,0xC5,0xD1,0x59,0x40,0x9D,0x0C,0x1A,0xB7,0x79,0x45,0x9A,0xF8,0x6D,
+		0x5A,0x5C,0xC2,0x80,0xFC,0xAA,0x8A,0xA4,0xFE,0x68,0x61,0x7D,0xFE,0x2C,0x36,0xE3,
+		0xE0,0x59,0x28,0x40,0x79,0xAD,0x2D,0x28,0x12,0x30,0xFC,0x56,0x2E,0x1D,0xEC,0x48,
+		0x3A,0xF0,0xC5,0x6C,0x31,0xE0,0x2E,0xB3,0x91,0x70,0xB9,0x9E,0xBD,0xE7,0x96,0x58,
+		0xCB,0xBC,0x1C,0xE4,0xC7,0x78,0xC7,0x1E,0x39,0xDB,0xB8,0x77,0x50,0xB7,0x65,0x20,
+		0x04,0x16,0x8B,0xFC,0x66,0xC4,0x6D,0x05,0x8C,0x3C,0xB6,0x32,0x2F,0xDE,0xC3,0x6F,
+		0xFC,0x82,0x06,0x02,0x87,0x47,0xFD,0xD8,0xDA,0x75,0xE0,0x4E,0x8C,0x40,0x00,0xB2,
+		0x9B,0x35,0x78,0xA4,0x61,0x64,0x96,0x62,0x37,0xF6,0x3E,0x39,0xFA,0x14,0x5B,0xC4,
+		0x70,0x17,0xDC,0x0C,0x9E,0x31,0x82,0x2C,0x63,0xCC,0x8A,0x43,0x7C,0x69,0x12,0x05,
+		0x18,0xA3,0x62,0xCC,0xA2,0x13,0x96,0x25,0xA6,0x1B,0xF2,0x10,0xC8,0x73,0x4F,0xCB,
+		0x80,0xCA,0xAF,0x73,0xC9,0x78,0xB1,0xAE,0x87,0xB8,0xDF,0x50,0xD3,0x55,0x1E,0x3A,
+		0x81,0xF6,0x84,0xD6,0x57,0x36,0xCF,0x38,0xB7,0xBC,0xBC,0x1E,0x48,0x62,0x9F,0x0F,
+		0x0C,0xE5,0xF0,0x63,0x33,0xE6,0x59,0x6B,0x1E,0xE6,0x1C,0x8A,0xF9,0xDD,0x6B,0xA3,
+		0xDC,0x02,0x4A,0x2F,0x8C,0x6A,0x8D,0x16,0x7E,0x2F,0xF1,0x75,0xD5,0x15,0x93,0x07,
+		0x27,0xD9,0x6F,0x1A,0x5D,0x43,0xF3,0x47,0xC4,0xED,0xAD,0x05,0x9F,0xEC,0x8F,0xD0,
+		0xBE,0xB5,0x58,0xF4,0xF6,0xBE,0x08,0x73,0x96,0x19,0x05,0x25,0xEC,0x3D,0x26,0xF4,
+		0x93,0xDB,0x9F,0x56,0x48,0x4C,0xBC,0xD0,0x02,0x59,0xD1,0x40,0x4C,0xA6,0x06,0x41,
+		0xE8,0x7D,0x47,0xAE,0x3A,0x9E,0x1A,0x71,0x52,0xD4,0x67,0xC1,0x14,0x7E,0x40,0x6F,
+		0x1C,0x75,0x30,0x7B,0x70,0x3A,0xE0,0x37,0xB7,0x41,0x7F,0xCB,0x4A,0xBA,0xA7,0xCE,
+		0x56,0x54,0xC5,0x46,0x65,0x6F,0xB4,0xB6,0xF0,0x57,0xCE,0x2E,0x4F,0xA9,0xF0,0x14,
+		0x50,0xC3,0x30,0xC5,0xBA,0xE1,0x5E,0xD6,0xDC,0xC5,0x78,0x55,0x32,0xAA,0xCB,0x29,
+		0x35,0x81,0x46,0x5E,0x92,0xE7,0xDE,0xCC,0x92,0x29,0x86,0xE0,0x8F,0x91,0x3C,0x74,
+		0x97,0x79,0x63,0x97,0x4A,0xCC,0x88,0xB5,0xA3,0x7A,0xF0,0xF0,0x33,0x87,0xCD,0xBD
+	};
+	uint8_t b = Value ^ xvia3_N0F11_EncBasis(Value, lookup[(((AddrInd * 2) + 0) * 256) + Value]);
+	return (Value ^ xvia3_N0F11_EncBasis(b, lookup[(((AddrInd * 2) + 1) * 256) + b]));
+}
+
+// Func1
+void
+xvia3_N0F11_EncPhase1(uint8_t *dcw)
+{
+	static const uint8_t lookup1[] = {
+		0x16,0x71,0xCA,0x14,0xC4,0xF4,0xA3,0x5A,0x9D,0x5F,0x85,0x8B,0xA6,0x77,0xFD,0x3C,
+		0x5F,0x13,0x2A,0x5F,0x61,0x36,0xE4,0xDC,0x0D,0x82,0x92,0xC5,0x25,0xE1,0x7A,0x1C,
+		0x29,0x19,0x94,0x2F,0xC5,0xD2,0xDC,0xBA,0x86,0x60,0x64,0x60,0x86,0x92,0xA3,0x4E,
+		0x3D,0x9B,0xCC,0x16,0xBB,0xBA,0xD2,0xF0,0x6A,0xD3,0x2F,0x07,0x75,0xBD,0x28,0xDB
+	};
+	static const int8_t 	lookup2[] = {1, -1, -1, 1, -1, 2, 1, -2, -1, 1, 2, -2, 1, -2, -2, 4};
+	static const int8_t 	CAddrIndex[] = {0, 1, 3, 4};
+	int32_t i, j, i1, i2, i3;
+
+	for (i=3; i >= 0; --i) {
+		// Func1_1
+		for (j=0; j <= 15; ++j) {
+			dcw[j] = dcw[j] ^ xvia3_N0F11_EncBasis(j, lookup1[(16*i) + j]);
+		}
+		// Func1_2
+		uint8_t  Buffer[16];
+		uint32_t k;
+		for (i1=0; i1 <= 3; ++i1) {
+			for (i2 = 0; i2 <= 3; ++i2) {
+				k = 0;
+				for (i3 = 0; i3 <= 3; ++i3) {
+					k = k + (dcw[(i2*4) + i3] * lookup2[(i3*4) + i1]);
+					Buffer[(i2 * 4) + i1] = (uint8_t)k;
+				}
+			}
+		}
+		memcpy (dcw, Buffer, 16);
+
+		// Func1_3
+		// CW positions are mixed around here
+		uint8_t a4[4];
+		for (i1=1; i1 <= 3; ++i1) {
+			for (i2 = 0; i2 <= 3; ++i2) {
+				a4[i2] = i1 + (i2*4);
+			}
+			for (i2=0; i2 <= i1 - 1; ++i2) {	// the given code in Func1_3 seems to be wrong here(3 instead of i1-1)!
+				uint8_t tmp = dcw[a4[0]];
+				for (i3 = 1; i3 <= 3; ++i3) {
+					dcw[a4[i3-1]] = dcw[a4[i3]];
+				}
+				dcw[a4[3]] = tmp;
+			}
+		}
+		// Func1_4
+		for (i1=0; i1 <= 15; ++i1) {
+			dcw[i1] = xvia3_N0F11_EncLookup(dcw[i1], CAddrIndex[i1 & 3]);
+		}
+	}
+}
+
+// Func2_1
+static void
+xvia3_N0F11_EncPhase2sub(uint8_t *dcwA, uint8_t *dcwB, uint8_t AddrInd)
+{
+	uint8_t Buffer[8];
+	uint8_t tmp;
+	int i;
+	// Func2_1_1
+	for (i=0; i<=7; ++i) {
+		Buffer[i] = xvia3_N0F11_EncLookup(dcwB[i], AddrInd);
+	}
+	// some bitshifting
+	tmp = Buffer[7];
+	for (i=7; i>=1; --i) {
+		Buffer[i] = ((Buffer[1] >> 4) & 0xFF) | ((Buffer[i-1] << 4) & 0xFF);
+	}
+	Buffer[0] = ((Buffer[0] >> 4) & 0xFF) | ((tmp << 4) & 0xFF);
+
+	// saving the result
+	for (i=0; i<=7; ++i) {
+		dcwA[i] = dcwA[i] ^ Buffer[i];
+	}
+}
+
+// Func2
+static void
+xvia3_N0F11_EncPhase2(uint8_t *dcw)
+{
+	xvia3_N0F11_EncPhase2sub(dcw, dcw + 8, 0);
+	xvia3_N0F11_EncPhase2sub(dcw + 8, dcw, 1);
+	xvia3_N0F11_EncPhase2sub(dcw, dcw + 8, 2);
+	xvia3_N0F11_EncPhase2sub(dcw + 8, dcw, 3);
+	xvia3_N0F11_EncPhase2sub(dcw, dcw + 8, 4);
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#if 1
+const uint8_t TNT1315_TAB_0s[0x800] = {
+	0x54,0x75,0x01,0x0C,0x7C,0xE2,0xC3,0xC2,0x5E,0x13,0x26,0xCA,0xB2,0xCD,0xB8,0x3D,
+	0x02,0x2C,0xE4,0x19,0x41,0x3D,0xE4,0x0F,0xEC,0xF1,0x45,0x83,0xE2,0xE2,0x72,0xF9,
+	0xCD,0x75,0x1E,0x41,0xCC,0x0C,0x1F,0x39,0x87,0x9B,0x46,0xFF,0x68,0x1F,0x00,0xD8,
+	0x41,0x82,0xCA,0xC6,0xEF,0x87,0x90,0xA2,0x7E,0xD9,0xDE,0xC8,0x25,0xEA,0xC9,0x75,
+	0x6E,0x18,0x81,0xD8,0x5A,0xA6,0x74,0x05,0xAF,0xAE,0xE0,0x4F,0x85,0xAD,0x94,0xF6,
+	0x45,0xF4,0xF5,0x55,0xA8,0xEB,0xEC,0xDB,0x6C,0xFF,0x2F,0xC2,0xC3,0x7D,0x93,0xE6,
+	0xF5,0x31,0x96,0xB7,0x9A,0xDB,0xE5,0x76,0x66,0xFB,0xDD,0xBC,0x19,0x18,0x42,0xC6,
+	0x36,0xCD,0x46,0x33,0xEA,0xF1,0x4C,0xC0,0x72,0x07,0xCD,0x61,0xCE,0x0E,0x08,0x01,
+	0xA3,0xFA,0x84,0x21,0xF2,0x43,0x37,0x1C,0xDE,0x25,0x8A,0x1A,0xF4,0xBB,0x40,0xF3,
+	0x53,0xFE,0x17,0x60,0x91,0x6D,0x7B,0x6D,0x5F,0x1C,0x15,0x73,0xCC,0x6E,0x73,0x46,
+	0x27,0x73,0xA3,0x10,0x16,0x32,0xB3,0x39,0x45,0xA6,0x55,0xE7,0x91,0x32,0x24,0xC8,
+	0xAE,0xAF,0x1B,0x28,0x69,0x22,0x2F,0xE9,0x77,0x72,0xBF,0x4B,0x8B,0x07,0x82,0x31,
+	0xB0,0x95,0x10,0x78,0x9F,0xC5,0xF3,0x73,0xE1,0xF8,0x36,0x84,0xFE,0x1B,0x92,0xB2,
+	0xE6,0xA5,0xCE,0xDA,0x56,0x48,0x52,0x77,0x9D,0x9D,0x8E,0x37,0x4B,0xC8,0x35,0x7E,
+	0xB9,0x5D,0xA4,0xAE,0x3F,0xD0,0xAA,0x60,0xA8,0x4C,0x85,0x49,0xF6,0x0C,0x27,0xE8,
+	0x94,0x84,0xA0,0xAA,0x06,0x4D,0xAC,0x58,0x8B,0x61,0x29,0x3D,0x68,0x25,0xD3,0xD3,
+	0x8E,0xA1,0xE0,0x71,0xBF,0x21,0x0C,0xC7,0x18,0x19,0xF1,0x25,0x98,0x5F,0x79,0x5E,
+	0x51,0xBA,0x8C,0x2F,0x52,0x43,0xF3,0x5A,0xE3,0x58,0x97,0x64,0x23,0xE0,0x44,0x4F,
+	0x30,0x2A,0xE0,0x16,0x8D,0x4D,0xD1,0x1F,0x7B,0xC9,0xC5,0x74,0x11,0x23,0x5D,0x95,
+	0xAC,0x7F,0x2E,0x30,0xBE,0x2D,0xE3,0xB5,0xC6,0xA7,0x69,0x99,0x1F,0x18,0x3C,0x96,
+	0x30,0x45,0x99,0x71,0x28,0x08,0x3C,0xF7,0x37,0x4F,0x6A,0xD6,0xAE,0x9B,0x57,0xC1,
+	0xCC,0x2C,0xE2,0x0F,0x7D,0x66,0xF4,0x36,0x0C,0x3B,0x35,0xF6,0x28,0x03,0xA3,0x7A,
+	0x83,0x15,0xF5,0x61,0x5E,0xE8,0xB7,0xD8,0x54,0x33,0x93,0x63,0x80,0x40,0x43,0xD0,
+	0x9C,0xAA,0x3A,0x98,0x50,0xD2,0xB8,0x80,0x5D,0x16,0xDF,0x1C,0x03,0xAA,0x87,0xC7,
+	0x63,0xA5,0x8D,0xA9,0x2E,0xFB,0x4F,0x7C,0x2B,0xF5,0xF9,0x57,0xB5,0x90,0xD8,0x75,
+	0xAB,0x81,0x4C,0x1B,0xAF,0x6C,0x0E,0xCB,0xB1,0x4F,0xD3,0xE3,0x69,0x18,0x8C,0x7A,
+	0x3C,0xE1,0x11,0x86,0x47,0x78,0x11,0xA0,0xD4,0x28,0xC3,0x0D,0xAC,0xC6,0x17,0xA1,
+	0x32,0x9F,0x8F,0x42,0xD9,0x3F,0x66,0xD7,0x2D,0x87,0x7B,0x65,0xD3,0xD6,0x90,0x83,
+	0xA2,0x75,0xE8,0x98,0x90,0x9D,0xDE,0x81,0x9E,0x3D,0xE4,0xA9,0xE4,0x0B,0xBC,0xBA,
+	0x96,0xDD,0x05,0xCA,0xAE,0x78,0x69,0x24,0xDB,0xA7,0x3E,0x7A,0x3B,0xB4,0xC4,0x59,
+	0x61,0xD2,0xF2,0xE3,0x99,0x8F,0x8F,0x8A,0x82,0x33,0xB8,0x17,0x5E,0x7A,0x32,0x41,
+	0x10,0x8D,0xC2,0xEF,0xAA,0xF8,0x5A,0xF7,0xD2,0x1D,0xC0,0xCB,0x5E,0xB7,0x8A,0x78,
+	0x49,0x42,0xEB,0x19,0x1B,0x61,0xA0,0x77,0x5A,0xF4,0x6D,0x55,0xDA,0xEB,0xCE,0x4E,
+	0xB8,0xE6,0x32,0xD7,0x51,0x3F,0x73,0x14,0x34,0x6E,0x38,0xD6,0xA7,0x28,0x87,0x4A,
+	0x59,0xCA,0x1C,0x80,0xB5,0x8C,0x9D,0x94,0xCB,0xFE,0x29,0x41,0xE5,0x69,0xCF,0xFD,
+	0x0B,0xE1,0x7C,0xA1,0x70,0x12,0x76,0x43,0xDA,0xB9,0xD4,0xC3,0x31,0xBC,0x94,0x77,
+	0x04,0xB4,0x1C,0xAA,0xEC,0x6F,0xA5,0x12,0x9D,0x6F,0x34,0x65,0x77,0xA0,0xD2,0x6F,
+	0x60,0xC6,0x47,0xC2,0xDF,0x6A,0x10,0x53,0xD4,0xBA,0xF3,0xB7,0x38,0x79,0x63,0xC9,
+	0xD4,0x77,0xBC,0x54,0xE9,0x79,0x42,0xD5,0xE0,0x71,0xE7,0x9E,0x5A,0x62,0x0C,0xAD,
+	0x01,0x09,0xA8,0x9F,0x8E,0x67,0x4A,0x30,0xA4,0xB1,0x08,0xFC,0x0A,0xEA,0x7A,0x1D,
+	0x4C,0x4A,0x21,0xDE,0x00,0xD7,0x41,0x98,0x6B,0x38,0x50,0x3E,0x1F,0x25,0x06,0xE3,
+	0x6C,0xA3,0x84,0x5B,0xC1,0xED,0x47,0xDD,0xB3,0x83,0x46,0x72,0x69,0xCE,0x72,0x04,
+	0x43,0x67,0x3A,0x19,0xD9,0x0A,0xF7,0x43,0x88,0xCA,0xC7,0x31,0x34,0x21,0x4E,0x4C,
+	0xE8,0xD1,0x70,0x00,0xBD,0xB1,0xB6,0x76,0x6F,0x5B,0xF9,0xF5,0xF4,0x19,0x20,0x21,
+	0xC1,0xF0,0x11,0x36,0x66,0xAB,0x15,0xBD,0x69,0x92,0xC6,0x46,0xDE,0xDC,0xE9,0x9A,
+	0xF8,0x6C,0x15,0x29,0x15,0xA6,0x35,0x3E,0x08,0xE5,0x90,0x62,0x9F,0x86,0x56,0x83,
+	0x5D,0x60,0x0D,0x22,0x77,0xA7,0x60,0x9B,0x26,0x80,0x16,0x67,0xB4,0x46,0xBF,0x74,
+	0x55,0x92,0x5B,0x34,0xFF,0xC8,0x28,0x37,0xFF,0x14,0x62,0xFA,0xBD,0x03,0x78,0x04,
+	0x1B,0x65,0x7F,0x99,0x05,0x27,0x14,0xC0,0x06,0x4D,0x4B,0x0E,0x98,0x34,0x6A,0xB3,
+	0xA1,0xFE,0xBC,0x45,0x7D,0x52,0x50,0x0E,0x2C,0xFB,0x91,0xF5,0xFB,0x2A,0xB7,0xD9,
+	0xB8,0xB8,0x54,0x31,0x81,0x03,0x93,0x2C,0xE1,0x5C,0xB9,0x2C,0xE8,0x38,0xC0,0xA7,
+	0x58,0x18,0x92,0xC5,0x8B,0xEF,0x1E,0x33,0xA4,0xBA,0x86,0x2B,0xE9,0xEE,0xB1,0xDF,
+	0xAB,0xB8,0x48,0xDA,0x84,0xF1,0x68,0x05,0x4E,0xDE,0xB5,0x9E,0x88,0x12,0xC9,0x60,
+	0x50,0x58,0x56,0x9D,0x26,0x84,0xB6,0x1A,0xE6,0x4B,0x40,0x94,0x6D,0xE9,0x1D,0x0D,
+	0x8A,0xF9,0x2A,0xB5,0xBC,0xDB,0x06,0x8F,0x13,0x7E,0x1D,0x1C,0xC7,0xFD,0x8F,0x78,
+	0x55,0x3F,0x16,0x84,0x48,0xDA,0x1A,0xD1,0x93,0x95,0x20,0x58,0x92,0x39,0xF6,0x73,
+	0x4E,0x9E,0x7B,0x70,0xFC,0x1E,0x5B,0x20,0x48,0x96,0xB3,0x7C,0x50,0x09,0x5B,0x61,
+	0x57,0x97,0x36,0x04,0x29,0x2C,0x32,0x8E,0x93,0x4A,0x45,0xFA,0xD5,0x24,0x14,0x1A,
+	0x28,0x9C,0x1A,0x71,0xAE,0x85,0x4B,0x26,0x79,0x99,0x65,0xD0,0x07,0x98,0xED,0xC9,
+	0x1B,0x39,0x57,0x5B,0xDB,0x3D,0x87,0x69,0x66,0x9B,0x03,0x23,0x54,0x6B,0x4B,0xAC,
+	0x6E,0x7A,0x25,0x1E,0xB6,0x97,0xCF,0x1D,0x07,0xCB,0x2A,0x3E,0x85,0x02,0x93,0x31,
+	0x12,0x27,0xF0,0xA6,0x6D,0x0F,0x9A,0xB6,0xFC,0x22,0x79,0x6C,0x77,0xFD,0x3F,0xDC,
+	0x19,0xD0,0xDF,0xBD,0x9E,0xE0,0xBE,0x20,0x13,0xA3,0x0A,0x0B,0x22,0xF2,0xC8,0x6B,
+	0xA1,0xDD,0x6C,0x67,0xB3,0xFD,0x71,0xC2,0x7B,0x08,0x3B,0xF1,0x37,0xB5,0x0F,0x86,
+	0xFA,0xA9,0xE9,0x42,0xD1,0xE8,0xCD,0x05,0xEF,0xD3,0xCC,0x0B,0x70,0x51,0x5B,0x97,
+	0x06,0xC4,0x9D,0x88,0x11,0x3E,0x99,0x9F,0xBE,0x76,0x8C,0x8D,0xE6,0xBA,0xDA,0x48,
+	0xD0,0x04,0x86,0x4F,0xA9,0xC6,0xB0,0xED,0xA4,0x94,0x46,0x96,0x27,0xEE,0x9F,0xBD,
+	0xDA,0x9B,0x3D,0x11,0x80,0xD3,0x7B,0x5A,0x48,0x94,0xE5,0xCC,0x48,0xEA,0xE4,0x18,
+	0xDF,0x51,0xB3,0x02,0x57,0x20,0x4B,0x0F,0x07,0xFF,0x41,0x33,0x0F,0x6B,0x2E,0xAA,
+	0xDE,0xB2,0x56,0xF7,0xFB,0xA2,0x48,0x3C,0x97,0x1A,0x64,0x2C,0xD1,0x74,0x40,0xCF,
+	0x65,0x7F,0x14,0x08,0x59,0xC4,0x35,0xD3,0x8A,0x0F,0xFD,0x71,0x7A,0x71,0xAC,0x2D,
+	0xF3,0xFD,0x7B,0x12,0x5F,0xC0,0xBC,0x4E,0x96,0x12,0xF2,0x8E,0x41,0x84,0x01,0x0F,
+	0xED,0x7B,0xC1,0xB9,0x39,0x03,0x35,0x40,0x49,0x53,0xB8,0xB4,0x6B,0xA6,0xE7,0x0A,
+	0x14,0xBB,0x29,0x16,0xEC,0x2A,0x3A,0xD6,0x09,0xBB,0x5C,0x20,0xF8,0x09,0xFD,0x86,
+	0xC4,0x25,0x09,0x85,0x0B,0xD5,0xD8,0x51,0xB1,0xA2,0xCB,0xDC,0xC4,0xDD,0x34,0xDF,
+	0xE2,0x85,0xA9,0xCC,0x4E,0x66,0x51,0xFA,0x9C,0x4D,0xB7,0x1E,0x3E,0x49,0x34,0x9C,
+	0x21,0x66,0x07,0x44,0xB2,0xEC,0x73,0xC5,0xBB,0x27,0x9A,0xA5,0x91,0x5A,0xB9,0x9F,
+	0xBE,0xC8,0xA2,0x27,0x89,0x21,0xA7,0xEE,0x50,0x4D,0x43,0x50,0x67,0xC2,0x3B,0x7C,
+	0x20,0x0B,0x95,0x40,0xBE,0xEA,0xB5,0xD9,0x82,0xD7,0x9C,0xB5,0x21,0xAD,0xA6,0xF9,
+	0x70,0xEA,0xCD,0x04,0xDD,0x58,0x91,0x89,0xB2,0xA9,0xF9,0xB4,0x12,0xA2,0x63,0x89,
+	0x40,0x8E,0xEA,0x62,0xEE,0x0B,0x01,0x82,0x6F,0xB3,0x5E,0x5C,0x36,0xBE,0xF4,0x97,
+	0x2C,0xCF,0x96,0x7C,0x0D,0xAD,0x62,0xCE,0xD4,0x38,0xC5,0x32,0x02,0x24,0x57,0x27,
+	0xE0,0xCF,0x56,0xA5,0x72,0x6D,0x90,0x89,0x2D,0x4C,0x34,0xF6,0x1D,0xDD,0x88,0x5E,
+	0x7A,0x23,0xE3,0x6F,0x42,0xA3,0xD9,0x58,0x7E,0xE3,0x52,0x74,0x57,0x63,0xB7,0xB2,
+	0xC1,0xA3,0x30,0x92,0x2E,0xB0,0x91,0x01,0x13,0x36,0x9A,0x6A,0xA7,0x5B,0x3C,0x07,
+	0xFB,0xD8,0x1E,0x7E,0xCF,0x49,0xAB,0x3F,0xCA,0xCE,0x74,0x40,0x54,0x8D,0x83,0x61,
+	0xCA,0xC3,0x76,0x59,0x5C,0x9F,0x49,0x8A,0x7D,0xD1,0x17,0x9C,0xA4,0xDB,0xB9,0x16,
+	0x4D,0x64,0xF7,0xC7,0xF0,0x24,0xE7,0x00,0xB6,0x98,0xD5,0x8B,0x54,0xCB,0x1E,0x8B,
+	0xA2,0x2B,0x7D,0x50,0x51,0x8A,0xF0,0xEF,0x47,0xAE,0xD0,0xD6,0xA0,0x42,0x8A,0xD8,
+	0x22,0xAF,0x02,0x99,0x4A,0xE0,0x8D,0x8D,0xBF,0x11,0x05,0xA4,0xC4,0x9D,0xB3,0x89,
+	0xB4,0x4C,0xC9,0xF7,0x4D,0xC5,0x2A,0x35,0x95,0x30,0xF3,0x0E,0x2F,0xEC,0x6E,0x3A,
+	0x8B,0x05,0x76,0xED,0x1A,0x7C,0xC0,0xE7,0x22,0xCB,0x59,0xFF,0xE6,0x37,0x78,0x44,
+	0xD4,0xEE,0xAD,0xD7,0xBD,0x2E,0xB7,0x6A,0xA4,0x4E,0x0E,0xFB,0xB0,0xF5,0xCB,0x87,
+	0xCF,0xC3,0x18,0x64,0x6F,0x26,0x5C,0xD7,0x16,0xC8,0x7F,0xAB,0x29,0xC4,0xBA,0xFF,
+	0xCD,0x1C,0xE4,0x3A,0xF2,0xEB,0x6A,0x38,0xE4,0x65,0xC2,0x33,0x03,0x26,0x7D,0x9B,
+	0x7E,0x1D,0x83,0x00,0x04,0x2D,0x2B,0x5F,0xFE,0x39,0x7E,0xF1,0x3C,0xA2,0x8C,0x52,
+	0x95,0xBF,0x46,0x81,0x24,0x44,0xF8,0x10,0xC3,0x87,0x8E,0x64,0x80,0x17,0x44,0xE2,
+	0x8B,0xD1,0x3C,0x4A,0xE2,0x1F,0xA9,0xDE,0x75,0x13,0xFC,0x2E,0x86,0x0A,0x5C,0x5F,
+	0x92,0x2B,0x92,0x2D,0x2A,0xEC,0xD2,0x5C,0x82,0x6B,0x76,0x1E,0xED,0xE6,0x56,0xF7,
+	0xD2,0xDB,0x96,0x68,0x02,0x68,0x99,0x49,0xEE,0x88,0x66,0xCE,0x5D,0x08,0x88,0xA8,
+	0xB9,0x24,0xB0,0xB4,0xDC,0xA6,0xC9,0xD8,0x68,0x80,0xBF,0x6B,0x32,0x57,0x7F,0x91,
+	0x0E,0x37,0x59,0xF6,0x76,0xD2,0xC5,0x0B,0xF3,0x23,0xBF,0x38,0x52,0x0D,0x97,0x81,
+	0x17,0xBB,0x9A,0xC2,0x55,0x44,0x72,0xCE,0xEE,0xFA,0xBB,0xDA,0xAB,0xB0,0x09,0xEA,
+	0xDB,0xBF,0x45,0x95,0x07,0x88,0xD4,0xD2,0x0D,0x2E,0x15,0x31,0xBE,0x6A,0xF4,0xEF,
+	0xA3,0x7D,0x22,0x81,0x3B,0xA8,0x83,0xF9,0x42,0xE5,0x9B,0x79,0x01,0xF5,0xDC,0x19,
+	0x64,0xEB,0x47,0x67,0xAF,0xA4,0xB2,0xAE,0xF8,0xF9,0x4D,0x63,0xAD,0x54,0xE1,0x02,
+	0x56,0x89,0x4E,0x0A,0xE8,0x3E,0x03,0xFA,0x33,0x61,0x58,0x80,0x64,0x55,0x3C,0x8C,
+	0x2A,0x3D,0x70,0x3E,0xE5,0xC1,0xA7,0x75,0xFC,0x91,0x75,0x05,0x8C,0x6E,0x3A,0x74,
+	0x10,0xF1,0x30,0xE6,0xF6,0xF7,0xAB,0x6C,0xB1,0x2B,0xF0,0x2F,0x13,0x6E,0xD4,0x0A,
+	0x64,0x29,0xF8,0xBB,0xA1,0xAA,0x55,0x09,0x93,0x47,0x2F,0x8C,0x7D,0xF1,0x2D,0x81,
+	0xFE,0x78,0xFC,0xEE,0x3F,0xDD,0x49,0xDC,0x0D,0x52,0x5C,0x3B,0x8F,0x08,0xB0,0xDF,
+	0xDC,0xFC,0xBE,0x5F,0x3B,0x53,0x82,0xE2,0xBD,0x6D,0x5D,0xF2,0x8D,0xFB,0x5A,0x1D,
+	0x15,0x1B,0xE4,0xB1,0x56,0x06,0x1A,0xF8,0x9C,0xB9,0x44,0xF2,0xD9,0xF4,0xB2,0x00,
+	0x9A,0x94,0x62,0x33,0x7E,0x0A,0xB0,0x0C,0xD5,0xEF,0x8E,0xA8,0xEB,0x47,0xE9,0x20,
+	0xA8,0x68,0xEF,0x53,0xA0,0x59,0x1B,0xA0,0x2B,0xC5,0x2B,0x30,0xB6,0x5D,0xAB,0xB4,
+	0x5F,0x86,0x71,0x95,0x89,0xFC,0xC7,0x9A,0xC3,0xED,0x82,0xA0,0x3D,0x73,0xC1,0x36,
+	0x01,0x5F,0x9E,0xD7,0xE3,0xC0,0x62,0x74,0xED,0x13,0xB6,0xD6,0xD5,0x37,0x17,0xE1,
+	0x39,0xC7,0x6D,0x31,0xBA,0x02,0xAF,0xD5,0xCC,0x51,0xA8,0x09,0x3F,0x00,0x4A,0x8F,
+	0xA6,0x23,0x13,0x88,0xCD,0x1F,0x38,0x60,0xE7,0xE7,0x53,0xDC,0x65,0xE8,0x53,0x26,
+	0xBB,0xE1,0x1F,0x65,0xF0,0xAD,0x53,0x3B,0xBD,0xAD,0x97,0xAC,0xD1,0xA5,0xD0,0xE9,
+	0xEB,0xD6,0x11,0xD5,0x00,0xDF,0x72,0x9C,0xCC,0x7F,0xD3,0x67,0xA1,0x3A,0x79,0xE1,
+	0x85,0x70,0xE5,0x43,0xC9,0x28,0xA5,0x2F,0x9E,0xE7,0xFE,0xEB,0x14,0x10,0x23,0xC7,
+	0xAF,0xB1,0x24,0xC8,0xE5,0x44,0x6F,0x4C,0x04,0xEC,0xC1,0xF0,0x23,0x1C,0xF6,0xAC,
+	0xAF,0xC4,0x0E,0x2D,0x59,0x39,0x47,0xA9,0x9E,0xD9,0x2E,0x79,0xBA,0xFE,0x4F,0x12,
+	0x7F,0x63,0x7F,0x62,0x67,0x7C,0x52,0x2F,0xCA,0x8B,0x6B,0x4F,0x10,0x8F,0x14,0xC6,
+	0xA1,0x9B,0x45,0x15,0x90,0x63,0x22,0x5D,0x68,0x4B,0xCF,0xFA,0x6A,0x06,0xF0,0x26,
+	0xAC,0x6C,0x3A,0x89,0x25,0xF3,0x5E,0x90,0x06,0x93,0xB6,0x35,0x0D,0x85,0x60,0x98,
+	0xBC,0x6E,0xF2,0xA5,0x17,0x29,0x70,0xD6,0xFF,0x0C,0xD0,0xC0,0x35,0xD7,0x4A,0xFD,
+};
+
+const uint8_t TNT1315_TAB_1s[11*8] = {
+	0x70,0x49,0xD7,0xE3,0xDF,0x3C,0x96,0x03,0x2A,0x70,0x82,0xA6,0x5F,0xDE,0xCC,0x0C,
+	0x2A,0x62,0x2A,0x3E,0xA4,0x0C,0x0A,0xAB,0x4F,0x06,0x5D,0xD4,0x14,0xAA,0xE1,0xC3,
+	0x96,0xDA,0x16,0x36,0x45,0x3C,0x63,0xC2,0x97,0x71,0x87,0xAB,0xFA,0xB2,0xFC,0xD6,
+	0x8F,0x85,0xC9,0x04,0x56,0xBA,0xEB,0x3F,0x42,0x9F,0xCB,0x66,0x55,0x45,0x1C,0x96,
+	0xFF,0x4D,0x35,0xDF,0x88,0x0E,0xDC,0xC8,0x4E,0x3F,0x81,0x74,0xD8,0x77,0x4C,0x8E,
+	0x00,0xC0,0x64,0x83,0x4E,0xBB,0xF0,0xB1,
+};
+const uint8_t TNT1315_TAB_3s[88] = {
+	0x1B,0x12,0x12,0x0C,0x12,0x0C,0x0C,0x08,0x09,0x09,0x06,0x06,0x06,0x06,0x04,0x04,
+	0x08,0x04,0x04,0x02,0x04,0x02,0x02,0x01,0x09,0x06,0x09,0x06,0x06,0x04,0x06,0x04,
+	0x03,0x03,0x03,0x03,0x02,0x02,0x02,0x02,0x04,0x04,0x02,0x02,0x02,0x02,0x01,0x01,
+	0x09,0x06,0x06,0x04,0x09,0x06,0x06,0x04,0x03,0x03,0x02,0x02,0x03,0x03,0x02,0x02,
+	0x04,0x02,0x04,0x02,0x02,0x01,0x02,0x01,0x03,0x02,0x03,0x02,0x03,0x02,0x03,0x02,
+	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
+};
+
+
+void
+xvia3_N1315_fn1(const uint8_t *datain, uint8_t *dataout)
+{
+	int i1,i2;
+	uint32_t bb;
+
+	for (i1 = 0; i1 < 11; i1++)
+	{
+		bb = 0;
+		for (i2 = 0; i2 < 8; i2++)
+			{ bb += (TNT1315_TAB_3s[(i1 * 8) + i2] * datain[i2]); }
+		dataout[i1] = (bb & 0xFF);
+	}
+}
+
+
+uint16_t
+xvia3_N1315_fn2(const uint8_t *data, const uint32_t num)
+{
+	uint32_t bb1, bb2;
+
+	bb1 = num >> 3;
+	bb2 = (data[bb1] << 24) + (data[bb1 + 1] << 16) + (data[bb1 + 2] << 8);
+	return ((bb2 >> (21 - (num & 7))) & 0x7FF);
+}
+
+void
+xvia3_N1315_fn3(uint8_t *data0, uint8_t *data1, int nbrloop)
+{
+	int i;
+	uint32_t bb1, bb2;
+
+	bb1 = 0;
+	bb2 = 0;
+	for (i = nbrloop - 1; i >= 0; i--)
+	{
+		bb1 += (data0[i] * 2) + data1[i];
+		bb2 += data0[i] + data1[i];
+		data0[i] = (bb1 & 0xFF);
+		data1[i] = (bb2 & 0xFF);
+		bb1 >>= 8;
+		bb2 >>= 8;
+	}
+}
+/*
+int CalcIndexs(unsigned char *B1, int a2)
+{
+	int v2; // edx@1
+	int v3; // ebx@1
+
+	v3 = 11 * a2 & 7;
+	v2 = 11 * a2 / 8;
+	if ( v3 <= 5 )
+		return (((B1[v2] << 8) | B1[ v2 + 1]) >> (5 - v3)) & 0x7FF;
+	else
+		return (((B1[v2] << 24) | (B1[v2 + 2] << 8) | (B1[v2 + 1] << 16)) >>(0xF5 - v3)) & 0x7FF;
+}*/
+
+void
+xvia3_N1315_fnC(const uint8_t *datain, uint8_t *dataout, int loopval)
+{
+	uint16_t buff8[8];
+	uint8_t  buff11[11+1];        // +1 to avoid func2 bug
+	int i1,  i2;
+
+	xvia3_N1315_fn1(datain, buff11);
+	for (i1 = 0; i1 < 11; i1++)
+		{ buff11[i1] ^= TNT1315_TAB_1s[(loopval * 11) + i1]; }
+
+	for (i1 = 0; i1 < 8; i1++)
+		{ buff8 [i1]  = xvia3_N1315_fn2(buff11, i1 * 11); }
+
+	for (i1 = 0; i1 < 8; i1++)
+		{ dataout[i1] = TNT1315_TAB_0s[buff8[i1]]; }
+
+	i1 = 1;
+	while (i1 < 8)
+	{
+		i2 = 0 ;
+		while (i2 < 8)
+		{
+			xvia3_N1315_fn3(&dataout[i2], &dataout[i1 + i2], i1);
+			i2 += (i1 * 2);
+		}
+		i1 *= 2;
+	}
+}
+
+void
+xvia3_N1315_fnCommon(uint8_t *cw0, const uint8_t *cw1, int loopval)
+{
+	int i;
+	uint8_t buff8[8];
+
+	xvia3_N1315_fnC(cw1, buff8, loopval);
+	for (i = 0; i < 8; i++)
+		{ cw0[i] ^= buff8[i]; }
+}
+
+void
+xvia3_N1315_exchange(uint8_t *cw0, uint8_t *cw1)
+{
+	int i;
+	uint8_t b;
+
+	for (i = 0; i < 8; i++)
+	{
+		b = cw1[i];
+		cw1[i] = cw0[i];
+		cw0[i] = b;
+	}
+}
+
+
+void
+xvia3_N1315_Phase1(uint8_t *cws)
+{
+	int i;
+
+	for (i = 0; i <= 7; i++)
+	{
+		// Possible code
+		if ((i & 1)==0)
+			xvia3_N1315_fnCommon((uint8_t *) &cws[0], (uint8_t *) &cws[8], i);
+		else
+			xvia3_N1315_fnCommon((uint8_t *) &cws[8], (uint8_t *) &cws[0], i);
+	// Other possible code
+	//	xvia3_N1315_fnCommon((uint8_t *) &cws[0], (uint8_t *) &cws[8], i);
+	//	xvia3_N1315_exchange((uint8_t *) &cws[0], (uint8_t *) &cws[8]);
+	}
+	xvia3_N1315_exchange((uint8_t *) &cws[0], (uint8_t *) &cws[8]);
+}
+
+void
+xvia3_N1315_Phase2(uint8_t *cws)
+{
+	int i;
+
+	for (i = 7; i >= 0; i--)
+	{
+		// Possible code
+		if ((i & 1)==0)
+			xvia3_N1315_fnCommon((uint8_t *) &cws[8], (uint8_t *) &cws[0], i);
+		else
+			xvia3_N1315_fnCommon((uint8_t *) &cws[0], (uint8_t *) &cws[8], i);
+	// Other possible code
+	//	xvia3_N1315_fnCommon((uint8_t *) &cws[0], (uint8_t *) &cws[8], i);
+	//	xvia3_N1315_exchange((uint8_t *) &cws[0], (uint8_t *) &cws[8]);
+	}
+	xvia3_N1315_exchange((uint8_t *) &cws[8], (uint8_t *) &cws[0]);
+}
+
+
+/*
+// AES simulation with AES key 0D (hard coded - Only for nano D2 15/13 demonstration purpose)
+int AES_Simul(uint8_t *data)
+{
+	const uint8_t AES_DATA[2*16] = {
+		0x90,0xB9,0x15,0x52,0xC6,0xAD,0x60,0x48,0xA9,0x29,0xE6,0xCC,0xEC,0x0A,0x9E,0xD4,
+		0x2D,0xE0,0xCA,0xEA,0x49,0x22,0xDA,0x8F,0x9B,0x9D,0x8F,0x03,0x90,0x64,0x6F,0xDB};
+
+	if (memcmp(data, &AES_DATA[0], 16)==0)
+	{
+		memcpy(data, &AES_DATA[16], 16);
+		return (1);
+	}
+	return (0);
+}
+void
+xvia3_N1315_simulation(void)
+{
+	// After Viaccess 0x30B00 initial CWs process
+	const uint8_t CWS_IN[16] = {0x6C,0xA9,0x63,0xCC,0x7E,0x5B,0xDE,0xAE,  0xE9,0x3F,0xFB,0xB1,0x73,0xA2,0x8F,0x26};
+	// Expected final DCWs
+	const uint8_t DCWS[16]   = {0xE5,0x10,0x4F,0x44,0xD8,0x6D,0x76,0xBB,  0xBA,0x9C,0x30,0x86,0xA9,0x07,0xBE,0x6E};
+
+	uint8_t cws[16];
+
+	myprintf("\n");
+	memcpy(cws, CWS_IN, 16);
+	myprdump("Initial CWS:", cws, 16);
+
+	xvia3_N1315_Phase1(cws);
+	myprdump("After Func1 CWS:", cws, 16);
+
+	if (AES_Simul(cws)==0)
+		myprintf("** ERROR AES Simulation **\n");
+	else
+	{
+		myprdump("After AES CWS:", cws, 16);
+
+		xvia3_N1315_Phase2(cws);
+		myprdump("After Func2 (=Final) CWS:", cws, 16);
+
+		if (memcmp(cws, DCWS, 16)==0)
+			myprintf("DCWs OK !!\n");
+		else
+			myprintf("** ERROR DCWs **\n");
+	}
+}
+*/
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static void
+xvia3_AesDecrypt(uint8_t *data, uint8_t *Aesk)
+{
+	AES_CTX_t ctxAes;
+
+	AES_CTX_SetKey (&ctxAes, Aesk);
+	AES_CTX_Decrypt(&ctxAes, data, data);
+}
+
+
+static void
+xvia3_AesEncrypt(uint8_t *data, uint8_t *Aesk)
+{
+	AES_CTX_t ctxAes;
+
+	AES_CTX_SetKey (&ctxAes, Aesk);
+	AES_CTX_Encrypt(&ctxAes, data, data);
+}
+
+void
+xvia3_AesNano11(uint8_t *cwMake,	uint8_t *pkAes)
+{
+	xvia3_N0F11_EncPhase1(cwMake);
+	xvia3_N0F11_EncPhase2(cwMake);
+	xvia3_AesDecrypt(cwMake, pkAes);
+	xvia3_N0F11_EncPhase1(cwMake);
+}
+
+void
+xvia3_AesNano15(uint8_t *cwMake,	uint8_t *pkAes)
+{
+	xvia3_N1315_Phase1(cwMake);
+	xvia3_AesDecrypt(cwMake, pkAes);
+	xvia3_N1315_Phase2(cwMake);
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static void
+xvia3_ArrXor(PC30_TAB *vkp, uint8_t *data, int offset)
+{
+	uint8_t	*xorArray;
+	int i;
+
+	xorArray = vkp->xorArray;
+	for (i=0; i<4; i++)
+	{
+		data[i] ^= xorArray[(offset+i) & 0x7];
+	}
+}
+
+
+static void
+xvia3_FctCore(PC30_TAB *vkp, uint8_t *data, int offset)
+{
+	uint8_t	*pMkTABLE;
+	uint8_t	t2,t3,t4,t6,t7;
+	uint16_t	ix;
+	int i;
+
+	xvia3_ArrXor(vkp, data, offset);
+	t2=t3=t4=t6=t7=0x0;
+
+	switch (vkp->prid)
+	{
+		case 0x030B00:
+			//	All Ok
+			#if 0
+				data[4] =  data[0] + ((_u_mul(_u_mul(2,data[2]) , (data[3] ^ (data[3] + 110))) + 23) | (data[1] ^ (data[1] + 119)) & (unsigned char)(data[0] ^ (data[0] - 41)));
+				data[5] =  data[1] + (data[0] ^ _u_mul((data[1] ^ (data[1] + 27)) , ((unsigned char)(data[3] ^ (data[3] + 113))) ^ 0x90) ^ ((unsigned char)_u_mul(2,data[2]) ));
+				data[6] = (data[1] ^ (data[0] + 74)) + data[2] + ((unsigned char)(_u_mul(data[3],data[3])) | 1 | (data[2] + (data[2] ^ 0x35)));
+				data[7] = ((0xfE - data[3]) ^ (data[1] | _u_mul(2 , _u_mul(data[2] , data[0])))) + data[3];
+			#else
+				t6 = (data[3]+0x6E) ^ data[3];
+				t6 = (t6*(data[2]<<1))+0x17;
+				t3 = (data[1]+0x77) ^ data[1];
+				t4 = (data[0]+0xD7) ^ data[0];
+				data[4] = ((t4 & t3) | t6)+data[0];
+
+				t4 = ((data[3]+0x71) ^ data[3]) ^ 0x90;
+				t6 =  (data[1]+0x1B) ^ data[1];
+				t4 =  (t4*t6)^ data[0];
+				data[5] = (t4^(data[2]<<1))+data[1];
+
+				t3 =   (data[3]*data[3]) | 0x01;
+				t4 = (((data[2]^0x35)+data[2]) | t3)+data[2];
+				t6 =    data[1]^(data[0]+0x4A);
+				data[6] = t6+t4;
+
+				t3 = (data[0]*(data[2]<<1)) | data[1];
+				t4 = (uint8_t)0xfE - data[3];
+				t3 = t4^t3;
+				data[7] = t3+data[3];
+			#endif
+			break;
+
+		case 0x032820:
+		default:
+			//	All same Ok
+			#if 0
+				#if 0
+					data[4] = data[2] + ((0xE4 * data[1]) | data[2] ^ (data[0] + (data[0] ^ 0xBD) - ((data[3] ^ 0xEB) + data[3])));
+					data[5] = ((2 * data[2] | (unsigned char)(data[0] ^ (data[0] + 6))) ^ 0x65) + data[0] + (((data[1] ^ 0xED) + data[1]) * (data[3] ^ (data[3] + 41)));
+					data[6] = data[1] + ((((data[2] + (data[2] ^ 0x33)) & 0xA) + (data[0] ^ (data[0] - 83))) | (data[1] + ((unsigned char)(data[3] * data[3]) | 1)));
+					data[7] = (((data[3] * data[3]) | data[0] | 1) & ((data[1] & 7) - data[2])) + data[3];
+				#else
+					data[4] = data[2] + (_u_mul(0xE4,data[1]) | data[2] ^ (data[0] + (data[0] ^ 0xBD) - ((data[3] ^ 0xEB) + data[3])));
+					data[5] = ((2 * data[2] | (uint8_t)(data[0] ^ (data[0] + 6))) ^ 0x65) + data[0] + \
+							  _u_mul(((data[1] ^ 0xED) + data[1]), (data[3] ^ (data[3] + 41)));
+					data[6] = data[1] + ((((data[2] + (data[2] ^ 0x33)) & 0xA) + (data[0] ^ (data[0] - 83))) | (data[1] + ((uint8_t)_u_mul(data[3],data[3]) | 1)));
+					data[7] = ((_u_mul(data[3], data[3]) | data[0] | 1) & ((data[1] & 7) - data[2])) + data[3];
+				#endif
+			#else
+				t2 = (data[0]^0xBD)+data[0];
+				t3 = (data[3]^0xEB)+data[3];
+				t2 = (t2-t3)^data[2];
+			//	t3 = (0x39*data[1])<<2;
+				t3 = (0xE4*data[1]);
+				data[4] = (t2|t3)+data[2];
+
+			//	t3 =  (((data[0]+0x06)^data[0]) | ((data[2]<<1)) ^ 0x65)+data[0];
+				t3 = ((((data[0]+0x06)^data[0]) |  (data[2]<<1)) ^ 0x65)+data[0];
+				t2 =    (data[1]^0xED)+data[1];
+				t7 =   ((data[3]+0x29)^data[3])*t2;
+				data[5] = t7+t3;
+
+				t2 = ((data[2]^0x33) + data[2]) & 0x0A;
+			//	t3 =  (data[0]+0xAD) ^ data[0];
+				t3 =  (data[0]-0x53) ^ data[0];
+				t3 = t3+t2;
+				t2 = data[3]*data[3];
+				t7 = (t2 | 0x01)+data[1];
+				data[6] = (t3 | t7)+data[1];
+
+				t3 = data[1] & 0x07;
+				t2 = (t3-data[2]) & (data[0] | t2 | 0x01);
+				data[7] = t2+data[3];
+			#endif
+			break;
+	}
+
+	pMkTABLE = vkp->tMAsk;
+	for (i= 0; i<4; i++)
+	{
+		ix = data[i + 4];
+		data[i+4] = pMkTABLE[ix];
+	}
+}
+
+
+static void
+xvia3_Fct1(PC30_TAB *vkp, uint8_t *data)
+{
+	uint8_t	temp; // eax@1
+
+	xvia3_FctCore(vkp, data, 0);
+	switch (vkp->prid)
+	{
+		case 0x030B00:
+			temp	  = data[7];
+			data[7] = data[5];
+			data[5] = temp;
+			break;
+
+		case 0x032820:
+		default:
+			temp	  = data[7];
+			data[7] = data[4];
+			data[4] = temp;
+			break;
+	}
+}
+
+
+static void
+xvia3_Fct2(PC30_TAB *vkp, uint8_t *data)
+{
+	uint8_t temp;
+
+	xvia3_FctCore(vkp, data, 4);
+	switch (vkp->prid)
+	{
+		case 0x030B00:
+			temp	  = data[7];
+			data[7] = data[6];
+			data[6] = temp;
+			break;
+
+		case 0x032820:
+		default:
+			temp	  = data[4];
+			data[4] = data[7];
+			data[7] = data[5];
+			data[5] = data[6];
+			data[6] = temp;
+			break;
+	}
+}
+
+
+static void
+xvia3_Mix1(PC30_TAB *vkp, uint8_t *data, uint8_t *cwArray)
+{
+	uint8_t	*xorArray;
+	int i;
+
+	xorArray = vkp->xorArray;
+	for (i=0; i<4; i++) data[i] ^= xorArray[i+4];
+	for (i=0; i<4; i++)
+	{
+		cwArray[i] = cwArray[i+4] ^ data[i+4];
+		cwArray[i+4] = data[i];
+	}
+}
+
+
+static void
+xvia3_Mix2(PC30_TAB *vkp, uint8_t *data, uint8_t *cwArray)
+{
+	uint8_t	*xorArray;
+	int i;
+
+	xorArray = vkp->xorArray;
+	for (i= 0; i<4; i++) data[i] ^= xorArray[i];
+	for (i= 0; i<4; i++)
+	{
+		cwArray[i] = cwArray[i+4] ^ data[i+4];
+		cwArray[i+4] = data[i];
+	}
+}
+
+
+static void
+xvia3_Des3(uint8_t *c3DESK, uint8_t *cwArray)
+{
+	DES_key_schedule K1s;
+	DES_key_schedule K2s;
+	DES_cblock result;
+
+	DES_set_key((const_DES_cblock *)&c3DESK[0], &K1s);
+	DES_set_key((const_DES_cblock *)&c3DESK[8], &K2s);
+	DES_ecb3_encrypt((const_DES_cblock *)cwArray, &result, &K1s, &K2s, &K1s, _DECRYPT_);
+	memcpy(cwArray, (void *)result, 8);
+}
+
+
+static void
+xvia3_EcmCore(PC30_TAB *vkp, uint8_t *servk, uint8_t *dcw)
+{
+	uint8_t	CoreArray[8];
+	uint8_t *cwMake;
+	int16_t	ix;
+	int i;
+
+	memset(CoreArray, 0x0, 8);
+
+	for (ix=0; ix<2; ix++)
+	{
+		cwMake = &(dcw[ix * 8]);
+
+		for (i=0; i<4; i++) CoreArray[i] = cwMake[i+4];
+		xvia3_Fct1(vkp, CoreArray);
+
+		for (i=0; i<4; i++) CoreArray[i] = cwMake[i] ^ CoreArray[i+4];
+		xvia3_Fct2(vkp, CoreArray);
+		xvia3_Mix1(vkp, CoreArray, cwMake);
+
+		xvia3_Des3(servk, cwMake);
+
+		for (i=0; i<4; i++) CoreArray[i] = cwMake[i+4];
+		xvia3_Fct2(vkp, CoreArray);
+
+		for (i=0; i<4; i++) CoreArray[i] = cwMake[i] ^ CoreArray[i+4];
+		xvia3_Fct1(vkp, CoreArray);
+		xvia3_Mix2(vkp, CoreArray, cwMake);
+	}
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static int
+xvia3_Algo(PC30_TAB *vk3p, uint8_t kNr, uint8_t *cwDATAs, uint16_t D2Nvar)
+{
+	uint8_t 	*pfxkey;
+	uint8_t	*cw1xor;
+	uint8_t	*pkAes;
+	uint8_t	d2Algo;
+	uint8_t 	cwMake[16];
+	uint8_t 	servk [16];
+	uint16_t	ANr = 0, Aidx;
+	uint16_t	ki;
+	int i;
+
+	ki = (kNr&0x07) * 16;
+	pfxkey = &(vk3p->serviceK[ki]);
+	myprdump("xvia3:pfxkey", pfxkey, 16);
+	myprdump("xvia3:dcw", cwDATAs, 16);
+
+	if (!cs_Isxx(pfxkey,16)) return 0;
+	//
+	//
+	//
+	// NANOD2 d2 02 0d 02 -> D2 nano, len 2
+	// 0d, 0f -> post AES decrypt CW
+	// 0b, 11 -> pre  AES decrypt CW
+	// d2 02 11 0c(ok)
+	switch (D2Nvar>>8)
+	{
+		case 0x0B: d2Algo = 0x1; break;	// 0000 1 01 1
+		case 0x0D: d2Algo = 0x2; break;	// 0000 1 10 1
+		case 0x0F: d2Algo = 0x3; break;	// 0000 1 11 1
+		case 0x11: d2Algo = 0x4; break;	// 0001 0 00 1
+
+		case 0x13: d2Algo = 0x5; break; 	// 0001 0 01 1 /* ??? */
+		case 0x15: d2Algo = 0x6; break; 	// 0001 0 10 1 /* ??? */
+		default:   d2Algo = 0x0; break;
+	}
+
+	if (d2Algo == 0x1 || d2Algo == 0x3 || d2Algo == 0x5)
+	{
+		if (d2Algo == 0x3) {
+			xvia3_N0F11_EncPhase1(cwDATAs);
+			xvia3_N0F11_EncPhase2(cwDATAs);
+		}
+		else
+		if (d2Algo == 0x5) {
+			xvia3_N1315_Phase1(cwDATAs);
+			myprdump("xvia3:Fct1 After", cwDATAs, 16);
+		}
+
+		ANr   = D2Nvar & 0x1f;
+		Aidx  = ANr * 16;
+		pkAes = &(vk3p->cAesK[Aidx]);
+		myprdump("xvia3:pkAes1", pkAes, 16);
+		xvia3_AesDecrypt(cwDATAs, pkAes);
+
+		if (d2Algo == 0x3) {
+			xvia3_N0F11_EncPhase1(cwDATAs);
+		}
+		else
+		if (d2Algo == 0x5) {
+			xvia3_N1315_Phase2(cwDATAs);
+			myprdump("xvia3:Fct2 After", cwDATAs, 16);
+		}
+	}
+	//
+	//
+	//
+	memcpy(servk,  pfxkey, 16);
+	memcpy(cwMake, cwDATAs,16);
+	xvia3_EcmCore(vk3p, servk, cwMake);
+	myprdump("xvia3:Core After", cwMake, 16);
+
+	cw1xor = vk3p->chainArray;
+	for (i=0;i<8;i++) cwMake[i]   ^= cw1xor[i];
+	for (i=0;i<8;i++) cwMake[i+8] ^= cwDATAs[i];
+	myprdump("xvia3:xor After", cwMake, 16);
+	//
+	//
+	//
+	if (d2Algo == 0x2 || d2Algo == 0x4 || d2Algo == 0x6)
+	{
+		if (d2Algo == 0x4) {
+			xvia3_N0F11_EncPhase1(cwMake);
+			xvia3_N0F11_EncPhase2(cwMake);
+		}
+		else
+		if (d2Algo == 0x6) {
+			xvia3_N1315_Phase1(cwMake);
+			myprdump("xvia3:Fct1 After", cwMake, 16);
+		}
+		ANr   = D2Nvar & 0x1f;
+		Aidx  = ANr * 16;
+		pkAes = &(vk3p->cAesK[Aidx]);
+		myprdump("xvia3:pkAes2", pkAes, 16);
+		xvia3_AesDecrypt(cwMake, pkAes);
+//		myprdump("xvia3:pkAes", pkAes, 16);
+		myprdump("xvia3:Aes After", cwMake, 16);
+
+		if (d2Algo == 0x4) {
+			xvia3_N0F11_EncPhase1(cwMake);
+		}
+		else
+		if (d2Algo == 0x6) {
+			xvia3_N1315_Phase2(cwMake);
+			myprdump("xvia3:Fct2 After", cwMake, 16);
+		}
+	}
+	//
+	//
+	//
+	if (chk_cw_violation(cwMake))
+	{
+		MYEMU_TRACE("myxviacess:PC3.0{%02X} chksum fail.\n", ANr);
+		return 0;
+	}
+	myprdump("xvia3:CWs", cwMake, 16);
+	memcpy(cwDATAs, cwMake, 16);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//======================================================================
+//======================================================================
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static int
+xvia3x26_Algo(uint32_t prid,
+	void	 	*Issuerp,
+	uint8_t	kNr,
+	uint16_t D2Nvar,
+	uint8_t  *source,
+	int  	 	sourcesize,
+	uint8_t  *cw1,
+	uint8_t	*cw2)
+{
+	uint8_t	*cDATAEAp;
+	uint8_t	*cDATAExp;
+	uint8_t  *pDxptr;
+	uint8_t	 signature[8];
+	uint8_t	 cDxsize;
+	int cwAvail;
+	int i = 0;
+	int k;
+
+	cwAvail  = 0;
+	cDATAEAp = NULL;
+	cDATAExp = NULL;
+
+	while (i<sourcesize)
+	{
+		switch (source[i])
+		{
+			case 0xDD:
+				k = 0;
+				cDxsize =  source[i+1];
+				pDxptr  = &source[i+2];
+				while (k<cDxsize)
+				{
+					switch (pDxptr[k])
+					{
+						case 0x97:
+							break;
+
+						case 0xEA:
+							cDATAExp = &pDxptr[k+2];
+							break;
+
+						case 0xf0:
+							// Signature algo's of VIA2.6 and 3 are not public.
+							memcpy(signature, &pDxptr[k+2], 8);
+							break;
+					}
+					k += pDxptr[k+1]+2;
+					if (cDATAExp) break;
+				}
+				break;
+
+			case 0xEA:
+				cDATAEAp = &source[i+2];
+				break;
+
+			case 0xf0:
+				// UNAVAILABLE.
+				memcpy(signature, &source[i+2], 8);
+				break;
+		}
+		i += source[i+1]+2;
+		if (cDATAEAp) break;
+	}
+	if (!cDATAEAp) return 0;
+
+	switch (prid>>16)
+	{
+		case 0x02:
+			MYEMU_TRACE("myxviacess:2x{%06X.%02X}\n", prid, kNr);
+			cwAvail = xvia2_Algo((PC26_TAB *)Issuerp, kNr, cDATAEAp);
+			break;
+
+		case 0x03:
+			MYEMU_TRACE("myxviacess:3x{%06X.%02X,%04X}\n", prid, kNr, D2Nvar);
+			cwAvail = xvia3_Algo((PC30_TAB *)Issuerp, kNr, cDATAEAp, D2Nvar);
+			break;
+	}
+
+	if (cwAvail)
+	{
+		memcpy(cw1, &cDATAEAp[0], 8);
+		memcpy(cw2, &cDATAEAp[8], 8);
+	}
+	return (cwAvail);
+}
+
+
+
+static void *
+xvia3x26_ChkPCIssuers(struct s_reader *reader, uint32_t prid, uint8_t kNr, uint8_t Aidx, uint8_t *pfxkey)
+{
+	char Atag[32];
+	int  cMax;
+	int  ki,i;
+
+	prid &= 0xFFFFF0;
+	cMax  = (sizeof(PC26_Issuers) / sizeof(PC26_TAB));
+	for (i= 0; i<cMax; i++)
+	{
+		if (PC26_Issuers[i].prid == prid)
+		{
+			if (PC26_Lst.prid != prid)
+			{
+				memcpy(&PC26_Lst, &PC26_Issuers[i], sizeof(PC26_TAB));
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "C1", PC26_Lst.chainArray, 8);
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "P1", PC26_Lst.permArray, 8);
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "X1", PC26_Lst.xorArray, 8);
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "T1", PC26_Lst.tMAsk, 256);
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "D1", PC26_Lst.des1K, 8);
+			}
+			if (pfxkey)
+			{
+				ki = (kNr&0x07) * 16;
+				memcpy(&(PC26_Lst.serviceK[ki]), pfxkey, 16);
+			}
+			return (&PC26_Lst);
+		}
+	}
+
+	cMax  = (sizeof(PC30_Issuers) / sizeof(PC30_TAB));
+	for (i= 0; i<cMax; i++)
+	{
+		if (PC30_Issuers[i].prid == prid)
+		{
+			if (PC30_Lst.prid != prid)
+			{
+				memcpy(&PC30_Lst, &PC30_Issuers[i], sizeof(PC30_TAB));
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "C1", PC30_Lst.chainArray, 8);
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "X1", PC30_Lst.xorArray, 8);
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, "T1", PC30_Lst.tMAsk, 256);
+
+//				ki = (Aidx&0x0f)*16;
+				ki = (Aidx&0x1f)*16;
+				sprintf(Atag, "E%X", Aidx);
+				XEMUKEY_SpecialSearch(reader, CASS_VIACCESS, prid, Atag, &(PC30_Lst.cAesK[ki]), 16);
+			}
+			if (pfxkey)
+			{
+				ki = (kNr&0x07) * 16;
+				memcpy(&(PC30_Lst.serviceK[ki]), pfxkey, 16);
+			}
+			return (&PC30_Lst);
+		}
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////
+unsigned char TNTSATEMM_AesBuff[0x200]=
+{
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0xF1,0xDC,0xB1,0x5A,0x3D,0xE3,0xFA,0x1D,0x7E,0x29,0x98,0xDA,0x7D,0xD4,0x89,0x8A,
+	0x48,0xC1,0x9B,0x86,0xA4,0xE2,0xEB,0x72,0x88,0xDF,0xDC,0xE7,0xC2,0xBB,0x75,0x77,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x9A,0x3E,0xAB,0x02,0x03,0xEB,0xFF,0xCA,0x85,0xB4,0xF1,0x82,0x80,0x74,0x9F,0x56,
+	0x25,0x04,0xb3,0x82,0xB1,0x6D,0x8C,0x67,0x58,0xDB,0x96,0x0E,0x31,0x1E,0x93,0x51,
+	0x34,0x98,0x83,0xE5,0x4D,0x58,0x33,0x6D,0xCA,0x75,0x0A,0x87,0x8A,0xCC,0x5C,0xD5,
+	0x4A,0x26,0xAD,0x25,0x17,0x95,0xA5,0x8A,0x11,0xBB,0xC0,0x7B,0x53,0xC4,0x43,0x48,
+	0x28,0x44,0x25,0x87,0x92,0xF6,0xD9,0x52,0x9A,0x32,0x8B,0x3E,0x8C,0xD2,0xFD,0x0E,
+	0xF6,0x2C,0x3B,0xE3,0x00,0xE9,0x8B,0xBB,0x37,0x8D,0xFA,0x38,0xBB,0x6E,0xEE,0xF1,
+	0xDD,0x39,0x0F,0xED,0x21,0x91,0xD2,0x82,0x01,0x60,0x25,0x09,0x3E,0xE0,0x91,0xBA,
+	0x8C,0x61,0x99,0xE0,0xB8,0x87,0x7F,0x4B,0xD2,0x13,0x6E,0xF6,0xD1,0x14,0x2D,0x15,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+unsigned char TNTSATEMM_CRC32_TBL[0x400]=
+{
+	0x00,0x00,0x00,0x00,0xB7,0x1D,0xC1,0x04,0x6E,0x3B,0x82,0x09,0xD9,0x26,0x43,0x0D,
+	0xDC,0x76,0x04,0x13,0x6B,0x6B,0xC5,0x17,0xB2,0x4D,0x86,0x1A,0x05,0x50,0x47,0x1E,
+	0xB8,0xED,0x08,0x26,0x0F,0xF0,0xC9,0x22,0xD6,0xD6,0x8A,0x2F,0x61,0xCB,0x4B,0x2B,
+	0x64,0x9B,0x0C,0x35,0xD3,0x86,0xCD,0x31,0x0A,0xA0,0x8E,0x3C,0xBD,0xBD,0x4F,0x38,
+	0x70,0xDB,0x11,0x4C,0xC7,0xC6,0xD0,0x48,0x1E,0xE0,0x93,0x45,0xA9,0xFD,0x52,0x41,
+	0xAC,0xAD,0x15,0x5F,0x1B,0xB0,0xD4,0x5B,0xC2,0x96,0x97,0x56,0x75,0x8B,0x56,0x52,
+	0xC8,0x36,0x19,0x6A,0x7F,0x2B,0xD8,0x6E,0xA6,0x0D,0x9B,0x63,0x11,0x10,0x5A,0x67,
+	0x14,0x40,0x1D,0x79,0xA3,0x5D,0xDC,0x7D,0x7A,0x7B,0x9F,0x70,0xCD,0x66,0x5E,0x74,
+	0xE0,0xB6,0x23,0x98,0x57,0xAB,0xE2,0x9C,0x8E,0x8D,0xA1,0x91,0x39,0x90,0x60,0x95,
+	0x3C,0xC0,0x27,0x8B,0x8B,0xDD,0xE6,0x8F,0x52,0xFB,0xA5,0x82,0xE5,0xE6,0x64,0x86,
+	0x58,0x5B,0x2B,0xBE,0xEF,0x46,0xEA,0xBA,0x36,0x60,0xA9,0xB7,0x81,0x7D,0x68,0xB3,
+	0x84,0x2D,0x2F,0xAD,0x33,0x30,0xEE,0xA9,0xEA,0x16,0xAD,0xA4,0x5D,0x0B,0x6C,0xA0,
+	0x90,0x6D,0x32,0xD4,0x27,0x70,0xF3,0xD0,0xFE,0x56,0xB0,0xDD,0x49,0x4B,0x71,0xD9,
+	0x4C,0x1B,0x36,0xC7,0xFB,0x06,0xF7,0xC3,0x22,0x20,0xB4,0xCE,0x95,0x3D,0x75,0xCA,
+	0x28,0x80,0x3A,0xF2,0x9F,0x9D,0xFB,0xF6,0x46,0xBB,0xB8,0xFB,0xF1,0xA6,0x79,0xFF,
+	0xF4,0xF6,0x3E,0xE1,0x43,0xEB,0xFF,0xE5,0x9A,0xCD,0xBC,0xE8,0x2D,0xD0,0x7D,0xEC,
+	0x77,0x70,0x86,0x34,0xC0,0x6D,0x47,0x30,0x19,0x4B,0x04,0x3D,0xAE,0x56,0xC5,0x39,
+	0xAB,0x06,0x82,0x27,0x1C,0x1B,0x43,0x23,0xC5,0x3D,0x00,0x2E,0x72,0x20,0xC1,0x2A,
+	0xCF,0x9D,0x8E,0x12,0x78,0x80,0x4F,0x16,0xA1,0xA6,0x0C,0x1B,0x16,0xBB,0xCD,0x1F,
+	0x13,0xEB,0x8A,0x01,0xA4,0xF6,0x4B,0x05,0x7D,0xD0,0x08,0x08,0xCA,0xCD,0xC9,0x0C,
+	0x07,0xAB,0x97,0x78,0xB0,0xB6,0x56,0x7C,0x69,0x90,0x15,0x71,0xDE,0x8D,0xD4,0x75,
+	0xDB,0xDD,0x93,0x6B,0x6C,0xC0,0x52,0x6F,0xB5,0xE6,0x11,0x62,0x02,0xFB,0xD0,0x66,
+	0xBF,0x46,0x9F,0x5E,0x08,0x5B,0x5E,0x5A,0xD1,0x7D,0x1D,0x57,0x66,0x60,0xDC,0x53,
+	0x63,0x30,0x9B,0x4D,0xD4,0x2D,0x5A,0x49,0x0D,0x0B,0x19,0x44,0xBA,0x16,0xD8,0x40,
+	0x97,0xC6,0xA5,0xAC,0x20,0xDB,0x64,0xA8,0xF9,0xFD,0x27,0xA5,0x4E,0xE0,0xE6,0xA1,
+	0x4B,0xB0,0xA1,0xBF,0xFC,0xAD,0x60,0xBB,0x25,0x8B,0x23,0xB6,0x92,0x96,0xE2,0xB2,
+	0x2F,0x2B,0xAD,0x8A,0x98,0x36,0x6C,0x8E,0x41,0x10,0x2F,0x83,0xF6,0x0D,0xEE,0x87,
+	0xF3,0x5D,0xA9,0x99,0x44,0x40,0x68,0x9D,0x9D,0x66,0x2B,0x90,0x2A,0x7B,0xEA,0x94,
+	0xE7,0x1D,0xB4,0xE0,0x50,0x00,0x75,0xE4,0x89,0x26,0x36,0xE9,0x3E,0x3B,0xF7,0xED,
+	0x3B,0x6B,0xB0,0xF3,0x8C,0x76,0x71,0xF7,0x55,0x50,0x32,0xFA,0xE2,0x4D,0xF3,0xFE,
+	0x5F,0xF0,0xBC,0xC6,0xE8,0xED,0x7D,0xC2,0x31,0xCB,0x3E,0xCF,0x86,0xD6,0xFF,0xCB,
+	0x83,0x86,0xB8,0xD5,0x34,0x9B,0x79,0xD1,0xED,0xBD,0x3A,0xDC,0x5A,0xA0,0xFB,0xD8,
+	0xEE,0xE0,0x0C,0x69,0x59,0xFD,0xCD,0x6D,0x80,0xDB,0x8E,0x60,0x37,0xC6,0x4F,0x64,
+	0x32,0x96,0x08,0x7A,0x85,0x8B,0xC9,0x7E,0x5C,0xAD,0x8A,0x73,0xEB,0xB0,0x4B,0x77,
+	0x56,0x0D,0x04,0x4F,0xE1,0x10,0xC5,0x4B,0x38,0x36,0x86,0x46,0x8F,0x2B,0x47,0x42,
+	0x8A,0x7B,0x00,0x5C,0x3D,0x66,0xC1,0x58,0xE4,0x40,0x82,0x55,0x53,0x5D,0x43,0x51,
+	0x9E,0x3B,0x1D,0x25,0x29,0x26,0xDC,0x21,0xF0,0x00,0x9F,0x2C,0x47,0x1D,0x5E,0x28,
+	0x42,0x4D,0x19,0x36,0xF5,0x50,0xD8,0x32,0x2C,0x76,0x9B,0x3F,0x9B,0x6B,0x5A,0x3B,
+	0x26,0xD6,0x15,0x03,0x91,0xCB,0xD4,0x07,0x48,0xED,0x97,0x0A,0xFF,0xF0,0x56,0x0E,
+	0xFA,0xA0,0x11,0x10,0x4D,0xBD,0xD0,0x14,0x94,0x9B,0x93,0x19,0x23,0x86,0x52,0x1D,
+	0x0E,0x56,0x2F,0xF1,0xB9,0x4B,0xEE,0xF5,0x60,0x6D,0xAD,0xF8,0xD7,0x70,0x6C,0xFC,
+	0xD2,0x20,0x2B,0xE2,0x65,0x3D,0xEA,0xE6,0xBC,0x1B,0xA9,0xEB,0x0B,0x06,0x68,0xEF,
+	0xB6,0xBB,0x27,0xD7,0x01,0xA6,0xE6,0xD3,0xD8,0x80,0xA5,0xDE,0x6F,0x9D,0x64,0xDA,
+	0x6A,0xCD,0x23,0xC4,0xDD,0xD0,0xE2,0xC0,0x04,0xF6,0xA1,0xCD,0xB3,0xEB,0x60,0xC9,
+	0x7E,0x8D,0x3E,0xBD,0xC9,0x90,0xFF,0xB9,0x10,0xB6,0xBC,0xB4,0xA7,0xAB,0x7D,0xB0,
+	0xA2,0xFB,0x3A,0xAE,0x15,0xE6,0xFB,0xAA,0xCC,0xC0,0xB8,0xA7,0x7B,0xDD,0x79,0xA3,
+	0xC6,0x60,0x36,0x9B,0x71,0x7D,0xF7,0x9F,0xA8,0x5B,0xB4,0x92,0x1F,0x46,0x75,0x96,
+	0x1A,0x16,0x32,0x88,0xAD,0x0B,0xF3,0x8C,0x74,0x2D,0xB0,0x81,0xC3,0x30,0x71,0x85,
+	0x99,0x90,0x8A,0x5D,0x2E,0x8D,0x4B,0x59,0xF7,0xAB,0x08,0x54,0x40,0xB6,0xC9,0x50,
+	0x45,0xE6,0x8E,0x4E,0xF2,0xFB,0x4F,0x4A,0x2B,0xDD,0x0C,0x47,0x9C,0xC0,0xCD,0x43,
+	0x21,0x7D,0x82,0x7B,0x96,0x60,0x43,0x7F,0x4F,0x46,0x00,0x72,0xF8,0x5B,0xC1,0x76,
+	0xFD,0x0B,0x86,0x68,0x4A,0x16,0x47,0x6C,0x93,0x30,0x04,0x61,0x24,0x2D,0xC5,0x65,
+	0xE9,0x4B,0x9B,0x11,0x5E,0x56,0x5A,0x15,0x87,0x70,0x19,0x18,0x30,0x6D,0xD8,0x1C,
+	0x35,0x3D,0x9F,0x02,0x82,0x20,0x5E,0x06,0x5B,0x06,0x1D,0x0B,0xEC,0x1B,0xDC,0x0F,
+	0x51,0xA6,0x93,0x37,0xE6,0xBB,0x52,0x33,0x3F,0x9D,0x11,0x3E,0x88,0x80,0xD0,0x3A,
+	0x8D,0xD0,0x97,0x24,0x3A,0xCD,0x56,0x20,0xE3,0xEB,0x15,0x2D,0x54,0xF6,0xD4,0x29,
+	0x79,0x26,0xA9,0xC5,0xCE,0x3B,0x68,0xC1,0x17,0x1D,0x2B,0xCC,0xA0,0x00,0xEA,0xC8,
+	0xA5,0x50,0xAD,0xD6,0x12,0x4D,0x6C,0xD2,0xCB,0x6B,0x2F,0xDF,0x7C,0x76,0xEE,0xDB,
+	0xC1,0xCB,0xA1,0xE3,0x76,0xD6,0x60,0xE7,0xAF,0xF0,0x23,0xEA,0x18,0xED,0xE2,0xEE,
+	0x1D,0xBD,0xA5,0xF0,0xAA,0xA0,0x64,0xF4,0x73,0x86,0x27,0xF9,0xC4,0x9B,0xE6,0xFD,
+	0x09,0xFD,0xB8,0x89,0xBE,0xE0,0x79,0x8D,0x67,0xC6,0x3A,0x80,0xD0,0xDB,0xFB,0x84,
+	0xD5,0x8B,0xBC,0x9A,0x62,0x96,0x7D,0x9E,0xBB,0xB0,0x3E,0x93,0x0C,0xAD,0xFF,0x97,
+	0xB1,0x10,0xB0,0xAF,0x06,0x0D,0x71,0xAB,0xDF,0x2B,0x32,0xA6,0x68,0x36,0xF3,0xA2,
+	0x6D,0x66,0xB4,0xBC,0xDA,0x7B,0x75,0xB8,0x03,0x5D,0x36,0xB5,0xB4,0x40,0xF7,0xB1
+};
+
+unsigned char TNTSATEMM_CardBuffs[4*10]=
+{
+	0x10,0x00,0xD0,0x00,
+	0x20,0x00,0xD0,0x00,
+	0x30,0x00,0xD0,0x00,
+	0x40,0x00,0xD0,0x00,
+	0x50,0x00,0xD0,0x00,
+	0x60,0x00,0xD0,0x00,
+	0x70,0x00,0xD0,0x00,
+	0x80,0x00,0xD0,0x00,
+	0x90,0x00,0xD0,0x00,
+	0xFF,0x00,0xD0,0x00
+};
+
+unsigned char TNTSATEMM_EMMKeys[0x30]=
+{
+	0x1A,0x2D,0x8C,0x57,0x1E,0x32,0xA1,0xDE,0xE6,0xD6,0x72,0x24,0x92,0xFF,0x71,0x58,
+	0x1A,0x2D,0x8C,0x57,0x1E,0x32,0xA1,0xDE,0xE6,0xD6,0x72,0x24,0x92,0xFF,0x71,0x58,
+	0x1A,0x2D,0x8C,0x57,0x1E,0x32,0xA1,0xDE,0xE6,0xD6,0x72,0x24,0x92,0xFF,0x71,0x58
+};
+
+unsigned char *
+xvia3_EMM_FindNano(unsigned char *pData,unsigned char *pEnd,unsigned char nano)
+{
+	unsigned char *pBuf=pData;
+	if (pData>=pEnd) { return 0; }
+
+	unsigned char *tmp=0;
+	while(pBuf<pEnd)
+	{
+		unsigned char nanoLen = pBuf[1];
+		if (pBuf[0]==nano)
+		{
+			tmp=pBuf;
+			break;
+		}
+		int pad=nanoLen+2;
+		pBuf+=pad;
+	}
+	return tmp;
+}
+
+int
+xvia3_EMM_DecryptBlk(unsigned char *r0,unsigned char *r1,int r2,unsigned char *r3,unsigned char *r4,int r5)
+{
+	unsigned char *r22=r0;
+	unsigned char *r23=r1;
+	int r13=r2;
+	unsigned char *r15=r3;
+	unsigned char *r24=r4;
+	int r25=r5;
+	if (r22==0) { return -1; }
+	if (r23==0) { return -2; }
+	if (r15==0) { return -3; }
+	if (r24==0) { return -4; }
+	if (r13==0) { return -5; }
+	if (r25!=0x10) { return -6; }
+	/////
+	unsigned char key[16];
+	memcpy(key,r24,0x10);
+	int r14=(r13>>4);//nblk
+	unsigned char *r17=r22;
+	unsigned char *r16=r23;
+	int r18=0;
+	if (r14>0)
+	{
+		unsigned char tmp[16];
+		while(r18<r14)
+		{
+		//	do_Aes(key,tmp,1,r15);
+			memcpy(tmp, key, 16);
+			xvia3_AesDecrypt(tmp,r15);
+			int r19=0;
+			while(r19<0x10)
+			{
+				r16[r19]=r17[r19]^tmp[r19];
+				r19+=1;
+			}
+			#if 0
+			*((unsigned long *)(key))     = *((unsigned long *)(tmp));
+			*((unsigned long *)(key+4))   = *((unsigned long *)(tmp+4));
+			*((unsigned long *)(key+8))   = *((unsigned long *)(tmp+8));
+			*((unsigned long *)(key+0xC)) = *((unsigned long *)(tmp+0xC));
+			#else
+			int i;
+			for (i=0; i<16; i++) key[i] = tmp[i];
+			#endif
+			r17+=0x10;
+			r16+=0x10;
+			r18+=1;
+		}
+	}
+
+	int rLen=(r13&0xF);
+	if (rLen>0)
+	{
+		unsigned char tmp[16];
+	//	do_Aes(key,tmp,1,r15);
+		memcpy(tmp, key, 16);
+		xvia3_AesDecrypt(tmp,r15);
+		int r19=0;
+		while(r19<rLen)
+		{
+			r16[r19]=r17[r19]^tmp[r19];
+			r19+=1;
+		}
+	}
+	return 0;
+}
+
+void
+xvia3_EMM_GetAesKeys(unsigned char *pBuf,unsigned char *Key,unsigned char algo,unsigned long prov)
+{
+	unsigned char idx=pBuf[0];
+	unsigned char *tmpKey=pBuf+1;
+	if ((algo-0xB)>0xA) { return; }
+
+	switch(algo)
+	{
+		case 0x0B:
+		//	do_Aes(tmpKey,tmpKey,1,Key);
+			xvia3_AesDecrypt(tmpKey,Key);
+			break;
+		case 0x0D:
+		//	do_Aes(tmpKey,tmpKey,1,Key);
+			xvia3_AesDecrypt(tmpKey,Key);
+			break;
+		case 0x0F:
+		//	aes_nano11(tmpKey,tmpKey,Key);
+			xvia3_AesNano11(tmpKey,Key);
+			break;
+		case 0x11:
+		//	aes_nano11(tmpKey,tmpKey,Key);
+			xvia3_AesNano11(tmpKey,Key);
+			break;
+		case 0x13:
+		//	aes_nano15(tmpKey,Key);
+			xvia3_AesNano15(tmpKey,Key);
+			break;
+		case 0x15:
+		//	aes_nano15(tmpKey,Key);
+			xvia3_AesNano15(tmpKey,Key);
+			break;
+	}
+	if (prov==0x30B00)
+	{
+		memcpy(TNTSATEMM_AesBuff+(16*idx),tmpKey,16);
+	}
+}
+
+int
+xvia3_EMM_DecryptAesKeys(unsigned char *r0,unsigned long r1)
+{
+	unsigned char *r19=r0;
+	unsigned long r17=r1;
+	if (r19==0) { return 1; }
+	if (r19[0]!=0x68) { return 0; }
+	unsigned char r14s=0;
+
+	while(r19[r14s]==0x68)
+	{
+		unsigned char r14=r19[1];
+		r19+=2;
+		unsigned char *pNanoD2=xvia3_EMM_FindNano(r19,r19+r14,0xD2);
+		if (pNanoD2==0) { return 0; }
+//		unsigned char r18=pNanoD2[1];
+		pNanoD2+=2;
+		unsigned char r15=pNanoD2[0];
+		unsigned char r16=pNanoD2[1];
+		unsigned char *pNano01=xvia3_EMM_FindNano(r19,r19+r14,1);
+		if (pNano01==0) { return 0; }
+		r14=pNano01[1];
+		pNano01+=2;
+		unsigned char idx=pNano01[0];
+		if ((idx!=1)&&(idx!=2)) { return 0; }
+
+		r19=pNano01;
+		xvia3_EMM_GetAesKeys(r19,TNTSATEMM_EMMKeys+(r16*16),(r15&0xFF),r17);
+		r19+=r14;
+	}
+	return 1;
+}
+
+int
+xvia3_EMM_CRC32Test(unsigned char *r0,int r1,unsigned char *r2)
+{
+	unsigned char *r13=r0;
+	unsigned long r4=0xFFFFFFFF;
+	int r5=0;
+	if (r1>0)
+	{
+		for(r5=0;r5<r1;r5++)
+		{
+			unsigned long r10=*((unsigned long*)(TNTSATEMM_CRC32_TBL+((r13[r5]^(r4>>0x18))<<2)));
+			r4<<=8;
+			r4^=r10;
+		}
+	}
+	for(r5=0;r5<4;r5++)
+	{
+		unsigned long r10=*((unsigned long*)(TNTSATEMM_CRC32_TBL+((r2[r5]^(r4>>0x18))<<2)));
+		r4<<=8;
+		r4^=r10;
+	}
+	if (r4==0) { return 1; }
+	return 0;
+}
+
+int
+XVIACESS_EmmProcess(struct s_reader *rdr, unsigned char *emm, int emmLen, unsigned long provid)
+{
+	unsigned short cur_Time=0;
+	unsigned long  pCard;
+
+	if (emm[0]==0x88)
+	{
+		pCard=emm[0xC]|((emm[0xB]<<8)|(emm[0xA]<<0x10));
+		return 0;
+	}
+
+	pCard=(emm[5]<<0x10)|(emm[6]<<8)|emm[7];
+	int isOK=0;
+
+	int k;
+	for(k=0;k<0xA;k++)
+	{
+		unsigned long p=*((unsigned long*)(TNTSATEMM_CardBuffs+(k*4)));
+		if (p==pCard)
+		{
+			isOK=1;
+			break;
+		}
+	}
+
+	if (isOK==0) { return 0; }
+
+	unsigned char *r23=0;
+	int ptr=3;
+	if (emm[0]==0x88)
+	{
+		r23=emm+0x13;
+		ptr=8;
+	}
+
+	if (emm[ptr  ]!=0x90) { return 0; }
+	if (emm[ptr+1]!=0x03) { return 0; }
+	if (emm[ptr+5]!=0xD2) { return 0; }
+	////
+//	unsigned char tmp[4]={0,};
+//	tmp[1]=emm[ptr+2];
+//	tmp[2]=emm[ptr+3];
+//	tmp[3]=emm[ptr+4];
+	unsigned char Algo=emm[ptr+7];
+	unsigned char KeyIdx=emm[ptr+8];
+	if (KeyIdx>2) { return 0; }
+
+	if (Algo==0)  { return 0; }
+	if (Algo!=0xE){ return 0; }
+
+	if (emm[ptr+9]==0x41)
+	{
+		unsigned char nanoLen=emm[ptr+0xA];
+		if ((nanoLen!=6)&&(nanoLen!=9)) { return 0; }
+	}
+
+	unsigned char tmp2[16]="";
+	int KeyPtr=(KeyIdx*16);
+
+//	do_Aes(tmp2,tmp2,1,TNTSATEMM_EMMKeys+KeyPtr);
+	xvia3_AesDecrypt(tmp2,TNTSATEMM_EMMKeys+KeyPtr);
+	int i=0;
+	unsigned char nanoLen=emm[ptr+0xA];
+
+	if (nanoLen!=0)
+	{
+		for(i=0;i<nanoLen;i++)
+		{
+			tmp2[i]=emm[ptr+0xB+i]^tmp2[i];
+		}
+	}
+
+	unsigned char aTntsat[]={0x54,0x4E,0x54,0x53,0x41,0x54,0x00,0x00};
+	if (memcmp(tmp2,aTntsat,nanoLen)!=0) { return 0; }
+
+	unsigned char *pNanoBA=xvia3_EMM_FindNano(emm+ptr+9,emm+emmLen,0xBA);
+	if (pNanoBA==0) { return 0; }
+	if (pNanoBA[1]!=2) { return 0; }
+
+	unsigned short pTime=(pNanoBA[2]<<8)|pNanoBA[3];
+	if (pTime<=cur_Time) { return 0; }
+	cur_Time=pTime;
+
+	unsigned char *pNano43=xvia3_EMM_FindNano(emm+ptr,emm+emmLen,0x43);
+	if (pNano43==0) { return 0; }
+	if (pNano43[1]!=0x10) { return 0; }
+
+	unsigned char *pNano44=xvia3_EMM_FindNano(emm+ptr,emm+emmLen,0x44);
+	if (pNano44==0) { return 0; }
+	unsigned char Len=pNano44[1];
+	unsigned char keyLen=pNano43[1];
+
+	int isDecrypted=xvia3_EMM_DecryptBlk(pNano44+2,pNano44,Len, TNTSATEMM_EMMKeys+KeyPtr,pNano43+2,keyLen);
+	if (isDecrypted!=0) { return 0; }
+
+	if (pNano44[Len-6]!=0xF0) { return 0; }
+	if (pNano44[Len-5]!=0x04) { return 0; }
+
+	unsigned char pCrc[4];
+	pCrc[0]=pNano44[Len-4];
+	pCrc[1]=pNano44[Len-3];
+	pCrc[2]=pNano44[Len-2];
+	pCrc[3]=pNano44[Len-1];
+
+	unsigned char *crcBuff=emm+ptr;
+	if (r23!=0)
+	{
+		crcBuff=emm+ptr-5;
+	}
+
+	int crcLen=emmLen-ptr;
+	if (r23!=0)
+	{
+		crcLen=emmLen-ptr+5;
+	}
+	crcLen-=8;
+	int CrcOk=xvia3_EMM_CRC32Test(crcBuff,crcLen,pCrc);
+	if (CrcOk==0) { return 0; }
+	return xvia3_EMM_DecryptAesKeys(pNano44,provid);
+}
+////////////////////////////////////////////////////////////////////////
+/*
+TNTSAT 10/28/2013
+*/
+#if 0
+uint8_t  tntsat_ecm_tests[] = {
+	0x80,0x71,0x3F,0x01,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x0A,0x05,0x67,0x01,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0x72,
+	0xBF,0xED,0xB3,0x3D,0xD2,0xBC,0x32,0x2D,0xB7,0xD1,0x5B,0x96,0x9B,0x5E,0xD0,0xF0,0x08,0x78,0x8E,0x9F,0xC2,0x12,0xDA,0x67,0x70,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,
+	0x07,0x03,0x0B,0x00,0x08,0x06,0x15,0x01,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0xFE,0x52,0xC5,0x28,0x6E,0xBF,0x42,0x4E,0x2E,0x8D,0xAA,0x50,
+	0x6A,0xC4,0x27,0x45,0xF0,0x08,0x57,0xD8,0xD2,0x48,0xEB,0xEF,0xBB,0xB3,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x08,0x07,0x01,0x00,0xE2,0x03,0x43,
+	0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0xC4,0x8B,0xBE,0xFD,0x55,0x5A,0xA5,0xC4,0xF4,0x91,0x0C,0x65,0xFA,0x7A,0x5E,0x2A,0xF0,0x08,0xE4,0x13,0xA1,0x81,0x40,
+	0xB0,0x9A,0x88,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x08,0x07,0x01,0x01,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0xA7,0xB7,
+	0xB2,0x58,0x8A,0xE9,0x70,0xC2,0x2F,0xC1,0x12,0x81,0xE9,0x93,0xF2,0xBD,0xF0,0x08,0xBF,0x6C,0xC8,0xCF,0x07,0xBA,0xC3,0xAF,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,
+	0x03,0x0B,0x00,0x08,0x06,0x15,0x00,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0x19,0x5A,0xD8,0xA3,0xED,0xE5,0x0E,0x5E,0x79,0xCB,0x02,0x6B,0xAA,
+	0xF4,0xD1,0x9D,0xF0,0x08,0x24,0x18,0x96,0x3E,0x0F,0xED,0x2C,0xAB,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x0A,0x05,0x67,0x00,0xE2,0x03,0x43,0x5B,
+	0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0x4B,0xB3,0xB1,0x49,0x0C,0x66,0x2E,0x69,0x0D,0x50,0x97,0x8C,0x51,0x52,0xD0,0xC4,0xF0,0x08,0xDB,0xE5,0x68,0x1A,0xD4,0x2B,
+	0xED,0x20
+//
+//	CWs  : 4B B3 B1 49 0C 66 2E 69 0D 50 97 8C 51 52 D0 C4
+//	DCWs : E5 10 4F 44 D8 6D 76 BB BA 9C 30 86 A9 07 BE 6E
+//
+//
+//	Before Nano D2 02 15:
+//	CWs (Initial) : 4B B3 B1 49 0C 66 2E 69 0D 50 97 8C 51 52 D0 C4
+//	CWs after Viaccess Process : 6C A9 63 CC 7E 5B DE AE E9 3F FB B1 73 A2 8F 26
+//
+//	Nano D2 02 15:
+//	CWs after Func1 : 90 B9 15 52 C6 AD 60 48 A9 29 E6 CC EC 0A 9E D4
+//	CWs after AES : 2D E0 CA EA 49 22 DA 8F 9B 9D 8F 03 90 64 6F DB
+//	CWs after Func2 = Final : E5 10 4F 44 D8 6D 76 BB BA 9C 30 86 A9 07 BE 6E
+};
+#endif
+#if 0
+uint8_t  tntsat_ecm_tests[] = {
+0x80,0x71,0x3F,0x01,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x0A,
+0x05,0x67,0x01,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0x72,
+0xBF,0xED,0xB3,0x3D,0xD2,0xBC,0x32,0x2D,0xB7,0xD1,0x5B,0x96,0x9B,0x5E,0xD0,0xF0,
+0x08,0x78,0x8E,0x9F,0xC2,0x12,0xDA,0x67,0x70,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,
+0x07,0x03,0x0B,0x00,0x08,0x06,0x15,0x01,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,
+0x5B,0xFE,0xEA,0x10,0xFE,0x52,0xC5,0x28,0x6E,0xBF,0x42,0x4E,0x2E,0x8D,0xAA,0x50,
+0x6A,0xC4,0x27,0x45,0xF0,0x08,0x57,0xD8,0xD2,0x48,0xEB,0xEF,0xBB,0xB3,0x80,0x33,
+0xD2,0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x08,0x07,0x01,0x00,0xE2,0x03,0x43,
+0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0xC4,0x8B,0xBE,0xFD,0x55,0x5A,0xA5,
+0xC4,0xF4,0x91,0x0C,0x65,0xFA,0x7A,0x5E,0x2A,0xF0,0x08,0xE4,0x13,0xA1,0x81,0x40,
+0xB0,0x9A,0x88,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x08,0x07,
+0x01,0x01,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0xA7,0xB7,
+0xB2,0x58,0x8A,0xE9,0x70,0xC2,0x2F,0xC1,0x12,0x81,0xE9,0x93,0xF2,0xBD,0xF0,0x08,
+0xBF,0x6C,0xC8,0xCF,0x07,0xBA,0xC3,0xAF,0x80,0x33,0xD2,0x02,0x15,0x0D,0x40,0x07,
+0x03,0x0B,0x00,0x08,0x06,0x15,0x00,0xE2,0x03,0x43,0x5B,0x00,0xE2,0x03,0x43,0x5B,
+0xFE,0xEA,0x10,0x19,0x5A,0xD8,0xA3,0xED,0xE5,0x0E,0x5E,0x79,0xCB,0x02,0x6B,0xAA,
+0xF4,0xD1,0x9D,0xF0,0x08,0x24,0x18,0x96,0x3E,0x0F,0xED,0x2C,0xAB,0x80,0x33,0xD2,
+0x02,0x15,0x0D,0x40,0x07,0x03,0x0B,0x00,0x0A,0x05,0x67,0x00,0xE2,0x03,0x43,0x5B,
+0x00,0xE2,0x03,0x43,0x5B,0xFE,0xEA,0x10,0x4B,0xB3,0xB1,0x49,0x0C,0x66,0x2E,0x69,
+0x0D,0x50,0x97,0x8C,0x51,0x52,0xD0,0xC4,0xF0,0x08,0xDB,0xE5,0x68,0x1A,0xD4,0x2B,
+0xED,0x20,
+};
+#endif
+
+int
+XVIACESS_Process(struct s_reader *reader, ECM_REQUEST *er, uint8_t *cw)
+{
+	uint8_t	*ECM_source = 0;
+	uint8_t	cECMDATAs[512];
+	uint8_t  *ECMDATA_p;
+	void	 	*Issuerp;
+	uint8_t  cFxkey[16];
+	uint16_t D2Nvar;
+	uint32_t prid;
+	uint8_t	AesNr;
+	uint8_t	keyNr;
+//	uint16_t geometry;
+	int16_t	ECM_size;
+	int16_t	DATA_Len;
+	int		provlenn;
+	int		piEA, piMode;
+	int 		ecmBypass;
+	int 	 	bMultiple= 0;
+	int		bSucceed = 0;
+	int		bChTPS;
+	int 	 	existance;
+	int 	 	klenn;
+	int		ix;
+	//
+	//
+	//
+	ECM_source = er->ecm;
+//	ECM_source = tntsat_ecm_tests;
+	//
+	//
+	//
+//	myprdump("Via_ECM", ECM_source, SCT_LEN(ECM_source));
+	DATA_Len = SCT_DATLEN(ECM_source) - 1;
+	ECM_size = DATA_Len;
+	ECM_source += 4;
+	if (ECM_source[0] == 0x80) bMultiple = 1;
+	MYEMU_TRACE("myxviacess:processing{%02X.%d}\n", ECM_source[0], ECM_size);
+
+	do
+	{
+		piMode	 = 0;
+		bChTPS	 = 0;
+		ecmBypass = 0;
+	//	geometry	 = 0x0;
+		D2Nvar 	 = 0x0;
+		AesNr		 = 0x0;
+		if (bMultiple)
+		{
+			if (ECM_size < 0x18) break;
+			DATA_Len = ECM_source[1];
+			ECM_source += 2;
+			ECM_size   -= (DATA_Len + 2);
+		}
+//		myprdump("ECM_source", ECM_source, DATA_Len);
+		if (ECM_source[0] == 0xD2)
+		{
+			ix= ECM_source[1] + 2;
+			if (ECM_source[1] == 0x2)
+			{
+				D2Nvar = b2i(2,&ECM_source[2]);
+				AesNr  = ECM_source[3];
+				MYEMU_TRACE("myxviacess:D2NANO{%04X}.\n", D2Nvar);
+			}
+
+			if (ECM_source[ix]==0x40)
+			{
+				ECM_source += ix;
+			}
+			else
+			if (ECM_source[1] == 0x1 && ECM_source[2] == 0x1)
+			{
+				// CONVERT TPSCRYPT ECM TO VIACCESS ECM WITH XOR TABLE
+				//	DIED.
+				// TPS_CRYPT ECM XOR
+		 		MYEMU_TRACE("myxviacess:TPS\n");
+				xvia1_TPSXOR(&ECM_source[ix], DATA_Len-ix);
+				ECM_source += ix;
+			}
+			DATA_Len -= ix;
+		}
+
+		if ((ECM_source[0] == 0x90 || ECM_source[0] == 0x40) &&
+			 (ECM_source[1] == 0x03 || ECM_source[1] == 0x07))
+		{
+			provlenn = ECM_source[1];
+			if (bMultiple)
+			{
+				if (provlenn == 0x7)
+				{
+				//	geometry = b2i(2,&ECM_source[6]);
+				//	if (ECM_source[8] != 0x00 && ECM_source[8] != 0xff) ecmBypass = 1;
+					if (ECM_source[8] == 0x01) ecmBypass = 1;
+				}
+			}
+		}
+		else
+		{
+			MYEMU_TRACE("myxviacess:VIAID{%02X} UNDEFINED\nn", ECM_source[0]);
+			break;
+		}
+		//------------------------------------------------------------------
+		//------------------------------------------------------------------
+		//------------------------------------------------------------------
+		memcpy(cECMDATAs, ECM_source, DATA_Len);
+		ECMDATA_p = cECMDATAs;
+		ix 		 = ECMDATA_p[1] + 2;
+		prid		 = (uint32_t)(b2i(3,&ECMDATA_p[2]) & 0xFFFFF0);
+		klenn		 = (ECMDATA_p[2]) ? 16 : 8;
+		keyNr 	 = (provlenn == 0x7) ? (ECMDATA_p[5]) : (ECMDATA_p[4] & 0x0f);
+		bChTPS	 = xvia1_IsTPS(prid);
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		if (bChTPS)
+		{
+			// TPS_CHANNEL DIED.
+			MYEMU_TRACE("myxviacess:TPS Died\n");
+		}
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		memset(cFxkey, 0, sizeof(cFxkey));
+		if ((er_KNR == keyNr) && (er_KPRID == prid))
+		{
+			existance = er_KFOUND;
+			if (existance)
+			{
+				memcpy(cFxkey, er_KKEY, klenn);
+				MYEMU_TRACE("myxviacess:K{%06X.%02X, %02X...%02X}\n", prid, keyNr, cFxkey[0], cFxkey[klenn-1]);
+			}
+		}
+		else
+		{
+			er_KNR   	= keyNr;
+			er_KPRID 	= prid;
+			er_KFOUND 	= XEMUKEY_Searchkey(reader, CASS_VIACCESS, prid, keyNr, cFxkey, klenn);
+			existance 	= er_KFOUND;
+			if (existance) memcpy(er_KKEY, cFxkey, klenn);
+		}
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		// -------------------------------------------------------------
+		if (ecmBypass)
+		{
+ 			MYEMU_TRACE("myxviacess:ecm_bypass{%02X}\n", ECM_source[8]);
+		}
+		else
+		if ((Issuerp = xvia3x26_ChkPCIssuers(reader,
+							prid,
+							keyNr,
+							AesNr,
+							(existance) ? cFxkey : NULL)) != 0)
+		{
+			piMode = 1;
+			if (xvia3x26_Algo(prid,
+							Issuerp,
+							keyNr,
+							D2Nvar,
+							ECMDATA_p,
+							DATA_Len,
+							&cw[0],
+							&cw[8]))
+			{
+				bSucceed++;
+				break;
+			}
+		}
+		else
+		if (existance)
+		{
+			piMode = 1;
+			piEA = xvia1_Algo(cFxkey,
+							ECMDATA_p+ix,
+							DATA_Len -ix,
+							&cw[0],
+							&cw[8]);
+			if (piEA)
+			{
+				MYEMU_TRACE("myxviacess:signature oked.\n");
+				bSucceed++;
+				break;
+			}
+			MYEMU_TRACE("myxviacess:signature fail.\n");
+		}
+		ECM_source += DATA_Len;
+	} while (bMultiple);
+
+	if (bSucceed) return 1;
+	if (!piMode)
+	{
+	}
+	return 0;
+}
+
+
+void
+XVIACESS_Cleanup(void)
+{
+	er_KFOUND = 0;
+	er_KNR 	 = 0;
+	er_KPRID	 = 0x0;
+	memset(er_KKEY, 0x0, 16);
+}
+
+#endif	// defined(__XCAS_VIACESS__)
+#endif	// defined(MODULE_XCAS)
+
Index: globals.h
===================================================================
--- globals.h	(revision 10670)
+++ globals.h	(working copy)
@@ -110,7 +110,29 @@
 #ifndef uchar
 typedef unsigned char uchar;
 #endif
-
+//
+//
+// sky(n)
+#ifndef u32
+typedef unsigned int 	u32;
+typedef signed int 		s32;
+#endif
+#ifndef u16
+typedef unsigned short 	u16;
+typedef signed short 	s16;
+#endif
+#ifndef u8
+typedef unsigned char 	u8;
+#endif
+#ifndef FALSE
+#define FALSE		(0)
+#endif
+#ifndef TRUE
+#define TRUE		(!FALSE)
+#endif
+//
+//
+//
 #ifdef IPV6SUPPORT
 #define IN_ADDR_T struct in6_addr
 #define SOCKADDR sockaddr_storage
@@ -122,6 +144,10 @@
 #define ADDR_ANY INADDR_ANY
 #define DEFAULT_AF AF_INET
 #endif
+// sky(n)
+#if defined(WITH_HISILICON)
+#define NO_ENDIAN_H
+#endif
 
 #ifndef NO_ENDIAN_H
 #if defined(__APPLE__)
@@ -145,9 +171,12 @@
  * =========================== */
 // Prevent use of unsafe functions (doesn't work for MacOSX)
 #if !defined(__APPLE__)
+// sky(!)
+#ifndef __ANDROID__
 #define strcpy(a,b) UNSAFE_STRCPY_USE_CS_STRNCPY_INSTEAD()
 #define sprintf(a,...) UNSAFE_SPRINTF_USE_SNPRINTF_INSTEAD()
 #define strtok(a,b,c) UNSAFE_STRTOK_USE_STRTOK_R_INSTEAD()
+#endif
 #define gmtime(a) UNSAFE_GMTIME_NOT_THREADSAFE_USE_CS_GMTIME_R()
 #define localtime(a) UNSAFE_LOCALTIME_NOT_THREADSAFE_USE_LOCALTIME_R()
 #define asctime(a) UNSAFE_ASCTIME_NOT_THREADSAFE_USE_ASCTIME_R()
@@ -227,34 +256,197 @@
 
 //checking if (X) free(X) unneccessary since freeing a null pointer doesnt do anything
 #define NULLFREE(X) {if (X) {void *tmpX=X; X=NULL; free(tmpX); }}
+//######################################################################
+//
+//
+//
+//	#define __HISILICON_MANUFACTORY__
+//
+//
+//
+// 2013.12.04
+// --> env.__HISILICON_MANUFACTORY__
+// #define WEBIF 1
+// #define HAVE_DVBAPI 1
+// #define IRDETO_GUESSING 1
+// #define CS_ANTICASC 1
+// #define WITH_LB 1
+// #define CW_CYCLE_CHECK 1
+// #define MODULE_MONITOR 1
+// #define WITH_CARDREADER 1
+// #define READER_NAGRA 1
+// #define READER_IRDETO 1
+// #define READER_CONAX 1
+// #define READER_CRYPTOWORKS 1
+// #define READER_SECA 1
+// #define READER_VIACCESS 1
+// #define READER_VIDEOGUARD 1
+// #define READER_DRE 1
+// #define READER_TONGFANG 1
+// #define READER_BULCRYPT 1
+// #define READER_GRIFFIN 1
+// #define READER_DGCRYPT 1
+// #define CARDREADER_INTERNAL 1
+// <-- env.__HISILICON_MANUFACTORY__
+#if defined(__HISILICON_MANUFACTORY__)
+	#undef  MODULE_CAMD33
+	#undef  MODULE_CAMD35
+	#undef  MODULE_CAMD35_TCP
+	#undef  MODULE_NEWCAMD
+	#undef  MODULE_XCAS
+	#undef  MODULE_CCCAM
+	#undef  MODULE_CCCSHARE
+	#undef  MODULE_GBOX
+	#undef  MODULE_RADEGAST
+	#undef  MODULE_SERIAL
+	#undef  MODULE_CONSTCW
+	#undef  MODULE_PANDORA
+	#undef  MODULE_GHTTP
+	#undef  MODULE_SCAM
+#endif
+//
+//
+//
+//######################################################################
+// cccam test...
+// standk55.dyndns.org    	port  15800
+// meergott.no-ip.net   	port  12000
+// vestaair.mine.nu   		port   8914
+// gppvserver2.no-ip.net	port   8955
+//
+// saeidelcomx01 najhgodabxd 		## free for your self unlimited
+// saeidelcomx02 gasbxodbnsd  	## one week test
+//
+//
+// newcamd test...
+// spiderweb.selfip.net 33559 John1 John1 01-14
+// spiderweb.selfip.net 33559 John2 John2 01-14
+// spiderweb.selfip.net 33559 John3 John3 01-14
+// spiderweb.selfip.net 33559 John4 John4 01-14
+// spiderweb.selfip.net 33559 John5 John5 01-14
+// spiderweb.selfip.net 33559 John6 John6 01-14
+//######################################################################
+// sky(mgcamd,avatarcamd)
+#if defined(MODULE_NEWCAMD)
+	#define  MODULE_AVAMGCAMD
+#endif
+
+// sky(for debug)
+#if defined(WITH_HISILICON)
+	#define __ADB_TRACE__	0
+	// sky(quad)
+	#if (__ADB_TRACE__==1)
+		#define myprintf(format,args...)			 printf(format,##args)
+		#define mystrace(format,args...)			 printf(format,##args)
+		#define myprdump(s,data,size)				 cs_prdump(s,data,size)
+		#define myascdump(s,data,size)			 cs_ascdump(s,data,size)
+		#define mycs_trace(x,format,args...)	 printf(format"\n",##args)
+		#define mycs_log(format,args...)			 printf(format"\n",##args)
+		#define mycs_debug(x,format,args...)	 printf(format"\n",##args)
+		#define myrdr_log(r,format,args...)		 printf(format"\n",##args)
+		#define myrdr_debug(r,x,format,args...) printf(format"\n",##args)
+		#define myrdr_debug_mask(r,x,format,args...) printf(format"\n",##args)
+	#elif (__ADB_TRACE__==2)
+		#define myprintf(format,args...)			 cs_log(format,##args)
+		#define mystrace(format,args...)			 cs_log(format,##args)
+		#define myprdump(s,data,size)				 cs_prdump(s,data,size)
+		#define myascdump(s,data,size)			 cs_ascdump(s,data,size)
+		#define mycs_trace(x,format,args...)	 cs_log(format,##args)
+		#define mycs_log(format,args...)			 cs_log(format,##args)
+		#define mycs_debug(x,format,args...)	 cs_log_dbg(x,format,##args)
+		#define myrdr_log(r,format,args...)		 rdr_log(r,format,##args)
+		#define myrdr_debug(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+		#define myrdr_debug_mask(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+	#else
+		#define myprintf(format,args...)			 /* none */
+		#define mystrace(format,args...)			 /* none */
+		#define myprdump(s,data,size)				 /* none */
+		#define myascdump(s,data,size)			 /* none */
+		#define mycs_trace(x,format,args...)	 /* cs_log_dbg(x,format,##args) */
+		#define mycs_log(format,args...)			 cs_log(format,##args)
+		#define mycs_debug(x,format,args...)	 cs_log_dbg(x,format,##args)
+		#define myrdr_log(r,format,args...)		 rdr_log(r,format,##args)
+		#define myrdr_debug(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+		#define myrdr_debug_mask(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+	#endif
+#else
+	#define myprintf(format,args...)
+	#define mycs_log(format,args...)
+	#define mycs_debug(x,format,args...)
+	#define mycs_trace(x,format,args...)
+	#define myprdump(x,data,size)
+#endif
 
+//######################################################################
 /* ===========================
  *         constants
  * =========================== */
-#define CS_VERSION    "1.20-unstable_svn"
+#define CS_VERSION				"1.20.sky"	/* "1.20-unstable_svn" */
 #ifndef CS_SVN_VERSION
-#   define CS_SVN_VERSION "test"
+	#define CS_SVN_VERSION 		"0"
 #endif
 #ifndef CS_TARGET
-#   define CS_TARGET "unknown"
+	#define CS_TARGET 			"sky"		/* "unknown" */
 #endif
+
+#if defined(SDK3798C)
+	#define CS_OSCAMDIR			CS_CONFDIR
+#elif defined(SDKV600)
+	#define CS_OSCAMDIR			"/system/oscam"
+#else
+	#define CS_OSCAMDIR			"/system/oscamdata"
+	#define CS_XBMCUSERDIR		"/data/data/org.xbmc.xbmc/cache/apk/assets/userdata/Oscam"
+#endif
+
 #ifndef CS_CONFDIR
+	#if defined(WITH_HISILICON)
+	// /system/Oscam
+	//
+	// usbcopy #cp /mnt/sda/sda1/oscam-1.20 /data/data/org.xbmc.xbmc/cache/apk/assets/userdata
+
+	// #mount -t ext4 -o remount /dev/block/mmcblk0p5 /system
+	// #mount -t ext4 -o remount /dev/block/platform/hi_mci.1/by-name/system /system
+	// #mount -o remount,rw /dev/block/mmcblk0p5 /system
+	//	SD_USER   = /sdcard/Android/data/org.xbmc.xbmc/files/.xbmc/userdata
+	//	SD_USER   = /sdcard/Oscam
+	//	DATA_USER = /data/data/org.xbmc.xbmc/cache/apk/assets/userdata
+	//
+	// // SD_USER(Oscam.sh)
+		#if defined(SDKV600)
+			#define CS_CONFDIR	"/data/oscam"
+		#elif defined(SDKV500)
+			#define CS_CONFDIR	"/sdcard/Oscam"
+		#else
+			#define CS_CONFDIR	"/sdcard/Oscam"
+		#endif
+	#else
 #define CS_CONFDIR    "/usr/local/etc"
 #endif
+#endif
+
 #ifndef CS_LOGFILE
+	#if defined(WITH_HISILICON)
+		#define CS_LOGFILE		"/var/oscam.log"
+	#else
 #define CS_LOGFILE    "/var/log/oscam.log"
 #endif
+#endif
+
 #define CS_QLEN       128 // size of request queue
 #define CS_MAXCAIDTAB 32  // max. caid-defs/user
+#define CS_MAXTUNTAB  			100  	// max. betatunnel mappings
 #define CS_MAXPROV    32
+#define CS_MAXPRFLT    			256
 #define CS_MAXPORTS   32  // max server ports
+#define CS_MAXFILTERS   		16
+#define CS_MAX_CAIDVALUETAB 	16
 #define CS_CLIENT_HASHBUCKETS 32
 
 #define CS_ECMSTORESIZE   16  // use MD5()
 #define CS_EMMSTORESIZE   16  // use MD5()
-#define CS_CLIENT_TIMEOUT 5000
+#define CS_CLIENT_TIMEOUT 		5000	// 5000(sky)
 #define CS_CLIENT_MAXIDLE 120
-#define CS_BIND_TIMEOUT   120
+#define CS_BIND_TIMEOUT   		10		// 120(sky)
 #define CS_DELAY          0
 #define CS_ECM_RINGBUFFER_MAX 0x10 // max size for ECM last responsetimes ringbuffer. Keep this set to power of 2 values!
 
@@ -279,9 +471,11 @@
 #define D_CLIENTECM 0x0400  // Debug Client ECMs
 #define D_CSP       0x0800  // Debug CSP
 #define D_CWC       0x1000  // Debug CWC
+// sky(Add.D_ADB)
+#define D_ADB		 		0x2000  	// Debug myICAM/ADB
+#define D_XCAM		 		(D_ADB)
 #define D_ALL_DUMP  0xFFFF  // dumps all
-
-#define MAX_DEBUG_LEVELS 13
+#define MAX_DEBUG_LEVELS 14
 
 #define R_DB2COM1   0x1 // Reader Dbox2 @ com1
 #define R_DB2COM2   0x2 // Reader Dbox2 @ com1
@@ -289,7 +483,7 @@
 #define R_MP35      0x4 // AD-Teknik Multiprogrammer 3.5 and 3.6 (only usb tested)
 #define R_MOUSE     0x5 // Reader smartcard mouse
 /////////////////// phoenix readers which need baudrate setting and timings need to be guarded by OSCam: BEFORE R_MOUSE
-#define R_INTERNAL  0x6 // Reader smartcard intern
+#define R_INTERNAL  		0x6 		// Reader smartcard internal
 /////////////////// internal readers (Dreambox, Coolstream, IPBox) are all R_INTERNAL, they are determined compile-time
 /////////////////// readers that do not reed baudrate setting and timings are guarded by reader itself (large buffer built in): AFTER R_SMART
 #define R_SMART     0x7 // Smartreader+
@@ -304,6 +498,11 @@
 #define R_CSP       0x26  // Cache CSP
 #define R_GHTTP     0x27  // Reader ghttp
 #define R_SCAM      0x28  // Reader cascading scam
+// sky(n)
+// MODULE_XCAMD/MODULE_MORECAM/MODULE_XCAS
+#define R_XCAS	   		0x40  	// Reader for xcas
+#define R_XCAMD			0x41  	// Reader xcamd
+#define R_MORECAM			0x42  	// Reader morecam
 /////////////////// peer to peer proxy readers after R_CCCAM
 #define R_GBOX      0x30  // Reader cascading gbox
 #define R_CCCAM     0x35  // Reader cascading cccam
@@ -312,9 +512,24 @@
 #define R_IS_NETWORK    0x60
 #define R_IS_CASCADING  0xE0
 
-#define is_network_reader(__X) (__X->typ & R_IS_NETWORK)
-#define is_cascading_reader(__X) (__X->typ & R_IS_CASCADING)
+#define is_network_reader(rdr) 	(rdr && rdr->typ & R_IS_NETWORK)
+#define is_cascading_reader(rdr) (rdr && rdr->typ & R_IS_CASCADING)
 #define is_smargo_reader(__X) (__X->crdr && strcmp(__X->crdr->desc, "smargo") == 0)
+//
+//
+// sky(n)
+#define IS_ICS_READERS(rdr) 		(rdr && (rdr->typ == R_XCAMD || rdr->typ == R_MORECAM))
+#define IS_IKS_READERS(rdr) 		(rdr && (rdr->typ == R_XCAMD))
+#define IS_XCAMD_READERS(rdr) 	(rdr && (rdr->typ == R_XCAMD))
+#define IS_MORECAM_READERS(rdr) 	(rdr && (rdr->typ == R_MORECAM))
+//
+//
+//
+#define IS_NEWCAMD_READERS(rdr) 	(rdr && (rdr->typ == R_NEWCAMD))
+#define IS_CONSTCW_READERS(rdr) 	(rdr && (rdr->typ == R_CONSTCW))
+#define IS_XCAS_READERS(rdr) 		(rdr && (rdr->typ == R_XCAS))
+#define IS_EMU_READERS(rdr) 		(rdr && (rdr->typ == R_XCAS || rdr->typ == R_CONSTCW))
+#define IS_CARD_READER(rdr) 		(rdr && (rdr->typ == R_INTERNAL))
 
 //ECM rc codes:
 #define E_FOUND         0
@@ -332,6 +547,7 @@
 #define E_EXPDATE       11
 #define E_DISABLED  12
 #define E_STOPPED       13 //for selection of error, use <= E_STOPPED and exclude selection of found
+#define E_USELESS			14		// sky(n)
 ///////above is all notfound, some error or problem
 #define E_ALREADY_SENT	101
 #define E_WAITING		102
@@ -362,7 +578,12 @@
 #define LIS_CONSTCW     256
 #define LIS_SERIAL      1024
 #define LIS_CSPUDP      2048
-#define LIS_SCAM        4096
+// sky(n)
+// MODULE_XCAMD/MODULE_MORECAM/MODULE_XCAS
+#define LIS_XCAS			512
+#define LIS_XCAMD			4096
+#define LIS_MORECAM		8192
+#define LIS_SCAM        16384
 
 //EMM types:
 #define UNKNOWN 0
@@ -374,15 +595,49 @@
 #define NCD_524     1
 #define NCD_525     2
 
+#if defined(MODULE_AVAMGCAMD)
+#define NCD_MGCAMD    	1
+#define NCD_AVATARCAMD	2
+#define IS_MGCAMD(x)			((x)==NCD_MGCAMD)
+#define IS_AVATARCAMD(x)	((x)==NCD_AVATARCAMD)
+#define IS_MAVATARCAMD(x)	((x)==NCD_MGCAMD||(x)==NCD_AVATARCAMD)
+#define IS_MAVATAR_READERS(rdr) 	(rdr && (rdr->typ == R_NEWCAMD) && IS_MAVATARCAMD(rdr->ncd_exprotocol))
+#endif
+
 // moved from reader-common.h
 #define UNKNOWN               0
 #define CARD_NEED_INIT        1
 #define CARD_INSERTED         2
 #define CARD_FAILURE          3
 #define NO_CARD               4
-#define READER_DEVICE_ERROR   5
+#define CARD_UNREGISTER 5
+#define READER_DEVICE_ERROR   6
 
+// sky(n)
+#define READERSTATUS_DISABLED		0
+#define READERSTATUS_DISCONNECT	1
+#define READERSTATUS_FAILURE		2
+#define READERSTATUS_OK				3
+#define READERSTATUS_UNKNOWN		9
+#define READERSTATUS_NOTSUPPORT	99
+
+#define SMCSTATUS_NOCARD      	0
+#define SMCSTATUS_INIT 				1
+#define SMCSTATUS_FAILURE   		2
+#define SMCSTATUS_OK  				3
+#define SMCSTATUS_DEACTIVE			8
+#define SMCSTATUS_RESTART			9
+#ifdef HAVE_DVBAPI
+#define DEFAULT_DVBAPI			  	1
+#else
+#define DEFAULT_DVBAPI			  	0
+#endif
 // moved from stats
+// sky(n)
+#define DEFAULT_LOGHISTORYSIZE  		4096 // 8192  /* 4096 */
+#define DEFAULT_MINLOGHISTORYSIZE 	1024
+#define DEFAULT_MAXLOGHISTORYSIZE 	16384
+
 #define DEFAULT_REOPEN_SECONDS 30
 #define DEFAULT_MIN_ECM_COUNT 5
 #define DEFAULT_MAX_ECM_COUNT 500
@@ -409,8 +664,7 @@
 enum {E2_GLOBAL = 0, E2_GROUP, E2_CAID, E2_IDENT, E2_CLASS, E2_CHID, E2_QUEUE, E2_OFFLINE,
 	  E2_SID, E2_CCCAM_NOCARD,
 	  //From here only LB nonblocking events:
-	  E2_CCCAM_NOK1, E2_CCCAM_NOK2, E2_CCCAM_LOOP, E2_WRONG_CHKSUM, E2_RATELIMIT
-	 };
+      	E2_CCCAM_NOK1, E2_CCCAM_NOK2, E2_CCCAM_LOOP, E2_WRONG_CHKSUM, E2_RATELIMIT, E2_XCAS };
 
 #define LB_NONBLOCK_E2_FIRST E2_CCCAM_NOK1
 
@@ -436,6 +690,9 @@
 
 #define AVAIL_CHECK_CONNECTED   0
 #define AVAIL_CHECK_LOADBALANCE 1
+#define AVAIL_CHECK_CHANNEL		2
+#define AVAIL_CHECK_ECM				3
+#define AVAIL_CHECK_EMM				4
 
 #define ECM_FMT_LEN 109 //64
 #define CXM_FMT_LEN 209 // 160
@@ -455,7 +712,8 @@
 
 #define REQUEST_SENT            0x10
 #define REQUEST_ANSWERED        0x20
-
+// sky(n)
+#define REQUEST_BYPASS			(REQUEST_SENT|0x80)
 /* ===========================
  *      Default Values
  * =========================== */
@@ -478,8 +736,9 @@
 
 // Return MPEG section length
 #define SCT_LEN(sct) (3+((sct[1]&0x0f)<<8)+sct[2])
-// Used by readers
-#define MAX_LEN      256
+#define SCT_DATLEN(sct) (  ((sct[1]&0x0f)<<8)+sct[2])
+// (sky)Used by readers
+#define MAX_LEN      	288	/* 256 */
 
 #define NO_CAID_VALUE  0xfffe
 #define NO_SRVID_VALUE 0xfffe
@@ -535,7 +794,52 @@
 	int32_t				cvnum;
 	CAIDVALUETAB_DATA	*cvdata;
 } CAIDVALUETAB;
+//
+//
+// sky(n)
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM) || defined(MODULE_CONSTCW)
+#define CS_MAX_ECMTAB 	16
+typedef struct s_csecmtab
+{
+	int32_t		num;
+	uint16_t		caids	[CS_MAX_ECMTAB];
+	uint32_t		prids	[CS_MAX_ECMTAB];
+} CSECMTAB;
 
+#define CS_MAX_CASTAB 	16
+typedef struct s_cscasets
+{
+	uint16_t		srvid;
+	uint16_t		casid;
+	uint32_t		prid;
+	int32_t		cwjustice;
+	int32_t		ecmcounter;
+} CSCASETS;
+
+typedef struct s_cschsets {
+	uint16_t		muxid;
+	uint16_t		degree;
+	uint16_t		frequency;
+	uint16_t		srvid;
+	uint16_t		vpid;
+	CSECMTAB		castab;
+} CSCHSETS;
+
+typedef struct s_cschannel {
+	uint16_t		muxid;
+	uint16_t		degree;
+	uint16_t		frequency;
+	uint16_t		srvid;
+	uint16_t		vpid;
+	uint16_t		casid;
+	uint32_t		provid;
+	CSECMTAB		castab;
+	uint32_t		adultMovie;
+} CSCHANNEL;
+#endif
+//
+//
+//
 typedef struct s_classtab
 {
 	uchar           an;
@@ -585,8 +889,8 @@
 typedef struct s_filter
 {
 	uint16_t        caid;
-	uchar           nprids;
-	uint32_t        prids[CS_MAXPROV];
+	uint16_t		nprids;
+	uint32_t		prids	[CS_MAXPRFLT];
 } FILTER;
 
 typedef struct s_ftab
@@ -598,7 +902,7 @@
 typedef struct s_ncd_ftab
 {
 	int32_t         nfilts;
-	FILTER          filts[16];
+	FILTER    	filts[CS_MAXFILTERS];
 } NCD_FTAB;
 
 struct ncd_port
@@ -613,12 +917,12 @@
 	int32_t         fd;
 	int32_t         s_port;
 	struct ncd_port *ncd; // newcamd specific settings
-} PORT;
+} PORTTAB;
 
 typedef struct s_ptab
 {
 	int32_t         nports;
-	PORT            ports[CS_MAXPORTS];
+	PORTTAB		ports	[CS_MAXPORTS];
 } PTAB;
 
 typedef struct aes_entry
@@ -706,6 +1010,8 @@
 	uint32_t        class;              // the class needed for some systems
 	time_t          start;              // startdate
 	time_t          end;                // enddate
+	// sky(oscam.smartcard)
+	char			comments[64];
 } S_ENTITLEMENT;
 
 struct s_client ;
@@ -746,6 +1052,11 @@
 	int32_t (*c_cache_push)(struct s_client *, struct ecm_request_t *);         //Cache push
 	int32_t (*c_cache_push_chk)(struct s_client *, struct ecm_request_t *);         //Cache push Node Check, 0=no push
 #endif
+#if defined(MODULE_CONSTCW) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	int32_t			(*c_ChSetting)(struct s_client *, struct ecm_request_t *, int chstages);
+	int32_t			(*c_ChCloser)(struct s_client *, int muxid);
+#endif
+	int32_t			(*c_Cleanup)(struct s_client *);
 	int32_t         c_port;
 	PTAB            ptab;
 	int32_t         num;
@@ -817,6 +1128,7 @@
 {
 	const char      *desc;
 	const uint16_t  *caids;
+	int32_t			caidsvarious;	// sky(a)
 	int32_t (*card_init)(struct s_reader *reader, struct s_ATR *);
 	void    (*card_done)(struct s_reader *reader);
 	int32_t (*card_info)(struct s_reader *);
@@ -831,12 +1143,25 @@
 };
 
 #define MAX_ECM_SIZE 512
+// sky(powervu)
+typedef struct cw_extendted_t
+{
+	uint16_t	type;
+	uint8_t	audio[ 4][16];
+	uint8_t	data [16];
+	uint8_t	vbi  [16];
+	uint16_t	algo;
+	uint16_t	cipher;
+} CWEXTENTION;
 
 typedef struct ecm_request_t
 {
+	uint16_t			dmuxid;	// sky(powervu)
 	uchar           ecm[MAX_ECM_SIZE];
-	uchar           cw[16];
 	uchar           ecmd5[CS_ECMSTORESIZE];
+	uchar				cw[16];
+	CWEXTENTION   	cwEx;	// sky(powervu)
+	int				cwdesalgo;
 	int16_t         ecmlen;
 	uint16_t        caid;
 	uint16_t        ocaid;              //original caid, used for betatunneling
@@ -845,11 +1170,23 @@
 	uint16_t        tsid;
 	uint16_t        pmtpid;
 	uint32_t        ens;                // enigma namespace
-	uint32_t        vpid;               // videopid
-	uint16_t        chid;
+	uint16_t			vpid;			// videopid
+	uint32_t			chid;
 	uint16_t        pid;
 	uint16_t        idx;
 	uint32_t        prid;
+	// sky(n)
+	uint32_t			exprid;
+	bool				ecm_bypass;
+	uint32_t			ecm_crc;
+	bool				ecm_cssolo;
+	bool				ecm_useless;
+	bool				ecm_dongles;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM) || defined(MODULE_XCAS)
+	int16_t			constAfterwards;
+	CSCHSETS			chSets;
+#endif
+
 	struct s_reader *selected_reader;
 	struct s_ecm_answer *matching_rdr;      //list of matching readers
 	const struct s_reader   *fallback;      //fallback is the first fallback reader in the list matching_rdr
@@ -917,11 +1253,11 @@
 struct s_ecm_answer
 {
 	uint8_t         status;
-	struct s_reader *reader;
 	ECM_REQUEST     *er;
 	int8_t          rc;
 	uint8_t     rcEx;
 	uchar           cw[16];
+	CWEXTENTION  	cwEx;	// sky(powervu)
 	char            msglog[MSGLOGSIZE];
 	struct timeb    time_request_sent;  //using for evaluate ecm_time
 	int32_t         ecm_time;
@@ -929,6 +1265,7 @@
 	int32_t     value;
 	int32_t     time;
 #endif
+	struct s_reader 		*reader;
 	struct s_ecm_answer *next;
 	CS_MUTEX_LOCK   ecmanswer_lock;
 	struct s_ecm_answer *pending;
@@ -1051,6 +1388,7 @@
 	int32_t         emmok;              // count EMM ok
 	int32_t         emmnok;             // count EMM nok
 	int8_t          pending;            // number of ECMs pending
+	int8_t			emmsento;			// sky(a)
 #ifdef CS_CACHEEX
 	int32_t         cwcacheexpush;      // count pushed ecms/cws
 	int32_t         cwcacheexgot;       // count got ecms/cws
@@ -1084,6 +1422,18 @@
 	void            *cc;
 #endif
 
+// sky(n)
+#if defined(WITH_HISILICON)
+	uint32_t			frameAcquire;
+#endif
+#if defined(MODULE_CONSTCW) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	uint16_t			ch_ecmsequece;
+	CSCHANNEL		ch_ics;
+#endif
+#if defined(MODULE_XCAS)
+	int32_t			emu_casid;
+#endif
+
 #ifdef MODULE_GBOX
 	void            *gbox;
 	uint16_t	gbox_peer_id;
@@ -1196,7 +1546,7 @@
 	uint16_t        caid;
 	uint32_t        provid;
 	uint16_t        srvid;
-	uint16_t        chid;
+	uint32_t		chid;
 	int32_t         ratelimitecm;
 	int32_t         ratelimittime;
 	int32_t         srvidholdtime;
@@ -1247,6 +1597,32 @@
 	int16_t min;
 	int16_t max;
 };
+// sky(n)
+//
+//
+#define	__LOG_SERVERSECRETE__
+//
+//
+//
+#define	IS_SERVER_EMBEDDED(rdr)		((rdr && rdr->svradr_hidden) ? 1 : 0)
+#define	T_IPEMBEDDED					"127.0.0.1"
+#define	T_PORTEMBEDDED					1234
+#define	T_READER_DEVICES(rdr)		((IS_SERVER_EMBEDDED(rdr)) ? T_IPEMBEDDED   : rdr->device)
+#define	T_READER_RPORTS(rdr)			((IS_SERVER_EMBEDDED(rdr)) ? T_PORTEMBEDDED : rdr->r_port)
+#define	T_READER_LPORTS(rdr)			((IS_SERVER_EMBEDDED(rdr)) ? T_PORTEMBEDDED : rdr->l_port)
+
+enum{
+	TRICOLOR_CENTR,
+	TRICOLOR_CABLETV,
+	TRICOLOR_PHMEDIA,
+	TRICOLOR_SYBERIA,
+	TRICOLOR_PLATFORMAHD,
+	TRICOLOR_NC1,
+	TRICOLOR_TV,
+	TRICOLOR_TVDRE3,
+	TRICOLOR_LYBIDTV,
+	TRICOLOR_UNKNOWN
+};
 
 struct s_reader                                     //contains device info, reader info and card info
 {
@@ -1279,6 +1655,7 @@
 	char            *description;
 #endif
 	char            device[128];
+	int8_t			svradr_hidden;			// sky(xcamd,morecam)
 	uint16_t        slot;                           // in case of multiple slots like sc8in1; first slot = 1
 	int32_t         handle;                         // device handle
 	int64_t         handle_nr;                      // device handle_nr for mutiple readers same driver
@@ -1294,6 +1671,7 @@
 	CAIDTAB         ctab;
 	uint32_t        boxid;
 	int8_t          nagra_read;                     // read nagra ncmed records: 0 Disabled (default), 1 read all records, 2 read valid records only
+	int8_t			nagra_negotiate;
 	uint8_t         boxkey[16];                      // n3 boxkey 8byte, seca sessionkey 16byte
 	int8_t          force_irdeto;
 	uchar           rsa_mod[120];                   // rsa modulus for nagra cards.
@@ -1338,8 +1716,55 @@
 	int8_t          ncd_connect_on_init;
 	int8_t          ncd_disable_server_filt;
 	int8_t          ncd_proto;
+#if defined(MODULE_AVAMGCAMD)
+	int8_t			ncd_exprotocol;
+	uchar				ncd_exkey[5];
+	int8_t			ncd_exregistration;
+#endif
+	uint8_t			ncd_clientmessages[256];
+	char				ncd_version[8];
 	int8_t          currenthops;                    // number of hops (cccam & gbox)
 	int8_t          sh4_stb;                        // to set sh4 type box used to identify sci type.
+
+	// sky(n)
+	int32_t			ch_descramble;
+#if defined(MODULE_XCAS) || defined(MODULE_CONSTCW) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	bool				ics_chMonitor;
+	uint16_t			ics_chRetune;
+	bool				ics_chActivte;
+	bool				ics_chRequired;
+	int32_t			ics_chReplied;
+	int32_t			ics_failure;
+	#if defined(MODULE_XCAMD)
+		int32_t		iks_gateports;
+		char			iks_gateservers[128];
+		int32_t		iks_onebyone;
+		int32_t		iks_cwMaxes;
+		int32_t		iks_cwAssured;
+		CSCASETS		iks_cwCases[CS_MAX_CASTAB];
+		CSCASETS		iks_ecmCas;
+		int32_t		iks_ecmRequired;
+		int32_t		iks_ecmSento;
+//		CSCASETS		iks_auCas;
+		int32_t		iks_emmRequired;
+		time_t		iks_rtocass;
+
+		uint32_t		iks_sccamid;
+		uint16_t		iks_sccasysid;
+
+		uint16_t		xcamd_dongle;
+		uint32_t		xcamd_version;
+		uint32_t		xcamd_svrnum;
+		uint8_t		xcamd_regskey[8];
+		int8_t		xcamd_Adults;
+		uint32_t		xcamd_subscribers;
+	#endif
+	#if defined(MODULE_MORECAM)
+		char			morecam_connid[16+1];
+		char			morecam_userid[20+1];
+	#endif
+#endif
+
 #ifdef MODULE_CCCAM
 	char            cc_version[7];                  // cccam version
 	char            cc_build[7];                    // cccam build number
@@ -1418,6 +1843,10 @@
 	unsigned char   VgFuse;
 	unsigned char	VgCountryC[3];
 	unsigned char   VgRegionC[8];
+#if defined(WITH_HISILICON)
+	int32_t			scinum;
+	int32_t			scideprecated;
+#endif
 #ifdef WITH_LB
 	int32_t         lb_weight;                      //loadbalance weight factor, if unset, weight=100. The higher the value, the higher the usage-possibility
 	int8_t          lb_force_fallback;				//force this reader as fallback if fallback or fallback_percaid paramters set
@@ -1465,6 +1894,10 @@
 	uint8_t		gbox_cccam_reshare;
 	char		last_gsms[128];
 #endif
+// sky(2016,powervu)
+#ifdef MODULE_XCAS
+	uint16_t			powervu_ecmnb[32];
+#endif
 
 #ifdef MODULE_PANDORA
 	uint8_t         pand_send_ecm;
@@ -1473,6 +1906,34 @@
 	uint8_t         ghttp_use_ssl;
 #endif
 	uint8_t cnxlastecm; // == 0 - las ecm has not been paired ecm, > 0 last ecm has been paired ecm
+	int16_t      	rotate;
+	struct s_emm 	*emmcache;
+
+// sky(oscam.smartcard)
+	int8_t			DRE_type; 				// sky
+	int8_t			DRE_cass; 				// sky
+	int8_t			DRE_3s; 					// sky
+	int8_t 			restarting;
+	uint16_t 		acs;
+	char     		country_code[3];		// irdeto country code.
+	char				ascserial[64];
+	uint16_t			cardver;
+//	uint16_t			maturity;
+
+	time_t			start_time;
+	time_t			current_time;
+	time_t			close_time;
+#ifdef XCAMDSERVER_NEWCAMD_CLIENTS
+	uint16_t			set_sid;
+	FTAB				cas_info;
+	uint16_t			work_sid;
+	uint16_t			work_cid;
+	uint32_t			work_ppid;
+	uint32_t			work_crc;
+	uint8_t			ecmdata[512];
+	uint16_t			ecm_cache_count;
+#endif
+
 	LLIST           *emmstat; //emm stats
 	CS_MUTEX_LOCK   emmstat_lock;
 	struct s_reader *next;
@@ -1679,6 +2140,7 @@
 	char            *emmlogdir;
 	char            *logfile;
 	char            *mailfile;
+	int32_t		logsvrsecrete;	// sky(a)
 	uint8_t         logtostdout;
 	uint8_t         logtosyslog;
 	int8_t          logduplicatelines;
@@ -1988,10 +2452,10 @@
 	int16_t         ecmlen;
 } STAT_QUERY;
 
-
+#define MAX_EMM_SIZE 	288
 typedef struct emm_packet_t
 {
-	uchar           emm[258];
+	uchar			emm[MAX_EMM_SIZE];
 	int16_t         emmlen;
 	uchar           caid[2];
 	uchar           provid[4];
@@ -2022,6 +2486,9 @@
 // These are used pretty much everywhere
 extern struct s_config cfg;
 extern uint16_t cs_dblevel;
+extern int32_t 			cs_timefaults;	// sky(a)
+extern bool					g_smartcard_supported;	// sky(sim)
+extern bool					g_factoy_products;	// sky(sim)
 
 #include "oscam-log.h"
 #include "oscam-log-reader.h"
@@ -2044,6 +2511,8 @@
 char *get_servicename_or_null(struct s_client *cl, uint16_t srvid, uint16_t caid, char *buf);
 char *get_tiername(uint16_t tierid, uint16_t caid, char *buf);
 char *get_provider(uint16_t caid, uint32_t provid, char *buf, uint32_t buflen);
+// sky(oscam.smartcard)
+char 	*get_provider_existnace(uint16_t caid, uint32_t provid, char *buf, uint32_t buflen);
 void add_provider(uint16_t caid, uint32_t provid, const char *name, const char *sat, const char *lang);
 bool boxtype_is(const char *boxtype);
 bool boxname_is(const char *boxname);
@@ -2059,6 +2528,11 @@
 static inline bool caid_is_betacrypt(uint16_t caid) { return caid >> 8 == 0x17; }
 static inline bool caid_is_nagra(uint16_t caid) { return caid >> 8 == 0x18; }
 static inline bool caid_is_bulcrypt(uint16_t caid) { return caid == 0x5581 || caid == 0x4AEE; }
+static inline bool caid_is_powervu(uint16_t caid) { return caid >> 8 == 0x0E; } /* sky(powevu) */
+static inline bool caid_is_dvn(uint16_t caid) { return caid == 0x4A30; }
 char *get_cardsystem_desc_by_caid(uint16_t caid);
+// sky(sim)
+bool   chker_smartcard_enable(void);
+bool   chker_factoy_products(void);
 
 #endif
Index: module-anticasc.c
===================================================================
--- module-anticasc.c	(revision 10670)
+++ module-anticasc.c	(working copy)
@@ -82,6 +82,8 @@
 	for(client = first_client; client; client = client->next)
 	{
 		if(client->typ != 'c') { continue; }
+		// sky(2016,powervu)
+		if (!strcmp(client->account->usr, "dvbapi"))  { continue; }
 
 		struct s_acasc *ac_stat = &client->account->ac_stat;
 		struct s_acasc_shm *acasc = &client->acasc;
Index: module-cacheex.c
===================================================================
--- module-cacheex.c	(revision 10670)
+++ module-cacheex.c	(working copy)
@@ -460,6 +460,9 @@
  */
 void cacheex_cache_push(ECM_REQUEST *er)
 {
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (er->ecm_bypass) return;
+#endif
 	if(er->rc >= E_NOTFOUND) { return; }
 
 	//cacheex=2 mode: push (server->remote)
@@ -632,7 +635,8 @@
 	{
 		c = ((er->cw[i] + er->cw[i + 1] + er->cw[i + 2]) & 0xff);
 		null |= (er->cw[i] | er->cw[i + 1] | er->cw[i + 2]);
-		if(er->cw[i + 3] != c)
+		// sky(2016,powervu)
+		if (!er->cwdesalgo && er->cw[i + 3] != c)
 		{
 			cs_log_dump_dbg(D_CACHEEX, er->cw, 16, "push received cw with chksum error from %s", csp ? "csp" : username(cl));
 			cl->cwcacheexerr++;
@@ -831,7 +835,8 @@
 
 
 
-CWCHECK get_cwcheck(ECM_REQUEST *er){
+CWCHECK get_cwcheck(ECM_REQUEST *er)
+{
 	int32_t i;
 	int8_t mode = 0;
 	int16_t counter = 1;
Index: module-camd33.c
===================================================================
--- module-camd33.c	(revision 10670)
+++ module-camd33.c	(working copy)
@@ -44,13 +44,12 @@
 
 	//TODO: just take the first reader in list
 	LL_ITER itr = ll_iter_create(cur_client()->aureader_list);
-	while((rdr = ll_iter_next(&itr)))
-	{
+	while ((rdr = ll_iter_next(&itr))) {
 		aureader = rdr;
 		break;
 	}
 
-	if(!aureader) { return; }
+	if (!aureader) return;
 
 	if(aureader->hexserial[0])
 	{
@@ -151,8 +150,7 @@
 
 static void *camd33_server(struct s_client *UNUSED(client), uchar *mbuf, int32_t n)
 {
-	switch(mbuf[0])
-	{
+	switch (mbuf[0]) {
 	case 2:
 		camd33_process_ecm(mbuf, n);
 		break;
Index: module-cccam-cacheex.c
===================================================================
--- module-cccam-cacheex.c	(revision 10670)
+++ module-cccam-cacheex.c	(working copy)
@@ -265,8 +265,13 @@
 		cs_log_dbg(D_CWC, "CWC (CE) push to %s cycletime: %isek - nextcwcycle: CW%i for %04X:%06X:%04X", username(cl), er->cwc_cycletime, er->cwc_next_cw_cycle, er->caid, er->prid, er->srvid);
 	}
 
+	// sky(dvn) /* tableid:0x50 */
+	if (caid_is_dvn(er->caid)) {
+		buf[19] = er->ecm[0];
+	}
+	else {
 	buf[19] = er->ecm[0] != 0x80 && er->ecm[0] != 0x81 ? 0 : er->ecm[0];
-
+	}
 	uint8_t *ofs = buf + 20;
 
 	//write oscam ecmd5:
@@ -335,7 +340,13 @@
 	er->caid = b2i(2, buf + 0);
 	er->prid = b2i(4, buf + 2);
 	er->srvid = b2i(2, buf + 10);
-	er->ecm[0] = buf[19]!=0x80 && buf[19]!=0x81 ? 0 : buf[19]; //odd/even byte, usefull to send it over CSP and to check cw for swapping
+	// sky(dvn) /* tableid:0x50 */
+	if (caid_is_dvn(er->caid)) {
+		er->ecm[0] = buf[19];
+	}
+	else {
+		er->ecm[0] = (buf[19] != 0x80 && buf[19] != 0x81) ? 0 : buf[19]; //odd/even byte, usefull to send it over CSP and to check cw for swapping
+	}
 	er->rc = rc;
 
 	er->ecmlen = 0;
Index: module-cccam-data.h
===================================================================
--- module-cccam-data.h	(revision 10670)
+++ module-cccam-data.h	(working copy)
@@ -34,13 +34,11 @@
 
 #define HOP_RATING 5
 
-typedef enum
-{
+typedef enum {
 	DECRYPT, ENCRYPT
 } cc_crypt_mode_t;
 
-typedef enum
-{
+typedef enum {
 	MSG_CLI_DATA = 0,
 	MSG_CW_ECM = 1,
 	MSG_EMM_ACK = 2,
@@ -63,37 +61,32 @@
 	MSG_NO_HEADER = 0xffff
 } cc_msg_type_t;
 
-struct cc_crypt_block
-{
+struct cc_crypt_block {
 	uint8_t keytable[256];
 	uint8_t state;
 	uint8_t counter;
 	uint8_t sum;
 };
 
-struct cc_srvid
-{
+struct cc_srvid {
 	uint16_t sid;
 	uint16_t chid;
 	uint8_t ecmlen;
 };
 
-struct cc_srvid_block
-{
+struct cc_srvid_block {
 	uint16_t sid;
 	uint16_t chid;
 	uint8_t  ecmlen;
 	time_t   blocked_till;
 };
 
-struct cc_provider
-{
+struct cc_provider {
 	uint32_t prov;  //provider
 	uint8_t sa[4]; //shared address
 };
 
-typedef enum
-{
+typedef enum {
 	CT_LOCALCARD = 1,
 	CT_CARD_BY_SERVICE_READER = 2,
 	CT_CARD_BY_SERVICE_USER = 3,
@@ -103,8 +96,7 @@
 	CT_REMOTECARD = 10
 } cc_card_type;
 
-struct cc_card
-{
+struct cc_card {
 	uint32_t id; // cccam card (share) id - reader
 	uint32_t remote_id;
 	uint16_t caid;
@@ -128,8 +120,7 @@
 	int8_t rating;
 };
 
-typedef enum
-{
+typedef enum {
 	MODE_UNKNOWN = 0,
 	MODE_PLAIN = 1,
 	MODE_AES = 2,
@@ -138,8 +129,7 @@
 	MODE_LEN0 = 5,
 } cc_cmd05_mode;
 
-typedef enum
-{
+typedef enum {
 	MODE_CMD_0x0C_NONE = 0,
 	MODE_CMD_0x0C_RC6 = 1,
 	MODE_CMD_0x0C_RC4 = 2,
@@ -149,8 +139,7 @@
 } cc_cmd0c_mode;
 
 
-struct cc_extended_ecm_idx
-{
+struct cc_extended_ecm_idx {
 	uint8_t send_idx;
 	uint16_t ecm_idx;
 	struct cc_card *card;
@@ -160,8 +149,7 @@
 	uint32_t cccam_id;
 };
 
-struct cc_data
-{
+struct cc_data {
 	uint8_t g_flag;
 	char *prefix;
 
Index: module-cccam.c
===================================================================
--- module-cccam.c	(revision 10670)
+++ module-cccam.c	(working copy)
@@ -171,13 +171,11 @@
 
 	switch(cc->cmd0c_mode)
 	{
-	case MODE_CMD_0x0C_NONE:   // none additional encryption
-	{
+		case MODE_CMD_0x0C_NONE: { // none additional encryption
 		memcpy(out, buf, len);
 		break;
 	}
-	case MODE_CMD_0x0C_RC6 :   //RC6
-	{
+		case MODE_CMD_0x0C_RC6 : { //RC6
 		// buf may be unaligned, 
 		// so we use malloc() memory for the uint32_t* cast
 		uint8_t *tmp;
@@ -194,42 +192,36 @@
 		NULLFREE(tmp);
 		break;
 	}
-	case MODE_CMD_0x0C_RC4:   // RC4
-	{
+		case MODE_CMD_0x0C_RC4: { // RC4
 		cc_rc4_crypt(&cc->cmd0c_cryptkey, buf, len, ENCRYPT);
 		memcpy(out, buf, len);
 		break;
 	}
-	case MODE_CMD_0x0C_CC_CRYPT:   // cc_crypt
-	{
+		case MODE_CMD_0x0C_CC_CRYPT: { // cc_crypt
 		cc_crypt(&cc->cmd0c_cryptkey, buf, len, DECRYPT);
 		memcpy(out, buf, len);
 		break;
 	}
-	case MODE_CMD_0x0C_AES:   // AES
-	{
+		case MODE_CMD_0x0C_AES: { // AES
 		int32_t i;
 		for(i = 0; i < len / 16; i++)
 			AES_decrypt((unsigned char *) buf + i * 16,
 						(unsigned char *) out + i * 16, &cc->cmd0c_AES_key);
 		break;
 	}
-	case MODE_CMD_0x0C_IDEA :   //IDEA
-	{
+		case MODE_CMD_0x0C_IDEA : { //IDEA
 		int32_t i = 0;
 		int32_t j;
 
-		while(i < len)
-		{
+			while (i < len) {
 			idea_ecb_encrypt(buf + i, out + i, &cc->cmd0c_IDEA_dkey);
 			i += 8;
 		}
 
 		i = 8;
-		while(i < len)
-		{
+			while (i < len) {
 			for(j = 0; j < 8; j++)
-				{ out[j + i] ^= buf[j + i - 8]; }
+					out[j+i] ^= buf[j+i-8];
 			i += 8;
 		}
 
@@ -250,40 +242,34 @@
 	memset(&key_buf, 0, sizeof(key_buf));
 
 	if(len > 32)
-		{ len = 32; }
+		len = 32;
 
 	memcpy(key_buf, key, len);
 
-	switch(cc->cmd0c_mode)
-	{
+	switch (cc->cmd0c_mode) {
 
-	case MODE_CMD_0x0C_NONE :   //NONE
-	{
+		case MODE_CMD_0x0C_NONE : { 	//NONE
 		break;
 	}
 
-	case MODE_CMD_0x0C_RC6 :   //RC6
-	{
+		case MODE_CMD_0x0C_RC6 : { 	//RC6
 		rc6_key_setup(key_buf, 32, cc->cmd0c_RC6_cryptkey);
 		break;
 	}
 
 	case MODE_CMD_0x0C_RC4:  //RC4
-	case MODE_CMD_0x0C_CC_CRYPT:   //CC_CRYPT
-	{
+		case MODE_CMD_0x0C_CC_CRYPT: {//CC_CRYPT
 		cc_init_crypt(&cc->cmd0c_cryptkey, key_buf, 32);
 		break;
 	}
 
-	case MODE_CMD_0x0C_AES:   //AES
-	{
+		case MODE_CMD_0x0C_AES: { 		//AES
 		memset(&cc->cmd0c_AES_key, 0, sizeof(cc->cmd0c_AES_key));
 		AES_set_decrypt_key((unsigned char *) key_buf, 256, &cc->cmd0c_AES_key);
 		break;
 	}
 
-	case MODE_CMD_0x0C_IDEA :   //IDEA
-	{
+		case MODE_CMD_0x0C_IDEA : { 	//IDEA
 		uint8_t key_buf_idea[16];
 		memcpy(key_buf_idea, key_buf, 16);
 		IDEA_KEY_SCHEDULE ekey;
@@ -418,20 +404,19 @@
 {
 	struct s_reader *rdr = cl->reader;
 	struct cc_data *cc = cl->cc;
-	if(!rdr || !cc)
-		{ return; }
+	if (!rdr || !cc) return;
 
-	if(rdr) { rdr->tcp_connected = 0; }
-	if(rdr) { rdr->card_status = NO_CARD; }
-	if(rdr) { rdr->last_s = rdr->last_g = 0; }
-	if(cl) { cl->last = 0; }
+	if (rdr) rdr->tcp_connected = 0;
+	if (rdr) rdr->card_status = NO_CARD;
+	if (rdr) rdr->last_s = rdr->last_g = 0;
+	if (cl)  cl->last = 0;
 
 	if(call_conclose)  //clears also pending ecms!
-		{ network_tcp_connection_close(rdr, "close"); }
+		network_tcp_connection_close(rdr, "close");
 	else
 	{
-		if(cl->udp_fd)
-		{
+		if (cl->udp_fd) {
+			shutdown(cl->udp_fd, SHUT_RDWR); /* sky */
 			close(cl->udp_fd);
 			cl->udp_fd = 0;
 			cl->pfd = 0;
@@ -529,17 +514,14 @@
 	LL_ITER it = ll_iter_create(cc->extended_ecm_idx);
 	while((eei = ll_iter_next(&it)))
 	{
-		if(eei->card == card)
-		{
-			if(null_only)
-			{
+		if (eei->card == card) {
+			if (null_only) {
 				cc_reset_pending(cl, eei->ecm_idx);
 				if(eei->free_card)
 					{ NULLFREE(eei->card); }
 				ll_iter_remove_data(&it);
 			}
-			else
-			{
+			else {
 				if(eei->free_card)
 					{ NULLFREE(eei->card); }
 				eei->card = NULL;
@@ -571,22 +553,21 @@
 		pfd.events = POLLIN | POLLPRI;
 
 		rc = poll(&pfd, 1, cfg.cc_recv_timeout);
-
-		if(rc < 0)
-		{
-			if(errno == EINTR) { continue; }
+		if (rc < 0) {
+			if (errno==EINTR) continue;
+//			cs_log("cc_recv_to(%d,%s)..", errno, strerror(errno));
 			return (-1); //error!!
 		}
 
-		if(rc == 1)
-		{
-			if(pfd.revents & POLLHUP)
-				{ return (-1); } //hangup = error!!
-			else
-				{ break; }
+		if (rc == 1) {
+			if (pfd.revents & POLLHUP) {
+				return (-1); //hangup = error!!
+			}
+			else break;
+		}
+		else {
+			return (-2); //timeout!!
 		}
-		else
-			{ return (-2); } //timeout!!
 	}
 	return recv(cl->udp_fd, buf, len, MSG_WAITALL);
 }
@@ -636,8 +617,7 @@
 
 	len = recv(handle, buf, 4, MSG_WAITALL);
 
-	if(len != 4)    // invalid header length read
-	{
+	if (len != 4) { // invalid header length read
 		if(len <= 0)
 			{ cs_log_dbg(cl->typ == 'c' ? D_CLIENT : D_READER, "%s disconnected by remote server", getprefix()); }
 		else
@@ -694,38 +674,36 @@
 int32_t cc_cmd_send(struct s_client *cl, uint8_t *buf, int32_t len, cc_msg_type_t cmd)
 {
 	if(!cl->udp_fd)  //disconnected
-		{ return -1; }
+		return -1;
 
 	struct s_reader *rdr = (cl->typ == 'c') ? NULL : cl->reader;
 
 	int32_t n;
 	struct cc_data *cc = cl->cc;
 
-	if(!cl->cc || cl->kill) { return -1; }
+	if (!cl->cc || cl->kill) return -1;
 	cs_writelock(&cc->lockcmd);
-	if(!cl->cc || cl->kill)
-	{
+	if (!cl->cc || cl->kill) {
 		cs_writeunlock(&cc->lockcmd);
 		return -1;
 	}
 
 	uint8_t *netbuf;
-	if(!cs_malloc(&netbuf, len + 4))
-		{ return -1; }
-
-	if(cmd == MSG_NO_HEADER)
-	{
+	if (!cs_malloc(&netbuf, len + 4)) {
+		cs_writeunlock(&cc->lockcmd); // sky(a)
+		return -1;
+	}
+  	if (cmd == MSG_NO_HEADER) {
 		memcpy(netbuf, buf, len);
 	}
-	else
-	{
+	else {
 		// build command message
 		netbuf[0] = cc->g_flag; // flags??
 		netbuf[1] = cmd & 0xff;
 		netbuf[2] = len >> 8;
 		netbuf[3] = len & 0xff;
 		if(buf)
-			{ memcpy(netbuf + 4, buf, len); }
+			memcpy(netbuf + 4, buf, len);
 		len += 4;
 	}
 
@@ -733,19 +711,17 @@
 	cc_crypt(&cc->block[ENCRYPT], netbuf, len, ENCRYPT);
 
 	n = send(cl->udp_fd, netbuf, len, 0);
-	if(rdr) { rdr->last_s = time(NULL); }
-	if(cl) { cl->last = time(NULL); }
+	if (rdr) rdr->last_s = time(NULL);
+	if (cl) cl->last = time(NULL);
 
 	cs_writeunlock(&cc->lockcmd);
 
 	NULLFREE(netbuf);
 
-	if(n != len)
-	{
+	if (n != len) {
 		if(rdr)
-			{ cc_cli_close(cl, 1); }
-		else
-		{
+			cc_cli_close(cl, 1);
+		else {
 			cs_writeunlock(&cc->cards_busy);
 			cs_disconnect_client(cl);
 		}
@@ -770,18 +746,15 @@
 	int32_t i;
 	for(i = 0; i < CC_VERSIONS; i++)
 	{
-		if(!memcmp(cc_version, version[i], strlen(version[i])))
-		{
+		if (!memcmp(cc_version, version[i], strlen(version[i]))) {
 			memcpy(cc_build, build[i], strlen(build[i]) + 1);
 			cs_log_dbg(D_CLIENT, "cccam: auto build set for version: %s build: %s",
 						  cc_version, cc_build);
 			return;
 		}
 	}
-	memcpy(cc_version, version[CC_DEFAULT_VERSION], strlen(
-			   version[CC_DEFAULT_VERSION]));
-	memcpy(cc_build, build[CC_DEFAULT_VERSION], strlen(
-			   build[CC_DEFAULT_VERSION]));
+	memcpy(cc_version, version[CC_DEFAULT_VERSION], strlen(version[CC_DEFAULT_VERSION]));
+	memcpy(cc_build, build[CC_DEFAULT_VERSION], strlen(build[CC_DEFAULT_VERSION]));
 
 	cs_log_dbg(D_CLIENT, "cccam: auto version set: %s build: %s", cc_version, cc_build);
 
@@ -792,21 +765,17 @@
 {
 	int32_t res = 0;
 	int32_t i = 0;
-	for(i = 0; i < CC_VERSIONS; i++)
-	{
-		if(!strcmp(cfg.cc_version, version[i]))
-		{
+	for (i = 0; i < CC_VERSIONS; i++) {
+		if (!strcmp(cfg.cc_version, version[i])) {
 			res += extcompat[i];
 			break;
 		}
 	}
 	if(!res)
-		{ return 0; }
+		return 0;
 
-	for(i = 0; i < CC_VERSIONS; i++)
-	{
-		if(!strcmp(cc->remote_version, version[i]))
-		{
+	for (i = 0; i < CC_VERSIONS; i++) {
+		if (!strcmp(cc->remote_version, version[i])) {
 			res += extcompat[i];
 			break;
 		}
@@ -879,11 +848,11 @@
 int32_t loop_check(uint8_t *myid, struct s_client *cl)
 {
 	if(!cl)
-		{ return 0; }
+		return 0;
 
 	struct cc_data *cc = cl->cc;
 	if(!cc)
-		{ return 0; }
+		return 0;
 
 	return !memcmp(myid, cc->peer_node_id, sizeof(cc->peer_node_id)); // same nodeid? ignore
 }
@@ -908,7 +877,7 @@
 		er = &cl->ecmtask[i];
 		if((comp_timeb(&t, &er->tps) >= diff) && (er->rc >= E_NOCARD))  // drop timeouts
 		{
-			write_ecm_answer(cl->reader, er, E_TIMEOUT, 0, NULL, NULL);
+			write_ecm_answer(cl->reader, er, E_TIMEOUT, 0, NULL, NULL, NULL);
 		}
 
 		else if(er->rc >= E_NOCARD && er->rc <= E_UNHANDLED)    // stil active and waiting
@@ -918,7 +887,7 @@
 			{
 				cs_log_dbg(D_READER, "%s ecm loop detected! client %s (%8lX)",
 							  getprefix(), er->client->account->usr, (unsigned long)er->client->thread);
-				write_ecm_answer(cl->reader, er, E_NOTFOUND, E2_CCCAM_LOOP, NULL, NULL);
+				write_ecm_answer(cl->reader, er, E_NOTFOUND, E2_CCCAM_LOOP, NULL, NULL, NULL);
 			}
 			else
 				// search for the ecm with the lowest time, this should be the next to go
@@ -926,8 +895,7 @@
 				{
 
 					//check for already pending:
-					if(cc && cc->extended_mode)
-					{
+				if (cc && cc->extended_mode) {
 						int32_t j, found;
 						ECM_REQUEST *erx;
 						for(found = j = 0; j < cfg.max_pending; j++)
@@ -935,20 +903,17 @@
 							erx = &cl->ecmtask[j];
 							if(i != j && erx->rc == E_ALREADY_SENT &&
 									er->caid == erx->caid &&
-									er->ecmd5 == erx->ecmd5)
-							{
+							er->ecmd5==erx->ecmd5) {
 								found = 1;
 								break;
 							}
 						}
-						if(!found)
-						{
+					if (!found) {
 							n = i;
 							ern = er;
 						}
 					}
-					else
-					{
+				else {
 						n = i;
 						ern = er;
 					}
@@ -966,36 +931,30 @@
 {
 	struct cc_data *cc = cl->cc;
 	if(!cc->cmd05_active || cc->ecm_busy)  //exit if not in cmd05 or waiting for ECM answer
-		{ return 0; }
+		return 0;
 
 	cc->cmd05_active--;
 	if(cc->cmd05_active)
-		{ return 0; }
+		return 0;
 
 	uint8_t *data = cc->cmd05_data;
 	cc_cmd05_mode cmd05_mode = MODE_UNKNOWN;
 
 	// by Project:Keynation
-	switch(cc->cmd05_data_len)
-	{
-	case 0:   //payload 0, return with payload 0!
-	{
+	switch (cc->cmd05_data_len) {
+		case 0: { //payload 0, return with payload 0!
 		cc_cmd_send(cl, NULL, 0, MSG_CMD_05);
 		cmd05_mode = MODE_LEN0;
 		break;
 	}
-	case 256:
-	{
+		case 256: {
 		cmd05_mode = cc->cmd05_mode;
-		switch(cmd05_mode)
-		{
-		case MODE_PLAIN:   //Send plain unencrypted back
-		{
+			switch (cmd05_mode) {
+			case MODE_PLAIN: { 	//Send plain unencrypted back
 			cc_cmd_send(cl, data, 256, MSG_CMD_05);
 			break;
 		}
-		case MODE_AES:   //encrypt with received aes128 key:
-		{
+			case MODE_AES: { 		//encrypt with received aes128 key:
 			AES_KEY key;
 			uint8_t aeskey[16];
 			uint8_t out[256];
@@ -1012,14 +971,12 @@
 			cc_cmd_send(cl, out, 256, MSG_CMD_05);
 			break;
 		}
-		case MODE_CC_CRYPT:   //encrypt with cc_crypt:
-		{
+			case MODE_CC_CRYPT: { //encrypt with cc_crypt:
 			cc_crypt(&cc->cmd05_cryptkey, data, 256, ENCRYPT);
 			cc_cmd_send(cl, data, 256, MSG_CMD_05);
 			break;
 		}
-		case MODE_RC4_CRYPT:  //special xor crypt:
-		{
+			case MODE_RC4_CRYPT: {//special xor crypt:
 			cc_rc4_crypt(&cc->cmd05_cryptkey, data, 256, DECRYPT);
 			cc_cmd_send(cl, data, 256, MSG_CMD_05);
 			break;
@@ -1031,14 +988,13 @@
 	}
 	default:
 		cmd05_mode = MODE_UNKNOWN;
+			break;
 	}
 
 	//unhandled types always needs cycle connection after 50 ECMs!!
-	if(cmd05_mode == MODE_UNKNOWN)
-	{
+	if (cmd05_mode == MODE_UNKNOWN) {
 		cc_cmd_send(cl, NULL, 0, MSG_CMD_05);
-		if(!cc->max_ecms)    //max_ecms already set?
-		{
+		if (!cc->max_ecms) { //max_ecms already set?
 			cc->max_ecms = 50;
 			cc->ecm_counter = 0;
 		}
@@ -1053,8 +1009,7 @@
 int32_t get_UA_ofs(uint16_t caid)
 {
 	int32_t ofs = 0;
-	switch(caid >> 8)
-	{
+	switch (caid >> 8) {
 	case 0x05: //VIACCESS:
 	case 0x0D: //CRYPTOWORKS:
 		ofs = 1;
@@ -1078,7 +1033,7 @@
 {
 	int32_t i, len = 0;
 	for(i = 0; i < 8; i++)
-		if(ua[i]) { len++; }
+		if (ua[i]) len++;
 	return len;
 }
 void UA_left(uint8_t *in, uint8_t *out, int32_t ofs)
@@ -1094,7 +1049,7 @@
 	{
 		memcpy(out + ofs, in, len);
 		len--;
-		if(out[len]) { break; }
+		if (out[len]) break;
 		ofs++;
 		out[0] = 0;
 	}
@@ -1224,7 +1179,7 @@
 
 			p++;
 			rdr->nprov = p;
-			if(p >= CS_MAXPROV) { break; }
+			if (p >= CS_MAXPROV) break;
 		}
 	}
 
@@ -1244,9 +1199,9 @@
 	uint8_t *node1 = ll_has_elements(card1->remote_nodes);
 	uint8_t *node2 = ll_has_elements(card2->remote_nodes);
 
-	if(!node1 && !node2) { return 1; }  //both NULL, same!
+	if (!node1 && !node2) return 1; //both NULL, same!
 
-	if(!node1 || !node2) { return 0; }  //one NULL, not same!
+	if (!node1 || !node2) return 0; //one NULL, not same!
 
 	return !memcmp(node1, node2, 8); //same?
 }
@@ -1338,10 +1293,8 @@
 				{ xcard = ncard; } //remember card (D+ / 1810 fix) if request has no provider, but card has
 
 			rating = ncard->rating - ncard->hop * HOP_RATING;
-			if(rating < MIN_RATING)
-				{ rating = MIN_RATING; }
-			else if(rating > MAX_RATING)
-				{ rating = MAX_RATING; }
+			if (rating < MIN_RATING) rating = MIN_RATING;
+			else if (rating > MAX_RATING) rating = MAX_RATING;
 
 			if(!ll_count(ncard->providers))    //card has no providers:
 			{
@@ -1359,7 +1312,8 @@
 				struct cc_provider *provider;
 				while((provider = ll_iter_next(&it2)))
 				{
-					if(!cur_er->prid || (provider->prov == cur_er->prid))    // provid matches
+					// sky(chinese,20160429)
+					if (!provider->prov || !cur_er->prid || (provider->prov == cur_er->prid)) // provid matches
 					{
 						if(rating  > best_rating)
 						{
@@ -1408,15 +1362,13 @@
 	struct timeb timeout;
 	struct timeb cur_time;
 
-	if(!cc || !cc->ecm_busy)
-		{ return 0; }
+	if (!cc || !cc->ecm_busy) return 0;
 
 	cs_ftime(&cur_time);
 
 	timeout = cc->ecm_time;
 	int32_t tt = rdr->cc_reconnect;
-	if(tt <= 0)
-		{ tt = DEFAULT_CC_RECONNECT; }
+	if (tt<=0) tt = DEFAULT_CC_RECONNECT;
 
 	add_ms_to_timeb(&timeout, tt);
 	return (comp_timeb(&cur_time, &timeout) >= 0);
@@ -1434,9 +1386,9 @@
 	if(!rdr->tcp_connected)
 		{ cc_cli_connect(cl); }
 
-	int32_t n;
 	struct cc_data *cc = cl->cc;
 	struct cc_card *card = NULL;
+	int32_t n;
 	LL_ITER it;
 	ECM_REQUEST *cur_er;
 	struct timeb cur_time;
@@ -1444,25 +1396,22 @@
 
 	if(!cc || (cl->pfd < 1) || !rdr->tcp_connected)
 	{
-		if(er)
-		{
+		if (er) {
 			cs_log_dbg(D_READER, "%s server not init! ccinit=%d pfd=%d",
 						  rdr->label, cc ? 1 : 0, cl->pfd);
-			write_ecm_answer(rdr, er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL);
+			write_ecm_answer(rdr, er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL, NULL);
 		}
 		//cc_cli_close(cl);
 		return 0;
 	}
 
-	if(rdr->tcp_connected != 2)
-	{
+	if (rdr->tcp_connected != 2) {
 		cs_log_dbg(D_READER, "%s Waiting for CARDS", getprefix());
 		return 0;
 	}
 
 	//No Card? Waiting for shares
-	if(!ll_has_elements(cc->cards))
-	{
+	if (!ll_has_elements(cc->cards)) {
 		cs_log_dbg(D_READER, "%s NO CARDS!", getprefix());
 		return 0;
 	}
@@ -1480,9 +1429,9 @@
 						  getprefix());
 
 			if(!cc_request_timeout(cl))
-				{ return 0; } //pending send...
+				return 0; //pending send...
 			if(!cc_cycle_connection(cl))
-				{ return 0; }
+				return 0;
 		}
 		cc->ecm_busy = 1;
 		cs_log_dbg(D_READER, "cccam: ecm trylock: got lock");
@@ -1495,18 +1444,17 @@
 		//Search next ECM to send:
 		if((n = cc_get_nxt_ecm(cl)) < 0)
 		{
-			if(!cc->extended_mode)
-			{
+			if (!cc->extended_mode) {
 				cc->ecm_busy = 0;
 			}
 			cs_log_dbg(D_READER, "%s no ecm pending!", getprefix());
 			if(!cc_send_pending_emms(cl))
-				{ send_cmd05_answer(cl); }
+				send_cmd05_answer(cl);
 			return 0; // no queued ecms
 		}
 		cur_er = &cl->ecmtask[n];
 		cur_er->rc = E_ALREADY_SENT; //mark ECM as already send
-		cs_log_dbg(D_READER, "cccam: ecm-task %d", cur_er->idx);
+		cs_log_dbg(D_READER, "cccam: ecm-task %d{%04x.%04x,%d)", cur_er->idx, cur_er->caid, cur_er->pid, cur_er->srvid);
 
 		//sleepsend support:
 		static const char *typtext[] = { "ok", "invalid", "sleeping" };
@@ -1516,17 +1464,14 @@
 			if(cur_er->srvid == cl->lastsrvid && cur_er->caid == cl->lastcaid
 					&& cur_er->pid == cl->lastpid)
 			{
-				cs_log(
-					"%s is stopped - requested by server (%s)", cl->reader->label, typtext[cl->stopped]);
-				if(!cc->extended_mode)
-				{
+				cs_log("%s is stopped - requested by server (%s)", cl->reader->label, typtext[cl->stopped]);
+				if (!cc->extended_mode) {
 					cc->ecm_busy = 0;
 				}
-				write_ecm_answer(rdr, cur_er, E_STOPPED, 0, NULL, NULL);
+				write_ecm_answer(rdr, cur_er, E_STOPPED, 0, NULL, NULL, NULL);
 				return 0;
 			}
-			else
-			{
+			else {
 				cl->stopped = 0;
 			}
 		}
@@ -1536,8 +1481,7 @@
 		cl->lastpid = cur_er->pid;
 		//sleepsend support end
 
-		if(buf)
-			{ memcpy(buf, cur_er->ecm, cur_er->ecmlen); }
+		if (buf) memcpy(buf, cur_er->ecm, cur_er->ecmlen);
 
 		struct cc_srvid cur_srvid;
 		cur_srvid.sid = cur_er->srvid;
@@ -1554,9 +1498,9 @@
 			struct cc_card *ncard;
 			while((ncard = ll_iter_next(&it)))
 			{
-				if(ncard == cur_er->origin_card)    //Search the origin card
-				{
+				if (ncard == cur_er->origin_card) { // Search the origin card
 					card = ncard; //found it, use it!
+					myprintf("mycccam:card found it\n");
 					break;
 				}
 			}
@@ -1567,9 +1511,7 @@
 			reopen_sids(cc, 0, cur_er, &cur_srvid);
 			card = get_matching_card(cl, cur_er, 0);
 		}
-
-		if(!card && has_srvid(rdr->client, cur_er))
-		{
+		if (!card && has_srvid(rdr->client, cur_er)) {
 			reopen_sids(cc, 1, cur_er, &cur_srvid);
 			card = get_matching_card(cl, cur_er, 0);
 		}
@@ -1577,8 +1519,7 @@
 		if(card)
 		{
 			uint8_t *ecmbuf;
-			if(!cs_malloc(&ecmbuf, cur_er->ecmlen + 13))
-				{ break; }
+			if (!cs_malloc(&ecmbuf, cur_er->ecmlen + 13)) break;
 
 			// build ecm message
 			ecmbuf[0] = cur_er->caid >> 8;
@@ -1597,28 +1538,24 @@
 			memcpy(ecmbuf + 13, cur_er->ecm, cur_er->ecmlen);
 
 			uint8_t send_idx = 1;
-			if(cc->extended_mode)
-			{
+			if (cc->extended_mode) {
 				cc->server_ecm_idx++;
 				if(cc->server_ecm_idx >= 256)
-					{ cc->server_ecm_idx = 1; }
+					cc->server_ecm_idx = 1;
 				cc->g_flag = cc->server_ecm_idx; //Flag is used as index!
 				send_idx = cc->g_flag;
 			}
 
 			struct cc_extended_ecm_idx *eei = get_extended_ecm_idx(cl, send_idx, 0);
-			if(eei)
-			{
+			if (eei) {
 				eei->ecm_idx = cur_er->idx;
 				eei->card = card;
 				eei->cccam_id = card->id;
 				eei->srvid = cur_srvid;
 			}
-			else
-			{
+			else {
 				eei = add_extended_ecm_idx(cl, send_idx, cur_er->idx, card, cur_srvid, 0);
-				if(!eei)
-				{
+				if (!eei) {
 					NULLFREE(ecmbuf);
 					cs_readunlock(&cc->cards_busy);
 					break;
@@ -1641,8 +1578,7 @@
 			cs_readunlock(&cc->cards_busy);
 
 			processed_ecms++;
-			if(cc->extended_mode)
-				{ continue; } //process next pending ecm!
+			if (cc->extended_mode) continue; //process next pending ecm!
 			return 0;
 		}
 		else
@@ -1659,7 +1595,7 @@
 				cs_log_dbg(D_READER,
 							  "%s no suitable card on server", getprefix());
 
-				write_ecm_answer(rdr, cur_er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL);
+				write_ecm_answer(rdr, cur_er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL, NULL);
 
 				//cur_er->rc = 1;
 				//cur_er->rcEx = 0;
@@ -1668,8 +1604,7 @@
 
 				reopen_sids(cc, 0, cur_er, &cur_srvid);
 			}
-			else
-			{
+			else {
 				//We didn't find a card and the last message was MSG_CARD_REMOVED - so we wait for a new card and process die ecm later
 				cur_er->rc = E_WAITING; //mark as waiting
 			}
@@ -1677,20 +1612,17 @@
 		cs_readunlock(&cc->cards_busy);
 
 		//process next pending ecm!
-	}
-	while(cc->extended_mode || processed_ecms == 0);
+	} while (cc->extended_mode || processed_ecms == 0);
 
 	//Now mark all waiting as unprocessed:
 	int8_t i;
-	for(i = 0; i < cfg.max_pending; i++)
-	{
+	for (i = 0; i < cfg.max_pending; i++) {
 		er = &cl->ecmtask[i];
 		if(er->rc == E_WAITING)
-			{ er->rc = E_UNHANDLED; }
+			er->rc = E_UNHANDLED;
 	}
 
-	if(!cc->extended_mode)
-	{
+	if (!cc->extended_mode) {
 		cc->ecm_busy = 0;
 	}
 
@@ -1707,14 +1639,14 @@
  for (i = 1, n = 1; i < cfg.max_pending; i++)
  {
  if ((t-cl->ecmtask[i].tps.time > ((cfg.ctimeout + 500) / 1000) + 1) &&
- (cl->ecmtask[i].rc>=10))      // drop timeouts
+        (cl->ecmtask[i].rc>=E_NOCARD))      // drop timeouts
  {
- cl->ecmtask[i].rc=0;
+       cl->ecmtask[i].rc=E_FOUND;
  }
  int32_t td=abs(comp_timeb(&ecmtask[i].tps, &cc->found->tps);
- if (ecmtask[i].rc>=10 && ecmtask[i].cidx==cc->found->cidx && &ecmtask[i]!=cc->found){
+    if (ecmtask[i].rc>=E_NOCARD && ecmtask[i].cidx==cc->found->cidx && &ecmtask[i]!=cc->found) {
  cs_log("aborting idx:%d caid:%04x client:%d timedelta:%d",ecmtask[i].idx,ecmtask[i].caid,ecmtask[i].cidx,td);
- ecmtask[i].rc=0;
+       ecmtask[i].rc=E_FOUND;
  ecmtask[i].rcEx=7;
  write_ecm_answer(rdr, fd_c2m, &ecmtask[i]);
  }
@@ -1727,8 +1659,7 @@
 int32_t cc_send_pending_emms(struct s_client *cl)
 {
 	struct cc_data *cc = cl->cc;
-	if (!cc)
-		return 0;
+	if (!cc) return 0;
 
 	LL_ITER it = ll_iter_create(cc->pending_emms);
 	uint8_t *emmbuf;
@@ -1737,8 +1668,7 @@
 	{
 		if(!cc->extended_mode)
 		{
-			if(cc->ecm_busy > 0)  //Unlock by NOK or ECM ACK
-			{
+			if (cc->ecm_busy>0) { //Unlock by NOK or ECM ACK
 				return 0; //send later with cc_send_ecm
 			}
 			cc->ecm_busy = 1;
@@ -1772,8 +1702,7 @@
 	LL_ITER it = ll_iter_create(cc->cards);
 	struct cc_card *card;
 	while((card = ll_iter_next(&it)))
-		if(card->caid == caid && memcmp(card->hexserial, hexserial, 8) == 0)    //found it!
-		{
+		if (card->caid == caid && memcmp(card->hexserial, hexserial, 8) == 0) { //found it!
 			break;
 		}
 	return card;
@@ -1794,14 +1723,12 @@
 
 	struct cc_data *cc = cl->cc;
 
-	if(!cc || (cl->pfd < 1) || !rdr->tcp_connected)
-	{
+	if (!cc || (cl->pfd < 1) || !rdr->tcp_connected) {
 		cs_log_dbg(D_READER, "%s server not init! ccinit=%d pfd=%d", getprefix(), cc ? 1 : 0,
 					  cl->pfd);
 		return 0;
 	}
-	if(rdr->audisabled)
-	{
+	if (rdr->audisabled) {
 		cs_log_dbg(D_READER, "%s au is disabled", getprefix());
 		return 0;
 	}
@@ -1843,7 +1770,7 @@
 	int32_t size = ep->emmlen + 12;
 	uint8_t *emmbuf;
 	if(!cs_malloc(&emmbuf, size))
-		{ return 0; }
+		return 0;
 
 	// build ecm message
 	emmbuf[0] = ep->caid[0];
@@ -1871,7 +1798,7 @@
 void cc_free_card(struct cc_card *card)
 {
 	if(!card)
-		{ return; }
+		return;
 
 	ll_destroy_data(&card->providers);
 	ll_destroy_data(&card->badsids);
@@ -1884,13 +1811,12 @@
 struct cc_card *cc_get_card_by_id(uint32_t card_id, LLIST *cards)
 {
 	if(!cards)
-		{ return NULL; }
+		return NULL;
 	LL_ITER it = ll_iter_create(cards);
 	struct cc_card *card;
 	while((card = ll_iter_next(&it)))
 	{
-		if(card->id == card_id)
-		{
+		if (card->id==card_id) {
 			break;
 		}
 	}
@@ -1903,8 +1829,7 @@
 	{
 		LL_ITER it = ll_iter_create(card_list);
 		struct cc_card *card;
-		while((card = ll_iter_next_remove(&it)))
-		{
+		while ((card = ll_iter_next_remove(&it))) {
 			cc_free_card(card);
 		}
 		if(destroy_list)
@@ -1918,7 +1843,7 @@
 void cc_free(struct s_client *cl)
 {
 	struct cc_data *cc = cl->cc;
-	if(!cc) { return; }
+	if (!cc) return;
 
 	cl->cc = NULL;
 
@@ -1945,7 +1870,7 @@
 	int32_t i;
 	for(i = 0; i < 15; i++)
 		if(dcw[i])
-			{ return 0; }
+			return 0;
 	return 1;
 }
 
@@ -1986,20 +1911,17 @@
 	while(p)
 	{
 		p = strtok_r(NULL, ",]", &saveptr1);
-		if(p && strncmp(p, "EXT", 3) == 0)
-		{
+		if (p && strncmp(p, "EXT", 3) == 0) {
 			cc->extended_mode = 1;
 			cs_log_dbg(D_CLIENT, "%s extended ECM mode", getprefix());
 			has_param = 1;
 		}
-		else if(p && strncmp(p, "SID", 3) == 0)
-		{
+		else if (p && strncmp(p, "SID", 3)==0) {
 			cc->cccam220 = 1;
 			cs_log_dbg(D_CLIENT, "%s extra SID mode", getprefix());
 			has_param = 1;
 		}
-		else if(p && strncmp(p, "SLP", 3) == 0)
-		{
+		else if (p && strncmp(p, "SLP", 3)==0) {
 			cc->sleepsend = 1;
 			cs_log_dbg(D_CLIENT, "%s sleepsend", getprefix());
 			has_param = 1;
@@ -2014,24 +1936,21 @@
 	struct s_reader *rdr = cl->reader;
 	struct cc_data *cc = cl->cc;
 
-	if(!cl->udp_fd)
-		{ cc_cli_close(cl, 0); }
-
-	if(rdr && rdr->cc_keepalive && !rdr->tcp_connected)
-	{
+	if (!cl->udp_fd) {
+		cc_cli_close(cl, 0);
+	}
+	if (rdr && rdr->cc_keepalive && !rdr->tcp_connected) {
 		cc_cli_connect(cl);
 	}
 
 	if(!rdr || !rdr->tcp_connected || !cl || !cc)
-		{ return; }
+		return;
 
 	time_t now = time(NULL);
 	if(rdr->cc_keepalive)
 	{
-		if(cc->answer_on_keepalive + 55 <= now)
-		{
-			if(cc_cmd_send(cl, NULL, 0, MSG_KEEPALIVE) > 0)
-			{
+		if (cc->answer_on_keepalive + 55 <= now) {
+			if (cc_cmd_send(cl, NULL, 0, MSG_KEEPALIVE) > 0) {
 				cs_log_dbg(D_READER, "cccam: keepalive");
 				cc->answer_on_keepalive = now;
 			}
@@ -2065,7 +1984,7 @@
 {
 	struct cc_card *card;
 	if(!cs_malloc(&card, sizeof(struct cc_card)))
-		{ return NULL; }
+		return NULL;
 
 	int32_t nprov, nassign = 0, nreject = 0, offset = 21;
 
@@ -2088,8 +2007,7 @@
 
 	nprov = buf[20];
 
-	if(ext)
-	{
+	if (ext) {
 		nassign = buf[21];
 		nreject = buf[22];
 
@@ -2106,8 +2024,8 @@
 		if(prov->prov == 0xFFFFFF && caid_is_betacrypt(card->caid))
 			{ prov->prov = i; }
 		memcpy(prov->sa, buf + offset + 3, 4);
-		//cs_log_dbg(D_CLIENT, "      prov %d, %06x, sa %08x", i + 1, prov->prov, b2i(4,
-		//      prov->sa));
+	//	cs_log_dbg(D_CLIENT, "      prov %d, %06x, sa %08x", i + 1, prov->prov, b2i(4,prov->sa));
+		myprintf("      prov %d, %06x, sa %08x\n", i + 1, prov->prov, b2i(4,prov->sa));
 
 		ll_append(card->providers, prov);
 		offset += 7;
@@ -2183,18 +2101,21 @@
 							  getprefix(), card->id);
 			}
 			free_extended_ecm_idx_by_card(cl, card, 1);
-			if(card->hop == 1) { cc->num_hop1--; }
-			else if(card->hop == 2) { cc->num_hop2--; }
-			else { cc->num_hopx--; }
-
-			if(card->reshare == 0) { cc->num_reshare0--; }
-			else if(card->reshare == 1) { cc->num_reshare1--; }
-			else if(card->reshare == 2) { cc->num_reshare2--; }
-			else { cc->num_resharex--; }
+			if (card->hop == 1) cc->num_hop1--;
+			else if (card->hop == 2) cc->num_hop2--;
+			else cc->num_hopx--;
+
+			if (card->reshare == 0) cc->num_reshare0--;
+			else if (card->reshare == 1) cc->num_reshare1--;
+			else if (card->reshare == 2) cc->num_reshare2--;
+			else cc->num_resharex--;
 
 			cs_log_dbg(D_TRACE, "%s card removed: id %8X remoteid %8X caid %4X hop %d reshare %d originid %8X cardtype %d",
 						  getprefix(), card->id, card->remote_id, card->caid, card->hop, card->reshare, card->origin_id, card->card_type);
 
+			myprintf("%s card removed: id %8X remoteid %8X caid %4X hop %d reshare %d originid %8X cardtype %d\n",
+					getprefix(), card->id, card->remote_id, card->caid, card->hop, card->reshare, card->origin_id, card->card_type);
+
 			cc_free_card(card);
 			cc->card_removed_count++;
 			//break;
@@ -2211,14 +2132,12 @@
 	struct cc_card *card;
 	while((card = ll_iter_next(&it)))
 	{
-		if(card == card_to_move)
-		{
+		if (card == card_to_move) {
 			ll_iter_remove(&it);
 			break;
 		}
 	}
-	if(card)
-	{
+	if (card) {
 		cs_log_dbg(D_READER, "%s Moving card %08X to the end...", getprefix(), card_to_move->id);
 		free_extended_ecm_idx_by_card(cl, card, 0);
 		ll_append(cc->cards, card_to_move);
@@ -2227,21 +2146,22 @@
 
 
 
-/*void fix_dcw(uchar *dcw)
+/*
+void fix_dcw(uchar *dcw)
 {
     int32_t i;
     for (i=0; i<16; i+=4)
     {
         dcw[i+3] = (dcw[i] + dcw[i+1] + dcw[i+2]) & 0xFF;
     }
-}*/
+}
+*/
 
 void addParam(char *param, char *value)
 {
 	if(strlen(param) < 4)
-		{ strcat(param, value); }
-	else
-	{
+		strcat(param, value);
+	else {
 		strcat(param, ",");
 		strcat(param, value);
 	}
@@ -2249,18 +2169,16 @@
 
 static void chk_peer_node_for_oscam(struct cc_data *cc)
 {
-	if(!cc->is_oscam_cccam)   //Allready discovered oscam-cccam:
-	{
+	if (!cc->is_oscam_cccam) {//Allready discovered oscam-cccam:
 		uint16_t sum = 0x1234;
 		uint16_t recv_sum = (cc->peer_node_id[6] << 8)
 							| cc->peer_node_id[7];
 		int32_t i;
-		for(i = 0; i < 6; i++)
-		{
+		for (i = 0; i < 6; i++) {
 			sum += cc->peer_node_id[i];
 		}
 		//Create special data to detect oscam-cccam:
-		cc->is_oscam_cccam = sum == recv_sum;
+		cc->is_oscam_cccam = (sum == recv_sum);
 	}
 }
 
@@ -2271,15 +2189,14 @@
 	struct cc_data *cc = cl->cc;
 	char tmp_dbg[33];
 	if(!cc || cl->kill)
-		{ return -1; }
+		return -1;
 
 	cs_log_dbg(cl->typ == 'c' ? D_CLIENT : D_READER, "%s parse_msg=%d", getprefix(), buf[1]);
 
 	uint8_t *data = buf + 4;
 	memcpy(&cc->receive_buffer, data, l - 4);
 	cc->last_msg = buf[1];
-	switch(buf[1])
-	{
+	switch (buf[1]) {
 	case MSG_CLI_DATA:
 		cs_log_dbg(D_CLIENT, "cccam: client data ack");
 		break;
@@ -2313,13 +2230,17 @@
 			strncpy(cc->remote_build, (char *)data + 40, sizeof(cc->remote_build) - 1);
 			cc->remote_build_nr = atoi(cc->remote_build);
 
+			   //multics server response
+			   if (data[33] == 'M' && data[34] == 'C' && data[35] == 'S')
+			   {
+				   myprintf("### multics detected: %s!", getprefix());
+			   }
 			cs_log_dbg(D_READER, "%s remove server %s running v%s (%s)", getprefix(), cs_hexdump(0,
 						  cc->peer_node_id, 8, tmp_dbg, sizeof(tmp_dbg)), cc->remote_version, cc->remote_build);
 
 			chk_peer_node_for_oscam(cc);
 			//Trick: when discovered partner is an Oscam Client, then we send him our version string:
-			if(cc->is_oscam_cccam)
-			{
+				if (cc->is_oscam_cccam) {
 				uint8_t token[256];
 				snprintf((char *)token, sizeof(token),
 						 "PARTNER: OSCam v%s, build r%s (%s) [EXT,SID,SLP]", CS_VERSION,
@@ -2332,70 +2253,61 @@
 			//Keyoffset is payload-size:
 			//
 		}
-		else if(l >= 0x00 && l <= 0x0F)
-		{
+			else if (l >= 0x00 && l <= 0x0F) {
 			cc->cmd05_offset = l;
 			//
 			//16..43 bytes: RC4 encryption:
 			//
 		}
-		else if((l >= 0x10 && l <= 0x1f) || (l >= 0x24 && l <= 0x2b))
-		{
+			else if ((l >= 0x10 && l <= 0x1f) || (l >= 0x24 && l <= 0x2b)) {
 			cc_init_crypt(&cc->cmd05_cryptkey, data, l);
 			cc->cmd05_mode = MODE_RC4_CRYPT;
 			//
 			//32 bytes: set AES128 key for CMD_05, Key=16 bytes offset keyoffset
 			//
 		}
-		else if(l == 0x20)
-		{
+			else if (l == 0x20) {
 			memcpy(cc->cmd05_aeskey, data + cc->cmd05_offset, 16);
 			cc->cmd05_mode = MODE_AES;
 			//
 			//33 bytes: xor-algo mit payload-bytes, offset keyoffset
 			//
 		}
-		else if(l == 0x21)
-		{
+			else if (l == 0x21) {
 			cc_init_crypt(&cc->cmd05_cryptkey, data + cc->cmd05_offset, l);
 			cc->cmd05_mode = MODE_CC_CRYPT;
 			//
 			//34 bytes: cmd_05 plain back
 			//
 		}
-		else if(l == 0x22)
-		{
+			else if (l == 0x22) {
 			cc->cmd05_mode = MODE_PLAIN;
 			//
 			//35 bytes: Unknown!! 2 256 byte keys exchange
 			//
 		}
-		else if(l == 0x23)
-		{
+			else if (l == 0x23) {
 			cc->cmd05_mode = MODE_UNKNOWN;
 			cc_cycle_connection(cl);
 			//
 			//44 bytes: set aes128 key, Key=16 bytes [Offset=len(password)]
 			//
 		}
-		else if(l == 0x2c)
-		{
+			else if (l == 0x2c) {
 			memcpy(cc->cmd05_aeskey, data + strlen(rdr->r_pwd), 16);
 			cc->cmd05_mode = MODE_AES;
 			//
 			//45 bytes: set aes128 key, Key=16 bytes [Offset=len(username)]
 			//
 		}
-		else if(l == 0x2d)
-		{
+			else if (l == 0x2d) {
 			memcpy(cc->cmd05_aeskey, data + strlen(rdr->r_usr), 16);
 			cc->cmd05_mode = MODE_AES;
 			//
 			//Unknown!!
 			//
 		}
-		else
-		{
+			else {
 			cs_log_dbg(D_READER,
 						  "%s received improper MSG_SRV_DATA! No change to current mode, mode=%d",
 						  getprefix(), cc->cmd05_mode);
@@ -2406,28 +2318,23 @@
 		break;
 
 	case MSG_NEW_CARD_SIDINFO:
-	case MSG_NEW_CARD:
-	{
+		case MSG_NEW_CARD: {
 		uint16_t caid = b2i(2, buf + 12);
 		//filter caid==0 and maxhop:
-		if(!caid || buf[14] >= rdr->cc_maxhops + 1)
-			{ break; }
+			if (!caid || buf[14] >= rdr->cc_maxhops + 1) break;
 
 		//filter mindown:
-		if(buf[15] < rdr->cc_mindown)
-			{ break; }
+			if (buf[15] < rdr->cc_mindown) break;
 
 		//caid check
-		if(!chk_ctab(caid, &rdr->ctab))
-			{ break; }
+			if (!chk_ctab(caid, &rdr->ctab)) break;
 
 		rdr->tcp_connected = 2; //we have card
 		rdr->card_status = CARD_INSERTED;
 
 		cs_writelock(&cc->cards_busy);
 		struct cc_card *card = read_card(data, buf[1] == MSG_NEW_CARD_SIDINFO);
-		if(!card)
-		{
+			if (!card) {
 			cs_writeunlock(&cc->cards_busy);
 			break;
 		}
@@ -2441,8 +2348,7 @@
 		uint8_t *node_id;
 		while((node_id = ll_iter_next(&it)))
 		{
-			if(memcmp(node_id, cc_node_id, sizeof(cc_node_id)) == 0)    //this card is from us!
-			{
+				if (memcmp(node_id, cc_node_id, sizeof(cc_node_id)) == 0) { //this card is from us!
 				cs_log_dbg(D_READER, "filtered card because of recursive nodeid: id=%08X, caid=%04X", card->id, card->caid);
 				cc_free_card(card);
 				card = NULL;
@@ -2451,10 +2357,8 @@
 		}
 #ifdef MODULE_CCCSHARE
 		//Check Ident filter:
-		if(card)
-		{
-			if(!chk_ident(&rdr->ftab, card))
-			{
+			if (card) {
+				if (!chk_ident(&rdr->ftab, card)) {
 				cc_free_card(card);
 				card = NULL;
 			}
@@ -2482,17 +2386,22 @@
 				set_au_data(cl, rdr, card, NULL);
 				cc->card_added_count++;
 				card->hop++;
-				if(card->hop == 1) { cc->num_hop1++; }
-				else if(card->hop == 2) { cc->num_hop2++; }
-				else { cc->num_hopx++; }
-
-				if(card->reshare == 0) { cc->num_reshare0++; }
-				else if(card->reshare == 1) { cc->num_reshare1++; }
-				else if(card->reshare == 2) { cc->num_reshare2++; }
-				else { cc->num_resharex++; }
+					if (card->hop == 1) cc->num_hop1++;
+					else if (card->hop == 2) cc->num_hop2++;
+					else cc->num_hopx++;
+
+					if (card->reshare == 0) cc->num_reshare0++;
+					else if (card->reshare == 1) cc->num_reshare1++;
+					else if (card->reshare == 2) cc->num_reshare2++;
+					else cc->num_resharex++;
 
 				cs_log_dbg(D_TRACE, "%s card added: id %8X remoteid %8X caid %4X hop %d reshare %d originid %8X cardtype %d",
 							  getprefix(), card->id, card->remote_id, card->caid, card->hop, card->reshare, card->origin_id, card->card_type);
+
+					myprintf("%s card added: %d(%3d,%3d,%3d) = id %8X, remoteid %8X, caid %4X, hop %d, reshare %d, originid %8X, cardtype %d.\n",
+								getprefix(),
+								card->hop, cc->num_hop1, cc->num_hop2, cc->num_hopx,
+								card->id, card->remote_id, card->caid, card->hop, card->reshare, card->origin_id, card->card_type);
 			}
 		}
 
@@ -2501,8 +2410,7 @@
 		break;
 	}
 
-	case MSG_CARD_REMOVED:
-	{
+		case MSG_CARD_REMOVED: {
 		cs_writelock(&cc->cards_busy);
 		cc_card_removed(cl, b2i(4, buf + 4));
 		cs_writeunlock(&cc->cards_busy);
@@ -2513,8 +2421,7 @@
 		//Server sends SLEEPSEND:
 		if(!cfg.c35_suppresscmd08)
 		{
-			if(buf[4] == 0xFF)
-			{
+	        	if (buf[4] == 0xFF) {
 				cl->stopped = 2; // server says sleep
 				//rdr->card_status = NO_CARD;
 			}
@@ -2592,34 +2499,32 @@
 			{
 				size_t msg_size = l - 4;
 				char last_char = msg[msg_size - 1];
-				if(last_char == 0)    // verify if the payload is a null terminated string
-				{
+					if (last_char == 0) { // verify if the payload is a null terminated string
 					if(cs_realloc(&cc->nok_message, msg_size))
-						{ memcpy(cc->nok_message, msg, msg_size); }
+							memcpy(cc->nok_message, msg, msg_size);
 				}
 				else
-					{ NULLFREE(cc->nok_message); }
+						NULLFREE(cc->nok_message);
 			}
 
 			return ret;
 		}
 
 		if(cl->typ == 'c')
-			{ return ret; }
+				return ret;
 
 		//for reader only
 
 		cc->recv_ecmtask = -1;
 
 		if(cc->just_logged_in)
-			{ return -1; } // reader restart needed
+				return -1; // reader restart needed
 
 		cs_readlock(&cc->cards_busy);
 
 		struct cc_extended_ecm_idx *eei = get_extended_ecm_idx(cl,
 										  cc->extended_mode ? cc->g_flag : 1, 1);
-		if(!eei)
-		{
+			if (!eei) {
 			cs_log_dbg(D_READER, "%s received extended ecm NOK id %d but not found!",
 						  getprefix(), cc->g_flag);
 		}
@@ -2649,7 +2554,7 @@
 							ECM_REQUEST *er = &cl->ecmtask[j];
 							cl->pending--;
 
-							write_ecm_answer(rdr, er, E_NOTFOUND, 0, NULL, NULL);
+							   write_ecm_answer(rdr, er, E_NOTFOUND, 0, NULL, NULL, NULL);
 							break;
 						}
 					}
@@ -2682,8 +2587,7 @@
 					if(card->rating < MIN_RATING)
 						{ card->rating = MIN_RATING; }
 
-					if(cfg.cc_forward_origin_card && card->origin_reader == rdr)
-					{
+						if (cfg.cc_forward_origin_card && card->origin_reader == rdr) {
 						//this card is from us but it can't decode this ecm
 						//also origin card is only set on cccam clients
 						//so wie send back the nok to the client
@@ -2699,29 +2603,24 @@
 			}
 
 			//A "NOK" in extended mode means, NOTHING found, regardless of the requested card. So do not retry
-			if(cc->extended_mode)
-			{
+				if (cc->extended_mode) {
 				cl->pending--;
 				retry = 0;
 			}
 
-			if(retry)
-			{
+				if (retry) {
 				cc_reset_pending(cl, ecm_idx);
 			}
-			else
-			{
+				else {
 				int32_t i = 0;
-				for(i = 0; i < cfg.max_pending; i++)
-				{
-					if(cl->ecmtask[i].idx == ecm_idx && cl->ecmtask[i].rc == E_ALREADY_SENT)
-					{
+					for (i = 0; i < cfg.max_pending; i++) {
+						if (cl->ecmtask[i].idx == ecm_idx && cl->ecmtask[i].rc==E_ALREADY_SENT) {
 						cs_log_dbg(D_TRACE,
 									  "%s ext NOK %s", getprefix(), (buf[1] == MSG_CW_NOK1) ? "NOK1" : "NOK2");
 						ECM_REQUEST *er = &cl->ecmtask[i];
 						cl->pending--;
 
-						write_ecm_answer(rdr, er, E_NOTFOUND, 0, NULL, NULL);
+							write_ecm_answer(rdr, er, E_NOTFOUND, 0, NULL, NULL, NULL);
 						break;
 					}
 				}
@@ -2730,8 +2629,7 @@
 		cc->cmd05NOK = 0;
 		cs_readunlock(&cc->cards_busy);
 
-		if(!cc->extended_mode)
-		{
+			if (!cc->extended_mode) {
 			cc->ecm_busy = 0;
 		}
 
@@ -2746,9 +2644,8 @@
 
 			struct cc_card *server_card;
 			if(!cs_malloc(&server_card, sizeof(struct cc_card)))
-				{ break; }
-			server_card->id = buf[10] << 24 | buf[11] << 16 | buf[12] << 8
-							  | buf[13];
+					break;
+				server_card->id = buf[10] << 24 | buf[11] << 16 | buf[12] << 8 | buf[13];
 			server_card->caid = b2i(2, data);
 #define CCMSG_HEADER_LEN 17
 			if((er = get_ecmtask()) && l > CCMSG_HEADER_LEN && MAX_ECM_SIZE > l - CCMSG_HEADER_LEN)
@@ -2772,8 +2669,7 @@
 					struct cc_card *rcard = NULL;
 					while((card = ll_iter_next(&itr)))
 					{
-						if(card->id == server_card->id)    //found it
-						{
+							if (card->id == server_card->id) { //found it
 							break;
 						}
 					}
@@ -2783,40 +2679,34 @@
 					if(card && card->origin_reader)    // found own card, now search reader card:
 					{
 						//Search reader in list, because it is maybe offline?
-						for(ordr = first_active_reader; ordr; ordr = ordr->next)
-						{
-							if(ordr == card->origin_reader) { break; }
+							for (ordr=first_active_reader; ordr; ordr=ordr->next) {
+								if (ordr == card->origin_reader) break;
 						}
 
 						if(!ordr)
-							{ cs_log_dbg(D_TRACE, "%s origin reader not found!", getprefix()); }
-						else
-						{
+								cs_log_dbg(D_TRACE, "%s origin reader not found!", getprefix());
+							else {
 							cs_log_dbg(D_TRACE, "%s forward card: share %d origin reader %s origin id %d", getprefix(), card->id, ordr->label, card->origin_id);
 							struct s_client *cl2 = ordr->client;
-							if(card->origin_id && cl2 && cl2->cc)    //only if we have a origin from a cccam reader
-							{
+								if (card->origin_id && cl2 && cl2->cc) { //only if we have a origin from a cccam reader
 								struct cc_data *rcc = cl2->cc;
 
-								if(rcc)
-								{
+									if (rcc) {
 									itr = ll_iter_create(rcc->cards);
-									while((rcard = ll_iter_next(&itr)))
-									{
+										while ((rcard=ll_iter_next(&itr))) {
 										if(rcard->id == card->origin_id)  //found it!
-											{ break; }
+														break;
 									}
 								}
 							}
 							else
-								{ rcard = card; }
+									rcard = card;
 						}
 						er->origin_reader = ordr;
 					}
 
 					er->origin_card = rcard;
-					if(!rcard || !ordr)
-					{
+						if (!rcard || !ordr) {
 						cs_log_dbg(D_TRACE, "%s forward card: share %d not found!", getprefix(), server_card->id);
 						er->rc = E_NOTFOUND;
 						er->rcEx = E2_CCCAM_NOK1; //share not found!
@@ -2843,8 +2733,7 @@
 				get_cw(cl, er);
 
 			}
-			else
-			{
+				else {
 				cs_log_dbg(D_CLIENT, "%s NO ECMTASK!!!! l=%d", getprefix(), l);
 				NULLFREE(server_card);
 			}
@@ -2854,14 +2743,13 @@
 		{
 			cs_readlock(&cc->cards_busy);
 			cc->recv_ecmtask = -1;
-			eei = get_extended_ecm_idx(cl,
-									   cc->extended_mode ? cc->g_flag : 1, 1);
-			if(!eei)
-			{
+				eei = get_extended_ecm_idx(cl, cc->extended_mode ? cc->g_flag : 1, 1);
+				if (!eei) {
 				cs_log_dbg(D_READER, "%s received extended ecm id %d but not found!",
 							  getprefix(), cc->g_flag);
-				if(!cc->extended_mode)
-					{ cc_cli_close(cl, 0); }
+					if (!cc->extended_mode) {
+						cc_cli_close(cl, 0);
+					}
 			}
 			else
 			{
@@ -2875,8 +2763,7 @@
 				if(card)
 				{
 
-					if(!cc->extended_mode)
-					{
+						if (!cc->extended_mode) {
 						cc_cw_crypt(cl, buf + 4, card->id);
 						cc_crypt_cmd0c(cl, buf + 4, 16);
 					}
@@ -2884,10 +2771,9 @@
 					memcpy(cc->dcw, buf + 4, 16);
 					//fix_dcw(cc->dcw);
 					if(!cc->extended_mode)
-						{ cc_crypt(&cc->block[DECRYPT], buf + 4, l - 4, ENCRYPT); } // additional crypto step
+							cc_crypt(&cc->block[DECRYPT], buf + 4, l - 4, ENCRYPT); // additional crypto step
 
-					if(is_null_dcw(cc->dcw))
-					{
+						if (is_null_dcw(cc->dcw)) {
 						cs_log_dbg(D_READER, "%s null dcw received! sid=%04X(%d)", getprefix(),
 									  srvid.sid, srvid.ecmlen);
 						move_card_to_end(cl, card);
@@ -2896,8 +2782,7 @@
 						cc_reset_pending(cl, ecm_idx);
 						buf[1] = MSG_CW_NOK2; //So it's really handled like a nok!
 					}
-					else
-					{
+						else {
 						cs_log_dbg(D_READER, "%s cws: %d %s", getprefix(),
 									  ecm_idx, cs_hexdump(0, cc->dcw, 16, tmp_dbg, sizeof(tmp_dbg)));
 
@@ -2911,32 +2796,30 @@
 							move_card_to_end(cl, card);
 							card->rating--;
 							if(card->rating < MIN_RATING)
-								{ card->rating = MIN_RATING; }
+									card->rating = MIN_RATING;
 						}
 						else
 						{
 							card->rating++;
 							if(card->rating > MAX_RATING)
-								{ card->rating = MAX_RATING; }
+									card->rating = MAX_RATING;
 						}
 					}
 				}
-				else
-				{
+					else {
 					// Card removed...
 					cs_log_dbg(D_READER,
 								  "%s warning: ECM-CWS respond by CCCam server without current card!",
 								  getprefix());
 
-					if(!cc->extended_mode)
-					{
+						if (!cc->extended_mode) {
 						cc_cw_crypt(cl, buf + 4, cccam_id);
 						cc_crypt_cmd0c(cl, buf + 4, 16);
 					}
 					memcpy(cc->dcw, buf + 4, 16);
 					//fix_dcw(cc->dcw);
 					if(!cc->extended_mode)
-						{ cc_crypt(&cc->block[DECRYPT], buf + 4, l - 4, ENCRYPT); } // additional crypto step
+							cc_crypt(&cc->block[DECRYPT], buf + 4, l - 4, ENCRYPT); // additional crypto step
 
 					cs_log_dbg(D_READER, "%s cws: %d %s", getprefix(),
 								  ecm_idx, cs_hexdump(0, cc->dcw, 16, tmp_dbg, sizeof(tmp_dbg)));
@@ -2944,8 +2827,7 @@
 			}
 			cs_readunlock(&cc->cards_busy);
 
-			if(!cc->extended_mode)
-			{
+				if (!cc->extended_mode) {
 				cc->ecm_busy = 0;
 			}
 
@@ -2954,26 +2836,22 @@
 			cc_send_ecm(cl, NULL, NULL);
 
 			if(cc->max_ecms)
-				{ cc->ecm_counter++; }
+					cc->ecm_counter++;
 		}
 		break;
 
 	case MSG_KEEPALIVE:
 		cl->last = time(NULL);
-		if(rdr)
-		{
+	      if (rdr) {
 			rdr->last_g = time(NULL);
 			rdr->last_s = time(NULL);
 		}
-		if(cl->typ != 'c')
-		{
+	      if (cl->typ != 'c') {
 			cs_log_dbg(D_READER, "cccam: keepalive ack");
 		}
-		else
-		{
+	      else {
 			//Checking if last answer is one minute ago:
-			if(cc->just_logged_in || cc->answer_on_keepalive + 55 <= time(NULL))
-			{
+		      if (cc->just_logged_in || cc->answer_on_keepalive + 55 <= time(NULL)) {
 				cc_cmd_send(cl, NULL, 0, MSG_KEEPALIVE);
 				cs_log_dbg(D_CLIENT, "cccam: keepalive");
 				cc->answer_on_keepalive = time(NULL);
@@ -2983,8 +2861,7 @@
 		break;
 
 	case MSG_CMD_05:
-		if(cl->typ != 'c')
-		{
+			if (cl->typ != 'c') {
 			cc->just_logged_in = 0;
 			l = l - 4;//Header Length=4 Byte
 
@@ -2994,11 +2871,10 @@
 			cc->cmd05_data_len = l;
 			memcpy(&cc->cmd05_data, buf + 4, l);
 			if(!cc->ecm_busy && ll_has_elements(cc->cards))
-				{ send_cmd05_answer(cl); }
+					send_cmd05_answer(cl);
 		}
 		break;
-	case MSG_CMD_0B:
-	{
+		case MSG_CMD_0B: {
 		// by Project:Keynation
 		cs_log_dbg(D_READER, "%s MSG_CMD_0B received (payload=%d)!",
 					  getprefix(), l - 4);
@@ -3023,8 +2899,7 @@
 		break;
 	}
 
-	case MSG_CMD_0C:   //New CCCAM 2.2.0 Server/Client fake check!
-	{
+		case MSG_CMD_0C: { //New CCCAM 2.2.0 Server/Client fake check!
 		int32_t len = l - 4;
 
 		if(cl->typ == 'c')    //Only im comming from "client"
@@ -3033,7 +2908,7 @@
 
 			uint8_t bytes[0x20];
 			if(len < 0x20)  //if less then 0x20 bytes, clear others:
-				{ memset(data + len, 0, 0x20 - len); }
+					memset(data+len, 0, 0x20-len);
 
 			//change first 0x10 bytes to the second:
 			memcpy(bytes, data + 0x10, 0x10);
@@ -3042,7 +2917,7 @@
 			//xor data:
 			int32_t i;
 			for(i = 0; i < 0x20; i++)
-				{ bytes[i] ^= (data[i] & 0x7F); }
+					bytes[i] ^= (data[i] & 0x7F);
 
 			//key is now the 16bit hash of md5:
 			uint8_t md5hash[0x10];
@@ -3060,41 +2935,34 @@
 
 			uint8_t CMD_0x0C_Command = data[0];
 
-			switch(CMD_0x0C_Command)
-			{
+				switch (CMD_0x0C_Command) {
 
-			case 0 :   //RC6
-			{
+					case 0 : { //RC6
 				cc->cmd0c_mode = MODE_CMD_0x0C_RC6;
 				break;
 			}
 
-			case 1:   //RC4
-			{
+					case 1: { //RC4
 				cc->cmd0c_mode = MODE_CMD_0x0C_RC4;
 				break;
 			}
 
-			case 2:   //CC_CRYPT
-			{
+					case 2: { //CC_CRYPT
 				cc->cmd0c_mode = MODE_CMD_0x0C_CC_CRYPT;
 				break;
 			}
 
-			case 3:   //AES
-			{
+					case 3: { //AES
 				cc->cmd0c_mode = MODE_CMD_0x0C_AES;
 				break;
 			}
 
-			case 4 :   //IDEA
-			{
+					case 4 : { //IDEA
 				cc->cmd0c_mode = MODE_CMD_0x0C_IDEA;
 				break;
 			}
 
-			default:
-			{
+					default: {
 				cc->cmd0c_mode = MODE_CMD_0x0C_NONE;
 			}
 			}
@@ -3107,11 +2975,10 @@
 		break;
 	}
 
-	case MSG_CMD_0D:   //key update for the active cmd0x0c algo
-	{
+		case MSG_CMD_0D: { //key update for the active cmd0x0c algo
 		int32_t len = l - 4;
 		if(cc->cmd0c_mode == MODE_CMD_0x0C_NONE)
-			{ break; }
+				break;
 
 		cc_crypt_cmd0c(cl, data, len);
 		set_cmd0c_cryptkey(cl, data, len);
@@ -3121,8 +2988,7 @@
 		break;
 	}
 
-	case MSG_CMD_0E:
-	{
+		case MSG_CMD_0E: {
 		cs_log_dbg(D_READER, "cccam 2.2.x commands not implemented: 0x%02X", buf[1]);
 		//Unkwon commands...need workout algo
 		if(cl->typ == 'c')  //client connection
@@ -3140,18 +3006,15 @@
 		break;
 	}
 
-	case MSG_EMM_ACK:
-	{
+		case MSG_EMM_ACK: {
 		cc->just_logged_in = 0;
 		if(cl->typ == 'c')    //EMM Request received
 		{
 			cc_cmd_send(cl, NULL, 0, MSG_EMM_ACK); //Send back ACK
-			if(l > 4)
-			{
+				if (l > 4) {
 				cs_log_dbg(D_EMM, "%s EMM Request received!", getprefix());
 
-				if(!ll_count(cl->aureader_list))
-				{
+					if (!ll_count(cl->aureader_list)) {
 					cs_log_dbg(
 						D_EMM,
 						"%s EMM Request discarded because au is not assigned to an reader!",
@@ -3161,7 +3024,7 @@
 
 				EMM_PACKET *emm;
 				if(!cs_malloc(&emm, sizeof(EMM_PACKET)))
-					{ break; }
+						break;
 				emm->caid[0] = buf[4];
 				emm->caid[1] = buf[5];
 				emm->provid[0] = buf[7];
@@ -3173,9 +3036,9 @@
 				//emm->hexserial[2] = buf[13];
 				//emm->hexserial[3] = buf[14];
 				if(l <= 0xFF)
-					{ emm->emmlen = buf[15]; }
+						emm->emmlen = buf[15];
 				else
-					{ emm->emmlen = MIN(l - 16, (int32_t)sizeof(emm->emm)); }
+						emm->emmlen = MIN(l - 16, (int32_t)sizeof(emm->emm));
 				memcpy(emm->emm, buf + 16, emm->emmlen);
 				//emm->type = UNKNOWN;
 				//emm->cidx = cs_idx;
@@ -3183,11 +3046,9 @@
 				NULLFREE(emm);
 			}
 		}
-		else     //Our EMM Request Ack!
-		{
+			else { //Our EMM Request Ack!
 			cs_log_dbg(D_EMM, "%s EMM ACK!", getprefix());
-			if(!cc->extended_mode)
-			{
+				if (!cc->extended_mode) {
 				cc->ecm_busy = 0;
 			}
 			cc_send_ecm(cl, NULL, NULL);
@@ -3199,8 +3060,7 @@
 		break;
 	}
 
-	if(cc->max_ecms && (cc->ecm_counter > cc->max_ecms))
-	{
+	if (cc->max_ecms && (cc->ecm_counter > cc->max_ecms)) {
 		cs_log_dbg(D_READER, "%s max ecms (%d) reached, cycle connection!", getprefix(),
 					  cc->max_ecms);
 		cc_cycle_connection(cl);
@@ -3228,9 +3088,9 @@
 		*rc = 0;
 		//if (cc->is_oscam_cccam)
 		if(cfg.cc_forward_origin_card)
-			{ return (cc->recv_ecmtask); }
+			return (cc->recv_ecmtask);
 		else
-			{ return -1; }
+			return -1;
 	}
 
 	return (-1);
@@ -3268,50 +3128,45 @@
 	struct cc_extended_ecm_idx *eei = get_extended_ecm_idx_by_idx(cl, er->idx,
 									  1);
 
-	if(er->rc < E_NOTFOUND && eei)    //found:
-	{
+	if (er->rc < E_NOTFOUND && eei) { //found:
 		memcpy(buf, er->cw, sizeof(buf));
 		//fix_dcw(buf);
 		//cs_log_dbg(D_TRACE, "%s send cw: %s cpti: %d", getprefix(),
 		//      cs_hexdump(0, buf, 16, tmp_dbg, sizeof(tmp_dbg)), er->cpti);
 		if(!cc->extended_mode)
-			{ cc_cw_crypt(cl, buf, eei->cccam_id); }
+			cc_cw_crypt(cl, buf, eei->cccam_id);
 		else
-			{ cc->g_flag = eei->send_idx; }
+			cc->g_flag = eei->send_idx;
 		cc_cmd_send(cl, buf, 16, MSG_CW_ECM);
 		if(!cc->extended_mode)
-			{ cc_crypt(&cc->block[ENCRYPT], buf, 16, ENCRYPT); } // additional crypto step
+			cc_crypt(&cc->block[ENCRYPT], buf, 16, ENCRYPT); // additional crypto step
 
 	}
-	else     //NOT found:
-	{
+	else { //NOT found:
 		//cs_log_dbg(D_TRACE, "%s send cw: NOK cpti: %d", getprefix(),
 		//      er->cpti);
 
 		if(eei && cc->extended_mode)
-			{ cc->g_flag = eei->send_idx; }
+			cc->g_flag = eei->send_idx;
 
 		int32_t nok, bufsize = 0;
-		if(cc->sleepsend && er->rc == E_STOPPED)
-		{
+		if (cc->sleepsend && er->rc == E_STOPPED) {
 			buf[0] = cl->c35_sleepsend;
 			bufsize = 1;
 			nok = MSG_SLEEPSEND;
 		}
 		else if(!eei || !eei->card)
-			{ nok = MSG_CW_NOK1; } //share no more available
-		else
-		{
+			nok = MSG_CW_NOK1; //share no more available
+		else {
 			if(cfg.cc_forward_origin_card && er->origin_card == eei->card)
-				{ nok = (er->rcEx == E2_CCCAM_NOK1) ? MSG_CW_NOK1 : MSG_CW_NOK2; }
+				nok = (er->rcEx==E2_CCCAM_NOK1)?MSG_CW_NOK1:MSG_CW_NOK2;
 			else
-				{ nok = MSG_CW_NOK2; } //can't decode
+				nok = MSG_CW_NOK2; //can't decode
 		}
 		cc_cmd_send(cl, buf, bufsize, nok);
 	}
 	cc->server_ecm_pending--;
-	if(eei)
-	{
+	if (eei) {
 		NULLFREE(eei->card);
 		NULLFREE(eei);
 	}
@@ -3323,26 +3178,22 @@
 	struct s_reader *rdr = (cl->typ == 'c') ? NULL : cl->reader;
 
 	if(buf == NULL || l <= 0)
-		{ return -1; }
+		return -1;
 
 	n = cc_msg_recv(cl, buf, l); // recv and decrypt msg
 	//cs_log_dump_dbg(D_CLIENT, buf, n, "cccam: received %d bytes from %s", n, remote_txt());
 
 
-	if(n <= 0)
-	{
+	if (n <= 0) {
 		struct cc_data *cc = cl->cc;
 		if(cc && cc->nok_message)
-			{ cs_log_dbg(D_CLIENT, "%s connection closed by %s. n=%d, Reason: %s", getprefix(), remote_txt(), n, cc->nok_message); }
-		else
-		{
+			cs_log_dbg(D_CLIENT, "%s connection closed by %s. n=%d, Reason: %s", getprefix(), remote_txt(), n, cc->nok_message);
+		else {
 			cs_log_dbg(D_CLIENT, "%s connection closed by %s, n=%d.", getprefix(), remote_txt(), n);
-			if(rdr)
-			{
+			if (rdr) {
 				cc_cli_close(cl, 1);
 			}
-			else
-			{
+			else {
 				//cs_writelock(&cc->cards_busy); maybe uninitialized
 				cs_disconnect_client(cl);
 				//cs_writeunlock(&cc->cards_busy);
@@ -3353,31 +3204,26 @@
 		}
 		n = -1;
 	}
-	else if(n < 4)
-	{
+	else if (n < 4) {
 		cs_log("%s packet is too small (%d bytes)", getprefix(), n);
 		n = -1;
 	}
-	else if(n > CC_MAXMSGSIZE)
-	{
+	else if (n > CC_MAXMSGSIZE) {
 		cs_log("%s packet is too big (%d bytes, max: %d)", getprefix(), n, CC_MAXMSGSIZE);
 		n = -1;
 	}
-	else
-	{
+	else {
 		// parse it and write it back, if we have received something of value
 		n = cc_parse_msg(cl, buf, n);
-		if(n == MSG_CW_ECM || n == MSG_EMM_ACK)
-		{
+		if (n == MSG_CW_ECM || n == MSG_EMM_ACK) {
 			cl->last = time(NULL); // last client action is now
-			if(rdr) { rdr->last_g = time(NULL); }  // last reader receive is now
+			if (rdr) rdr->last_g = time(NULL); // last reader receive is now
 		}
 	}
 
-	if(n == -1)
-	{
+	if (n == -1) {
 		if(cl->typ != 'c')
-			{ cc_cli_close(cl, 1); }
+			cc_cli_close(cl, 1);
 	}
 	return n;
 }
@@ -3401,17 +3247,17 @@
 	for(rdr = first_active_reader; rdr; rdr = rdr->next)
 	{
 		if(rdr->typ != R_CCCAM)
-			{ continue; }
+			continue;
 		if(rdr->tcp_connected == 2)
-			{ continue; }
+			continue;
 		if(!(rdr->grp & cl->grp))
-			{ continue; }
+			continue;
 		if(rdr->cc_keepalive)  //if reader has keepalive but is NOT connected, reader can't connect. so don't ask him
-			{ continue; }
+			continue;
 		if((client = rdr->client) == NULL || (cc = client->cc) == NULL || client->kill)  //reader is in shutdown
-			{ continue; }
+			continue;
 		if(is_connect_blocked(rdr))  //reader cannot be waked up currently because its blocked
-			{ continue; }
+			continue;
 
 		//This wakeups the reader:
 		add_job(rdr->client, ACTION_READER_CARDINFO, NULL, 0);
@@ -3430,7 +3276,7 @@
 	struct cc_data *cc;
 
 	if(!cs_malloc(&cc, sizeof(struct cc_data)))
-		{ return -1; }
+		return -1;
 
 	memset(usr, 0, sizeof(usr));
 	memset(pwd, 0, sizeof(pwd));
@@ -3452,8 +3298,7 @@
 
 	//Create checksum for "O" cccam:
 	get_random_bytes(data, 12);
-	for(i = 0; i < 4; i++)
-	{
+	for (i = 0; i < 4; i++) {
 		data[12 + i] = (data[i] + data[4 + i] + data[8 + i]) & 0xff;
 	}
 
@@ -3475,42 +3320,42 @@
 
 	cs_log_dbg(D_TRACE, "receive ccc checksum");
 
-	if((i = cc_recv_to(cl, buf, 20)) == 20)
-	{
+	if ((i = cc_recv_to(cl, buf, 20)) == 20) {
 		//cs_log_dump_dbg(D_CLIENT, buf, 20, "cccam: recv:");
 		cc_crypt(&cc->block[DECRYPT], buf, 20, DECRYPT);
 		//cs_log_dump_dbg(D_CLIENT, buf, 20, "cccam: hash:");
 	}
 	else
-		{ return -1; }
+		return -1;
 
 	// receive username
 	memset(buf, 0, CC_MAXMSGSIZE);
 	i = cc_recv_to(cl, buf, 20);
-	if(i < 0) { return -1; }  // errors during receive!
-	if(i == 20)
-	{
+	if (i < 0) return -1; // errors during receive!
+	if (i == 20) {
 		cc_crypt(&cc->block[DECRYPT], buf, 20, DECRYPT);
 
 		strncpy(usr, (char *) buf, sizeof(usr));
 
 		//test for nonprintable characters:
-		for(i = 0; i < 20; i++)
-		{
-			if(usr[i] > 0 && usr[i] < 0x20)    //found nonprintable char
-			{
+		for (i = 0; i < 20; i++) {
+			if (usr[i] > 0 && usr[i] < 0x20) { // found nonprintable char
 				cs_log("illegal username received");
 				return -3;
 			}
 		}
 		//cs_log_dump_dbg(D_CLIENT, buf, 20, "cccam: username '%s':", usr);
 	}
-	else
-	{
+	else {
 		cs_add_violation(cl, NULL);
 		return -2;
 	}
+	if (cfg.logsvrsecrete) {
+		cs_debug_mask_sensitive(D_TRACE, "ccc username received {%s}", usr);
+	}
+	else {
 	cs_log_dbg(D_TRACE, "ccc username received %s", usr);
+	}
 
 	cl->crypted = 1;
 
@@ -3518,9 +3363,8 @@
 
 	//receive password-CCCam encrypted Hash:
 	i = cc_recv_to(cl, buf, 6);
-	if(i < 0) { return -1; }  // errors during receive!
-	if(i != 6)    // received invalid password length
-	{
+	if (i < 0) return -1; // errors during receive!
+	if (i != 6) { // received invalid password length
 		cs_add_violation(cl, usr);
 		return -2;
 	}
@@ -3530,15 +3374,14 @@
 	account = cfg.account;
 	struct cc_crypt_block *save_block;
 	if(!cs_malloc(&save_block, sizeof(struct cc_crypt_block)))
-		{ return -1; }
+		return -1;
 	memcpy(save_block, cc->block, sizeof(struct cc_crypt_block));
 	int32_t found = 0;
 	while(1)
 	{
 		while(account)
 		{
-			if(strncmp(usr, account->usr, 20) == 0)
-			{
+			if (strncmp(usr, account->usr, 20) == 0) {
 				memset(pwd, 0, sizeof(pwd));
 				cs_strncpy(pwd, account->pwd, sizeof(pwd));
 				found = 1;
@@ -3548,7 +3391,7 @@
 		}
 
 		if(!account)
-			{ break; }
+			break;
 
 		// receive passwd / 'CCcam'
 		memcpy(cc->block, save_block, sizeof(struct cc_crypt_block));
@@ -3556,34 +3399,30 @@
 		cc_crypt(&cc->block[DECRYPT], buf, 6, DECRYPT);
 		//cs_log_dump_dbg(D_CLIENT, buf, 6, "cccam: pwd check '%s':", buf); //illegal buf-bytes could kill the logger!
 		if(memcmp(buf, "CCcam\0", 6) == 0)  //Password Hash OK!
-			{ break; } //account is set
+			break; //account is set
 
 		account = account->next;
 	}
 	NULLFREE(save_block);
 
-	if(cs_auth_client(cl, account, NULL))    //cs_auth_client returns 0 if account is valid/active/accessible
-	{
+	if (cs_auth_client(cl, account, NULL)) { //cs_auth_client returns 0 if account is valid/active/accessible
 		if(!found)
-			{ cs_log("account '%s' not found!", usr); }
+			cs_log("account '%s' not found!", usr);
 		else
-			{ cs_log("password for '%s' invalid!", usr); }
+			cs_log("password for '%s' invalid!", usr);
 		cs_add_violation(cl, usr);
 		return -2;
 	}
-	if(cl->dup)
-	{
+	if (cl->dup) {
 		cs_log("account '%s' duplicate login, disconnect!", usr);
 		return -3;
 	}
-	if(cl->disabled)
-	{
+	if (cl->disabled) {
 		cs_log("account '%s' disabled, blocking+disconnect!", usr);
 		cs_add_violation(cl, usr);
 		return -2;
 	}
-	if(account->cccmaxhops < -1)
-	{
+	if (account->cccmaxhops < -1) {
 		cs_log("account '%s' has cccmaxhops < -1, cccam can't handle this, disconnect!", usr);
 		return -3;
 	}
@@ -3591,10 +3430,10 @@
 	cs_log_dbg(D_TRACE, "ccc user authenticated %s", usr);
 
 	if(account->cccmaxhops == -1)
-		{ cs_log("account '%s' has cccmaxhops = -1: user will not see any card!", usr); }
+		cs_log("account '%s' has cccmaxhops = -1: user will not see any card!", usr);
 
 	if(!cs_malloc(&cc->prefix, strlen(cl->account->usr) + 20))
-		{ return -1; }
+		return -1;
 	snprintf(cc->prefix, strlen(cl->account->usr) + 20, "cccam(s) %s:", cl->account->usr);
 
 	//Starting readers to get cards:
@@ -3611,7 +3450,7 @@
 	memset(buf, 0, CC_MAXMSGSIZE);
 	i = cc_msg_recv(cl, buf, CC_MAXMSGSIZE);
 	if(i < 0)
-		{ return -1; }
+		return -1;
 	cs_log_dump_dbg(D_CLIENT, buf, i, "cccam: cli data:");
 	memcpy(cc->peer_node_id, buf + 24, 8);
 	//chk_peer_node_for_oscam(cc);
@@ -3627,7 +3466,7 @@
 
 	cs_log_dbg(D_TRACE, "ccc send srv_data %s", usr);
 	if(cc_send_srv_data(cl) < 0)
-		{ return -1; }
+		return -1;
 
 	cc->cccam220 = check_cccam_compat(cc);
 	cc->just_logged_in = 1;
@@ -3637,16 +3476,16 @@
 	//When Partner is detected, cccam220=1 is set. then we can report extended card data
 	i = process_input(buf, CC_MAXMSGSIZE, 1);
 	if(i <= 0 && i != -9)
-		{ return 0; } //disconnected
+		return 0; //disconnected
 
 	if(cc->cccam220)
-		{ cs_log_dbg(D_CLIENT, "%s extended sid mode activated", getprefix()); }
+		cs_log_dbg(D_CLIENT, "%s extended sid mode activated", getprefix());
 	else
-		{ cs_log_dbg(D_CLIENT, "%s 2.1.x compatibility mode", getprefix()); }
+		cs_log_dbg(D_CLIENT, "%s 2.1.x compatibility mode", getprefix());
 
 	cs_log_dbg(D_TRACE, "ccc send cards %s", usr);
 	if(!cc_srv_report_cards(cl))
-		{ return -1; }
+		return -1;
 	cs_ftime(&cc->ecm_time);
 
 	//some clients, e.g. mgcamd, does not support keepalive. So if not answered, keep connection
@@ -3660,16 +3499,15 @@
 	if(!cl->init_done && !cl->kill)
 	{
 		if(IP_ISSET(cl->ip))
-			{ cs_log_dbg(D_CLIENT, "cccam: new connection from %s", cs_inet_ntoa(cl->ip)); }
+			cs_log_dbg(D_CLIENT, "cccam: new connection from %s", cs_inet_ntoa(cl->ip));
 
 		cl->pfd = cl->udp_fd;
 		int32_t ret;
-		if((ret = cc_srv_connect(cl)) < 0)
-		{
+		if ((ret=cc_srv_connect(cl)) < 0) {
 			if(errno != 0)
-				{ cs_log_dbg(D_CLIENT, "cccam: failed errno: %d (%s)", errno, strerror(errno)); }
+				cs_log_dbg(D_CLIENT, "cccam: failed errno: %d (%s)", errno, strerror(errno));
 			else
-				{ cs_log_dbg(D_CLIENT, "cccam: failed ret: %d", ret); }
+				cs_log_dbg(D_CLIENT, "cccam: failed ret: %d", ret);
 			cs_disconnect_client(cl);
 		}
 		else
@@ -3695,26 +3533,21 @@
 	rdr->card_status = CARD_FAILURE;
 	cl->stopped = 0;
 
-	if(!cc)
-	{
+	if (!cc) {
 		// init internals data struct
-		if(!cs_malloc(&cc, sizeof(struct cc_data)))
-			{ return -1; }
+		if (!cs_malloc(&cc, sizeof(struct cc_data))) return -1;
 		cc_init_locks(cc);
 		cc->cards = ll_create("cards");
 		cl->cc = cc;
 		cc->pending_emms = ll_create("pending_emms");
 		cc->extended_ecm_idx = ll_create("extended_ecm_idx");
 	}
-	else
-	{
+	else {
 		cc_free_cardlist(cc->cards, 0);
 		free_extended_ecm_idx(cc);
 	}
-	if(!cc->prefix)
-	{
-		if(!cs_malloc(&cc->prefix, strlen(cl->reader->label) + 20))
-			{ return -1; }
+	if (!cc->prefix) {
+		if (!cs_malloc(&cc->prefix, strlen(cl->reader->label) + 20)) return -1;
 	}
 	snprintf(cc->prefix, strlen(cl->reader->label) + 20, "cccam(r) %s:", cl->reader->label);
 
@@ -3725,10 +3558,10 @@
 	char pwd[64];
 
 	// check cred config
-	if(rdr->device[0] == 0 || rdr->r_pwd[0] == 0 || rdr->r_usr[0] == 0
-			|| rdr->r_port == 0)
+	if (rdr->device[0] == 0 || rdr->r_pwd [0] == 0 || rdr->r_usr [0] == 0 ||
+		 rdr->r_port == 0)
 	{
-		cs_log("%s configuration error!", rdr->label);
+		cs_log("%s configuration error.", rdr->label);
 		return -5;
 	}
 
@@ -3736,11 +3569,14 @@
 	handle = network_tcp_connection_open(rdr);
 	if(handle <= 0)
 	{
-		cs_log_dbg(D_READER, "%s network connect error!", rdr->label);
+//		cs_log_dbg(D_READER, "%s network connect error!", rdr->label);
+		cs_log("%s connection error{%d}.", rdr->label, handle);
 		return -1;
 	}
 	if(errno == EISCONN)
 	{
+		/* Transport endpoint is already connected */
+		cs_log("%s connection eisconn.", rdr->label);
 		cc_cli_close(cl, 0);
 		block_connect(rdr);
 		return -1;
@@ -3749,14 +3585,16 @@
 	// get init seed
 	if((n = cc_recv_to(cl, data, 16)) != 16)
 	{
-		if(n <= 0)
-			{ cs_log("init error from reader %s", rdr->label); }
-		else
+		if (n <= 0) {
+			cs_log("%s server seed error.", rdr->label);
+		}
+		else {
 			cs_log("%s server returned %d instead of 16 bytes as init seed (errno=%d %s)",
 				   rdr->label, n, errno, strerror(errno));
+		}
 		cc_cli_close(cl, 0);
 		block_connect(rdr);
-		return -2;
+		return -9;
 	}
 
 	cc->ecm_counter = 0;
@@ -3785,12 +3623,11 @@
 	uint16_t sum = 0x1234;
 	uint16_t recv_sum = (data[14] << 8) | data[15];
 	int32_t i;
-	for(i = 0; i < 14; i++)
-	{
+	for (i = 0; i < 14; i++) {
 		sum += data[i];
 	}
 	//Create special data to detect oscam-cccam:
-	cc->is_oscam_cccam = sum == recv_sum;
+	cc->is_oscam_cccam = (sum == recv_sum);
 
 	cc_xor(data); // XOR init bytes with 'CCcam'
 
@@ -3811,7 +3648,12 @@
 
 	memset(buf, 0, CC_MAXMSGSIZE);
 	memcpy(buf, rdr->r_usr, strlen(rdr->r_usr));
+	if (cfg.logsvrsecrete) {
+		cs_debug_mask_sensitive(D_CLIENT, "cccam: username {%s}", buf);
+	}
+	else {
 	cs_log_dump_dbg(D_CLIENT, buf, 20, "cccam: username '%s':", buf);
+	}
 	cc_cmd_send(cl, buf, 20, MSG_NO_HEADER); // send usr '0' padded -> 20 bytes
 
 	memset(buf, 0, CC_MAXMSGSIZE);
@@ -3823,25 +3665,23 @@
 	cc_crypt(&cc->block[ENCRYPT], (uint8_t *) pwd, strlen(pwd), ENCRYPT);
 	cc_cmd_send(cl, buf, 6, MSG_NO_HEADER); // send 'CCcam' xor w/ pwd
 
-	if((n = cc_recv_to(cl, data, 20)) != 20)
-	{
+	if ((n = cc_recv_to(cl, data, 20)) != 20) {
+		myprintf("??? cccam(%s,%s) {%d} fail!\n", rdr->r_usr, rdr->r_pwd, n);
 		cs_log("%s login failed, usr/pwd invalid", getprefix());
 		cc_cli_close(cl, 0);
 		block_connect(rdr);
 		return -2;
 	}
 	cc_crypt(&cc->block[DECRYPT], data, 20, DECRYPT);
-	cs_log_dump_dbg(D_CLIENT, data, 20, "cccam: login failed, usr/pwd invalid");
+	cs_log_dump_dbg(D_CLIENT, data, 20, "cccam: login");
 
-	if(memcmp(data, buf, 5))    // check server response
-	{
+	if (memcmp(data, buf, 5)) { // check server response
 		cs_log("%s login failed, usr/pwd invalid", getprefix());
 		cc_cli_close(cl, 0);
 		block_connect(rdr);
 		return -2;
 	}
-	else
-	{
+	else {
 		cs_log_dbg(D_READER, "%s login succeeded", getprefix());
 	}
 
@@ -3850,8 +3690,7 @@
 	cl->pfd = cl->udp_fd;
 	cs_log_dbg(D_READER, "cccam: pfd=%d", cl->pfd);
 
-	if(cc_send_cli_data(cl) <= 0)
-	{
+	if (cc_send_cli_data(cl) <= 0) {
 		cs_log("%s login failed, could not send client data", getprefix());
 		cc_cli_close(cl, 0);
 		block_connect(rdr);
@@ -3887,20 +3726,16 @@
 int32_t cc_cli_init_int(struct s_client *cl)
 {
 	struct s_reader *rdr = cl->reader;
-	if(rdr->tcp_connected)
-		{ return 1; }
+	if (rdr->tcp_connected) return 1;
 
-	if(rdr->tcp_ito < 1)
-		{ rdr->tcp_ito = 30; }
-	if(rdr->cc_maxhops < 0)
-		{ rdr->cc_maxhops = DEFAULT_CC_MAXHOPS; }
+	if (rdr->tcp_ito    < 1) rdr->tcp_ito = 30; // sky(30->60)
+	if (rdr->cc_maxhops < 0) rdr->cc_maxhops = DEFAULT_CC_MAXHOPS;
 
-	if(rdr->tcp_rto < 1)
-		{ rdr->tcp_rto = 30; } // timeout to 30s
-	cs_log_dbg(D_READER, "cccam: inactivity timeout: %d seconds, receive timeout: %d seconds", rdr->tcp_ito, rdr->tcp_rto);
+	if (rdr->tcp_rto    < 1) rdr->tcp_rto = 30; // sky(30->60).timeout to 30s
 	cc_check_version(rdr->cc_version, rdr->cc_build);
-	cs_log_dbg(D_READER, "proxy reader: %s (%s:%d) cccam v%s build %s, maxhops: %d",
-				  rdr->label, rdr->device, rdr->r_port, rdr->cc_version,
+	cs_log_dbg(D_READER, "cccam: inactivity timeout: %d seconds, receive timeout: %d seconds", rdr->tcp_ito, rdr->tcp_rto);
+	cs_log_dbg(D_READER, "cccam: %s: v%s build %s, maxhops: %d",
+			rdr->label, rdr->cc_version,
 				  rdr->cc_build, rdr->cc_maxhops);
 
 	return 0;
@@ -3910,29 +3745,40 @@
 {
 	struct s_reader *reader = cl->reader;
 
-	int32_t res = cc_cli_init_int(cl); //Create socket
+	int32_t nre = 0;
+	int32_t res = cc_cli_init_int(cl); // create socket
 
 	if(res == 0 && reader && (reader->cc_keepalive || !cl->cc) && !reader->tcp_connected)
 	{
-
-		cc_cli_connect(cl); //connect to remote server
-
-		//      while (!reader->tcp_connected && reader->cc_keepalive && cfg.reader_restart_seconds > 0) {
-		//
+		nre = cc_cli_connect(cl); // connect to remote server
+// sky(n.test)
+#if 0
+		if (nre==-9)
+		{
+			cs_log("init reconnect from reader %s", reader->label);
+			cs_sleepms(1000);
+			res = cc_cli_init_int(cl);
+			conres = cc_cli_connect(cl);
+		}
+#endif
+//		while (!reader->tcp_connected && reader->cc_keepalive && cfg.reader_restart_seconds > 0)
+//		{
 		//          if ((cc && cc->mode == CCCAM_MODE_SHUTDOWN))
 		//              return -1;
 		//
 		//          if (!reader->tcp_connected) {
 		//              cc_cli_close(cl, 0);
 		//              res = cc_cli_init_int(cl);
-		//              if (res)
-		//                  return res;
+//				if (res) return res;
 		//          }
 		//          cs_log_dbg(D_READER, "%s restarting reader in %d seconds", reader->label, cfg.reader_restart_seconds);
 		//          cs_sleepms(cfg.reader_restart_seconds*1000);
 		//          cs_log_dbg(D_READER, "%s restarting reader...", reader->label);
 		//          cc_cli_connect(cl);
 		//      }
+		if (nre==0) {
+			cs_log("succeeded connect from reader %s", reader->label);
+		}
 	}
 	return res;
 }
@@ -3943,17 +3789,19 @@
  */
 int32_t cc_available(struct s_reader *rdr, int32_t checktype, ECM_REQUEST *er)
 {
-	if(!rdr || !rdr->client) { return 0; }
+	if (!rdr || !rdr->client) return 0;
 
 	struct s_client *cl = rdr->client;
-	if(!cl) { return 0; }
+	if (!cl) return 0;
 	struct cc_data *cc = cl->cc;
 
 	if(er && cc && rdr->tcp_connected)
 	{
 		struct cc_card *card  = get_matching_card(cl, er, 1);
-		if(!card)
-			{ return 0; }
+		if (!card) {
+			cs_log_dbg(D_TRACE, "%s get_matching_card none", rdr->label);
+			return 0;
+		}
 	}
 	//cs_log_dbg(D_TRACE, "checking reader %s availibility", rdr->label);
 	if(!cc || rdr->tcp_connected != 2)
@@ -3964,8 +3812,10 @@
 		// 2. Keepalive OFF but not connected: Send requests to connect
 		//     pipe won't run full, because we are reading from pipe to
 		//     get the ecm request
-		if(rdr->cc_keepalive)
-			{ return 0; }
+		if (rdr->cc_keepalive) {
+			cs_log_dbg(D_TRACE, "%s cc_keepalive on", rdr->label);
+			return 0;
+		}
 	}
 
 	//if (er && er->ecmlen > 255 && cc && !cc->extended_mode && (cc->remote_build_nr < 3367))
@@ -3974,12 +3824,11 @@
 
 	if(checktype == AVAIL_CHECK_LOADBALANCE && cc && cc->ecm_busy)
 	{
-		if(cc_request_timeout(cl))
-			{ cc_cycle_connection(cl); }
-		if(!rdr->tcp_connected || cc->ecm_busy)
-		{
-			cs_log_dbg(D_TRACE, "checking reader %s availibility=0 (unavail)",
-						  rdr->label);
+		if (cc_request_timeout(cl)) {
+			cc_cycle_connection(cl);
+		}
+		if (!rdr->tcp_connected || cc->ecm_busy) {
+			cs_log_dbg(D_TRACE, "checking reader %s availibility=0 (unavail)", rdr->label);
 			return 0; //We are processing EMMs/ECMs
 		}
 	}
@@ -3997,13 +3846,13 @@
 	struct s_reader *rdr = cl->reader;
 
 	if(rdr && !rdr->tcp_connected)
-		{ cc_cli_connect(cl); }
+		cc_cli_connect(cl);
 }
 
 void cc_cleanup(struct s_client *cl)
 {
-	if(cl->typ != 'c')
-	{
+	if (cl->typ != 'c') {
+		myprintf("cccam:cc_cleanup\n");
 		cc_cli_close(cl, 1); // we need to close open fd's
 	}
 	cc_free(cl);
@@ -4020,8 +3869,7 @@
 	uint16_t sum = 0x1234; //This is our checksum
 	int32_t i;
 	get_random_bytes(cc_node_id, 4);
-	for(i = 0; i < 4; i++)
-	{
+	for (i = 0; i < 4; i++) {
 		sum += cc_node_id[i];
 	}
 
@@ -4031,8 +3879,7 @@
 
 	// generate checksum for Partner ID:
 	cc_node_id[5] = 0xAA;
-	for(i = 0; i < 5; i++)
-	{
+	for (i = 0; i < 5; i++) {
 		cc_node_id[5] ^= cc_node_id[i];
 	}
 	sum += cc_node_id[5];
@@ -4054,7 +3901,7 @@
 		{
 			ea->status &= ~(READER_ACTIVE | READER_FALLBACK);
 			if(card->origin_reader == ea->reader)
-				{ eab = ea; }
+				eab = ea;
 		}
 		if(eab)
 		{
@@ -4092,12 +3939,10 @@
 static void cc_s_idle(struct s_client *cl)
 {
 	cs_log_dbg(D_TRACE, "ccc idle %s", username(cl));
-	if(cfg.cc_keep_connected)
-	{
+	if (cfg.cc_keep_connected) {
 		cc_cmd_send(cl, NULL, 0, MSG_KEEPALIVE);
 	}
-	else
-	{
+	else {
 		cs_log_dbg(D_CLIENT, "%s keepalive after maxidle is reached", getprefix());
 		cs_disconnect_client(cl);
 	}
@@ -4134,15 +3979,14 @@
 
 #ifdef MODULE_CCCSHARE
 	int32_t i;
-	for(i = 0; i < CS_MAXPORTS; i++)
-	{
-		if(!cfg.cc_port[i]) { break; }
+	for (i=0;i<CS_MAXPORTS;i++) {
+		if (!cfg.cc_port[i]) break;
 		ph->ptab.ports[i].s_port = cfg.cc_port[i];
 		ph->ptab.nports++;
 	}
 
 	if(cfg.cc_port[0])
-		{ cccam_init_share(); }
+		cccam_init_share();
 #endif
 }
 #endif
Index: module-cccam.h
===================================================================
--- module-cccam.h	(revision 10670)
+++ module-cccam.h	(working copy)
@@ -28,18 +28,9 @@
 bool cccam_snprintf_cards_stat(struct s_client *cl, char *emmtext, size_t emmtext_sz);
 bool cccam_client_extended_mode(struct s_client *cl);
 #else
-static inline bool cccam_forward_origin_card(ECM_REQUEST *UNUSED(er))
-{
-	return false;
-}
-static inline bool cccam_snprintf_cards_stat(struct s_client *UNUSED(cl), char *UNUSED(emmtext), size_t UNUSED(emmtext_sz))
-{
-	return false;
-}
-static inline bool cccam_client_extended_mode(struct s_client *UNUSED(cl))
-{
-	return false;
-}
+static inline bool cccam_forward_origin_card(ECM_REQUEST *UNUSED(er)) { return false; }
+static inline bool cccam_snprintf_cards_stat(struct s_client *UNUSED(cl), char *UNUSED(emmtext), size_t UNUSED(emmtext_sz)) { return false; }
+static inline bool cccam_client_extended_mode(struct s_client *UNUSED(cl)) { return false; }
 #endif
 
 #endif
Index: module-constcw.c
===================================================================
--- module-constcw.c	(revision 10670)
+++ module-constcw.c	(working copy)
@@ -3,150 +3,424 @@
 //FIXME Not checked on threadsafety yet; after checking please remove this line
 #include "globals.h"
 #ifdef MODULE_CONSTCW
+#include "oscam-conf.h"
 #include "oscam-client.h"
+#include "oscam-chk.h"
 #include "oscam-ecm.h"
 #include "oscam-net.h"
 #include "oscam-string.h"
+#include "oscam-array.h"
+#include "module-dvbapi.h"
+#include "module-constcw.h"
+//
+//
+//
+#if 1
+	#define	MYCONST_TRACE	myprintf
+#else
+	#define	MYCONST_TRACE(...)
+#endif
+//
+//
+//
+//
+//
+struct xconst_keydata
+{
+	int16_t	found;
+	uint16_t	caid;
+	uint32_t	ppid;
+	uint32_t	freq;
+	uint32_t	ecmpid;
+	uint32_t	pmtpid;
+	uint32_t	vpid;
+	uint32_t	srvid;
+	uint8_t	constcw[16];
+};
+struct xconst_keydata g_xconst[MAX_DEMUX];
 
 static int32_t pserver;
+static int16_t		cFTA_Maxes = 0;
+static FTA_BISTAB	cFTA_Biss[MAX_FTABISS];
+
 
-int32_t constcw_file_available(void)
+bool
+CONSTCW_IsFtaBisses(struct s_reader *reader, uint16_t ccaid, uint32_t cpfid, uint16_t csrvid, uint16_t cvidpid, uint16_t cdgrid)
 {
+#if 0
+	// CAID:PROVIDER:SID:VPID:ECMPID::XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+	// CAID:PROVIDER:SID:PMTPID:ECMPID:VPID:XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+
 	FILE *fp;
+	char 	 token[512];
+	uint32_t caid, provid, srvid, vidpid, pmtpid, ecmpid;
+	uint32_t cwiv[16];
+	int32_t  cwfound = 0;
+	int rcval;
+
+	fp = open_config_file(reader->device);
+	if (!fp) return 0;
 
-	fp = fopen(cur_client()->reader->device, "r");
-	if(!fp)
+	while (fgets(token, sizeof(token), fp))
 	{
-		cs_log("ERROR: Can't open %s (errno=%d %s)", cur_client()->reader->device, errno, strerror(errno));
-		return (0);
+
+		if (token[0]=='#') continue;
+		if (token[0]=='<') continue;
+		if (token[0]==' ') continue;
+		caid  = provid = srvid = vidpid = ecmpid = pmtpid = 0;
+		memset(cwiv, 0, sizeof(cwiv));
+		rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x::%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &srvid, &vidpid, &ecmpid,
+							&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+							&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+
+		if (rcval != 13 && rcval != 21) {
+			rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x:%4x:%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &srvid, &pmtpid, &ecmpid, &vidpid,
+				   		&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+				   		&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+			if (rcval != 14 && rcval != 22) continue;
+		}
+
+		if ((ccaid == caid) &&
+			 (csrvid== srvid)  &&
+			 (cpfid ==provid) &&
+			 (cdgrid ==ecmpid) &&
+			 (cvidpid==vidpid))
+		{
+			MYCONST_TRACE("myconst:fta.constcw.%04X:%06X:%04X:%04X:%04X\n",
+					ccaid, cpfid, csrvid, cvidpid, cdgrid);
+			cwfound = 1;
+			break;
+		}
 	}
 	fclose(fp);
-	return (1);
+	return (cwfound);
+#else
+	int i;
+
+	for (i=0; i<cFTA_Maxes; i++)
+	{
+		if ( cFTA_Biss[i].caid   != ccaid) continue;
+		if ( cFTA_Biss[i].edgrid != cdgrid) continue;
+		if (!cFTA_Biss[i].srvid  || cFTA_Biss[i].srvid != csrvid)  continue;
+//		if (!cFTA_Biss[i].pfid   || cFTA_Biss[i].pfid  != cpfid)   continue;
+		if (!cFTA_Biss[i].pfid   || cFTA_Biss[i].pfid   < cpfid-1 || cFTA_Biss[i].pfid > cpfid+1) continue;
+		if ( cFTA_Biss[i].vidpid && cFTA_Biss[i].vidpid!= cvidpid) continue;
+		return 1;
+	}
+	return 0;
+#endif
 }
 
-int32_t constcw_analyse_file(uint16_t c_caid, uint32_t c_prid, uint16_t c_sid, uint16_t c_pmtpid, uint32_t c_vpid, uint16_t c_ecmpid, uchar *dcw)
+static bool
+constcw_analyser(struct s_client *client)
 {
+	// CAID:PROVIDER:SID:VPID:ECMPID::XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
 	//CAID:PROVIDER:SID:PMTPID:ECMPID:VPID:XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
 	FILE *fp;
 	char token[512];
-	uint32_t caid, provid, sid, vpid, pmtpid, ecmpid;
-	int32_t cw[16];
+	uint32_t frequency, degree;
+	uint32_t caid, provid, srvid, vidpid, pmtpid, ecmpid;
+	uint32_t cwiv[16];
+	int32_t  counter = 0;
+	CAIDTAB_DATA xcts[CS_MAXCAIDTAB];
+	int numcaids = 0;
+	int rcval;
+	int i;
+
+	cFTA_Maxes = 0;
+	caidtab_clear(&client->reader->ctab);
+	fp = open_config_file(client->reader->device);
+	if (!fp) return 0;
 
-	fp = fopen(cur_client()->reader->device, "r");
-	if(!fp)
+	while (fgets(token, sizeof(token), fp))
 	{
-		cs_log("ERROR: Can't open %s (errno=%d %s)", cur_client()->reader->device, errno, strerror(errno));
-		return (0);
+		if (counter > MAX_FTABISS-1) break;
+		if (token[0]=='#') continue;
+		if (token[0]=='<') continue;
+		if (token[0]==' ') continue;
+		caid  = provid = srvid = vidpid = ecmpid = pmtpid = 0;
+		memset(cwiv, 0, sizeof(cwiv));
+		rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x::%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &srvid, &vidpid, &ecmpid,
+							&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+							&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+
+		if (rcval != 13 && rcval != 21) {
+			rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x:%4x:%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &srvid, &pmtpid, &ecmpid, &vidpid,
+				   		&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+				   		&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+			if (rcval != 14 && rcval != 22) continue;
+		}
+		frequency = cs_BCD2i(provid);
+		degree = cs_BCD2i(ecmpid);
+		if ((caid_is_biss(caid)) &&
+			 (srvid)  &&
+			 (frequency && (frequency > 950 && frequency < 15000)) &&
+			 (degree < 3600) &&
+			 (vidpid && vidpid < 0x1fff))
+		{
+			MYCONST_TRACE("myconst:f.constcw.%04X:%06X:%04X:%04X:%04X\n",
+					caid, provid, srvid, vidpid, ecmpid);
+			cFTA_Biss[counter].caid   = caid;
+			cFTA_Biss[counter].srvid  = srvid;
+			cFTA_Biss[counter].pfid   = provid;
+			cFTA_Biss[counter].vidpid = vidpid;
+			cFTA_Biss[counter].edgrid = ecmpid;
+			counter++;
+		}
+
+		for (i=0; i<numcaids; i++)	{
+			if (xcts[i].caid == caid) break;
+		}
+		if (i==numcaids)
+		{
+			if (numcaids>(CS_MAXCAIDTAB-1)) {
+				mycs_debug(D_ADB, "xcaskey:CA{%04X} CS_MAXCAIDTAB exceed\n", caid);
+				break;
+			}
+			mycs_debug(D_ADB, "constcw:ctab.caid:%04X\n", caid);
+			xcts[numcaids].mask = 0xffff;
+			xcts[numcaids].cmap = 0x0;
+			xcts[numcaids].caid = caid;
+			caidtab_add(&client->reader->ctab, &xcts[numcaids]);
+			numcaids++;
+		}
+	}
+	fclose(fp);
+	cFTA_Maxes = counter;
+	return (counter);
 	}
 
-	cs_log("Searching CW for CAID %04X PROVID %06X SRVID %04X ECMPID %04X PMTPID %04X VPID %04X", c_caid, c_prid, c_sid, c_ecmpid, c_pmtpid, c_vpid);
-
-	while(fgets(token, sizeof(token), fp))
-	{
-		if(token[0] == '#') { continue; }
-		vpid = 0;
-		int ret = sscanf(token, "%4x:%6x:%4x:%4x:%4x::%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x", &caid, &provid, &sid, &pmtpid, &ecmpid,
-			   &cw[0], &cw[1], &cw[2], &cw[3], &cw[4], &cw[5], &cw[6], &cw[7],
-			   &cw[8], &cw[9], &cw[10], &cw[11], &cw[12], &cw[13], &cw[14], &cw[15]);
-		
-		if(ret != 21){   
-			ret = sscanf(token, "%4x:%6x:%4x:%4x:%4x:%4x:%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x", &caid, &provid, &sid, &pmtpid, &ecmpid, &vpid,
-				   &cw[0], &cw[1], &cw[2], &cw[3], &cw[4], &cw[5], &cw[6], &cw[7],
-				   &cw[8], &cw[9], &cw[10], &cw[11], &cw[12], &cw[13], &cw[14], &cw[15]);
-			if(ret != 22) continue;
-		}		
-
-		//cs_log("Line found: %s", token);
-		if(c_caid == caid && c_sid == sid && (!provid || provid == c_prid) && (!pmtpid || !c_pmtpid || pmtpid == c_pmtpid) && (!vpid || !c_vpid || vpid == c_vpid) 
-				&& (!ecmpid || !c_ecmpid || ecmpid == c_ecmpid))
+static int32_t
+constcw_available(struct s_client *client)
 		{
+	FILE *fp;
+
+	if (!client) return 0;
+//	fp = fopen(client->reader->device, "r");
+	fp = open_config_file(client->reader->device);
+	if (!fp) return 0;
 			fclose(fp);
-			int8_t i;
-			for(i = 0; i < 16; ++i)
-				{ dcw[i] = (uchar) cw[i]; }
-			cs_log("Entry found: %04X:%06X:%04X:%04X:%04X:%04X:%s", caid, provid, sid, pmtpid, ecmpid, vpid, cs_hexdump(1, dcw, 16, token, sizeof(token)));
 			return 1;
 		}
+
+static int32_t
+constcw_search(struct s_client *client, ECM_REQUEST *er, uchar *dcw)
+{
+	// CAID:PROVIDER:SID:VPID:ECMPID::XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+	// CAID:PROVIDER:SID:PMTPID:ECMPID:VPID:XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+	struct xconst_keydata *pxconst;
+	FILE 	*fp;
+	char 	 token[512];
+	uint32_t caid, provid, sid, vpid, pmtpid, ecmpid;
+	uint32_t cwiv[16];
+	int32_t  cwfound = 0;
+	int32_t  dmuxid;
+
+	if (!er) return 0;
+	if (!client) return 0;
+	MYCONST_TRACE("myconst:searching constcw.%04X:%06X:%04X:%04X:%04X\n",
+			er->caid, er->prid, er->srvid, er->vpid, er->pid);
+	dmuxid  = er->dmuxid % MAX_DEMUX;
+	pxconst = &g_xconst[dmuxid];
+	if (pxconst->caid == er->caid && pxconst->srvid == er->srvid && pxconst->ecmpid == er->pid && pxconst->vpid == er->vpid)
+	{
+		if (!pxconst->found) return 0;
+		memcpy(dcw, pxconst->constcw, 16);
+		MYCONST_TRACE("myconst:CONSTANT:%04X.%5d:%02X...%02X\n", er->caid, er->srvid, dcw[0], dcw[7]);
+		return 1;
 	}
+	pxconst->caid   = er->caid;
+	pxconst->ppid   = er->prid;
+	pxconst->freq	 = er->chSets.frequency;
+	pxconst->srvid  = er->srvid;
+	pxconst->pmtpid = er->pmtpid;
+	pxconst->ecmpid = er->pid;
+	pxconst->vpid   = er->vpid;
+	pxconst->found  = 0;
+
+//	fp = fopen(cur_client()->reader->device, "r");
+	fp = open_config_file(client->reader->device);
+	if (!fp) return 0;
 
+	while (fgets(token, sizeof(token), fp))
+	{
+		int rcval;
+		int singly = 0;
+		int i;
+
+		if (token[0]=='#') continue;
+		if (token[0]=='<') continue;
+		if (token[0]==' ') continue;
+		singly= 0;
+		caid  = provid = sid = vpid = ecmpid = pmtpid = 0;
+		memset(cwiv, 0, sizeof(cwiv));
+		rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x::%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &sid, &vpid, &ecmpid,
+							&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+							&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+//		MYCONST_TRACE("rcval: %d\n", rcval);
+		if (rcval == 13) singly = 1;
+		if (rcval != 13 && rcval != 21) {
+			rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x:%4x:%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &sid, &pmtpid, &ecmpid, &vpid,
+				   		&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+				   		&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+			if (rcval == 14) singly = 1;
+			if (rcval != 14 && rcval != 22) continue;
+		}
+
+//		MYCONST_TRACE("Line found: %s", token);
+		uint32_t freqid = cs_BCD2i(provid);
+		if (( er->caid == caid) &&
+			 ( er->srvid== sid)  &&
+			 ( er->chSets.frequency==freqid || er->chSets.frequency==freqid-1 || er->chSets.frequency==freqid+1 || er->prid==provid) &&
+		/*	 (!ecmpid || !er->pid || er->pid==ecmpid) && */
+			 (!pmtpid || !er->pmtpid || er->pmtpid==pmtpid) &&
+			 (!vpid   || !er->vpid || er->vpid==vpid))
+		{
+			for (i=0; i<16;i++) dcw[i] = cwiv[i];
+			if (singly) memcpy(&dcw[8], &dcw[0], 8);
+			cs_log("Entry found: %04X:%06X:%04X:%04X:%04X::%s",
+					caid, provid, sid, vpid, ecmpid,
+					cs_hexdump(1, dcw, 16, token, sizeof(token)));
+			pxconst->found = 1;
+			memcpy(pxconst->constcw, dcw, 16);
+			MYCONST_TRACE("myconst:constcw.%04X:%06X:%04X:%04X:%04X::%02X...%02X:%02X...%02X\n",
+					caid, provid, sid, vpid, ecmpid,
+					dcw[0], dcw[7], dcw[8], dcw[15]);
+			cwfound = 1;
+			break;
+		}
+	}
 	fclose(fp);
-	return 0;
+	return (cwfound);
 }
-//************************************************************************************************************************
+//**********************************************************************
 //* client/server common functions
-//************************************************************************************************************************
-static int32_t constcw_recv(struct s_client *client, uchar *buf, int32_t l)
+//**********************************************************************
+static int32_t
+constcw_recv(struct s_client *client, uchar *buf, int32_t l)
 {
 	int32_t ret;
 
-	if(!client->udp_fd) { return (-9); }
+	MYCONST_TRACE("myconst:constcw_recv...\n");
+	if (!client->udp_fd) return(-9);
 	ret = read(client->udp_fd, buf, l);
-	if(ret < 1) { return (-1); }
+	if (ret < 1) return -1;
 	client->last = time(NULL);
 	return (ret);
 }
 
-//************************************************************************************************************************
+//**********************************************************************
 //*       client functions
-//************************************************************************************************************************
-int32_t constcw_client_init(struct s_client *client)
+//**********************************************************************
+static int32_t
+constcw_client_init(struct s_client *client)
 {
 	int32_t fdp[2];
 
+	MYCONST_TRACE("myconst:constcw_client_init...\n");
 	client->pfd = 0;
 	if(socketpair(PF_LOCAL, SOCK_STREAM, 0, fdp))
 	{
-		cs_log("ERROR: Socket creation failed: %s", strerror(errno));
+		cs_log("constcw: Socket creation failed (%s)", strerror(errno));
 		return 1;
 	}
 	client->udp_fd = fdp[0];
 	pserver = fdp[1];
-
+	memset(&g_xconst,0, sizeof(g_xconst));
 	memset((char *) &client->udp_sa, 0, sizeof(client->udp_sa));
 	SIN_GET_FAMILY(client->udp_sa) = AF_INET;
 
 	// Oscam has no reader.au in s_reader like ki's mpcs ;)
 	// reader[ridx].au = 0;
 	// cs_log("local reader: %s (file: %s) constant cw au=0", reader[ridx].label, reader[ridx].device);
-	cs_log("Local reader: %s (file: %s)", client->reader->label, client->reader->device);
+	cs_log("local reader: %s (file: %s) constant cw", client->reader->label, client->reader->device);
 
 	client->pfd = client->udp_fd;
-
-	if(constcw_file_available())
+	if (constcw_available(client))
 	{
+		constcw_analyser(client);
 		client->reader->tcp_connected = 2;
 		client->reader->card_status = CARD_INSERTED;
 	}
+	client->reader->tcp_ito = 0;
+	client->reader->last_s = client->reader->last_g = time(NULL);
+	return 0;
+}
 
-	return (0);
+
+static void
+constcw_clidle(void)
+{
+	struct s_client *client = cur_client();
+	time_t  now;
+	int32_t time_diff;
+
+	if (!client) return;
+	if (!client->reader) return;
+	if (!client->reader->enable) return;
+	if ( client->reader->ch_descramble) return;
+
+	time(&now);
+	time_diff = now - client->reader->last_s;
+	if (time_diff > 12)
+	{
+#if defined(WITH_HISILICON)
+		if (chk_av_descrambling(client)) {
+			client->reader->ch_descramble = 1;
+			client->reader->tcp_ito = 0;
+			mycs_debug(D_ADB, "constcw:descrambling");
+		}
+		else {
+			mycs_debug(D_ADB, "constcw:scrambled");
+			dvbapi_constcw_afterwards(R_CONSTCW, client->ch_ics.muxid, 1);
+		}
+#endif
+	}
 }
 
-static int32_t constcw_send_ecm(struct s_client *client, ECM_REQUEST *er, uchar *UNUSED(msgbuf))
+static int32_t
+constcw_send_ecm(struct s_client *client, ECM_REQUEST *er, uchar *UNUSED(msgbuf))
 {
-	time_t t;
-	struct s_reader *rdr = client->reader;
-	uchar cw[16];
+	uint8_t cw[16];
+	int cwfound = 0;
 
-	t = time(NULL);
+	if (!er) return 0;
+	if (!client->reader) return 0;
+	if ( client->reader->card_status != CARD_INSERTED) return 0;
+	MYCONST_TRACE("myconst:constcw_send_ecm...\n");
+	cs_log("searching constcw %04X:%06X:%04X:%04X", er->caid, er->prid, er->srvid, er->vpid);
 	// Check if DCW exist in the files
-	//cs_log("Searching ConstCW for ECM: %04X:%06X:%04X (%d)", er->caid, er->prid, er->srvid, er->l);
-
-	if(constcw_analyse_file(er->caid, er->prid, er->srvid, er->pmtpid, er->vpid, er->pid, cw) == 0)
+	cwfound = constcw_search(client, er, cw);
+	if (cwfound)
 	{
-		write_ecm_answer(rdr, er, E_NOTFOUND, (E1_READER << 4 | E2_SID), NULL, NULL);
+		er->ecm_bypass = 1;
+		set_cw_checksum(cw, 16);
+		write_ecm_answer(client->reader, er, E_FOUND, 0, cw, NULL, NULL);
 	}
 	else
 	{
-		write_ecm_answer(rdr, er, E_FOUND, 0, cw, NULL);
+		MYCONST_TRACE("myconst:constcw.none\n");
+	//	sky(!)
+	//	write_ecm_answer(client->reader, er, E_NOTFOUND, (E1_READER<<4 | E2_SID), NULL, NULL, NULL);
 	}
 
-	client->last = t;
-	rdr->last_g = t;
-	return (0);
+	time_t now = time(NULL);
+	client->last = now;
+	client->reader->last_s  = client->reader->last_g = now;
+	client->reader->tcp_ito = 10;
+	return 0;
 }
 
-static int32_t constcw_recv_chk(struct s_client *UNUSED(client), uchar *UNUSED(dcw), int32_t *rc, uchar *UNUSED(buf), int32_t UNUSED(n))
+static int32_t
+constcw_recv_chk(struct s_client *UNUSED(client), uchar *UNUSED(dcw), int32_t *rc, uchar *UNUSED(buf), int32_t UNUSED(n))
 {
+	MYCONST_TRACE("myconst:constcw_recv_chk...\n");
 	//dcw = dcw;
 	//n = n;
 	//buf = buf;
@@ -150,13 +424,35 @@
 	//dcw = dcw;
 	//n = n;
 	//buf = buf;
-
 	*rc = 0;
-	return (-1);
+	return -1;
+}
+
+static int32_t
+constcw_ChCloser(struct s_client *client, int muxid)
+{
+	MYCONST_TRACE("constcw:closer\n");
+	if (!client) return -1;
+	if (!client->reader) return -1;
+	client->reader->tcp_ito = 0;
+	client->reader->ch_descramble = 0;
+	return 1;
+}
+
+static int32_t
+constcw_Cleanup(struct s_client *client)
+{
+	MYCONST_TRACE("constcw:cleanup\n");
+	if (!client) return -1;
+	if (!client->reader) return -1;
+	client->reader->tcp_ito = 0;
+	memset(&g_xconst,0, sizeof(g_xconst));
+	return 1;
 }
 
 void module_constcw(struct s_module *ph)
 {
+	MYCONST_TRACE("MODULE_constcw...\n");
 	ph->desc = "constcw";
 	ph->type = MOD_NO_CONN;
 	ph->listenertype = LIS_CONSTCW;
@@ -161,10 +457,13 @@
 	ph->type = MOD_NO_CONN;
 	ph->listenertype = LIS_CONSTCW;
 	ph->recv = constcw_recv;
-
 	ph->c_init = constcw_client_init;
+	ph->c_idle			= constcw_clidle;
 	ph->c_recv_chk = constcw_recv_chk;
 	ph->c_send_ecm = constcw_send_ecm;
+	ph->c_Cleanup		= constcw_Cleanup;
+	ph->c_ChCloser		= constcw_ChCloser;
 	ph->num = R_CONSTCW;
 }
-#endif
+#endif	// #ifdef MODULE_CONSTCW
+
Index: module-constcw.h
===================================================================
--- module-constcw.h	(nonexistent)
+++ module-constcw.h	(working copy)
@@ -0,0 +1,18 @@
+#ifndef MODULE_CONSTCW_H_
+#define MODULE_CONSTCW_H_
+#if defined(MODULE_CONSTCW)
+#define MAX_FTABISS	256
+
+typedef struct
+{
+	uint16_t caid;
+	uint32_t pfid;
+	uint16_t srvid;
+	uint16_t vidpid;
+	uint16_t edgrid;
+} FTA_BISTAB;
+
+bool CONSTCW_IsFtaBisses(struct s_reader *reader, uint16_t ccaid, uint32_t cpfid, uint16_t csrvid, uint16_t cvidpid, uint16_t cdgrid);
+#endif	// defined(MODULE_CONSTCW)
+#endif	// #ifndef MODULE_CONSTCW_H_
+
Index: module-csp.c
===================================================================
--- module-csp.c	(revision 10670)
+++ module-csp.c	(working copy)
@@ -53,8 +53,7 @@
 	int8_t rc = (er->rc < E_NOTFOUND) ? E_FOUND : er->rc;
 	uint8_t size = 0, type;
 
-	switch(rc)
-	{
+	switch (rc) {
 	case E_FOUND: // we have the cw
 		size = 29;
 		type = TYPE_REPLY;
@@ -69,12 +68,12 @@
 	}
 
 	uchar *buf;
-	if(!cs_malloc(&buf, size)) { return -1; }
+	if (!cs_malloc(&buf, size)) return -1;
 
 	uint16_t onid = er->onid;
-	if(onid == 0) { onid = FAKE_ONID; }
+	if (onid == 0) onid = FAKE_ONID;
 	uint8_t tag = er->ecm[0];
-	if(tag != 0x80 && tag != 0x81) { tag = FAKE_TAG; }
+	if (tag != 0x80 && tag != 0x81) tag = FAKE_TAG;
 
 	buf[0] = type;
 	buf[1] = tag;
@@ -83,8 +82,7 @@
 	i2b_buf(2, er->caid, buf + 6);
 	i2b_buf(4, er->csp_hash, buf + 8);
 
-	if(rc == E_FOUND)
-	{
+	if (rc == E_FOUND) {
 		buf[12] = tag;
 		memcpy(buf + 13, er->cw, sizeof(er->cw));
 	}
@@ -92,7 +90,7 @@
 	struct timeb tpe;
 	cs_ftime(&tpe);
 
-	if(tpe.time - cl->lastecm > PING_INTVL) { csp_send_ping(cl, 1000 * tpe.time + tpe.millitm); }
+	if (tpe.time - cl->lastecm > PING_INTVL) csp_send_ping(cl, 1000 * tpe.time + tpe.millitm);
 
 	cs_log_dump_dbg(D_TRACE, buf, size, "pushing cache update to csp onid=%04X caid=%04X srvid=%04X hash=%08X (tag: %02X)", onid, er->caid, er->srvid, er->csp_hash, tag);
 
@@ -130,73 +128,61 @@
 static int32_t csp_recv(struct s_client *client, uchar *buf, int32_t l)
 {
 	int32_t rs = 0;
-	if(!client->udp_fd) { return (-9); }
-	if(client->is_udp && client->typ == 'c')
-	{
+	if (!client->udp_fd) return(-9);
+	if (client->is_udp && client->typ == 'c') {
 		rs = recv_from_udpipe(buf); // whats this?
-	}
-	else
-	{
+	} else {
 		rs = recv(client->udp_fd, buf, client->is_udp ? l : 36, 0);
 	}
 	//cs_log_dump_dbg(D_TRACE, buf, rs, "received %d bytes from csp", rs);
 
 	uint8_t type = buf[0]; // TYPE
 
-	switch(type)
-	{
+    switch (type) {
 
 	case TYPE_REPLY: // request hash + reply received:
-		if(rs >= 29)
-		{
+    	  if (rs >= 29) {
 			ECM_REQUEST *er = get_ecmtask();
-			if(!er) { return -1; }
+				if (!er) return -1;
 
 			uint8_t commandTag = parse_request(er, buf + 1);
 			uint8_t rplTag = buf[12];
 
 			er->rc = E_FOUND;
 
-			if(chk_csp_ctab(er, &cfg.csp.filter_caidtab))
-			{
+			if (chk_csp_ctab(er, &cfg.csp.filter_caidtab)) {
 				memcpy(er->cw, buf + 13, sizeof(er->cw));
 				uchar orgname[32] = {0};
-				if(rs >= 31)
-				{
+					if (rs >= 31) {
 					// origin connector name included
 					uint16_t namelen = (buf[29] << 8) | buf[30];
-					if(namelen > sizeof(orgname)) { namelen = sizeof(orgname); }
+						if (namelen > sizeof(orgname)) namelen = sizeof(orgname);
 					memcpy(orgname, buf + 31, namelen);
 				}
 				cs_log_dump_dbg(D_TRACE, er->cw, sizeof(er->cw), "received cw from csp onid=%04X caid=%04X srvid=%04X hash=%08X (org connector: %s, tags: %02X/%02X)", er->onid, er->caid, er->srvid, er->csp_hash, orgname, commandTag, rplTag);
 				cacheex_add_to_cache_from_csp(client, er);
-			}
-			else { NULLFREE(er); }
+			} else NULLFREE(er);
 		}
 		break;
 
 	case TYPE_REQUEST: // pending request notification hash received
-		if(rs == 12)    // ignore requests for arbitration (csp "pre-requests", size 20)
-		{
+			if (rs == 12) { // ignore requests for arbitration (csp "pre-requests", size 20)
 			ECM_REQUEST *er = get_ecmtask();
-			if(!er) { return -1; }
+				if (!er) return -1;
 
 			uint8_t commandTag = parse_request(er, buf + 1);
 
 			er->rc = E_UNHANDLED;
 
-			if(chk_csp_ctab(er, &cfg.csp.filter_caidtab) && cfg.csp.allow_request)
-			{
+			if (chk_csp_ctab(er, &cfg.csp.filter_caidtab) && cfg.csp.allow_request) {
 				cs_log_dump_dbg(D_TRACE, buf, l, "received ecm request from csp onid=%04X caid=%04X srvid=%04X hash=%08X (tag: %02X)", er->onid, er->caid, er->srvid, er->csp_hash, commandTag);
 				cacheex_add_to_cache_from_csp(client, er);
-			}
-			else { NULLFREE(er); }
+			} else NULLFREE(er);
 		}
 		break;
 
 	case TYPE_PINGREQ:
-		if(rs >= 13)
-		{
+			if (rs >= 13) {
 			client->last = time((time_t *) 0);
 			uint32_t port = b2i(4, buf + 9);
 			SIN_GET_PORT(client->udp_sa) = htons(port);
@@ -210,8 +196,7 @@
 		break;
 
 	case TYPE_PINGRPL:
-		if(rs >= 9)
-		{
+			if (rs >= 9) {
 			struct timeb tpe;
 			cs_ftime(&tpe);
 			uint32_t ping = b2i(4, buf + 1);
@@ -222,11 +207,10 @@
 		break;
 
 	case TYPE_RESENDREQ: // sent as a result of delay alert in a remote cache
-		if(rs >= 16)
-		{
+			if (rs >= 16) {
 			uint32_t port = b2i(4, buf + 1);
 			ECM_REQUEST *er = get_ecmtask();
-			if(!er) { return -1; }
+				if (!er) return -1;
 
 			parse_request(er, buf + 5);
 
Index: module-dvbapi-chancache.c
===================================================================
--- module-dvbapi-chancache.c	(revision 10670)
+++ module-dvbapi-chancache.c	(working copy)
@@ -16,11 +16,10 @@
 
 void dvbapi_save_channel_cache(void)
 {
+#if defined(WITH_HISILICON)
+#else
 	if(boxtype_is("dbox2")) return; // dont save channelcache on these boxes, they lack resources and will crash!
 	
-	if (USE_OPENXCAS) // Why?
-		return;
-
 	char fname[256];
 	int32_t result = 0;
 	get_config_filename(fname, sizeof(fname), "oscam.ccache");
@@ -55,10 +54,13 @@
 
 	fclose(file);
 	cs_log("dvbapi channelcache saved to %s", fname);
+#endif
 }
 
 void dvbapi_load_channel_cache(void)
 {
+#if defined(WITH_HISILICON)
+#else
 	if(boxtype_is("dbox2")) return; // dont load channelcache on these boxes, they lack resources and will crash!
 	
 	if (USE_OPENXCAS) // Why?
@@ -121,6 +123,7 @@
 	}
 	fclose(file);
 	cs_log("dvbapi channelcache loaded from %s", fname);
+#endif
 }
 
 struct s_channel_cache *dvbapi_find_channel_cache(int32_t demux_id, int32_t pidindex, int8_t caid_and_prid_only)
Index: module-dvbapi-his.c
===================================================================
--- module-dvbapi-his.c	(nonexistent)
+++ module-dvbapi-his.c	(working copy)
@@ -0,0 +1,1219 @@
+/* Reversed from libhistream.so, this comes without any warranty */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include "globals.h"
+
+#if defined(WITH_HISILICON)
+
+#define DVBAPI_LOG_PREFIX 		1
+#include "module-dvbapi.h"
+#include "module-dvbapi-his.h"
+#include "oscam-string.h"
+#include "oscam-client.h"
+#include "oscam-time.h"
+
+#undef	UNUSED
+#include "hi_unf_demux.h"
+
+#if 1
+	#if (__ADB_TRACE__==1)
+	#define HIPRT_FATAL	myprintf
+	#else
+	#define HIPRT_FATAL	mycs_log
+	#endif
+#else
+	#define HIPRT_FATAL(...)
+#endif
+
+#if 1
+	#if (__ADB_TRACE__==1)
+	#define HIPRT_ERROR	myprintf
+	#else
+	#define HIPRT_ERROR	mycs_log
+	#endif
+#else
+	#define HIPRT_ERROR(...)
+#endif
+
+#if 1
+	#define HIPRT_WARN	myprintf
+#else
+	#define HIPRT_WARN(...)
+#endif
+
+#if 1
+	#define HIPRT_INFO	myprintf
+#else
+	#define HIPRT_INFO(...)
+#endif
+
+#if 1
+	#define HIPRT_TRACE	myprintf
+#else
+	#define HIPRT_TRACE(...)
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/***************************** Macro Definition ************************/
+#define TUNER0	0
+#define TUNER1	1
+#if defined(SDKV600)
+	// demux id 0 to 6
+	#define HIPORT_TUNER_ID 	HI_UNF_DMX_PORT_TSI_0
+	#define HIPORT_INTERNAL_ID HI_UNF_DMX_PORT_TSI_1
+	#define HIDEMUX_OSCAM_ID 	0
+	#define HIDEMUX_OSCAM1_ID 	HIDEMUX_OSCAM_ID
+	#define HIDEMUX_OSCAM2_ID 	5
+#elif defined(SDKV500)
+	// demux id 0 to 6
+	#define HIPORT_TUNER_ID 	HI_UNF_DMX_PORT_TSI_0
+	#define HIDEMUX_OSCAM_ID 	0
+#else
+	#define HIPORT_TUNER_ID 	1
+	#define HIDEMUX_OSCAM_ID	0	// 3
+#endif
+
+
+#define NUM_HIREGION				3
+#define NUM_HIPERREGION			32
+#define MAX_HICHANNEL			(NUM_HIREGION*NUM_HIPERREGION)	// DMX_TOTALCHAN_CNT
+#define MAX_HIFILTERS			(NUM_HIREGION*NUM_HIPERREGION)	// DMX_TOTALFILTER_CNT
+#define NUM_HIFILACQUIRES		32		// 3
+#define NUM_HIFLTDEPTH			16		// DMX_FILTER_MAX_DEPTH
+#define DVB_HIFLTBYTES			8		// DMX_FILTER_MAX_DEPTH
+#define MAX_HIBUFFERSIZE		(64 * 1024)
+#define INVALID_HIFILTER		-1
+#define INVALID_HIHANDLE		HI_INVALID_HANDLE
+
+#define IS_INVALID_PID(x)			((x)>=0x1fff)
+#define IS_INVALID_HIFILTERS(x)	((x)>MAX_HIFILTERS-1 || (x)<0)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#define HIAPI_ISDEMUXINIT() \
+	if (g_DemuxIniz == HI_FALSE) { \
+		HIPRT_FATAL("mydemux:demux none...\n"); \
+		return HI_FAILURE; \
+	}
+
+#define HIAPI_CHECKFILTERID(id) \
+	if ((id) >= MAX_HIFILTERS) { \
+		HIPRT_FATAL("mydemux:invalid filterid(%d)\n", (id)); \
+		return HI_FAILURE; \
+	}
+
+
+#define HIAPI_FILTERREGION(dmxid,region) \
+	if ((dmxid) == 0)      { (region) = 0; } \
+	else if ((dmxid) == 4) { (region) = 2; } \
+	else                   { (region) = 1; }
+
+#if 0
+#define HIAPI_CHECKERROR(hiReturn,FUNC)	do {} while (0);
+#else
+#define HIAPI_CHECKERROR(hiReturn,FUNC)	\
+	if (hiReturn != HI_SUCCESS) { \
+		HIPRT_ERROR("mydemux:%s.%s.error(%x)\n",__FUNCTION__,#FUNC, hiReturn); \
+	}
+#endif
+
+#define HIFLT_REVERSE_MASK(mask) 	(HI_U8)(~(mask))
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/*************************** Structure Definition **********************/
+/* Transparent transmission mode, only the data to reach the internal buffer of events and timeout events, not a copy of the data does not appear to copy data to an external buffer event
+	In copy mode, in addition to the data reaches the internal buffer of events and timeout events, there will be a copy of the data to the external buffer events.
+	However, in the copy mode, when the reach the data of the external buffer event, the user via the callback function's return value to confirm whether to continue copying, in order to discard the unwanted duplicate data.
+	At this point, the return value of 0 means copy a copy, and direct release.
+*/
+
+typedef struct hidemux_attrib
+{
+	HI_S32		dmuxid;
+	HI_S32		fltnum;
+
+	HI_U32		u32TUNERID;				/* TUNER ID ,0-1*/
+	HI_U32		u32DMXID;				/* DMX ID ,0-4*/
+	HI_U32		u32PID;					/* TS PID */
+
+	HI_S32		u32Type; 				/* task type 1 - TYPE_ECM  2- TYPE_EMM */
+	HI_U32		u32FilterType; 		/* section type 0 - SECTION  1- PES  2 - ECM/EMM */
+	HI_U32		u32CrcFlag; 			/* crc check flag,0 - close crc check 1-force crc check 2-crc check by sytax*/
+	HI_U32		u32TimeOutMs;			/* time out in ms,0 stand for not timeout,otherwise when timeout,the user can receive the envent*/
+
+	HI_U32		u32FilterDepth;		/* Filter Depth*/
+	HI_U8			u8Match	[NUM_HIFLTDEPTH];
+	HI_U8			u8Mask	[NUM_HIFLTDEPTH];
+	HI_U8			u8Negate	[NUM_HIFLTDEPTH];
+} HIDEMUX_ATTRIB;
+
+typedef struct hidemux_filters
+{
+	HIDEMUX_ATTRIB fltAttr;
+	HI_S32		uFiltype;
+	HI_U32		u32UseFlag;				/*use flag :0- available,1-busy*/
+	HI_U32		u32EnableFlag;			/*enable flag :0- enable,1-disable*/
+
+	HI_HANDLE	hChannel;				/*corresponding  channel of filter*/
+	HI_HANDLE	hFilter;					/*corresponding  hander of filter*/
+
+	HI_U32		u32TimerCount;			/*current value in timer of (ms)filter */
+} HIDEMUX_FILTERS;
+
+typedef struct hidemux_inform {
+	int32_t		adapter;
+	int32_t		dmuxid;
+	int32_t		flnum;
+	int32_t		hifltnum;
+	int32_t		type;
+	int32_t		pid;
+	bool			activated;
+} HIDEMUX_INFORM;
+
+
+struct hidemux_thread_param
+{
+	int32_t id;
+//	int32_t flnum;
+	struct s_client *cli;
+};
+
+/********************** Global Variable declaration ********************/
+extern struct s_client		*dvbApi_client;
+
+static HI_BOOL					g_DemuxIniz 	= 0;
+static HI_BOOL 				g_DemuxRuning 	= HI_TRUE;
+static pthread_mutex_t		g_FltMutex;
+static pthread_mutex_t		g_FltLocks;
+static pthread_t				g_FltEcmThread;
+static pthread_t				g_FltEmmThread;
+
+static HIDEMUX_FILTERS		g_HIFilters[MAX_HIFILTERS];
+static HIDEMUX_INFORM		g_dmuxes[MAX_DEMUX][MAX_FILTER];
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//feedback data to filter by callback
+static HI_BOOL
+hifilter_SectionCallbacks(HIDEMUX_FILTERS *ChFilter, HI_U8 *pSection, HI_U32 uSecLen)
+{
+	HIDEMUX_ATTRIB *pFltAttr;
+	int k = 0;
+
+	if (!uSecLen ) return 0;
+	if (!pSection) return 0;
+	if (ChFilter->u32UseFlag == 0) return 0;
+	if (ChFilter->u32EnableFlag == 0) return 0;
+	pFltAttr = &(ChFilter->fltAttr);
+	if ((0 == pFltAttr->u32FilterType || 2 == pFltAttr->u32FilterType) && pFltAttr->u32FilterDepth != 0) /*section data,filter data by software*/
+	{
+		if (pFltAttr->u8Negate[0])
+		{
+			if ((pFltAttr->u8Match[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])) ==
+			  	 (pSection[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])))
+			{
+			  	return 0;
+			}
+		}
+		else
+		{
+			if ((pFltAttr->u8Match[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])) !=
+			  	 (pSection[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])))
+			{
+			  	return 0;
+			}
+		}
+
+		for (k = 1; k < (int)(pFltAttr->u32FilterDepth); k++)
+		{
+			if (pFltAttr->u8Negate[k])
+			{
+			  	if ((pFltAttr->u8Match[k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])) ==
+					 (pSection[2+k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])))
+			  	{
+					break;
+			  	}
+			}
+			else
+			{
+			  	if ((pFltAttr->u8Match[k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])) !=
+					 (pSection[2+k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])))
+			  	{
+					break;
+			  	}
+			}
+		}
+	}
+	else
+	{
+		k = pFltAttr->u32FilterDepth; /*do not filter pes*/
+	}
+
+	if (k == (int)(pFltAttr->u32FilterDepth)) /*get matched filter condition */
+	{
+		ChFilter->u32TimerCount = 0;
+//		if (ChFilter->uFiltype==TYPE_EMM) {
+//			myprintf("FILTER:%d, %d\n", uFilNum, i);
+//		}
+		dvbapi_process_input(pFltAttr->dmuxid, pFltAttr->fltnum, (void *)pSection, uSecLen);
+		return 1;
+	}
+	return 0;
+}
+
+
+static void *
+hifilter_ThreadModules(void *param)
+{
+	struct hidemux_thread_param *para = (struct hidemux_thread_param *)param;
+	HI_UNF_DMX_DATA_S ChRcvBuf[NUM_HIFILACQUIRES];
+	HI_UNF_DMX_CHAN_STATUS_S channelstatus;
+//	HI_UNF_DMX_DATA_TYPE_E enDataType;
+//	HI_UNF_DMX_CHAN_ATTR_S stChAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	HI_HANDLE ChHandle;
+	HI_S32 	 ChTYPE;
+//	HI_U32 	 u32HandleNum = MAX_HICHANNEL;
+//	HI_HANDLE u32ChHandle[MAX_HICHANNEL];
+	HI_U32 u32AcqNum 	= 0;
+	HI_U32 u32BufLen 	= 0;
+	HI_U8  *pRecvBuff	= 0;
+	HI_S32 hiReturn = HI_FAILURE;
+	int f, ki = 0;
+
+	ChTYPE = para->id;
+	pthread_setspecific(getclient, para->cli);
+	while (g_DemuxRuning)
+	{
+//		usleep(10 * 1000);
+		cs_sleepms(20);
+//		memset((void *)u32ChHandle, 0, sizeof(HI_HANDLE) * MAX_HICHANNEL);
+//		u32HandleNum = MAX_HICHANNEL;
+//		hiReturn = HI_UNF_DMX_GetDataHandle(u32ChHandle, &u32HandleNum, 1000);	/* timeout 1000ms */
+//		if ((HI_SUCCESS != hiReturn) || (u32HandleNum == 0)) continue;
+		for (f = 0; f < MAX_HIFILTERS; f++)
+		{
+		  	ChFilter = &(g_HIFilters[f]);
+			if ( ChFilter->uFiltype != ChTYPE) continue;
+			if (!ChFilter->u32UseFlag || !ChFilter->u32EnableFlag) continue;
+			#if defined(SDKV500) || defined(SDKV600)
+				if (ChFilter->hChannel == 0) continue;
+			#else
+				if (ChFilter->hChannel < 0x150000 || ChFilter->hChannel > 0x200000) continue;
+			#endif
+
+			ChHandle = ChFilter->hChannel;
+			hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+			if ((HI_SUCCESS != hiReturn) || (HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus)) continue;
+
+			u32AcqNum = 0;
+			hiReturn  = HI_UNF_DMX_AcquireBuf(ChHandle, NUM_HIFILACQUIRES, &u32AcqNum, ChRcvBuf, 100);
+			if (hiReturn == HI_ERR_DMX_TIMEOUT ||
+				 hiReturn == HI_ERR_DMX_NOAVAILABLE_DATA ||
+				 u32AcqNum== 0) {
+				cs_sleep(10);
+				continue;
+			}
+			if (hiReturn == HI_FAILURE) break;
+			if (HI_SUCCESS != hiReturn)
+			{
+			 	HIPRT_WARN("mydemux:hi_unf_dmx_acquirebuf.error(%x)\n", (HI_U32)hiReturn);
+			 	break;
+			}
+//			hiReturn = HI_UNF_DMX_GetChannelAttr(ChHandle, &stChAttr);
+//			if (HI_SUCCESS != hiReturn) continue;
+			if (u32AcqNum==NUM_HIFILACQUIRES)
+			{
+			 	HIPRT_WARN("mydemux:max Acquire(%d)\n", u32AcqNum);
+			}
+//			else
+//			{
+//			 	HIPRT_WARN("mydemux:acquire\n");
+//			}
+			for (ki = 0; ki < (int)u32AcqNum; ki++) /*process data package gradually*/
+			{
+				pRecvBuff  = ChRcvBuf[ki].pu8Data;
+				u32BufLen  = ChRcvBuf[ki].u32Size;
+// 			enDataType = ChRcvBuf[ki].enDataType;
+//				if (stChAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_POST)
+//				{
+//					pRecvBuff += 5;
+//					hifilter_SectionCallbacks(ChFilter, pRecvBuff, u32BufLen);
+//				}
+//				else
+				{
+				  	hifilter_SectionCallbacks(ChFilter, pRecvBuff, u32BufLen);
+				}
+			}
+
+			/*release message*/
+			hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+			if ((HI_SUCCESS != hiReturn) ||
+				((HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus) && (HI_SUCCESS == hiReturn)))
+			{
+			  	/*avoid reference ChRcvBuf after closing channel */
+			  	break;
+			}
+//				hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+//				if ((HI_SUCCESS != hiReturn) || (HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus)) continue;
+			hiReturn = HI_UNF_DMX_ReleaseBuf(ChHandle, u32AcqNum, ChRcvBuf);
+//				HIAPI_CHECKERROR(hiReturn,hi_unf_dmx_releasebuf);
+			cs_sleep(10);
+		}
+	}
+	return NULL;
+}
+
+static HI_S32
+hifilter_CheckFltAttr(HIDEMUX_ATTRIB *pFltAttr)
+{
+	if (!pFltAttr) return -1;
+	if ((pFltAttr->u32FilterType > 2))
+	{
+	  	HIPRT_ERROR("mydemux:hifilter_checkfltattr.error.type(%d)\n", pFltAttr->u32FilterType);
+	  	return -1;
+	}
+
+	if (pFltAttr->u32CrcFlag > 2)
+	{
+	  	HIPRT_ERROR("mydemux:hifilter_checkfltattr.error.crc(%d)\n", pFltAttr->u32CrcFlag);
+	  	return -1;
+	}
+
+	if (pFltAttr->u32FilterDepth > NUM_HIFLTDEPTH)
+	{
+	  	HIPRT_ERROR("mydemux:hifilter_checkfltattr.error.depth(%d)\n", pFltAttr->u32FilterDepth);
+	  	return -1;
+	}
+
+	return 0;
+}
+
+/*pu32FltId's value scope is 0-95 */
+static HI_S32
+hifilter_GetFreeFltId(HI_U32 u32DmxID, HI_U32 *pu32FltId)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	int i;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (ChFilter->u32UseFlag == 0)
+		{
+			*pu32FltId = (uRegionNum * NUM_HIPERREGION) + i;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static HI_U32
+hifilter_GetChnFltNum(HI_S32 u32DmxID, HI_HANDLE uChHandle)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	HI_U32 uFltNum = 0;
+	int i = 0;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (!ChFilter->u32UseFlag) continue;
+		if ( ChFilter->hChannel == 0 || ChFilter->hChannel == INVALID_HIHANDLE) continue;
+		if ( ChFilter->hChannel == uChHandle) uFltNum++;
+	}
+
+	return uFltNum;
+}
+
+/*get filter amount which channel is enable */
+static HI_U32
+hifilter_GetChnEnFltNum(HI_S32 u32DmxID, HI_HANDLE uChHandle)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	HI_U32 uFltNum = 0;
+	int i = 0;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (!ChFilter->u32UseFlag || !ChFilter->u32EnableFlag) continue;
+		if ( ChFilter->hChannel == 0 || ChFilter->hChannel == INVALID_HIHANDLE) continue;
+		if ( ChFilter->hChannel == uChHandle) uFltNum++;
+	}
+
+	return uFltNum;
+}
+
+static HI_S32
+hifilter_Create(HIDEMUX_ATTRIB *pFltAttr, HI_S32 *ps32FilterID)
+{
+	HI_UNF_DMX_FILTER_ATTR_S sFilterAttr;
+	HI_UNF_DMX_CHAN_ATTR_S stChAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	HI_HANDLE hFilter;
+	HI_HANDLE hChannel;
+	HI_U32 u32FltID;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_create\n");
+	HIAPI_ISDEMUXINIT();
+	if (hifilter_CheckFltAttr(pFltAttr) != 0)
+	{
+		HIPRT_ERROR("mydemux:hifilter_checkfltattr.invalid param\n");
+		return HI_FAILURE;
+	}
+
+	if (hifilter_GetFreeFltId(pFltAttr->u32DMXID, &u32FltID) != 0)
+	{
+		HIPRT_ERROR("mydemux:hifilter_getfreefltid.no free\n");
+		return HI_FAILURE;
+	}
+
+	memset(&sFilterAttr, 0, sizeof(HI_UNF_DMX_FILTER_ATTR_S));
+	sFilterAttr.u32FilterDepth =  pFltAttr->u32FilterDepth;
+	memcpy(sFilterAttr.au8Mask, 	pFltAttr->u8Mask,  NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Match, 	pFltAttr->u8Match, NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Negate, pFltAttr->u8Negate,NUM_HIFLTDEPTH);
+	hiReturn = HI_UNF_DMX_CreateFilter(pFltAttr->u32DMXID, &sFilterAttr, &hFilter);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_createfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	hiReturn = HI_UNF_DMX_GetChannelHandle(pFltAttr->u32DMXID, pFltAttr->u32PID, &hChannel);
+	if ((HI_SUCCESS != hiReturn) && (HI_ERR_DMX_UNMATCH_CHAN != hiReturn))
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelhandle.error(%x)\n", hiReturn);
+		HI_UNF_DMX_DestroyFilter(hFilter);
+		return HI_FAILURE;
+	}
+
+	if ((HI_ERR_DMX_UNMATCH_CHAN == hiReturn) || (INVALID_HIHANDLE == hChannel))
+	{
+		/*do have channel for this PID,it need to create new channel */
+		hiReturn = HI_UNF_DMX_GetChannelDefaultAttr(&stChAttr);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_getchanneldefaultattr.error(%x)\n", hiReturn);
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			return HI_FAILURE;
+		}
+
+		if (pFltAttr->u32CrcFlag == 1)
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD;
+		}
+		else
+		if (pFltAttr->u32CrcFlag == 2)
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD;
+		}
+		else
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORBID;
+		}
+
+		if (pFltAttr->u32FilterType == 1)
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_PES;
+		}
+		else
+		if (pFltAttr->u32FilterType == 2)
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_ECM_EMM;
+		//	stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_POST;
+		}
+		else
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_SEC;
+		}
+
+		stChAttr.enOutputMode = HI_UNF_DMX_CHAN_OUTPUT_MODE_PLAY;
+		stChAttr.u32BufSize 	 = MAX_HIBUFFERSIZE; // not used, don't care
+
+		HIPRT_INFO("mydemux:call hi_unf_dmx_createchannel\n");
+		hiReturn = HI_UNF_DMX_CreateChannel(pFltAttr->u32DMXID, &stChAttr, &hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			HIPRT_ERROR("mydemux:hi_unf_dmx_createchannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		hiReturn = HI_UNF_DMX_SetChannelPID(hChannel, pFltAttr->u32PID);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			HI_UNF_DMX_DestroyChannel(hChannel);
+			HIPRT_ERROR("mydemux:hi_unf_dmx_setchannelpid.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+
+	ChFilter = &g_HIFilters[u32FltID];
+	memset(ChFilter, 0, sizeof(HIDEMUX_FILTERS));
+	ChFilter->u32EnableFlag = 0;
+	ChFilter->u32TimerCount = 0;
+	ChFilter->hFilter  		= hFilter;
+	ChFilter->hChannel 		= hChannel;
+	ChFilter->u32UseFlag 	= 1;
+	ChFilter->uFiltype  		= pFltAttr->u32Type;
+	memcpy(&ChFilter->fltAttr, pFltAttr, sizeof(HIDEMUX_ATTRIB));
+
+	*ps32FilterID = u32FltID;
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Destroy(HI_S32 s32FilterID)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_destroy\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_destroy.error\n");
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->u32EnableFlag)
+	{
+		hiReturn = HI_UNF_DMX_DetachFilter(ChFilter->hFilter, ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_detachfilter.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		ChFilter->u32EnableFlag = 0;
+	}
+
+	hiReturn = HI_UNF_DMX_DestroyFilter(ChFilter->hFilter);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_destroyfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32UseFlag = 0;
+	ChFilter->uFiltype   = 0;
+	/*if the channel did not attach filter,destroy the channel*/
+	if (!hifilter_GetChnFltNum(ChFilter->fltAttr.u32DMXID, ChFilter->hChannel))
+	{
+		HIPRT_INFO("mydemux:call hi_unf_dmx_destroychannel\n");
+		hiReturn = HI_UNF_DMX_DestroyChannel(ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_destroychannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+
+	ChFilter->hChannel = INVALID_HIHANDLE;
+	ChFilter->hFilter  = INVALID_HIHANDLE;
+	ChFilter->u32TimerCount = 0;
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_SetAttribute(HI_S32 s32FilterID, HIDEMUX_ATTRIB *pFltAttr)
+{
+	HI_UNF_DMX_FILTER_ATTR_S sFilterAttr;
+	HI_UNF_DMX_CHAN_ATTR_S sChanAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+	if (hifilter_CheckFltAttr(pFltAttr) != 0)
+	{
+		HIPRT_ERROR("mydemux:hifilter_checkfltattr.invalid param\n");
+		return HI_FAILURE;
+	}
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if (pFltAttr->u32FilterType != ChFilter->fltAttr.u32FilterType)
+	{
+		HIPRT_ERROR("mydemux:hifilter_setattr.error type\n");
+		return HI_FAILURE;
+	}
+
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_setattr.error\n");
+		return HI_FAILURE;
+	}
+
+	memset(&sFilterAttr, 0, sizeof(HI_UNF_DMX_FILTER_ATTR_S));
+	sFilterAttr.u32FilterDepth = pFltAttr->u32FilterDepth;
+	memcpy(sFilterAttr.au8Mask,  pFltAttr->u8Mask,   NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Match, pFltAttr->u8Match,  NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Negate,pFltAttr->u8Negate, NUM_HIFLTDEPTH);
+	hiReturn = HI_UNF_DMX_SetFilterAttr(ChFilter->hFilter, &sFilterAttr);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_setfilterattr.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->fltAttr.u32CrcFlag != pFltAttr->u32CrcFlag)
+	{
+		hiReturn = HI_UNF_DMX_GetChannelAttr(ChFilter->hChannel, &sChanAttr);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelattr.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		if (sChanAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_SEC ||
+			 sChanAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_ECM_EMM)
+		{
+			if ((ChFilter->fltAttr.u32CrcFlag == 1)
+				&& (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+			else
+			if ((ChFilter->fltAttr.u32CrcFlag == 2) && (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+			else
+			if ((ChFilter->fltAttr.u32CrcFlag == 0) && (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_FORBID))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORBID;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+
+			if (HI_SUCCESS != hiReturn)
+			{
+				 HIPRT_ERROR("mydemux:hifilter_setattr.crc.error(%x)\n", hiReturn);
+				 return HI_FAILURE;
+			}
+		}
+	}
+
+	memcpy(&ChFilter->fltAttr, pFltAttr, sizeof(HIDEMUX_ATTRIB));
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_GetAttr(HI_S32 s32FilterID, HIDEMUX_ATTRIB *pFltAttr)
+{
+	HIDEMUX_FILTERS *ChFilter;
+
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+	if (!pFltAttr)
+	{
+		HIPRT_ERROR("mydemux:hifilter_getattr.null\n");
+		return HI_FAILURE;
+	}
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	memcpy(pFltAttr, &ChFilter->fltAttr, sizeof(HIDEMUX_ATTRIB));
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Start(HI_S32 s32FilterID)
+{
+	HI_UNF_DMX_CHAN_STATUS_S stStatus;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_start\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_start.error\n");
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->u32EnableFlag)
+	{
+		HIPRT_ERROR("mydemux:hifilter_start.already\n");
+		return HI_SUCCESS;
+	}
+
+	hiReturn = HI_UNF_DMX_AttachFilter(ChFilter->hFilter, ChFilter->hChannel);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_attachfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32EnableFlag = 1;
+	ChFilter->u32TimerCount = 0;
+	hiReturn = HI_UNF_DMX_GetChannelStatus(ChFilter->hChannel, &stStatus);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelstatus.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	if (HI_UNF_DMX_CHAN_CLOSE == stStatus.enChanStatus)
+	{
+		hiReturn = HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_openchannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Stop(HI_S32 s32FilterID)
+{
+	HI_UNF_DMX_CHAN_STATUS_S stStatus;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_stop!\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_stop.error\n");
+		return HI_FAILURE;
+	}
+
+	if (!ChFilter->u32EnableFlag)
+	{
+		HIPRT_ERROR("mydemux:hifilter_stop.already\n");
+		return HI_SUCCESS;
+	}
+
+	hiReturn = HI_UNF_DMX_DetachFilter(ChFilter->hFilter, ChFilter->hChannel);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_detachfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32EnableFlag = 0;
+	ChFilter->u32TimerCount = 0;
+	/*if the channel did not attach filter,close the channel*/
+	if (!hifilter_GetChnEnFltNum(ChFilter->fltAttr.u32DMXID, ChFilter->hChannel))
+	{
+		HIPRT_INFO("mydemux:call hi_unf_dmx_closechannel\n");
+		hiReturn = HI_UNF_DMX_GetChannelStatus(ChFilter->hChannel, &stStatus);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelstatus.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		if (HI_UNF_DMX_CHAN_CLOSE != stStatus.enChanStatus)
+		{
+			hiReturn = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_ERROR("mydemux:hi_unf_dmx_closechannel.error(%x)\n", hiReturn);
+				return HI_FAILURE;
+			}
+		}
+	}
+	return HI_SUCCESS;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static int32_t
+hidemux_Start(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid, unsigned char *fltr, unsigned char *mask)
+{
+	HIDEMUX_ATTRIB FltAttr;
+	HI_S32 hifltnum = INVALID_HIFILTER;
+	int hiReturn;
+	int i;
+
+	FltAttr.dmuxid				= dmuxid;
+	FltAttr.fltnum				= n;
+	FltAttr.u32TUNERID		= TUNER0;
+	FltAttr.u32DMXID			= HIDEMUX_OSCAM_ID;
+	#if defined(SDKV600)
+		if (adapter==DEMUX_SECONDADAPTER) {
+			FltAttr.u32TUNERID= TUNER1;
+			FltAttr.u32DMXID	= HIDEMUX_OSCAM2_ID;
+		}
+	#endif
+	FltAttr.u32Type			= type;
+	FltAttr.u32FilterType 	= 0;	// Section/ECM.EMM
+	FltAttr.u32FilterType 	= (pid == CAT_PID) ? 0 : 2;
+	FltAttr.u32PID				= pid;
+	FltAttr.u32CrcFlag 		= 0;
+	FltAttr.u32TimeOutMs		= 9000;
+
+	memset(FltAttr.u8Match, 0x00,NUM_HIFLTDEPTH);
+	memset(FltAttr.u8Mask,  0xFF,NUM_HIFLTDEPTH);
+	memset(FltAttr.u8Negate,0x00,NUM_HIFLTDEPTH);
+	FltAttr.u8Match[0] 		= fltr[0];
+	FltAttr.u8Mask [0] 		= HIFLT_REVERSE_MASK(mask[0]);
+	FltAttr.u32FilterDepth	= DVB_HIFLTBYTES;
+	for (i=1; i<(int)FltAttr.u32FilterDepth; i++)
+	{
+		FltAttr.u8Match[i] 	= fltr[i];
+		FltAttr.u8Mask [i] 	= HIFLT_REVERSE_MASK(mask[i]);
+	}
+
+	cs_log_dbg(D_DVBAPI, "hifilter %d(%d) start(pid:%04X)", n, type, pid);
+	if (!IS_INVALID_PID(pid))
+	{
+		hiReturn = hifilter_Create(&FltAttr, &hifltnum);
+		if (HI_SUCCESS != hiReturn)
+		{
+			g_dmuxes[dmuxid][n].activated = 0;
+			HIPRT_ERROR("mydemux:hifilter %d(%d) failure", n, type);
+		}
+		else
+		{
+			hiReturn = hifilter_Start(hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_ERROR("mydemux:hifilter %d(%d) failure", n, type);
+			}
+			g_dmuxes[dmuxid][n].hifltnum  = hifltnum;
+			g_dmuxes[dmuxid][n].activated = 1;
+		}
+	}
+	HIPRT_INFO("mydemux:hifilter_start{%d:%d:%d,%04X}{%2d:%02X%02X%02X%02X%02X%02X%02X%02X}\n",
+				dmuxid,
+				type, n, pid,
+				g_dmuxes[dmuxid][n].hifltnum,
+				fltr[0],fltr[1],fltr[2],fltr[3],fltr[4],fltr[5],fltr[6],fltr[7]);
+	g_dmuxes[dmuxid][n].adapter= adapter;
+	g_dmuxes[dmuxid][n].dmuxid = dmuxid;
+	g_dmuxes[dmuxid][n].pid	 	= pid;
+	g_dmuxes[dmuxid][n].type	= type;
+	g_dmuxes[dmuxid][n].flnum 	= n;
+	return (n+1);
+}
+
+static int32_t
+hidemux_Stop(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid)
+{
+	int hiReturn;
+
+	if (n > MAX_FILTER-1) return 0;
+	if (g_dmuxes[dmuxid][n].activated)
+	{
+		HIPRT_INFO("mydemux:hifilter_stop{%d:%d:%d,%04x}{%d}\n",
+					dmuxid,
+					type, n, pid,
+					g_dmuxes[dmuxid][n].hifltnum);
+		g_dmuxes[dmuxid][n].activated = 0;
+//		if (g_dmuxes[dmuxid][n].dmuxid != dmuxid)
+//		{
+//			HIPRT_TRACE("mydemux:hidemux_filterclose dmuxid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].dmuxid, dmuxid);
+//			return 0;
+//		}
+//		if (pid  && g_dmuxes[dmuxid][n].pid != pid)
+//		{
+//			HIPRT_TRACE("mydemux:hidemux_filterclose pid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].pid, pid);
+//			return 0;
+//		}
+//		if (type && g_dmuxes[dmuxid][n].type != type)
+//		{
+//			HIPRT_TRACE("mydemux:hidemux_filterclose pid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].pid, pid);
+//			return 0;
+//		}
+		if (!IS_INVALID_HIFILTERS(g_dmuxes[dmuxid][n].hifltnum))
+		{
+			cs_log_dbg(D_DVBAPI, "hifilter %d(%d) stop(pid:%04X)", n, type, pid);
+			hiReturn = hifilter_Stop(g_dmuxes[dmuxid][n].hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_INFO("hifilter_stop.failed\n");
+				cs_log_dbg(D_DVBAPI, "hifilter %d(%d) failure{%x}", n, type, hiReturn);
+			}
+
+			hiReturn = hifilter_Destroy(g_dmuxes[dmuxid][n].hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_INFO("hifilter_destroy.failed\n");
+				cs_log_dbg(D_DVBAPI, "hifilter %d(%d) failure{%x}", n, type, hiReturn);
+			}
+		}
+	}
+	g_dmuxes[dmuxid][n].adapter	= -1;
+	g_dmuxes[dmuxid][n].dmuxid 	= -1;
+	g_dmuxes[dmuxid][n].type		=  0;
+	g_dmuxes[dmuxid][n].pid	 		=  0;
+	g_dmuxes[dmuxid][n].flnum  	= -1;
+	g_dmuxes[dmuxid][n].hifltnum 	= INVALID_HIFILTER;
+	return 1;
+}
+
+
+static int
+hidemux_Init(void)
+{
+	struct hidemux_thread_param *ecmpara, *emmpara;
+	pthread_attr_t attr;
+	int hiReturn;
+	int ret;
+	int dmuxid, n, i;
+
+//	HIPRT_TRACE("mydemux:hidemux_init{%p,%p)\n", dvbApi_client, cur_client());
+	HIPRT_TRACE("mydemux:hidemux_init{%d)\n", MAX_HIFILTERS);
+
+	if (g_DemuxIniz) return 1;
+
+	hiReturn = HI_UNF_DMX_Init();
+	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_Init);
+
+	#if defined(SDKV600)
+		#if 0
+			// use tvheadend...
+			/* 0,4 is PLAY DMX */
+			hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM1_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+			// TUNER 1
+			/* 0,4 is PLAY DMX */
+			hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM2_ID/*demux id*/, HIPORT_INTERNAL_ID/*port id*/); //for section
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+		#endif
+	#elif defined(SDKV500)
+		// tvheadend
+		#if 0
+			HI_UNF_DMX_PORT_ATTR_S PortAttr;
+			// TUNER 0
+			hiReturn = HI_UNF_DMX_GetTSPortAttr(HIPORT_TUNER_ID, &PortAttr);
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_GetTSPortAttr);
+			PortAttr.enPortType = HI_UNF_DMX_PORT_TYPE_SERIAL;
+			#if defined(Hi3719MV100)
+				PortAttr.u32SerialBitSelector = 1; //D0
+			#else
+				PortAttr.u32SerialBitSelector = 0; //D7
+			#endif
+			hiReturn = HI_UNF_DMX_SetTSPortAttr(HIPORT_TUNER_ID, &PortAttr);
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_SetTSPortAttr);
+		#endif
+
+		/* 0,4 is PLAY DMX */
+		hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+		HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+		// TUNER 1
+		//	hiReturn = HI_UNF_DMX_GetTSPortAttr(HI_UNF_DMX_PORT_TSI_3, &PortAttr);
+		//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_GetTSPortAttr);
+		//	PortAttr.enPortType = HI_UNF_DMX_PORT_TYPE_SERIAL;
+		//	PortAttr.u32SerialBitSelector = 0; //D7
+		//	hiReturn = HI_UNF_DMX_SetTSPortAttr(HI_UNF_DMX_PORT_TSI_3, &PortAttr);
+		//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_SetTSPortAttr);
+
+		/* 0,4 is PLAY DMX */
+	//	hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_DMX_ID2/*demux id*/, HI_UNF_DMX_PORT_TSI_3/*port id*/); //for section
+	//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+	#else
+		hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+		HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+	#endif
+
+	for (dmuxid=0; dmuxid<MAX_DEMUX; dmuxid++)
+	{
+		for (n=0; n<MAX_FILTER; n++)
+		{
+			g_dmuxes[dmuxid][n].dmuxid		= -1;
+			g_dmuxes[dmuxid][n].adapter	= -1;
+			g_dmuxes[dmuxid][n].type	 	= 0;
+			g_dmuxes[dmuxid][n].pid 	 	= 0;
+			g_dmuxes[dmuxid][n].flnum 	 	= -1;
+			g_dmuxes[dmuxid][n].hifltnum	= INVALID_HIFILTER;
+			g_dmuxes[dmuxid][n].activated = 0;
+		}
+	}
+	for (i=0; i<MAX_HIFILTERS; i++)
+	{
+		memset(&g_HIFilters[i], 0, sizeof(HIDEMUX_FILTERS));
+		g_HIFilters[i].hChannel = INVALID_HIHANDLE;
+		g_HIFilters[i].hFilter  = INVALID_HIHANDLE;
+	}
+
+	pthread_attr_init(&attr);
+	pthread_attr_setstacksize(&attr, PTHREAD_STACK_SIZE);
+
+	if (!cs_malloc(&ecmpara, sizeof(struct hidemux_thread_param))) return 0;
+//	ecmpara->flnum = HIDEMUX_OSCAM_ID;
+	ecmpara->id  	 = TYPE_ECM;
+	ecmpara->cli 	 = cur_client();
+	ret = pthread_create(&g_FltEcmThread, NULL, hifilter_ThreadModules, (void *)ecmpara);
+	if (ret) {
+		pthread_attr_destroy(&attr);
+		HIPRT_TRACE("hifilter_Init thread.errno(%d.%s)", ret, strerror(ret));
+		return 0;
+	}
+	else {
+		pthread_detach(g_FltEcmThread);
+	}
+
+	if (!cs_malloc(&emmpara, sizeof(struct hidemux_thread_param))) return 0;
+	emmpara->id  = TYPE_EMM;
+	emmpara->cli = cur_client();
+	ret = pthread_create(&g_FltEmmThread, NULL, hifilter_ThreadModules, (void *)emmpara);
+	if (ret) {
+		pthread_attr_destroy(&attr);
+		HIPRT_TRACE("hifilter_Init thread.errno(%d.%s)", ret, strerror(ret));
+		return 0;
+	}
+	else {
+		pthread_detach(g_FltEmmThread);
+	}
+	pthread_attr_destroy(&attr);
+	g_DemuxRuning = HI_TRUE;
+	if (hiReturn == HI_SUCCESS) g_DemuxIniz = 1;
+	return (g_DemuxIniz);
+}
+
+
+static int
+hidemux_DeInit(void)
+{
+	int hiReturn;
+	int dmuxid;
+	int n;
+
+	HIPRT_TRACE("mydemux:hidemux_close\n");
+	if (!g_DemuxIniz) return 1;
+
+	for (dmuxid=0;dmuxid<MAX_DEMUX;dmuxid++)
+	{
+		for (n=0;n<MAX_FILTER;n++)
+		{
+			hidemux_Stop(-1, dmuxid, 0, n, 0);
+		}
+	}
+	g_DemuxIniz = 0;
+	g_DemuxRuning = HI_FALSE;
+	usleep(100 * 1000);
+	pthread_join(g_FltEcmThread, 0);
+	pthread_join(g_FltEmmThread, 0);
+
+//	hiReturn = HI_UNF_DMX_DetachTSPort(HIPORT_TUNER_ID/*port id*/);
+//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+
+	hiReturn = HI_UNF_DMX_DeInit();
+	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_DeInit);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+int32_t
+hidemuxapi_AddFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid, uchar *flt, uchar *mask)
+{
+	int status;
+
+	if (!g_DemuxIniz) return -1;
+	pthread_mutex_lock(&g_FltLocks);
+	status = hidemux_Start(adapter, dmuxid, type, n, pid, flt, mask);
+	pthread_mutex_unlock(&g_FltLocks);
+	return status;
+}
+
+int32_t
+hidemuxapi_RemoveFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid)
+{
+	int status;
+
+	if (!g_DemuxIniz) return -1;
+	pthread_mutex_lock(&g_FltLocks);
+	status = hidemux_Stop(adapter, dmuxid, type, n, pid);
+	pthread_mutex_unlock(&g_FltLocks);
+	return status;
+}
+
+
+
+/* write cw to all demuxes in mask with passed index */
+int32_t
+hidemuxapi_Init(void)
+{
+	pthread_mutex_init(&g_FltLocks, NULL);
+	pthread_mutex_init(&g_FltMutex, NULL);
+	//
+	//
+	// link option -lhi_common
+	// for disable debug message
+	HI_SYS_Init();
+	#if defined(SDKV500) || defined(SDKV600)
+		HI_SYS_SetLogLevel(HI_ID_DEMUX,HI_LOG_LEVEL_ERROR);
+	#else
+		HI_SYS_SetLogLevel(HI_DEBUG_ID_DEMUX,HI_LOG_LEVEL_ERROR);
+	#endif
+	//
+	//
+	//
+	hidemux_Init();
+	atexit(hidemuxapi_Deinit);
+	return 1;
+}
+
+void
+hidemuxapi_Deinit(void)
+{
+	hidemux_DeInit();
+	//
+	//
+	//
+	HI_SYS_DeInit();
+	//
+	//
+	//
+	pthread_mutex_destroy(&g_FltLocks);
+	pthread_mutex_destroy(&g_FltMutex);
+}
+
+#endif	// #if defined(WITH_HISILICON)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+
Index: module-dvbapi-his.h
===================================================================
--- module-dvbapi-his.h	(nonexistent)
+++ module-dvbapi-his.h	(working copy)
@@ -0,0 +1,13 @@
+#ifndef _MODULE_HIAPI_H_
+#define _MODULE_HIAPI_H_
+
+#define DEMUX_MAINADAPTER		3
+#define DEMUX_SECONDADAPTER	2
+
+/* Local hiapi functions */
+int32_t 	hidemuxapi_Init(void);
+void    	hidemuxapi_Deinit(void);
+int32_t 	hidemuxapi_AddFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n,int32_t pid, uchar *flt, uchar *mask);
+int32_t 	hidemuxapi_RemoveFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid);
+
+#endif
Index: module-dvbapi.c
===================================================================
--- module-dvbapi.c	(revision 10670)
+++ module-dvbapi.c	(working copy)
@@ -11,6 +11,9 @@
 #include "module-dvbapi-coolapi.h"
 #include "module-dvbapi-stapi.h"
 #include "module-dvbapi-chancache.h"
+#if defined(WITH_HISILICON)
+#include "module-dvbapi-his.h"
+#endif
 #include "module-stat.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -24,7 +27,15 @@
 #include "oscam-time.h"
 #include "oscam-work.h"
 #include "reader-irdeto.h"
-
+#if defined(MODULE_XCAS)
+#include "module-xcas.h"
+#endif
+// sky(quad)
+#if 1
+	#define	MYDVB_TRACE	mystrace
+#else
+	#define	MYDVB_TRACE(...)
+#endif
 #if defined (__CYGWIN__)
 #define F_NOTIFY 0
 #define F_SETSIG 0
@@ -34,39 +45,7 @@
 #define DN_MULTISHOT 0
 #endif
 
-const char *streamtxt[] = {
-								"",			 																				// 00
-								"",																							// 01
-								"Videostream ",																				// 02
-								"Audiostream ",																			    // 03
-								"",																							// 04
-								"",																							// 05
-								"Datastream ",																				// 06
-								"",																							// 07
-								"",																							// 08
-								"Conditional Access ",																		// 09
-								"",																							// 0A
-								"",																							// 0B
-								"",																							// 0C
-								"",																							// 0D
-								"",																							// 0E
-								"",																							// 0F
-								"",																							// 10
-								"",																							// 11
-								"",																							// 12
-								"",																							// 13
-								"",																							// 14
-								"",																							// 15
-								"",																							// 16
-								"",																							// 17
-								"",																							// 18
-								"",																							// 19
-								"",																							// 1A
-								"MPEG-4 videostream ",																		// 1B
-								"MPEG-4 audiostream ",
-							};
-
-static int is_samygo;
+static int  is_samygo = 0;
 
 void flush_read_fd(int32_t demux_index, int32_t num, int fd)
 {
@@ -99,8 +78,7 @@
 	} 
 	else 
 	{
-		switch(request) 
-		{
+		switch(request) {
 			case DMX_SET_FILTER:
 			{
 				struct dmxSctFilterParams *sFP = va_arg(args, struct dmxSctFilterParams *);
@@ -149,8 +127,7 @@
 #endif
 	// FIXME: Workaround for su980 bug
 	// See: http://www.streamboard.tv/wbb2/thread.php?postid=533940
-	if(boxtype_is("su980"))
-		ret = 1;
+	if (boxtype_is("su980")) ret = 1;
 	va_end(args);
 	return ret;
 }
@@ -159,30 +136,46 @@
 #define FROM_TO 0
 #define TO_FROM 1
 
-int32_t pausecam = 0, disable_pmt_files = 0, pmt_stopmarking = 0, pmthandling = 0;
 DEMUXTYPE demux[MAX_DEMUX];
-struct s_dvbapi_priority *dvbapi_priority;
-struct s_client *dvbapi_client;
+struct s_dvbapi_priority 	*dvbApi_priority;
+struct s_client 				*dvbApi_client;
 
-const char *boxdesc[] = { "none", "dreambox", "duckbox", "ufs910", "dbox2", "ipbox", "ipbox-pmt", "dm7000", "qboxhd", "coolstream", "neumo", "pc", "pc-nodmx" };
+const char *boxtype_desc[] = {"none",
+										"dreambox",
+										"duckbox",
+										"ufs910",
+										"dbox2",
+										"ipbox",
+										"ipbox-pmt",
+										"dm7000",
+										"qboxhd",
+										"coolstream",
+										"neumo",
+										"pc",
+										"hisky", // WITH_HISILICON
+										"pc-nodmx",
+									};
 
-static const struct box_devices devices[BOX_COUNT] =
-{
+static const struct box_devices devices[BOX_COUNT] = {
 	/* QboxHD (dvb-api-3)*/     { "/tmp/virtual_adapter/",  "ca%d",         "demux%d",      "/tmp/camd.socket", DVBAPI_3    },
 	/* dreambox (dvb-api-3)*/   { "/dev/dvb/adapter%d/",    "ca%d",         "demux%d",      "/tmp/camd.socket", DVBAPI_3    },
 	/* dreambox (dvb-api-1)*/   { "/dev/dvb/card%d/",       "ca%d",         "demux%d",      "/tmp/camd.socket", DVBAPI_1    },
 	/* neumo (dvb-api-1)*/      { "/dev/",                  "demuxapi",     "demuxapi",     "/tmp/camd.socket", DVBAPI_1    },
 	/* sh4      (stapi)*/       { "/dev/stapi/",            "stpti4_ioctl", "stpti4_ioctl", "/tmp/camd.socket", STAPI       },
-	/* coolstream*/             { "/dev/cnxt/",             "null",         "null",         "/tmp/camd.socket", COOLAPI     }
+	/* coolstream*/			{ "/dev/cnxt/", 				"null",			"null",			"/tmp/camd.socket", COOLAPI },
+	// sky(!).
+	/* HiSilicon*/				{ "/dev/", 						"null",			"null",			"/var/camd.socket", HISILICONAPI },
 };
 
 static int32_t selected_box = -1;
 static int32_t selected_api = -1;
 static int32_t maxfilter = MAX_FILTER;
 static int32_t dir_fd = -1;
-char *client_name = NULL;
+static char   		*client_name = "hisilicon";
 static uint16_t client_proto_version = 0;
 
+static int32_t 	pausecam = 0, pmt_stopmarking = 0, pmt_handling = 0;
+int32_t				disable_pmt_files = 0;
 static int32_t ca_fd[MAX_DEMUX]; // holds fd handle of each ca device 0 = not in use
 static LLIST * ll_activestreampids; // list of all enabled streampids on ca devices
 
@@ -192,8 +185,7 @@
 	return streq(cfg.dvbapi_usr, usr);
 }
 
-struct s_emm_filter
-{
+struct s_emm_filter {
 	int32_t      demux_id;
 	uchar        filter[32];
 	uint16_t     caid;
@@ -299,6 +291,8 @@
 {
 	struct s_emm_filter *filter;
 	LL_ITER itr;
+
+//	MYDVB_TRACE("mydvb:get_emmfilter_by_filternum_internal\n");
 	if(ll_count(ll) > 0)
 	{
 		itr = ll_iter_create(ll);
@@ -313,6 +307,7 @@
 
 struct s_emm_filter *get_emmfilter_by_filternum(int32_t demux_id, uint32_t num)
 {
+//	MYDVB_TRACE("mydvb:get_emmfilter_by_filternum\n");
 	if(!ll_emm_active_filter)
 		{ ll_emm_active_filter = ll_create("ll_emm_active_filter"); }
 
@@ -324,14 +319,13 @@
 
 	struct s_emm_filter *emm_filter = NULL;
 	emm_filter = get_emmfilter_by_filternum_internal(ll_emm_active_filter, demux_id, num);
-	if(emm_filter)
-		{ return emm_filter; }
+	if (emm_filter) return emm_filter;
+
 	emm_filter = get_emmfilter_by_filternum_internal(ll_emm_inactive_filter, demux_id, num);
-	if(emm_filter)
-		{ return emm_filter; }
+	if (emm_filter) return emm_filter;
+
 	emm_filter = get_emmfilter_by_filternum_internal(ll_emm_pending_filter, demux_id, num);
-	if(emm_filter)
-		{ return emm_filter; }
+	if (emm_filter) return emm_filter;
 
 	return NULL;
 }
@@ -340,6 +334,7 @@
 {
 	struct s_emm_filter *filter;
 	LL_ITER itr;
+	MYDVB_TRACE("mydvb:remove_emmfilter_from_list_internal\n");
 	if(ll_count(ll) > 0)
 	{
 		itr = ll_iter_create(ll);
@@ -357,6 +352,7 @@
 
 void remove_emmfilter_from_list(int32_t demux_id, uint16_t caid, uint32_t provid, uint16_t pid, uint32_t num)
 {
+	MYDVB_TRACE("mydvb:remove_emmfilter_from_list\n");
 	if(ll_emm_active_filter && remove_emmfilter_from_list_internal(ll_emm_active_filter, demux_id, caid, provid, pid, num))
 		{ return; }
 	if(ll_emm_inactive_filter && remove_emmfilter_from_list_internal(ll_emm_inactive_filter, demux_id, caid, provid, pid, num))
@@ -532,7 +528,7 @@
 					memcpy(&packet[size], &pid, 2);
 					size += 2;
 
-					memcpy(&packet[size], fp->filter.filter, 16);
+					memcpy(&packet[size], fp->filter.filt, 16);
 					size += 16;
 					memcpy(&packet[size], fp->filter.mask, 16);
 					size += 16;
@@ -585,30 +581,31 @@
 	return 0;
 }
 
-int32_t dvbapi_set_filter(int32_t demux_id, int32_t api, uint16_t pid, uint16_t caid, uint32_t provid, uchar *filt, uchar *mask, int32_t timeout, int32_t pidindex, int32_t type,
+int32_t dvbapi_set_filter(int32_t demux_id, int32_t api, uint16_t pid, uint16_t caid, uint32_t provid, uchar *filt, uchar *mask, int32_t timeout, int32_t pidx, int32_t type,
 	int8_t add_to_emm_list)
 {
+#if defined WITH_AZBOX || defined WITH_MCA
 	openxcas_set_caid(demux[demux_id].ECMpids[pidindex].CAID);
 	openxcas_set_ecm_pid(pid);
-	if (USE_OPENXCAS)
-		return 1;
+	if (USE_OPENXCAS) return 1;
+#endif
 
 	int32_t ret = -1, n = -1, i;
 
-	for(i = 0; i < maxfilter && demux[demux_id].demux_fd[i].fd > 0; i++) { ; }
+	for (i=0; i<maxfilter && demux[demux_id].demux_fd[i].fd>0; i++);
 
-	if(i >= maxfilter)
-	{
+	MYDVB_TRACE("mydvb:dvbapi_set_filter{%d:%d, %d,%04X,%06X:%04X}\n", demux_id, i, type, caid, provid, pid);
+	if (i>=maxfilter) {
 		cs_log_dbg(D_DVBAPI, "no free filter");
 		return -1;
 	}
 	n = i;
-
-	demux[demux_id].demux_fd[n].pidindex = pidindex;
-	demux[demux_id].demux_fd[n].pid      = pid;
-	demux[demux_id].demux_fd[n].caid     = caid;
-	demux[demux_id].demux_fd[n].provid   = provid;
-	demux[demux_id].demux_fd[n].type     = type;
+// sky(move)
+//	demux[demux_id].demux_fd[n].pidindex = pidx;
+//	demux[demux_id].demux_fd[n].pid      = pid;
+//	demux[demux_id].demux_fd[n].caid     = caid;
+//	demux[demux_id].demux_fd[n].provid   = provid;
+//	demux[demux_id].demux_fd[n].type     = type;
 
 	switch(api)
 	{
@@ -625,17 +622,16 @@
 		sFP2.pid            = pid;
 		sFP2.timeout        = timeout;
 		sFP2.flags          = DMX_IMMEDIATE_START;
-		if(cfg.dvbapi_boxtype == BOXTYPE_NEUMO)
-		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_NEUMO) {
 			//DeepThought: on dgs/cubestation and neumo images, perhaps others
 			//the following code is needed to descramble
-			sFP2.filter.filter[0] = filt[0];
+				sFP2.filter.filt[0]=filt[0];
 			sFP2.filter.mask[0] = mask[0];
-			sFP2.filter.filter[1] = 0;
+				sFP2.filter.filt[1]=0;
 			sFP2.filter.mask[1] = 0;
-			sFP2.filter.filter[2] = 0;
+				sFP2.filter.filt[2]=0;
 			sFP2.filter.mask[2] = 0;
-			memcpy(sFP2.filter.filter + 3, filt + 1, 16 - 3);
+				memcpy(sFP2.filter.filt+3,filt+1,16-3);
 			memcpy(sFP2.filter.mask + 3, mask + 1, 16 - 3);
 			//DeepThought: in the drivers of the dgs/cubestation and neumo images,
 			//dvbapi 1 and 3 are somehow mixed. In the kernel drivers, the DMX_SET_FILTER
@@ -647,9 +643,8 @@
 			//expected by DMX_SET_FILTER. Otherwise, the timeout parameter is not passed correctly.
 			ret = dvbapi_ioctl(demux[demux_id].demux_fd[n].fd, DMX_SET_FILTER1, &sFP2);
 		}
-		else
-		{
-			memcpy(sFP2.filter.filter, filt, 16);
+			else {
+				memcpy(sFP2.filter.filt,filt,16);
 			memcpy(sFP2.filter.mask, mask, 16);
 			if (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
 				ret = dvbapi_net_send(DVBAPI_DMX_SET_FILTER, demux[demux_id].socket_fd, demux_id, n, (unsigned char *) &sFP2, NULL, NULL);
@@ -668,11 +663,26 @@
 		sFP1.pid            = pid;
 		sFP1.timeout        = timeout;
 		sFP1.flags          = DMX_IMMEDIATE_START;
-		memcpy(sFP1.filter.filter, filt, 16);
+			memcpy(sFP1.filter.filt,filt,16);
 		memcpy(sFP1.filter.mask, mask, 16);
 		ret = dvbapi_ioctl(demux[demux_id].demux_fd[n].fd, DMX_SET_FILTER1, &sFP1);
 
 		break;
+
+#if defined(WITH_HISILICON)
+		case HISILICONAPI:
+			//	demux[demux_id].demux_fd[n].fd = 1;
+			// sky(quad)
+			ret = hidemuxapi_AddFilters(demux[demux_id].adapter_index, demux[demux_id].demux_index, type, n, pid, filt, mask);
+			if (ret > 0) {
+				demux[demux_id].demux_fd[n].fd = ret;
+			}
+			else {
+				ret = -1; // error setting filter!
+			}
+			break;
+#endif
+
 #ifdef WITH_STAPI
 	case STAPI:
 		ret = stapi_set_filter(demux_id, pid, filt, mask, n, demux[demux_id].pmt_file);
@@ -692,23 +702,43 @@
 	default:
 		break;
 	}
-	if(ret != -1)  // filter set successful
+	if (ret < 0)
 	{
+		cs_log("ERROR: Could not start demux filter (api: %d errno=%d %s)", selected_api, errno, strerror(errno));
+		return (ret);
+	}
+	// sky(move)
+	demux[demux_id].demux_fd[n].pidindex = pidx;
+	demux[demux_id].demux_fd[n].pid      = pid;
+	demux[demux_id].demux_fd[n].caid     = caid;
+	demux[demux_id].demux_fd[n].provid   = provid;
+	demux[demux_id].demux_fd[n].type     = type;
+
 		cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d started successfully (caid %04X provid %06X pid %04X)", demux_id, n + 1, caid, provid, pid);
 		if(type == TYPE_EMM && add_to_emm_list){ 
 			add_emmfilter_to_list(demux_id, filt, caid, provid, pid, n + 1, true);
 		}
-	}
-	else
-	{
-		cs_log("ERROR: Could not start demux filter (api: %d errno=%d %s)", selected_api, errno, strerror(errno));
-	}
-	return ret;
+	return (n);
 }
 
 static int32_t dvbapi_detect_api(void)
 {
-#ifdef WITH_COOLAPI
+#if defined(WITH_HISILICON)
+	selected_api		 = HISILICONAPI;
+	selected_box 		 = 6;
+	disable_pmt_files  = 1;
+	cfg.dvbapi_pmtmode = 1;
+	cfg.dvbapi_boxtype = BOXTYPE_HISILICON;
+	cfg.dvbapi_listenport = 0; // TCP port to listen instead of camd.socket
+	if (hidemuxapi_Init() == 0)
+	{
+		cs_log("ERROR: dvbiapi: setting up hisky failed.");
+		return 0;
+	}
+	cs_log("Detected Hisilicon{%d}.", cfg.dvbapi_pmtmode);
+	MYDVB_TRACE("mydvb:Hisilicon\n");
+	return 1;
+#elif defined(WITH_COOLAPI)
 	selected_api = COOLAPI;
 	selected_box = 5;
 	disable_pmt_files = 1;
@@ -734,7 +764,7 @@
 		cfg.dvbapi_listenport = 0;
 	}
 	
-	int32_t i = 0, n = 0, devnum = -1, dmx_fd = 0, ret = 0, boxnum = sizeof(devices) / sizeof(struct box_devices);
+	int32_t i = 0, n = 0, devnum = -1, dmx_fd = 0, boxnum = sizeof(devices) / sizeof(struct box_devices);
 	char device_path[128], device_path2[128];
 
 	while (i < boxnum)
@@ -757,7 +787,8 @@
 		if((dmx_fd = open(device_path, O_RDWR | O_NONBLOCK)) > 0)
 		{
 			devnum = i;
-			ret = close(dmx_fd);
+			int32_t ret = close(dmx_fd);
+			if (ret < 0) { cs_log("ERROR: Could not close demuxer fd (errno=%d %s)", errno, strerror(errno)); }
 			break;
 		}
 		/* try at least 8 adapters */
@@ -769,8 +800,6 @@
 	if(selected_box > -1)
 		{ selected_api = devices[selected_box].api; }
 	
-	if(ret < 0) { cs_log("ERROR: Could not close demuxer fd (errno=%d %s)", errno, strerror(errno)); } // log it here since some needed var are not inited before!
-	if(is_samygo){ cs_log("SAMYGO detected."); } // log it here since some needed var are not inited before!
 #ifdef WITH_STAPI
 	if(devnum == 4 && stapi_open() == 0)
 	{
@@ -822,8 +851,9 @@
 
 int32_t dvbapi_open_device(int32_t type, int32_t num, int32_t adapter)
 {
-	int32_t dmx_fd, ret;
+	int32_t dmx_fd;
 	int32_t ca_offset = 0;
+	int32_t ret = 0;
 	char device_path[128], device_path2[128];
 
 	if(cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
@@ -847,12 +877,28 @@
 		if(cfg.dvbapi_boxtype == BOXTYPE_PC)
 			{ num = 0; }
 
+#if defined(WITH_HISILICON)
+		if (cfg.dvbapi_boxtype==BOXTYPE_HISILICON) num = 0;
+#endif
+
 		snprintf(device_path2, sizeof(device_path2), devices[selected_box].ca_device, num + ca_offset);
 		snprintf(device_path, sizeof(device_path), devices[selected_box].path, adapter);
 
 		strncat(device_path, device_path2, sizeof(device_path) - strlen(device_path) - 1);
 	}
 
+#if defined(WITH_HISILICON)
+	if (cfg.dvbapi_boxtype==BOXTYPE_HISILICON) {
+	   struct sockaddr_un saddr;
+ 	   memset(&saddr, 0, sizeof(saddr));
+	   saddr.sun_family = AF_UNIX;
+	   strncpy(saddr.sun_path, device_path, sizeof(saddr.sun_path) - 1);
+      dmx_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+		ret = connect(dmx_fd, (struct sockaddr *)&saddr, sizeof(saddr));
+		if (ret < 0) close(dmx_fd);
+	}
+	else
+#endif
 	if (is_samygo) {
 		struct sockaddr_un saddr;
 		memset(&saddr, 0, sizeof(saddr));
@@ -862,7 +908,9 @@
 		ret = connect(dmx_fd, (struct sockaddr *)&saddr, sizeof(saddr));
 		if (ret < 0)
 			close(dmx_fd);
-	} else {
+	}
+	else {
+	   MYDVB_TRACE("mydvb:dvbapi_open_device{%s}\n", device_path);
 		dmx_fd = ret = open(device_path, O_RDWR | O_NONBLOCK);
 	}
 
@@ -877,6 +925,35 @@
 	return dmx_fd;
 }
 
+int32_t dvbapi_open_netdevice(int32_t UNUSED(type), int32_t UNUSED(num), int32_t adapter)
+{
+	int32_t socketfd;
+
+	socketfd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
+	if (socketfd == -1) {
+		cs_log("ERROR: Failed create socket (%d %s)", errno, strerror(errno));
+	}
+	else {
+		struct sockaddr_in saddr;
+		set_nonblock(socketfd, true);
+		bzero(&saddr, sizeof(saddr));
+		saddr.sin_family = AF_INET;
+		saddr.sin_port = htons(PORT + adapter); // port = PORT + adapter number
+		saddr.sin_addr.s_addr = inet_addr("127.0.0.1");
+		int32_t r = connect(socketfd, (struct sockaddr *) &saddr, sizeof(saddr));
+		if (r<0) {
+			cs_log("ERROR: Failed to connect socket (%d %s), at localhost, port=%d", errno, strerror(errno), PORT + adapter);
+			int32_t ret = close(socketfd);
+			if (ret < 0) cs_log("ERROR: Could not close socket fd (errno=%d %s)", errno, strerror(errno));
+			socketfd = -1;
+		}
+	}
+
+	MYDVB_TRACE("mydvb:netdevice(port:%d)(fd.%d)\n", PORT + adapter, socketfd);
+	cs_log_dbg(D_DVBAPI, "NET DEVICE open (port = %d) fd %d", PORT + adapter, socketfd);
+	return socketfd;
+}
+
 uint16_t tunemm_caid_map(uint8_t direct, uint16_t caid, uint16_t srvid)
 {
 	int32_t i;
@@ -915,11 +992,12 @@
 	{
 		if(demux[demux_index].demux_fd[g].type == type)
 		{
+			MYDVB_TRACE("mydvb:dvbapi_stop_filter{%s.%d}\n", (type==TYPE_ECM) ? "ecm":"emm", g);
 			ret = dvbapi_stop_filternum(demux_index, g);
 		}
 	}
-	if(ret == -1) { return 0; }  // on error return 0
-	else { return 1; }
+	if (ret == -1) return 0; // on error return 0
+	else return 1;
 }
 
 int32_t dvbapi_stop_filternum(int32_t demux_index, int32_t num)
@@ -959,6 +1037,20 @@
 			retfd = coolapi_close_device(fd);
 			break;
 #endif
+#if defined(WITH_HISILICON)
+			case HISILICONAPI:
+		      MYDVB_TRACE("mydvb:dvbapi_stop_filternum{%s:%d.%04X}\n",
+		      		(demux[demux_index].demux_fd[num].type==TYPE_ECM) ? "ecm":"emm" ,
+		      		num, demux[demux_index].demux_fd[num].pid);
+		      retfilter = hidemuxapi_RemoveFilters(demux[demux_index].adapter_index,
+				      				demux_index,
+								      demux[demux_index].demux_fd[num].type,
+								      num,
+								      demux[demux_index].demux_fd[num].pid);
+				if (retfilter < 1) retfilter = -1;
+				retfd = 0;
+				break;
+#endif
 		default:
 			break;
 		}
@@ -966,6 +1058,8 @@
 		{
 			cs_log("ERROR: Demuxer %d could not stop Filter %d (fd:%d api:%d errno=%d %s)", demux_index, num + 1, fd, selected_api, errno, strerror(errno));
 		}
+#if defined(WITH_HISILICON)
+#else
 #ifndef WITH_COOLAPI // no fd close for coolapi and stapi, all others do close fd!
 		if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX)
 		{
@@ -985,9 +1079,18 @@
 			cs_log("ERROR: Demuxer %d could not close fd of Filter %d (fd=%d api:%d errno=%d %s)", demux_index, num + 1, fd,
 				   selected_api, errno, strerror(errno));
 		}
+#endif
 
 		if(demux[demux_index].demux_fd[num].type == TYPE_ECM)   //ecm filter stopped: reset index!
 		{
+// sky(n)
+#if defined(__DVCCRC_AVAILABLE__)
+			DVBCRC_Remove(demux_index, demux[demux_index].demux_fd[num].pid);
+#endif
+
+#if defined(WITH_HISILICON)
+			demux[demux_index].ECMpids[demux[demux_index].demux_fd[num].pidindex].index = 0;
+#else
 			int32_t oldpid = demux[demux_index].demux_fd[num].pidindex;
 			int32_t curpid = demux[demux_index].pidindex;
 			int32_t idx = demux[demux_index].ECMpids[oldpid].index;
@@ -1041,6 +1144,7 @@
 					}
 				}
 			}
+#endif
 		}
 
 		if(demux[demux_index].demux_fd[num].type == TYPE_EMM)   // If emm type remove from emm filterlist
@@ -1055,37 +1159,47 @@
 	return 1; // all ok!
 }
 
-void dvbapi_start_filter(int32_t demux_id, int32_t pidindex, uint16_t pid, uint16_t caid, uint32_t provid, uchar table, uchar mask, int32_t timeout, int32_t type)
+int32_t dvbapi_start_filter(int32_t demux_id, int32_t pidx, uint16_t pid, uint16_t caid, uint32_t provid, uchar table, uchar mask, int32_t timeout, int32_t type)
 {
+	uchar filter[32];
+	int32_t filnum;
 	int32_t o;
+
+//	MYDVB_TRACE("mydvb:dvbapi_start_filter{%d}{%04X.%06X,%04x}\n", type, caid, provid, pid);
 	for(o = 0; o < maxfilter; o++)    // check if ecmfilter is in use & stop all ecmfilters of lower status pids
 	{
 		if(demux[demux_id].demux_fd[o].fd > 0 &&
 			demux[demux_id].demux_fd[o].pid == pid &&
 			demux[demux_id].demux_fd[o].type == type && type == TYPE_ECM)	
 		{
-			return;
+			return demux[demux_id].cs_filtnum;
 		}
 	}
-	uchar filter[32];
-	memset(filter, 0, 32);
 
+	memset(filter,0,32);
 	filter[0] = table;
 	filter[16] = mask;
 
 	cs_log_dbg(D_DVBAPI, "Demuxer %d try to start new filter for caid: %04X, provid: %06X, pid: %04X", demux_id, caid, provid, pid);
-	dvbapi_set_filter(demux_id, selected_api, pid, caid, provid, filter, filter + 16, timeout, pidindex, type, 0);
+	filnum = dvbapi_set_filter(demux_id,
+						selected_api,
+						pid,
+						caid,
+						provid,
+						filter,
+						filter+16,
+						timeout,
+						pidx,
+						type,
+						0);
+	demux[demux_id].cs_filtnum = filnum;
+	return (filnum);
 }
 
-void dvbapi_start_emm_filter(int32_t demux_index)
+int32_t dvbapi_start_emm_filter(int32_t demux_index)
 {
-	unsigned int j;
-	if(!demux[demux_index].EMMpidcount)
-		{ return; }
-
-	//if (demux[demux_index].emm_filter)
-	//  return;
-
+	if (!demux[demux_index].EMMpidcount) return 0;
+//	if ( demux[demux_index].emm_filter)  return 0;
 
 	struct s_csystem_emm_filter *dmx_filter = NULL;
 	unsigned int filter_count = 0;
@@ -1094,14 +1208,22 @@
 
 	struct s_reader *rdr = NULL;
 	struct s_client *cl = cur_client();
-	if(!cl || !cl->aureader_list)
-		{ return; }
+
+	if (!cl) return 0;
+	if (!cl->aureader_list)
+	{
+		mycs_trace(D_ADB,"mydvb:dvbapi_start_emm_filter(%c.aureader_list none)", cl->typ);
+		return 0;
+	}
 
 	LL_ITER itr = ll_iter_create(cl->aureader_list);
 	while((rdr = ll_iter_next(&itr)))
 	{
 		if(rdr->audisabled || !rdr->enable || (!is_network_reader(rdr) && rdr->card_status != CARD_INSERTED))
 			{ continue; }
+		if (IS_ICS_READERS(rdr)) continue;
+		// sky(powervu)
+		if (IS_CONSTCW_READERS(rdr)) continue;
 
 		const struct s_cardsystem *csystem;
 		uint16_t c, match;
@@ -1110,6 +1232,10 @@
 		{
 			caid = ncaid = demux[demux_index].EMMpids[c].CAID;
 			if(!caid) continue;
+			// sky(powervu)
+			if (IS_XCAS_READERS(rdr)) {
+				if (!xcas_IsAuAvailable(rdr, caid, 0)) continue;
+			}
 
 			if(chk_is_betatunnel_caid(caid) == 2)
 			{
@@ -1154,10 +1280,10 @@
 					continue;
 				}
 
-				for(j = 0; j < filter_count ; j++)
+				int j;
+			   for (j = 0; j < (int)filter_count; j++)
 				{
-					if(dmx_filter[j].enabled == 0)
-					{ continue; }
+				   if (dmx_filter[j].enabled == 0) continue;
 
 					uchar filter[32];
 					memset(filter, 0, sizeof(filter));  // reset filter
@@ -1200,6 +1326,7 @@
 		demux[demux_index].emm_filter = 0;
 	}
 	cs_log_dbg(D_DVBAPI, "Demuxer %d handles %i emm filters", demux_index, demux[demux_index].emm_filter);
+	return (demux[demux_index].emm_filter);
 }
 
 void dvbapi_add_ecmpid_int(int32_t demux_id, uint16_t caid, uint16_t ecmpid, uint32_t provid) 
@@ -1226,13 +1353,15 @@
 		}
 	}
 
-	if(added == 1)
-		{ return; }
+	if (added == 1) return;
 	for(n = 0; n < demux[demux_id].ECMpidcount; n++)  // check for existing pid
 	{
 		if(demux[demux_id].ECMpids[n].CAID == caid && demux[demux_id].ECMpids[n].ECM_PID == ecmpid && demux[demux_id].ECMpids[n].PROVID == provid)
 			{ return; } // found same pid -> skip
 	}
+
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].table	 = 0;
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].tableid = 0;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].ECM_PID = ecmpid;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].CAID = caid;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].PROVID = provid;
@@ -1240,12 +1369,18 @@
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].checked = 0;
 	//demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].index = 0;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].status = 0;
-	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].tries = 0xFE;
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].tries 	 = 0xfe;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].streams = 0; // reset streams!
-	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_curindex = 0xFE; // reset
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_curindex = 0xfe; 	// reset
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_maxindex = 0; // reset
-	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_cycle = 0xFE; // reset
-	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].table = 0;
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_cycle		= 0xfe; 	// reset
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_cycling	= 0;
+#if defined(MODULE_XCAMD)
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].iks_irdeto_pi	= 0xfe;
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].iks_irdeto_chid	= 0x10000;
+#endif
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].constcw = (caid_is_biss(caid)) ? 1 : 0;
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].crcprevious = 0; /* sky(dvn) */
 
 	cs_log("Demuxer %d ecmpid %d CAID: %04X ECM_PID: %04X PROVID: %06X", demux_id, demux[demux_id].ECMpidcount, caid, ecmpid, provid);
 	if(caid_is_irdeto(caid)) { demux[demux_id].emmstart.time = 1; }  // marker to fetch emms early irdeto needs them!
@@ -1255,10 +1390,11 @@
 
 void dvbapi_add_ecmpid(int32_t demux_id, uint16_t caid, uint16_t ecmpid, uint32_t provid)
 {
+	MYDVB_TRACE("mydvb:dvbapi_add_ecmpid{%04X:%06X, %04X}\n", caid, provid, ecmpid);
 	dvbapi_add_ecmpid_int(demux_id, caid, ecmpid, provid);
 	struct s_dvbapi_priority *joinentry;
 
-	for(joinentry = dvbapi_priority; joinentry != NULL; joinentry = joinentry->next)
+	for (joinentry=dvbApi_priority; joinentry != NULL; joinentry=joinentry->next)
 	{
 		if((joinentry->type != 'j')
 				|| (joinentry->caid && joinentry->caid != caid)
@@ -1272,7 +1408,7 @@
 	}
 }
 
-void dvbapi_add_emmpid(int32_t demux_id, uint16_t caid, uint16_t emmpid, uint32_t provid, uint8_t type)
+void dvbapi_add_emmpid(struct s_reader *aurdr, int32_t demux_id, uint16_t caid, uint16_t emmpid, uint32_t provid, uint8_t type)
 {
 	char typetext[40];
 	cs_strncpy(typetext, ":", sizeof(typetext));
@@ -1301,13 +1437,15 @@
 	cs_log_dbg(D_DVBAPI, "Added new emmpid %d CAID: %04X EMM_PID: %04X PROVID: %06X TYPE %s", demux[demux_id].EMMpidcount - 1, caid, emmpid, provid, typetext);
 }
 
-void dvbapi_parse_cat(int32_t demux_id, uchar *buf, int32_t len)
+void dvbapi_parse_cat(int32_t demux_id, uchar *buffer, int32_t bufsize)
 {
-#ifdef WITH_COOLAPI
+#if defined(WITH_HISILICON)
+	demux[demux_id].max_emmfilters = MAX_FILTER-1;
+#elif defined(WITH_COOLAPI)
 	// driver sometimes reports error if too many emm filter
 	// but adding more ecm filter is no problem
 	// ... so ifdef here instead of limiting MAX_FILTER
-	demux[demux_id].max_emm_filter = 14;
+	demux[demux_id].max_emmfilters = 14;
 #else
 	if(cfg.dvbapi_requestmode == 1)
 	{
@@ -1315,71 +1453,131 @@
 		for(n = 0; n < demux[demux_id].ECMpidcount; n++)
 		{
 			if(demux[demux_id].ECMpids[n].status > -1)
-				{ ecm_filter_needed++; }
+				ecm_filter_needed++;
 		}
 		if(maxfilter - ecm_filter_needed <= 0)
-			{ demux[demux_id].max_emm_filter = 0; }
+			demux[demux_id].max_emmfilters = 0;
 		else
-			{ demux[demux_id].max_emm_filter = maxfilter - ecm_filter_needed; }
+			demux[demux_id].max_emmfilters = maxfilter-ecm_filter_needed;
 	}
-	else
-	{
-		demux[demux_id].max_emm_filter = maxfilter - 1;
+	else {
+		demux[demux_id].max_emmfilters = maxfilter-1;
 	}
 #endif
 	uint16_t i, k;
+	uint16_t sctlen = SCT_DATLEN(buffer);
+	if (bufsize != sctlen + 3) { // invalid CAT length
+		cs_log_dbg(D_DVBAPI, "[DVBAPI] Received an CAT with invalid length!");
+		return;
+	}
+
+ 	MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CAT\n");
+	cs_log_dump_dbg(D_DVBAPI, buffer, bufsize, "cat:");
+	struct s_client *cl = cur_client();
+	if (!cl) return;
+	if (!cl->aureader_list)
+	{
+		mycs_trace(D_ADB,"mydvb:dvbapi_parse_cat(%c.aureader_list none)", cl->typ);
+		return;
+	}
+
+	struct s_reader *aurdr = NULL;
+	LL_ITER itr = ll_iter_create(cl->aureader_list);
+	while ((aurdr = ll_iter_next(&itr))) // make a list of all readers
+	{
+		if (!aurdr->client
+			|| ( aurdr->audisabled)
+			|| (!aurdr->enable)
+			|| (!is_network_reader(aurdr) && aurdr->card_status != CARD_INSERTED))
+		{
+		//	MYDVB_TRACE("mydvb:Reader %12s au disabled or not enabled-> skip!\n", aurdr->label); // only parse au enabled readers that are enabled
+			cs_log_dbg(D_DVBAPI,"Reader %12s au disabled or not enabled-> skip!", aurdr->label); // only parse au enabled readers that are enabled
+			continue;
+		}
+		// sky(powervu)
+		if (IS_XCAMD_READERS(aurdr)) continue;
+		if (IS_MORECAM_READERS(aurdr)) continue;
+		if (IS_CONSTCW_READERS(aurdr)) continue;
 
-	cs_log_dump_dbg(D_DVBAPI, buf, len, "cat:");
+		MYDVB_TRACE("mydvb:Reader %s au enabled.\n", aurdr->label);
+		cs_log_dbg(D_DVBAPI,"Reader %s au enabled -> parsing cat for emm pids!", aurdr->label);
 
-	for(i = 8; i < (b2i(2, buf + 1)&0xFFF) - 1; i += buf[i + 1] + 2)
+		for (i = 8; i < sctlen - 1; i += buffer[i+1] + 2)
 	{
-		if(buf[i] != 0x09) { continue; }
-		if(demux[demux_id].EMMpidcount >= ECM_PIDS) { break; }
+			if (buffer[i] != 0x09) continue;
+			if (demux[demux_id].EMMpidcount >= EMM_PIDS) break;
 
-		uint16_t caid = b2i(2, buf + i + 2);
-		uint16_t emm_pid = b2i(2, buf + i +4)&0x1FFF;
+			uint16_t caid = b2i(2, buffer + i + 2);
+			uint16_t emm_pid = b2i(2, buffer + i +4)&0x1FFF;
 		uint32_t emm_provider = 0;
 
+//			MYDVB_TRACE("mydvb:emm-casysid: %04X,%04X\n", caid, emm_pid);
 		switch(caid >> 8)
 		{
 			case 0x01:
-				dvbapi_add_emmpid(demux_id, caid, emm_pid, 0, EMM_UNIQUE | EMM_GLOBAL);
-				for(k = i + 7; k < i + buf[i + 1] + 2; k += 4)
+// sky(powervu)
+#if defined(MODULE_XCAS)
+					if (IS_XCAS_READERS(aurdr)) break;
+#endif
+					dvbapi_add_emmpid(aurdr, demux_id, caid, emm_pid, 0, EMM_UNIQUE|EMM_GLOBAL);
+					for (k = i+7; k < i+buffer[i+1]+2; k += 4)
 				{
-					emm_provider = b2i(2, buf + k + 2);
-					emm_pid = b2i(2, buf + k)&0xFFF;
-					dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_SHARED);
+					   emm_provider = b2i(2, buffer + k + 2);
+					   emm_pid = b2i(2, buffer + k)&0xFFF;
+						dvbapi_add_emmpid(aurdr, demux_id, caid, emm_pid, emm_provider, EMM_SHARED);
 				}
 				break;
 			case 0x05:
-				for(k = i + 6; k < i + buf[i + 1] + 2; k += buf[k + 1] + 2)
+// sky(powervu)
+#if defined(MODULE_XCAS)
+					if (IS_XCAS_READERS(aurdr)) break;
+#endif
+					for (k = i+6; k < i+buffer[i+1]+2; k += buffer[k+1]+2)
 				{
-					if (buf[k] == 0x14)
+						if (buffer[k] == 0x14)
 					{
-						emm_provider = (b2i(3, buf + k + 2) & 0xFFFFF0); // viaccess fixup last digit is a dont care!
-						dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+							emm_provider = (b2i(3, buffer + k + 2) & 0xFFFFF0); // viaccess fixup last digit is a dont care!
+							dvbapi_add_emmpid(aurdr, demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
 					}
 				}
 				break;
 			case 0x18:
-				if(buf[i + 1] == 0x07 || buf[i + 1] == 0x0B)
+// sky(powervu)
+#if defined(MODULE_XCAS)
+					if (IS_XCAS_READERS(aurdr)) break;
+#endif
+					if (buffer[i + 1] == 0x07 || buffer[i + 1] == 0x0B)
 				{
-					for(k = i + 7; k < i + 7 + buf[i + 6]; k += 2)
+						for(k = i + 7; k < i + 7 + buffer[i + 6]; k += 2)
 					{
-						emm_provider = b2i(2, buf + k);
-						dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+							emm_provider = b2i(2, buffer + k);
+							dvbapi_add_emmpid(aurdr, demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
 					}
 				}
 				else
 				{
-					dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+						dvbapi_add_emmpid(aurdr, demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE|EMM_SHARED|EMM_GLOBAL);
 				}
 				break;
 			default:
-				dvbapi_add_emmpid(demux_id, caid, emm_pid, 0, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+				// sky(DRE3)
+				//	if (aurdr->DRE_3s)
+					{
+						if (((caid & 0xfffe)==0x4AE0) || ((caid & 0xfffe)==0x7BE0) || (caid ==0x2710)) {
+							if (buffer[i+1] > 4) emm_provider = buffer[i+6];
+						}
+					}
+// sky(powervu)
+#if defined(MODULE_XCAS)
+					if (IS_XCAS_READERS(aurdr)) {
+						if (!xcas_IsAuAvailable(aurdr, caid, emm_provider)) break;
+					}
+#endif
+					dvbapi_add_emmpid(aurdr, demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE|EMM_SHARED|EMM_GLOBAL);
 				break;
 		}
 	}
+	}
 	return;
 }
 
@@ -1418,6 +1616,8 @@
 void dvbapi_set_pid(int32_t demux_id, int32_t num, int32_t idx, bool enable)
 {
 	int32_t i, currentfd;
+
+//	MYDVB_TRACE("mydvb:dvbapi_set_pid{%d, %d.%04X}\n", demux[demux_id].pidindex, num, demux[demux_id].STREAMpids[num]);
 	if(demux[demux_id].pidindex == -1 && enable) return; // no current pid on enable? --> exit
 
 	switch(selected_api)
@@ -1432,6 +1632,13 @@
 	case COOLAPI:
 		break;
 #endif
+
+#if defined(WITH_HISILICON)
+// unnecessariness(tvheadend)....
+		case HISILICONAPI:
+			break;
+#endif
+
 	default:
 		for(i = 0; i < MAX_DEMUX; i++)
 		{
@@ -1509,86 +1716,167 @@
 void dvbapi_stop_descrambling(int32_t demux_id)
 {
 	int32_t i;
-	if(demux[demux_id].program_number == 0) { return; }
+
+ 	MYDVB_TRACE("mydvb:SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS STOP.\n");
+	MYDVB_TRACE("mydvb:dvbapi_stop_descrambling{%d,%d}\n", demux_id, demux[demux_id].program_number);
+	if (demux[demux_id].program_number==0) return;
+
 	char channame[32];
 	i = demux[demux_id].pidindex;
-	if(i < 0) { i = 0; }
-	demux[demux_id].pidindex = -1; // no ecmpid is to be descrambling since we start stop descrambling!
-	get_servicename(dvbapi_client, demux[demux_id].program_number, demux[demux_id].ECMpidcount > 0 ? demux[demux_id].ECMpids[i].CAID : 0, channame);
+	if (i< 0) i = 0;
+	int32_t idx = demux[demux_id].ECMpids[i].index;
+	get_servicename(dvbApi_client, demux[demux_id].program_number, demux[demux_id].ECMpidcount>0 ? demux[demux_id].ECMpids[i].CAID : 0, channame);
 	cs_log_dbg(D_DVBAPI, "Demuxer %d stop descrambling program number %04X (%s)", demux_id, demux[demux_id].program_number, channame);
 	dvbapi_stop_filter(demux_id, TYPE_EMM);
 	if(demux[demux_id].ECMpidcount > 0)
 	{
 		dvbapi_stop_filter(demux_id, TYPE_ECM);
+		demux[demux_id].cs_cwidx = -1;
+		demux[demux_id].pidindex = -1;
+		demux[demux_id].curindex = -1;
+		for (i=0; i<demux[demux_id].STREAMpidcount; i++) {
+			dvbapi_set_pid(demux_id, i, idx - 1, false); // disable all streampids for this index!
+		}
 	}
+// sky(powervu)
+#if defined(MODULE_XCAS) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	DVBICS_ChCloser(demux_id);
+#endif
 
 	memset(&demux[demux_id], 0 , sizeof(DEMUXTYPE));
 	demux[demux_id].pidindex = -1;
 	demux[demux_id].curindex = -1;
-	if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX)
+	demux[demux_id].cs_cwidx = -1;
+	// sky(his)
+	if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && cfg.dvbapi_boxtype != BOXTYPE_HISILICON) {
 		unlink(ECMINFO_FILE);
+	}
 	return;
 }
 
-int32_t dvbapi_start_descrambling(int32_t demux_id, int32_t pid, int8_t checked)
+// sky(n)
+#if defined(MODULE_XCAS)
+int32_t dvbapi_constcw_afterwards(int32_t typ, int32_t demux_id, int16_t direction)
 {
-	int32_t started = 0; // in case ecmfilter started = 1
-	int32_t fake_ecm = 0;
 	ECM_REQUEST *er;
+	int16_t idx = demux[demux_id].curindex;
+
+	mycs_debug(D_DVBAPI, "dvbapi_constcw_afterwards(%x){%d, %d}\n", typ, idx, direction);
+	if (!demux[demux_id].ECMpids[idx].constcw) return 0;
+
+	if (!(er = get_ecmtask())) return 0;
+	er->dmuxid = demux_id;// sky(powervu)
+	er->srvid  = demux[demux_id].program_number;
+	er->caid   = demux[demux_id].ECMpids[idx].CAID;
+	er->pid    = demux[demux_id].ECMpids[idx].ECM_PID;
+	er->prid   = demux[demux_id].ECMpids[idx].PROVID;
+	er->vpid   = demux[demux_id].ECMpids[idx].VPID;
+	er->ecmlen = 13;
+	er->ecm[0] = 0x80;
+	er->ecm[1] = 0;
+	er->ecm[2] = 10;
+	i2b_buf(2, er->srvid, er->ecm+3);
+	i2b_buf(2, er->vpid,  er->ecm+5);
+	i2b_buf(2, demux[demux_id].cs_degree, er->ecm+7);
+	i2b_buf(2, demux[demux_id].cs_frequency, er->ecm+9);
+	i2b_buf(2, demux[demux_id].cs_subsequence, er->ecm+11);
+	if (direction) er->constAfterwards++;
+	else er->constAfterwards = 0;
+	er->chSets.muxid	 	= demux_id;
+	er->chSets.srvid  	= demux[demux_id].program_number;
+	er->chSets.degree		= demux[demux_id].cs_degree;
+	er->chSets.frequency = demux[demux_id].cs_frequency;
+	er->chSets.vpid	 	= demux[demux_id].cs_vidpid;
+
+	demux[demux_id].cs_subsequence++;
+	dvbapi_request_cw(dvbApi_client, er, demux_id, demux[demux_id].cs_filtnum, 0);
+	return 1;
+}
+#endif
+
+int32_t dvbapi_start_descrambling(int32_t demux_id, int32_t pidx, int8_t checked)
+{
 	struct s_reader *rdr;
-	if(!(er = get_ecmtask())) { return started; }
-	demux[demux_id].ECMpids[pid].checked = checked + 1; // mark this pid as checked!
+	ECM_REQUEST *er;
+	int32_t started = 0; // in case ecmfilter started = 1
+//	int32_t ecmfake = 0;
+
+	if (!(er = get_ecmtask())) return started;
+	er->dmuxid = demux_id;// sky(powervu)
+	demux[demux_id].ECMpids[pidx].checked = checked + 1; // mark this pidx as checked!
+#if defined(MODULE_XCAMD)
+	demux[demux_id].ECMpids[pidx].iks_irdeto_pi = 0xfe;
+	demux[demux_id].ECMpids[pidx].iks_irdeto_chid = 0x10000;
+#endif
 
+	MYDVB_TRACE("mydvb:dvbapi_start_descrambling{%d, %d}\n", pidx, demux[demux_id].curindex);
 	struct s_dvbapi_priority *p;
-	for(p = dvbapi_priority; p != NULL ; p = p->next)
+	for (p = dvbApi_priority; p != NULL ; p = p->next)
 	{
 		if((p->type != 'p')
-				|| (p->caid && p->caid != demux[demux_id].ECMpids[pid].CAID)
-				|| (p->provid && p->provid != demux[demux_id].ECMpids[pid].PROVID)
-				|| (p->ecmpid && p->ecmpid != demux[demux_id].ECMpids[pid].ECM_PID)
+			|| (p->caid   && p->caid   != demux[demux_id].ECMpids[pidx].CAID)
+			|| (p->provid && p->provid != demux[demux_id].ECMpids[pidx].PROVID)
+			|| (p->ecmpid && p->ecmpid != demux[demux_id].ECMpids[pidx].ECM_PID)
 				|| (p->srvid && p->srvid != demux[demux_id].program_number)
-				|| (p->pidx && p->pidx-1 != pid))
+			|| (p->pidx   && p->pidx-1 != pidx))
 			{ continue; }
 		// if found chid and first run apply chid filter, on forced pids always apply!
-		if(p->type == 'p' && p->chid < 0x10000 && (demux[demux_id].ECMpids[pid].checked == 1 || (p && p->force)))
+		if (p->type == 'p' && p->chid <0x10000 && (demux[demux_id].ECMpids[pidx].checked == 1 || (p && p->force)))
 		{
-			if(demux[demux_id].ECMpids[pid].CHID < 0x10000)   // channelcache delivered chid
+			if (demux[demux_id].ECMpids[pidx].CHID < 0x10000) // channelcache delivered chid
 			{
-				er->chid = demux[demux_id].ECMpids[pid].CHID;
+				er->chid = demux[demux_id].ECMpids[pidx].CHID;
 			}
 			else
 			{
 				er->chid = p->chid; // no channelcache or no chid in use, so use prio chid
-				demux[demux_id].ECMpids[pid].CHID = p->chid;
+				demux[demux_id].ECMpids[pidx].CHID = p->chid;
 			}
-			//cs_log("********* CHID %04X **************", demux[demux_id].ECMpids[pid].CHID);
+		//	cs_log("********* CHID %04X **************", demux[demux_id].ECMpids[pidx].CHID);
 			break; // we only accept one!
 		}
 		else
 		{
-			if(demux[demux_id].ECMpids[pid].CHID < 0x10000)   // channelcache delivered chid
+			if (demux[demux_id].ECMpids[pidx].CHID < 0x10000) // channelcache delivered chid
 			{
-				er->chid = demux[demux_id].ECMpids[pid].CHID;
+				er->chid = demux[demux_id].ECMpids[pidx].CHID;
 			}
 			else   // no channelcache or no chid in use
 			{
 				er->chid = 0;
-				demux[demux_id].ECMpids[pid].CHID = 0x10000;
+				demux[demux_id].ECMpids[pidx].CHID = 0x10000;
 			}
 		}
 	}
+	er->onid   = demux[demux_id].onid;
 	er->srvid = demux[demux_id].program_number;
-	er->caid  = demux[demux_id].ECMpids[pid].CAID;
-	er->pid   = demux[demux_id].ECMpids[pid].ECM_PID;
-	er->prid  = demux[demux_id].ECMpids[pid].PROVID;
-	er->vpid  = demux[demux_id].ECMpids[pid].VPID;
+	er->caid   = demux[demux_id].ECMpids[pidx].CAID;
+	er->pid    = demux[demux_id].ECMpids[pidx].ECM_PID;
+	er->prid   = demux[demux_id].ECMpids[pidx].PROVID;
+	er->vpid   = demux[demux_id].ECMpids[pidx].VPID;
 	er->pmtpid  = demux[demux_id].pmtpid;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM) || defined(MODULE_XCAS)
+	er->chSets.muxid	 	= demux_id;
+	er->chSets.srvid  	= demux[demux_id].program_number;
+	er->chSets.degree		= demux[demux_id].cs_degree;
+	er->chSets.frequency = demux[demux_id].cs_frequency;
+	er->chSets.vpid	 	= demux[demux_id].cs_vidpid;
+#endif
+#if defined(MODULE_AVAMGCAMD)
+	er->exprid = er->prid;
+	if (IS_IRDETO(er->caid)) {
+		er->exprid = (((er->onid>>8)&0xff) ^ ((er->onid)&0xff));
+	}
+#endif
+#if defined(__DVCCRC_AVAILABLE__)
+	DVBCRC_Clean(&(demux[demux_id].ECMpids[pidx]));
+#endif
 
 	struct timeb now;
 	cs_ftime(&now);
 	for(rdr = first_active_reader; rdr != NULL ; rdr = rdr->next)
 	{
-		int8_t match = matching_reader(er, rdr); // check for matching reader
+		int8_t match = matching_reader(er, rdr, 1); // check for matching reader
 		int64_t gone = comp_timeb(&now, &rdr->emm_last);
 		if(gone > 3600*1000 && rdr->needsemmfirst && caid_is_irdeto(er->caid))
 		{
@@ -1604,7 +1892,7 @@
 		if(!match && chk_is_betatunnel_caid(er->caid))  // these caids might be tunneled invisible by peers
 			{ match = 1; } // so make it a match to try it!
 
-		if(config_enabled(CS_CACHEEX) && (!match && (cacheex_is_match_alias(dvbapi_client, er))))   // check if cache-ex is matching
+		if (config_enabled(CS_CACHEEX) && (!match && (cacheex_is_match_alias(dvbApi_client, er))))   // check if cache-ex is matching
 		{
 			match = 1; // so make it a match to try it!
 		}
@@ -1612,36 +1900,46 @@
 		// BISS or FAKE CAID
 		// ecm stream pid is fake, so send out one fake ecm request
 		// special treatment: if we asked the cw first without starting a filter the cw request will be killed due to no ecmfilter started
-		if(caid_is_fake(demux[demux_id].ECMpids[pid].CAID) || caid_is_biss(demux[demux_id].ECMpids[pid].CAID))
+		if (caid_is_fake(demux[demux_id].ECMpids[pidx].CAID) || caid_is_biss(demux[demux_id].ECMpids[pidx].CAID))
 		{
-			int32_t j, n;
-			er->ecmlen = 5;
-			er->ecm[0] = 0x80; // to pass the cache check it must be 0x80 or 0x81
-			er->ecm[1] = 0x00;
-			er->ecm[2] = 0x02;
+			MYDVB_TRACE("mydvb:biss channel\n");
+			er->ecmlen = 13;
+			er->ecm[0] = 0x80;
+			er->ecm[1] = 0;
+			er->ecm[2] = 10;
 			i2b_buf(2, er->srvid, er->ecm + 3);
+			i2b_buf(2, er->vpid,  er->ecm+5);
+			i2b_buf(2, demux[demux_id].cs_degree, er->ecm+7);
+			i2b_buf(2, demux[demux_id].cs_frequency, er->ecm+9);
+			i2b_buf(2, demux[demux_id].cs_subsequence, er->ecm+11);
+			demux[demux_id].cs_subsequence++;
+#if defined(MODULE_XCAS)
+			er->constAfterwards = 0;
+#endif
 
-			for(j = 0, n = 5; j < demux[demux_id].STREAMpidcount; j++, n += 2)
-			{
-				i2b_buf(2, demux[demux_id].STREAMpids[j], er->ecm + n);
-				er->ecm[2] += 2;
-				er->ecmlen += 2;
-			}
-
-			cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pid,
-				   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
-				   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pid].VPID);
-
-			demux[demux_id].curindex = pid; // set current pid to the fresh started one
-
-			dvbapi_start_filter(demux_id, pid, demux[demux_id].ECMpids[pid].ECM_PID, demux[demux_id].ECMpids[pid].CAID,
-								demux[demux_id].ECMpids[pid].PROVID, 0x80, 0xF0, 3000, TYPE_ECM);
+			cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pidx,
+				   demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID,
+				   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pidx].VPID);
+
+			demux[demux_id].curindex = pidx; // set current pidx to the fresh started one
+
+			int32_t filnum;
+			filnum = dvbapi_start_filter(demux_id,
+								pidx,
+								demux[demux_id].ECMpids[pidx].ECM_PID,
+								demux[demux_id].ECMpids[pidx].CAID,
+								demux[demux_id].ECMpids[pidx].PROVID,
+								0x80,
+								0xF0,
+								3000,
+								TYPE_ECM);
 			started = 1;
 
-			request_cw(dvbapi_client, er, demux_id, 0); // do not register ecm since this try!
-			fake_ecm = 1;
+			dvbapi_request_cw(dvbApi_client, er, demux_id, filnum, 0); // do not register ecm since this try!
+//			ecmfake = 1;
 			break; // we started an ecmfilter so stop looking for next matching reader!
 		}
+
 		if(match)   // if matching reader found check for irdeto cas if local irdeto card check if it received emms in last 60 minutes
 		{
 
@@ -1647,39 +1945,45 @@
 
 			if(caid_is_irdeto(er->caid))   // irdeto cas init irdeto_curindex to wait for first index (00)
 			{
-				if(demux[demux_id].ECMpids[pid].irdeto_curindex == 0xFE) { demux[demux_id].ECMpids[pid].irdeto_curindex = 0x00; }
+				if (demux[demux_id].ECMpids[pidx].irdeto_curindex==0xfe) demux[demux_id].ECMpids[pidx].irdeto_curindex = 0x00;
 			}
 
-			if(p && p->chid < 0x10000)  // do we prio a certain chid?
-			{
-				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X CHID %04X PMTPID %04X VPID %04X", demux_id, pid,
-					   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
-					   demux[demux_id].ECMpids[pid].CHID, demux[demux_id].pmtpid, demux[demux_id].ECMpids[pid].VPID);
-			}
-			else
-			{
-				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pid,
-					   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
-					   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pid].VPID);
+			if (p && p->chid<0x10000) { // do we prio a certain chid?
+				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X CHID %04X PMTPID %04X VPID %04X", demux_id, pidx,
+						demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID,
+						demux[demux_id].ECMpids[pidx].CHID, demux[demux_id].pmtpid, demux[demux_id].ECMpids[pidx].VPID);
 			}
-
-			demux[demux_id].curindex = pid; // set current pid to the fresh started one
-
-			dvbapi_start_filter(demux_id, pid, demux[demux_id].ECMpids[pid].ECM_PID, demux[demux_id].ECMpids[pid].CAID,
-								demux[demux_id].ECMpids[pid].PROVID, 0x80, 0xF0, 3000, TYPE_ECM);
+			else {
+				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pidx,
+						demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID,
+					   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pidx].VPID);
+			}
+
+			demux[demux_id].curindex = pidx; // set current pidx to the fresh started one
+
+			dvbapi_start_filter(demux_id,
+							pidx,
+							demux[demux_id].ECMpids[pidx].ECM_PID,
+							demux[demux_id].ECMpids[pidx].CAID,
+							demux[demux_id].ECMpids[pidx].PROVID,
+							0x00,
+							0x00,
+							3000,
+							TYPE_ECM);
 			started = 1;
 			break; // we started an ecmfilter so stop looking for next matching reader!
 		}
 	}
-	if(demux[demux_id].curindex != pid)
+	if (demux[demux_id].curindex != pidx)
 	{
-		cs_log("Demuxer %d impossible to descramble PID %d CAID %04X PROVID %06X ECMPID %04X PMTPID %04X (NO MATCHING READER)", demux_id, pid,
-			   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID, demux[demux_id].pmtpid);
-		demux[demux_id].ECMpids[pid].checked = 4; // flag this pid as checked
-		demux[demux_id].ECMpids[pid].status = -1; // flag this pid as unusable
-		dvbapi_edit_channel_cache(demux_id, pid, 0); // remove this pid from channelcache
+		cs_log("Demuxer %d impossible to descramble PID %d CAID %04X PROVID %06X ECMPID %04X PMTPID %04X (NO MATCHING READER)", demux_id, pidx,
+				demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID, demux[demux_id].pmtpid);
+		demux[demux_id].ECMpids[pidx].checked =  4; // flag this pid as checked
+		demux[demux_id].ECMpids[pidx].status  = -1; // flag this pid as unusable
+		dvbapi_edit_channel_cache(demux_id, pidx, 0); 	  // remove this pid from channelcache
 	}
-	if(!fake_ecm) { NULLFREE(er); }
+// sky(?)
+//	if (!ecmfake) NULLFREE(er);
 	return started;
 }
 
@@ -1689,6 +1993,7 @@
 	int32_t i;
 
 	uint16_t ecm_pid = 0;
+//	MYDVB_TRACE("mydvb:dvbapi_check_prio_match_emmpid\n");
 	for(i = 0; i < demux[demux_id].ECMpidcount; i++)
 	{
 		if((demux[demux_id].ECMpids[i].CAID == caid) && (demux[demux_id].ECMpids[i].PROVID == provid))
@@ -1699,9 +2004,9 @@
 	}
 
 	if(!ecm_pid)
-		{ return NULL; }
+		return NULL;
 
-	for(p = dvbapi_priority; p != NULL; p = p->next)
+	for(p = dvbApi_priority; p != NULL; p = p->next)
 	{
 		if(p->type != type
 				|| (p->caid && p->caid != caid)
@@ -1710,43 +2015,47 @@
 				|| (p->srvid && p->srvid != demux[demux_id].program_number)
 				|| (p->pidx && p->pidx-1 !=i)
 				|| (p->type == 'i' && (p->chid < 0x10000)))
-			{ continue; }
+			continue;
 		return p;
 	}
 	return NULL;
 }
 
-struct s_dvbapi_priority *dvbapi_check_prio_match(int32_t demux_id, int32_t pidindex, char type)
+struct s_dvbapi_priority *dvbapi_check_prio_match(int32_t demux_id, int32_t pidx, char type)
 {	
 	struct s_dvbapi_priority *p;
-	struct s_ecmpids *ecmpid = &demux[demux_id].ECMpids[pidindex];
+	struct s_ecmpids *ecmpid = &demux[demux_id].ECMpids[pidx];
 
-	for(p = dvbapi_priority; p != NULL; p = p->next)
+	for(p = dvbApi_priority; p != NULL; p = p->next)
 	{
 		if(p->type != type
 				|| (p->caid && p->caid != ecmpid->CAID)
 				|| (p->provid && p->provid != ecmpid->PROVID)
 				|| (p->ecmpid && p->ecmpid != ecmpid->ECM_PID)
 				|| (p->srvid && p->srvid != demux[demux_id].program_number)
-				//|| (p->type == 'i' && (p->chid > -1)))  ///????
-				|| (p->pidx && p->pidx-1 != pidindex)
+		//	|| (p->type == 'i' && (p->chid > -1)))  // ????
+			|| (p->pidx   && p->pidx-1 != pidx)
 				|| (p->chid < 0x10000 && p->chid != ecmpid->CHID))
-			{ continue; }
+		{
+			continue;
+		}
+		MYDVB_TRACE("mydvb:check_prio_matching\n");
 		return p;
 	}
 	return NULL;
 }
 
-void dvbapi_process_emm(int32_t demux_index, int32_t filter_num, unsigned char *buffer, uint32_t len)
+
+void dvbapi_process_emm(int32_t demux_index, int32_t filter_num, unsigned char *buffer, uint32_t bufsize)
 {
-	EMM_PACKET epg;
+	EMM_PACKET emmpkt_s;
+	int32_t emmsento = 0;
 
 	cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d fetched emm data", demux_index, filter_num + 1); // emm shown with -d64
 
 	struct s_emm_filter *filter = get_emmfilter_by_filternum(demux_index, filter_num + 1);
 
-	if(!filter)
-	{
+	if (!filter) {
 		cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d no filter matches -> SKIP!", demux_index, filter_num +1);
 		return;
 	}
@@ -1762,26 +2071,49 @@
 		caid = mapentry->mapcaid;
 		provider = mapentry->mapprovid;
 	}
+	#if (__ADB_TRACE__)
+		if (IS_CRYPTOWORKS(caid)) {
+			if (buffer[0] == 0x86) {
+				MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EMM{%02X}{%04X:%06X}{%02X.%d}\n", buffer[0], caid, provider, buffer[8], bufsize);
+			}
+			else {
+				MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EMM{%02X}{%04X:%06X}{%2d.%d}\n", buffer[0], caid, provider, filter_num, bufsize);
+				myprdump("@@@ EMM", buffer, bufsize);
+			}
+		}
+		else {
+			MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EMM{%02X}{%04X:%06X}{%d.%d}\n", buffer[0], caid, provider, filter_num, bufsize);
+			myprdump("@@@ EMM", buffer, bufsize);
+		}
+	#endif
 
-	memset(&epg, 0, sizeof(epg));
+	memset(&emmpkt_s, 0, sizeof(emmpkt_s));
 
-	i2b_buf(2, caid, epg.caid);
-	i2b_buf(4, provider, epg.provid);
+	i2b_buf(2, caid, emmpkt_s.caid);
+	i2b_buf(4, provider, emmpkt_s.provid);
 
-	epg.emmlen = len > sizeof(epg.emm) ? sizeof(epg.emm) : len;
-	memcpy(epg.emm, buffer, epg.emmlen);
+//	emmpkt_s.emmlen = bufsize;
+	emmpkt_s.emmlen = bufsize > sizeof(emmpkt_s.emm) ? sizeof(emmpkt_s.emm) : bufsize;
+	memcpy(emmpkt_s.emm, buffer, emmpkt_s.emmlen);
 
 	if(config_enabled(READER_IRDETO) && chk_is_betatunnel_caid(caid) == 2)
 	{
 		uint16_t ncaid = tunemm_caid_map(FROM_TO, caid, demux[demux_index].program_number);
-		if(caid != ncaid)
-		{
-			irdeto_add_emm_header(&epg);
-			i2b_buf(2, ncaid, epg.caid);
+		if (caid != ncaid) {
+			irdeto_add_emm_header(&emmpkt_s);
+			i2b_buf(2, ncaid, emmpkt_s.caid);
 		}
 	}
 
-	do_emm(dvbapi_client, &epg);
+	// sky(a!)
+	emmsento = do_emm(dvbApi_client, &emmpkt_s);
+	if (!emmsento)	{
+		if (dvbApi_client->emmsento) {
+			mycs_trace(D_ADB, "mydvb:emm.stop");
+		//	dvbapi_stop_filter(demux_index, TYPE_EMM); // stop all emm filters
+		}
+	}
+	dvbApi_client->emmsento = emmsento;
 }
 
 void dvbapi_read_priority(void)
@@ -1794,47 +2126,42 @@
 	const char *cs_prio = "oscam.dvbapi";
 
 	fp = fopen(get_config_filename(token, sizeof(token), cs_prio), "r");
-
-	if(!fp)
-	{
+	if (!fp) {
 		cs_log_dbg(D_DVBAPI, "ERROR: Can't open priority file %s", token);
 		return;
 	}
 
-	if(dvbapi_priority)
+	if (dvbApi_priority)
 	{
 		cs_log_dbg(D_DVBAPI, "reread priority file %s", cs_prio);
 		struct s_dvbapi_priority *o, *p;
-		for(p = dvbapi_priority; p != NULL; p = o)
-		{
+		for (p = dvbApi_priority; p != NULL; p = o) {
 			o = p->next;
 			NULLFREE(p);
 		}
-		dvbapi_priority = NULL;
+		dvbApi_priority = NULL;
 	}
 
 	while(fgets(token, sizeof(token), fp))
 	{
 		// Ignore comments and empty lines
 		if(token[0] == '#' || token[0] == '/' || token[0] == '\n' || token[0] == '\r' || token[0] == '\0')
-			{ continue; }
-		if(strlen(token) > 100) { continue; }
+			continue;
+		if (strlen(token)>100) continue;
 
 		memset(str1, 0, 128);
 
-		for(i = 0; i < (int)strlen(token) && token[i] == ' '; i++) { ; }
+		for (i=0; i<(int)strlen(token) && token[i]==' '; i++);
 		if(i  == (int)strlen(token) - 1)  //empty line or all spaces
-			{ continue; }
+			continue;
 
 		for(i = 0; i < (int)strlen(token); i++)
 		{
-			if((token[i] == ':' || token[i] == ' ') && token[i + 1] == ':')  // if "::" or " :"
-			{
+			if ((token[i]==':' || token[i]==' ') && token[i+1]==':') { 	// if "::" or " :"
 				memmove(token + i + 2, token + i + 1, strlen(token) - i + 1); //insert extra position
 				token[i + 1] = '0'; //and fill it with NULL
 			}
-			if(token[i] == '#' || token[i] == '/')
-			{
+			if (token[i]=='#' || token[i]=='/') {
 				token[i] = '\0';
 				break;
 			}
@@ -1863,8 +2190,8 @@
 		struct s_dvbapi_priority *entry;
 		if(!cs_malloc(&entry, sizeof(struct s_dvbapi_priority)))
 		{
-			ret = fclose(fp);
-			if(ret < 0) { cs_log("ERROR: Could not close oscam.dvbapi fd (errno=%d %s)", errno, strerror(errno)); }
+			int32_t retstatus = fclose(fp);
+			if (retstatus < 0) cs_log("ERROR: Could not close oscam.dvbapi fd (errno=%d %s)", errno, strerror(errno));
 			return;
 		}
 
@@ -1884,14 +2211,12 @@
 			cs_log_dbg(D_DVBAPI, "stapi prio: ret=%d | %c: %s %s | disable %d",
 						  ret, type, entry->devname, entry->pmtfile, disablefilter);
 
-			if(!dvbapi_priority)
-			{
-				dvbapi_priority = entry;
+			if (!dvbApi_priority) {
+				dvbApi_priority=entry;
 			}
-			else
-			{
+			else {
 				struct s_dvbapi_priority *p;
-				for(p = dvbapi_priority; p->next != NULL; p = p->next) { ; }
+				for (p = dvbApi_priority; p->next != NULL; p = p->next);
 				p->next = entry;
 			}
 			continue;
@@ -1968,8 +2293,7 @@
 					if(strcmp(this->prov, c_srvid + 1) == 0)
 					{
 						struct s_dvbapi_priority *entry2;
-						if(!cs_malloc(&entry2, sizeof(struct s_dvbapi_priority)))
-							{ continue; }
+					if (!cs_malloc(&entry2,sizeof(struct s_dvbapi_priority))) continue;
 						memcpy(entry2, entry, sizeof(struct s_dvbapi_priority));
 
 						entry2->srvid = this->srvid;
@@ -1978,14 +2302,12 @@
 									  ret, entry2->type, entry2->caid, entry2->provid, entry2->srvid, entry2->ecmpid, entry2->chid,
 									  entry2->mapcaid, entry2->mapprovid, entry2->mapecmpid, entry2->force, entry2->delay);
 
-						if(!dvbapi_priority)
-						{
-							dvbapi_priority = entry2;
+					if (!dvbApi_priority) {
+						dvbApi_priority = entry2;
 						}
-						else
-						{
+					else {
 							struct s_dvbapi_priority *p;
-							for(p = dvbapi_priority; p->next != NULL; p = p->next) { ; }
+						for (p = dvbApi_priority; p->next != NULL; p = p->next);
 							p->next = entry2;
 						}
 					}
@@ -1993,8 +2315,7 @@
 			NULLFREE(entry);
 			continue;
 		}
-		else
-		{
+		else {
 			sscanf(c_srvid, "%4x", &srvid);
 			entry->srvid = srvid;
 		}
@@ -2003,22 +2324,20 @@
 					  ret, entry->type, entry->caid, entry->provid, entry->srvid, entry->ecmpid, entry->chid, entry->mapcaid,
 					  entry->mapprovid, entry->mapecmpid, entry->force, entry->delay);
 
-		if(!dvbapi_priority)
-		{
-			dvbapi_priority = entry;
+		if (!dvbApi_priority) {
+			dvbApi_priority = entry;
 		}
-		else
-		{
+		else {
 			struct s_dvbapi_priority *p;
-			for(p = dvbapi_priority; p->next != NULL; p = p->next) { ; }
+			for (p = dvbApi_priority; p->next != NULL; p = p->next);
 			p->next = entry;
 		}
 	}
 
 	cs_log_dbg(D_DVBAPI, "Read %d entries from %s", count, cs_prio);
 
-	ret = fclose(fp);
-	if(ret < 0) { cs_log("ERROR: Could not close oscam.dvbapi fd (errno=%d %s)", errno, strerror(errno)); }
+	int32_t retstatus = fclose(fp);
+	if (retstatus < 0) cs_log("ERROR: Could not close oscam.dvbapi fd (errno=%d %s)", errno, strerror(errno));
 	return;
 }
 
@@ -2028,6 +2347,8 @@
 	uint16_t btun_caid = 0;
 	struct timeb start,end;
 	cs_ftime(&start);
+
+	MYDVB_TRACE("mydvb:dvbapi_resort_ecmpids{%d}.\n", demux[demux_index].ECMpidcount);
 	for(n = 0; n < demux[demux_index].ECMpidcount; n++)
 	{
 		demux[demux_index].ECMpids[n].status = 0;
@@ -2037,6 +2358,7 @@
 	demux[demux_index].max_status = 0;
 	demux[demux_index].curindex = -1;
 	demux[demux_index].pidindex = -1;
+	demux[demux_index].cs_cwidx  = -1;
 
 	struct s_channel_cache *c = NULL;
 
@@ -2071,15 +2393,19 @@
 		}
 	}
 
-	// prioritize & ignore according to oscam.dvbapi and cfg.preferlocalcards
-	if(!dvbapi_priority) { cs_log_dbg(D_DVBAPI, "Demuxer %d no oscam.dvbapi found or no valid rules are parsed!", demux_index); }
+#if defined(MODULE_XCAMD)
+	DVBICS_ChkEcmReaders(demux_index);
+#endif
 
-	if(dvbapi_priority)
+	// prioritize & ignore according to oscam.dvbapi and cfg.preferlocalcards
+//	if (!dvbApi_priority) {
+//		cs_log_dbg(D_DVBAPI,"[DVBAPI] No oscam.dvbapi found or no valid rules are parsed!");
+//	}
+	if ( dvbApi_priority)
 	{
 		struct s_reader *rdr;
 		ECM_REQUEST *er;
-		if(!cs_malloc(&er, sizeof(ECM_REQUEST)))
-			{ return; }
+		if (!cs_malloc(&er, sizeof(ECM_REQUEST))) return;
 
 		int32_t add_prio = 0; // make sure that p: values overrule cache
 		if(cache == 1)
@@ -2093,7 +2419,7 @@
 		highest_prio = (prio * demux[demux_index].ECMpidcount) + p_order;
 
 		struct s_dvbapi_priority *p;
-		for(p = dvbapi_priority; p != NULL; p = p->next)
+		for (p = dvbApi_priority; p != NULL; p = p->next)
 		{
 			if(p->type != 'p' && p->type != 'i')
 				{ continue; }
@@ -2106,10 +2432,18 @@
 				else if(cache == 2 && (demux[demux_index].ECMpids[n].status < 0 || demux[demux_index].ECMpids[n].status > prio * 2))
 					{ continue; }
 
+				er->dmuxid = demux_index;// sky(powervu)
 				er->caid = er->ocaid = demux[demux_index].ECMpids[n].CAID;
 				er->prid = demux[demux_index].ECMpids[n].PROVID;
 				er->pid = demux[demux_index].ECMpids[n].ECM_PID;
 				er->srvid = demux[demux_index].program_number;
+				er->onid   = demux[demux_index].onid;
+#if defined(MODULE_AVAMGCAMD)
+				er->exprid = er->prid;
+				if (IS_IRDETO(er->caid)) {
+					er->exprid = (((er->onid>>8)&0xff) ^ ((er->onid)&0xff));
+				}
+#endif
 				er->client = cur_client();
 
 				btun_caid = chk_on_btun(SRVID_MASK, er->client, er);
@@ -2127,10 +2461,8 @@
 				if (p->pidx && p->pidx-1 != n)
 					{ continue; }
 
-				if(p->type == 'i')    // check if ignored by dvbapi
-				{
-					if(p->chid == 0x10000)   // ignore all? disable pid
-					{
+				if (p->type == 'i') { // check if ignored by dvbapi
+					if (p->chid == 0x10000) { // ignore all? disable pid
 						demux[demux_index].ECMpids[n].status = -1;
 					}
 					cs_log_dbg(D_DVBAPI, "Demuxer %d ignore ecmpid %d %04X:%06X:%04X:%04X (file)", demux_index, n, demux[demux_index].ECMpids[n].CAID,
@@ -2150,7 +2482,7 @@
 								&& rdr->card_status == CARD_INSERTED)   // cfg.preferlocalcards = 1 local reader
 						{
 
-							if(matching_reader(er, rdr))
+							if (matching_reader(er, rdr, 0))
 							{
 								if(cache == 2 && demux[demux_index].ECMpids[n].status == 1)
 									{ demux[demux_index].ECMpids[n].status++; }
@@ -2167,7 +2499,7 @@
 						}
 						else        // cfg.preferlocalcards = 0 or cfg.preferlocalcards = 1 and no local reader
 						{
-							if(matching_reader(er, rdr))
+							if (matching_reader(er, rdr, 0))
 							{
 								if(cache == 2 && demux[demux_index].ECMpids[n].status == 1)
 									{ demux[demux_index].ECMpids[n].status++; }
@@ -2190,13 +2522,12 @@
 
 	if(!matching_done)      //works if there is no oscam.dvbapi or if there is oscam.dvbapi but not p rules in it
 	{
-		if(dvbapi_priority && !matching_done)
+		if (dvbApi_priority && !matching_done)
 			{ cs_log_dbg(D_DVBAPI, "Demuxer %d no prio rules in oscam.dvbapi matches!", demux_index); }
 
 		struct s_reader *rdr;
 		ECM_REQUEST *er;
-		if(!cs_malloc(&er, sizeof(ECM_REQUEST)))
-			{ return; }
+		if (!cs_malloc(&er, sizeof(ECM_REQUEST))) return;
 
 		highest_prio = prio * 2;
 
@@ -2205,11 +2536,21 @@
 			if(demux[demux_index].ECMpids[n].status == -1)  //skip ignores
 				{ continue; }
 
+			er->dmuxid = demux_index;// sky(powervu)
+			er->onid   = demux[demux_index].onid;
 			er->caid = er->ocaid = demux[demux_index].ECMpids[n].CAID;
 			er->prid = demux[demux_index].ECMpids[n].PROVID;
 			er->pid = demux[demux_index].ECMpids[n].ECM_PID;
 			er->srvid = demux[demux_index].program_number;
+#if defined(MODULE_AVAMGCAMD)
+			er->exprid = er->prid;
+			if (IS_IRDETO(er->caid)) {
+				er->exprid = (((er->onid>>8)&0xff) ^ ((er->onid)&0xff));
+			}
+#endif
 			er->client = cur_client();
+			MYDVB_TRACE("mydvb:matching_check...{%04X.%06X, srvid.%5d}, ecmpid.%04X\n",
+					er->caid, er->prid, er->srvid, er->pid);
 
 			btun_caid = chk_on_btun(SRVID_MASK, er->client, er);
 			if(btun_caid)
@@ -2221,7 +2562,7 @@
 						&& !is_network_reader(rdr)
 						&& rdr->card_status == CARD_INSERTED)   // cfg.preferlocalcards = 1 local reader
 				{
-					if(matching_reader(er, rdr))
+					if (matching_reader(er, rdr, 0))
 					{
 						demux[demux_index].ECMpids[n].status += prio * 2;
 						cs_log_dbg(D_DVBAPI, "Demuxer %d prio ecmpid %d %04X:%06X:%04X (localrdr: %s weight: %d)", demux_index,
@@ -2233,7 +2574,7 @@
 				}
 				else        // cfg.preferlocalcards = 0 or cfg.preferlocalcards = 1 and no local reader
 				{
-					if(matching_reader(er, rdr))
+					if (matching_reader(er, rdr, 0))
 					{
 						demux[demux_index].ECMpids[n].status += prio;
 						cs_log_dbg(D_DVBAPI, "Demuxer %d prio ecmpid %d %04X:%06X:%04X (rdr: %s weight: %d)", demux_index,
@@ -2259,9 +2600,18 @@
 		int32_t nr;
 		SIDTAB *sidtab;
 		ECM_REQUEST er;
+
+		er.dmuxid = demux_index;// sky(powervu)
 		er.caid  = demux[demux_index].ECMpids[n].CAID;
 		er.prid  = demux[demux_index].ECMpids[n].PROVID;
 		er.srvid = demux[demux_index].program_number;
+		er.onid   = demux[demux_index].onid;
+#if defined(MODULE_AVAMGCAMD)
+		er.exprid = er.prid;
+		if (IS_IRDETO(er.caid)) {
+			er.exprid = (((er.onid>>8)&0xff) ^ ((er.onid)&0xff));
+		}
+#endif
 
 		for(nr = 0, sidtab = cfg.sidtab; sidtab; sidtab = sidtab->next, nr++)
 		{
@@ -2293,10 +2643,12 @@
 	
 	for(n = 0; n < demux[demux_index].ECMpidcount; n++)
 	{
+		er->dmuxid = demux_index;// sky(powervu)
 		er->caid = er->ocaid = demux[demux_index].ECMpids[n].CAID;
 		er->prid = demux[demux_index].ECMpids[n].PROVID;
 		er->pid = demux[demux_index].ECMpids[n].ECM_PID;
 		er->srvid = demux[demux_index].program_number;
+		er->onid   = demux[demux_index].onid;
 		er->client = cur_client();
 		btun_caid = chk_on_btun(SRVID_MASK, er->client, er);
 		if(btun_caid)
@@ -2307,7 +2659,7 @@
 		int32_t match = 0;
 		for(rdr = first_active_reader; rdr ; rdr = rdr->next)
 		{
-			if(matching_reader(er, rdr))
+			if (matching_reader(er, rdr, 0))
 			{
 				match++;
 			}
@@ -2334,7 +2686,7 @@
 	}
 
 	struct s_dvbapi_priority *match;
-	for(match = dvbapi_priority; match != NULL; match = match->next)
+	for (match = dvbApi_priority; match != NULL; match = match->next)
 	{
 		if(match->type != 'p')
 			{ continue; }
@@ -2342,12 +2694,12 @@
 			{ continue; }
 		for(n = 0; n < demux[demux_index].ECMpidcount; n++)
 		{
-			if(match->caid &&  match->caid != demux[demux_index].ECMpids[n].CAID) { continue; }
-			if(match->provid && match->provid != demux[demux_index].ECMpids[n].PROVID) { continue; }
-			if(match->srvid && match->srvid != demux[demux_index].program_number) { continue; }
-			if(match->ecmpid && match->ecmpid != demux[demux_index].ECMpids[n].ECM_PID) { continue; }
+			if (match->caid   && match->caid   != demux[demux_index].ECMpids[n].CAID) 	 continue;
+			if (match->provid && match->provid != demux[demux_index].ECMpids[n].PROVID) continue;
+			if (match->srvid  && match->srvid  != demux[demux_index].program_number) 	 continue;
+			if (match->ecmpid && match->ecmpid != demux[demux_index].ECMpids[n].ECM_PID)continue;
 			if(match->pidx && match->pidx-1 != n) { continue; }
-			if(match->chid < 0x10000) { demux[demux_index].ECMpids[n].CHID = match->chid; }
+			if (match->chid < 0x10000) demux[demux_index].ECMpids[n].CHID = match->chid;
 			demux[demux_index].ECMpids[n].status = ++highest_prio;
 			cs_log_dbg(D_DVBAPI, "Demuxer %d forced ecmpid %d %04X:%06X:%04X:%04X", demux_index, n, demux[demux_index].ECMpids[n].CAID,
 						  demux[demux_index].ECMpids[n].PROVID, demux[demux_index].ECMpids[n].ECM_PID, (uint16_t) match->chid);
@@ -2371,7 +2723,7 @@
 				demux[demux_index].ECMpids[n].status = 1;
 			}
 		}
-		demux[demux_index].max_emm_filter = maxfilter - 1;
+		demux[demux_index].max_emmfilters = maxfilter - 1;
 		demux[demux_index].max_status = 1;
 		cs_log("Demuxer %d found channel in cache and matching prio -> start descrambling ecmpid %d ", demux_index, found);
 	}
@@ -2400,7 +2752,7 @@
 	{
 		descriptor_length = buffer[j + 1];
 
-		if(buffer[j] == 0x81 && descriptor_length == 8)    // private descriptor of length 8, assume enigma/tvh
+		if (buffer[j] == 0x81 && descriptor_length == 8) // CAPMT_DESC_PRIVATE:private descriptor of length 8, assume enigma/tvh
 		{
 			demux[demux_id].enigma_namespace = b2i(4, buffer + j + 2);
 			demux[demux_id].tsid = b2i(2, buffer + j + 6);
@@ -2413,15 +2765,14 @@
 			cs_log_dbg(D_TRACE, "Demuxer %d found pmt type: %02x length: %d", demux_id, buffer[j], descriptor_length);
 		}
 
-		if(buffer[j] != 0x09) { continue; }
-		
-		if(demux[demux_id].ECMpidcount >= ECM_PIDS) { break; }
+		if (buffer[j] != 0x09) continue;
+		if (demux[demux_id].ECMpidcount >= ECM_PIDS) break;
 
 		int32_t descriptor_ca_system_id = b2i(2, buffer + j + 2);
 		int32_t descriptor_ca_pid = b2i(2, buffer + j + 4)&0x1FFF;
 		int32_t descriptor_ca_provider = 0;
 
-		if(descriptor_ca_system_id >> 8 == 0x01)
+		if ((descriptor_ca_system_id>>8) == 0x01)
 		{
 			for(u = 2; u < descriptor_length; u += 15)
 			{
@@ -2435,10 +2786,15 @@
 			if(caid_is_viaccess(descriptor_ca_system_id) && descriptor_length == 0x0F && buffer[j + 12] == 0x14)
 				{ descriptor_ca_provider = b2i(3, buffer + j + 14) &0xFFFFF0; }
 
-			if(caid_is_nagra(descriptor_ca_system_id) && descriptor_length == 0x07)
+			else if (caid_is_nagra(descriptor_ca_system_id) && descriptor_length == 0x07)
 				{ descriptor_ca_provider = b2i(2, buffer + j + 7); }
-			
-			if(descriptor_ca_system_id >> 8 == 0x4A && descriptor_length == 0x05)
+			// sky(DRE3)
+			else if (((descriptor_ca_system_id & 0xfffe)==0x7BE0||
+						 (descriptor_ca_system_id & 0xfffe)==0x2710||
+						 (descriptor_ca_system_id & 0xfffe)==0x4AE0) && descriptor_length > 4)
+				{ descriptor_ca_provider = buffer[j + 6]; }
+			else if ( descriptor_ca_system_id == 0x4A02) { /* sky(tongfang) */ }
+			else if ((descriptor_ca_system_id>>8) == 0x4A && descriptor_length == 0x05)
 				{ descriptor_ca_provider = buffer[j + 6]; }
 
 			dvbapi_add_ecmpid(demux_id, descriptor_ca_system_id, descriptor_ca_pid, descriptor_ca_provider);
@@ -2447,7 +2803,7 @@
 	}
 
 	// Apply mapping:
-	if(dvbapi_priority)
+	if (dvbApi_priority)
 	{
 		struct s_dvbapi_priority *mapentry;
 		for(j = 0; (int32_t)j < demux[demux_id].ECMpidcount; j++)
@@ -2465,41 +2821,66 @@
 	}
 }
 
-void request_cw(struct s_client *client, ECM_REQUEST *er, int32_t demux_id, uint8_t delayed_ecm_check)
+void dvbapi_request_cw(struct s_client *client, ECM_REQUEST *er, int32_t demux_id, int32_t filnum, uint8_t delayed_ecm_check)
 {
 	int32_t filternum = dvbapi_set_section_filter(demux_id, er, -1); // set ecm filter to odd -> even and visaversa
 
-	if(!USE_OPENXCAS && filternum < 0)
-	{
+	if (!er) return;
+//	myprdump("ECM", er->ecm, er->ecmlen);
+ 	MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ECM{%02X.%d} {%02X:%06X,%04X(%02X.%04X)}(f.%d.%d)\n",
+					er->ecm[0],
+					er->ecmlen,
+					er->caid,
+					er->prid,
+					er->pid,
+					er->ecm[4],
+					er->chid,
+					filnum, demux[demux_id].demux_fd[filnum].pidindex);
+
+//	{
+//		uint8_t cw[16];
+//		XVIACESS_Process(CSREADER_GetReaders(R_XCAS), er, cw);
+//	}
+
+	filternum = filnum;
+#if defined WITH_AZBOX || defined WITH_MCA
+#elif defined(WITH_HISILICON)
+#else
+	if (filternum < 0 || filternum > MAX_FILTER-1) {
 		cs_log_dbg(D_DVBAPI, "Demuxer %d not requesting cw -> ecm filter was killed!", demux_id);
 		return;
 	}
+#endif
 
-	cs_log_dbg(D_DVBAPI, "Demuxer %d get controlword!", demux_id);
-	get_cw(client, er);
+	if (!get_cw(client, er)) return;
 
-	if (!USE_OPENXCAS) {
-		if(delayed_ecm_check) { memcpy(demux[demux_id].demux_fd[filternum].ecmd5, er->ecmd5, CS_ECMSTORESIZE); }  // register this ecm as latest request for this filter
-		else { memset(demux[demux_id].demux_fd[filternum].ecmd5, 0, CS_ECMSTORESIZE); } // zero out ecmcheck!
-	}
+#if defined WITH_AZBOX || defined WITH_MCA
+#else
+	if (delayed_ecm_check) memcpy(demux[demux_id].demux_fd[filternum].ecmd5, er->ecmd5, CS_ECMSTORESIZE); // register this ecm as latest request for this filter
+	else memset(demux[demux_id].demux_fd[filternum].ecmd5, 0, CS_ECMSTORESIZE); // zero out ecmcheck!
+#endif
 
 #ifdef WITH_DEBUG
+	if (D_DVBAPI & cs_dblevel) {
 	char buf[ECM_FMT_LEN];
 	format_ecm(er, buf, ECM_FMT_LEN);
 	cs_log_dbg(D_DVBAPI, "Demuxer %d request controlword for ecm %s", demux_id, buf);
+	}
 #endif
 }
 
-void dvbapi_try_next_caid(int32_t demux_id, int8_t checked)
+void dvbapi_try_next_caid(int32_t demux_id, int8_t checked, int32_t atfirst)
 {
-
 	int32_t n, j, found = -1, started = 0;
-
 	int32_t status = demux[demux_id].max_status;
 
+	MYDVB_TRACE("mydvb:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! TRY{%d(%d)}{%d}\n",
+			checked,
+			demux_id,
+			demux[demux_id].max_status);
+
 	for(j = status; j >= 0; j--)    // largest status first!
 	{
-
 		for(n = 0; n < demux[demux_id].ECMpidcount; n++)
 		{
 			//cs_log_dbg(D_DVBAPI,"Demuxer %d PID %d checked = %d status = %d (searching for pid with status = %d)", demux_id, n,
@@ -2507,14 +2888,18 @@
 			if(demux[demux_id].ECMpids[n].checked == checked && demux[demux_id].ECMpids[n].status == j)
 			{
 				found = n;
-
+#if defined WITH_AZBOX || defined WITH_MCA
 				openxcas_set_provid(demux[demux_id].ECMpids[found].PROVID);
 				openxcas_set_caid(demux[demux_id].ECMpids[found].CAID);
 				openxcas_set_ecm_pid(demux[demux_id].ECMpids[found].ECM_PID);
+#endif
 
 				// fixup for cas that need emm first!
 				if(caid_is_irdeto(demux[demux_id].ECMpids[found].CAID)) { demux[demux_id].emmstart.time = 0; }
 				started = dvbapi_start_descrambling(demux_id, found, checked);
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+				DVBICS_ChSettings(demux_id, (atfirst) ? CHCS_CASFIRST : CHCS_CASFOWARD);
+#endif
 				if(cfg.dvbapi_requestmode == 0 && started == 1) { return; }  // in requestmode 0 we only start 1 ecm request at the time
 			}
 		}
@@ -2527,23 +2912,76 @@
 	}
 }
 
+// sky(n)
+void dvbapi_try_goto_caid(int32_t demux_id, int8_t checked, int32_t chknum)
+{
+
+	int32_t n, j, found = -1, started = 0;
+
+	int32_t status = demux[demux_id].max_status;
+
+	MYDVB_TRACE("mydvb:gggggggggggggggggggggggggggggggggggggggg TRY{%d(%d)}{%d, %d}\n",
+			checked,
+			demux_id,
+			demux[demux_id].max_status, chknum);
+
+	for (j = status; j >= 0; j--) // largest status first!
+	{
+		for (n=0; n<demux[demux_id].ECMpidcount; n++)
+		{
+			//	cs_log_dbg(D_DVBAPI,"[DVBAPI] Demuxer %d PID %d checked = %d status = %d (searching for pid with status = %d)", demux_id, n,
+			//			demux[demux_id].ECMpids[n].checked, demux[demux_id].ECMpids[n].status, j);
+			if (chknum==n)
+			{
+				found = n;
+				// fixup for cas that need emm first!
+				if (caid_is_irdeto(demux[demux_id].ECMpids[found].CAID)) { demux[demux_id].emmstart.time = 0; }
+				started = dvbapi_start_descrambling(demux_id, found, checked);
+
+#if defined(MODULE_XCAMD)
+				DVBICS_ChSettings(demux_id, CHCS_CAS2FAKE);
+#endif
+			   if (cfg.dvbapi_requestmode == 0 && started == 1) return; // in requestmode 0 we only start 1 ecm request at the time
+			}
+		}
+	}
+
+	if (found == -1 && demux[demux_id].pidindex == -1)
+	{
+		cs_log("Demuxer %d no suitable readers found that can be used for decoding!", demux_id);
+		return;
+	}
+}
+
+void dvbapi_try_stop_caid(int32_t demux_id, int8_t checked)
+{
+	if (demux[demux_id].ECMpidcount == 1) return;
+	MYDVB_TRACE("mydvb:nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn STP{%d(%d)}\n", checked, demux_id);
+	if (checked==1) {
+		dvbapi_try_next_caid(demux_id, 0, 0);
+	}
+	else {
+		dvbapi_stop_filter(demux_id, TYPE_ECM);
+	}
+}
+
+
 static void getDemuxOptions(int32_t demux_id, unsigned char *buffer, uint16_t *ca_mask, uint16_t *demux_index, uint16_t *adapter_index, uint16_t *pmtpid)
 {
 	*ca_mask = 0x01, *demux_index = 0x00, *adapter_index = 0x00, *pmtpid = 0x00;
 
 	if(buffer[17] == 0x82 && buffer[18] == 0x02)
 	{
-		// enigma2
+		// CAPMT_DESC_DEMUX:enigma2
 		*ca_mask = buffer[19];
-		uint32_t demuxid = buffer[20];
-		if (demuxid == 0xff) demuxid = 0; // tryfix prismcube (0xff -> "demux-1" = error! )
-		*demux_index = demuxid;
-		if (buffer[21]==0x84 && buffer[22]==0x02) *pmtpid = b2i(2, buffer+23);
+		uint32_t demuxidx = buffer[20];
+		if (demuxidx == 0xff) demuxidx = 0; // tryfix prismcube (0xff -> "demux-1" = error! )
+		*demux_index = demuxidx;
+	//	if (buffer[21]==0x84 && buffer[22]==0x02) *pmtpid = (buffer[23] << 8) | buffer[24];
 		if (buffer[25]==0x83 && buffer[26]==0x01) *adapter_index=buffer[27]; // from code cahandler.cpp 0x83 index of adapter
 	}
 
-	if(cfg.dvbapi_boxtype == BOXTYPE_IPBOX_PMT)
-	{
+	if (cfg.dvbapi_boxtype == BOXTYPE_IPBOX_PMT) {
 		*ca_mask = demux_id + 1;
 		*demux_index = demux_id;
 	}
@@ -2562,6 +3000,17 @@
 		*adapter_index = buffer[10]; // adapter index can be 0,1,2
 		*ca_mask = (1 << *adapter_index); // use adapter_index as ca_mask (used as index for ca_fd[] array)
 	}
+
+#if defined(WITH_HISILICON)
+	// tvheadend
+	// CAPMT_DESC_DEMUX
+	if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON && buffer[7]==0x82 && buffer[8]==0x02)
+	{
+		*demux_index   = buffer[ 9]; 		 // it is always 0 but you never know
+		*adapter_index = buffer[10]; 		 // adapter index can be 0,1,2
+		*ca_mask = (1 << *adapter_index); // use adapter_index as ca_mask (used as index for ca_fd[] array)
+	}
+#endif
 }
 
 static void dvbapi_capmt_notify(struct demux_s *dmx)
@@ -2581,21 +3030,101 @@
 	}
 }
 
+#if defined(WITH_HISILICON)
+void
+DVBICS_csdescriptor_parse(int32_t demux_id, uint32_t pgminfosize, unsigned char *buffer)
+{
+	uint32_t descriptor_len=0;
+	uint32_t i;
+	short		longitude;
+	// tvheadend(WITH_HISILICON)
+	// 03 00 02 13 00 19 01
+	//	82 02 00 03
+	//	81 08 00 00 00 00 00 02 00 01
+	//	84 02 00 4E
+	//	09 04 06 11 E0 4E
+	// 01 00 85 00 06
+	if (pgminfosize<1) return;
+	if (buffer[0]==0x01)
+	{
+		buffer = buffer+1;
+		pgminfosize--;
+	}
+
+	for (i=0; i<pgminfosize; i+=(descriptor_len+2))
+	{
+		descriptor_len = buffer[i+1];
+		switch (buffer[i]) {
+			case 0x83:	// CAPMT_DESC_INFO
+				longitude = (short)(buffer[i+ 2] << 8 | buffer[i+ 3]);
+				if (longitude < 0) longitude = 3600 + (short)longitude;
+				demux[demux_id].cs_degree	  		= longitude;
+				demux[demux_id].cs_frequency 		= (buffer[i+ 4] << 8 | buffer[i+ 5]);
+				demux[demux_id].cs_vidpid 			= (buffer[i+ 6] << 8 | buffer[i+ 7]);
+				demux[demux_id].cs_symbolrate 	= (buffer[i+ 8] << 8 | buffer[i+ 9]);
+				demux[demux_id].cs_polarisation 	= (buffer[i+10] << 8 | buffer[i+11]);
+				mycs_trace(D_ADB, "mypmt:--- chiks:%d, %d.%d,%d, vpid:%04x",
+							demux[demux_id].cs_degree,
+							demux[demux_id].cs_frequency,
+							demux[demux_id].cs_symbolrate,
+							demux[demux_id].cs_polarisation,
+							demux[demux_id].cs_vidpid);
+				break;
+
+			case 0x84:	// CAPMT_DESC_PID
+				demux[demux_id].pmtpid = (buffer[i+2] << 8 | buffer[i+3]);
+				mycs_trace(D_ADB, "mypmt:--- pmtpid:%04x", demux[demux_id].pmtpid);
+				break;
+
+			case 0x81:	// CAPMT_DESC_PRIVATE
+				// parse private descriptor as used by enigma (4 bytes namespace, 2 tsid, 2 onid)
+				demux[demux_id].enigma_namespace=(buffer[i+2] << 24 | buffer[i+3] << 16 | buffer[i+4] << 8 | buffer[i+5]);
+				demux[demux_id].tsid = (buffer[i+6] << 8 | buffer[i+7]);
+				demux[demux_id].onid = (buffer[i+8] << 8 | buffer[i+9]);
+				mycs_trace(D_ADB, "mypmt:--- tsid:%04X, onid=%04X", demux[demux_id].tsid, demux[demux_id].tsid);
+				break;
+
+			case 0x09: return;
+			case 0x00: return;
+			default:
+				mycs_trace(D_ADB, "mypmt:--- type:%02X, len{%d}", buffer[i], descriptor_len);
+				break;
+		}
+	}
+}
+#endif // #if defined(WITH_HISILICON)
+
+#define CAPMT_LIST_MORE   				0x00	// append a 'MORE' CAPMT object the list and start receiving the next object
+#define CAPMT_LIST_FIRST  				0x01	// clear the list when a 'FIRST' CAPMT object is received, and start receiving the next object
+#define CAPMT_LIST_LAST   				0x02	// append a 'LAST' CAPMT object to the list and start working with the list
+#define CAPMT_LIST_ONLY   				0x03 	// clear the list when an 'ONLY' CAPMT object is received, and start working with the object
+#define CAPMT_LIST_ADD    				0x04	// append an 'ADD' CAPMT object to the current list and start working with the updated list
+#define CAPMT_LIST_UPDATE 				0x05 	// replace an entry in the list with an 'UPDATE' CAPMT object, and start working with the updated list
+// ca_pmt_cmd_id values:
+#define CAPMT_CMD_OK_DESCRAMBLING	0x01  // start descrambling the service in this CAPMT object as soon as the list of CAPMT objects is complete
+#define CAPMT_CMD_OK_MMI            0x02  //
+#define CAPMT_CMD_QUERY             0x03  //
+#define CAPMT_CMD_NOT_SELECTED      0x04
+// ca_pmt_descriptor types
+#define CAPMT_DESC_PRIVATE 			0x81
+#define CAPMT_DESC_DEMUX   			0x82
+#define CAPMT_DESC_PID     			0x84
+
+#define LIST_MORE 	CAPMT_LIST_MORE
+#define LIST_FIRST 	CAPMT_LIST_FIRST
+#define LIST_LAST 	CAPMT_LIST_LAST
+#define LIST_ONLY 	CAPMT_LIST_ONLY
+#define LIST_ADD 		CAPMT_LIST_ADD
+#define LIST_UPDATE 	CAPMT_LIST_UPDATE
+
+
 int32_t dvbapi_parse_capmt(unsigned char *buffer, uint32_t length, int32_t connfd, char *pmtfile)
 {
 	uint32_t i = 0, start_descrambling = 0;
 	int32_t j = 0;
 	int32_t demux_id = -1;
-	uint16_t ca_mask, demux_index, adapter_index, pmtpid;
-
-#define LIST_MORE 0x00    //*CA application should append a 'MORE' CAPMT object to the list and start receiving the next object
-#define LIST_FIRST 0x01   //*CA application should clear the list when a 'FIRST' CAPMT object is received, and start receiving the next object
-#define LIST_LAST 0x02   //*CA application should append a 'LAST' CAPMT object to the list and start working with the list
-#define LIST_ONLY 0x03   //*CA application should clear the list when an 'ONLY' CAPMT object is received, and start working with the object
-#define LIST_ADD 0x04    //*CA application should append an 'ADD' CAPMT object to the current list and start working with the updated list
-#define LIST_UPDATE 0x05 //*CA application should replace an entry in the list with an 'UPDATE' CAPMT object, and start working with the updated list
-
-#ifdef WITH_COOLAPI
+	uint16_t ca_mask, demux_index, adapter_index, pmtpid = 0;
+#if WITH_COOLAPI
 	int32_t ca_pmt_list_management = LIST_ONLY;
 #else
 	int32_t ca_pmt_list_management = buffer[0];
@@ -2603,34 +3132,33 @@
 	uint32_t program_number = b2i(2, buffer + 1);
 	uint32_t program_info_length = b2i(2, buffer + 4) &0xFFF;
 	
+ 	MYDVB_TRACE("mydvb:PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP CAPMT{%d}\n", program_number);
+	MYDVB_TRACE("mydvb:sends PMT(%d) command %d for channel %d\n", ca_pmt_list_management, cfg.dvbapi_pmtmode, program_number);
 	cs_log_dump_dbg(D_DVBAPI, buffer, length, "capmt:");
 	cs_log_dbg(D_DVBAPI, "Receiver sends PMT command %d for channel %04X", ca_pmt_list_management, program_number);
-	
-	if(!pmt_stopmarking && (ca_pmt_list_management == LIST_FIRST || ca_pmt_list_management == LIST_ONLY))
+	if ((ca_pmt_list_management == LIST_FIRST || ca_pmt_list_management == LIST_ONLY))
 	{
 		for(i = 0; i < MAX_DEMUX; i++) 
 		{
+			if (cfg.dvbapi_pmtmode == 6 && pmt_stopmarking == 1) { continue; } // already marked -> skip!
 			if(demux[i].program_number == 0) { continue; }  // skip empty demuxers
+			if (demux[i].ECMpidcount != 0 && demux[i].pidindex != -1 ) { demux[i].running = 1; }  // running channel changes from scrambled to fta
 			if(demux[i].socket_fd != connfd) { continue; }  // skip demuxers belonging to other ca pmt connection
-			if((demux[i].socket_fd == -1) && (strcmp(demux[i].pmt_file, pmtfile) != 0)) { continue; } // skip demuxers handled by other pmt files
+			if (cfg.dvbapi_pmtmode == 6)
+			{
 			demux[i].stopdescramble = 1; // Mark for deletion if not used again by following pmt objects.
 			cs_log_dbg(D_DVBAPI, "Marked demuxer %d/%d (srvid = %04X fd = %d) to stop decoding", i, MAX_DEMUX, demux[i].program_number, connfd);
 		}
-		pmt_stopmarking = 1; // only stop demuxing for first pmt record
 	}
-	
-	getDemuxOptions(i, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
-	cs_log_dbg(D_DVBAPI,"Receiver wants to demux srvid %04X on adapter %04X camask %04X index %04X pmtpid %04X",
-		program_number, adapter_index, ca_mask, demux_index, pmtpid);
-	
+		pmt_stopmarking = 1;
+	}
 	for(i = 0; i < MAX_DEMUX; i++)    // search current demuxers for running the same program as the one we received in this PMT object
 	{
 		if(demux[i].program_number == 0) { continue; }
 		if(cfg.dvbapi_boxtype == BOXTYPE_IPBOX_PMT) demux_index = i; // fixup for ipbox
 
 		bool full_check = 1, matched = 0;
-		if (config_enabled(WITH_COOLAPI) || is_samygo)
-			full_check = 0;
+		if (config_enabled(WITH_COOLAPI) || is_samygo) full_check = 0;
 
 		if (full_check)
 			matched = (connfd > 0 && demux[i].socket_fd == connfd) && demux[i].program_number == program_number;
@@ -2639,6 +3167,8 @@
 
 		if(matched)
 		{
+			MYDVB_TRACE("mydvb:capmt same.....\n");
+			getDemuxOptions(i, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
 			if (full_check) {
 				if (demux[i].adapter_index != adapter_index) continue; // perhaps next demuxer matches?
 				if (demux[i].ca_mask != ca_mask) continue; // perhaps next demuxer matches?
@@ -2650,17 +3180,22 @@
 
 			demux_id = i;
 			
+#if defined(WITH_HISILICON)
+			dvbapi_stop_descrambling(i);
+#endif
 			cs_log("Demuxer %d continue decoding of SRVID %04X", i, demux[i].program_number);
 
+#if defined WITH_AZBOX || defined WITH_MCA
 			openxcas_set_sid(program_number);
+#endif
 
 			demux[i].stopdescramble = 0; // dont stop current demuxer!		
 			break; // no need to explore other demuxers since we have a found!
 		}
 	}
 
-	// start using the new list
-	if(ca_pmt_list_management != LIST_FIRST && ca_pmt_list_management != LIST_MORE)
+	// stop descramble old demuxers from this ca pmt connection that arent used anymore
+	if ((ca_pmt_list_management == LIST_LAST) || (ca_pmt_list_management == LIST_ONLY))
 	{
 		for(j = 0; j < MAX_DEMUX; j++)
 		{
@@ -2668,26 +3203,46 @@
 			if(demux[j].stopdescramble == 1) { dvbapi_stop_descrambling(j); }  // Stop descrambling and remove all demuxer entries not in new PMT.
 		}
 		start_descrambling = 1; // flag that demuxer descrambling is to be executed!
-		pmt_stopmarking = 0; // flag that demuxers may be marked for stop decoding again
 	}
 
 	if(demux_id == -1)
 	{
-		for(demux_id = 0; demux_id < MAX_DEMUX && demux[demux_id].program_number > 0; demux_id++) { ; }
+		for(demux_id=0; demux_id<MAX_DEMUX && demux[demux_id].program_number>0; demux_id++);
+#if defined(WITH_HISILICON)
+// multi-demux simulation
+		if (demux_id) {
+			MYDVB_TRACE("mydvb:demux_id strange{%d}.......\n", demux_id);
+		// sky(quad)
+		//	demux_id = 0;
+		}
+#endif
 	}
 
 	if(demux_id >= MAX_DEMUX)
 	{
+		MYDVB_TRACE("mydvb:No free id (MAX_DEMUX).......\n");
 		cs_log("ERROR: No free id (MAX_DEMUX)");
 		return -1;
 	}
-	
+	myprintf("mydvb:start emmyyy{%d}{%d,%d}\n", demux_id, demux[demux_id].running, (int)demux[demux_id].emmstart.time);
 	demux[demux_id].program_number = program_number; // do this early since some prio items use them!
-
+	demux[demux_id].pmtpid = pmtpid;
+	// CAPMT_DESC_PRIVATE
+	if (buffer[7]==0x81 && buffer[8]==0x08) {
+		// parse private descriptor as used by enigma (4 bytes namespace, 2 tsid, 2 onid)
+		demux[demux_id].enigma_namespace=(buffer[9] << 24 | buffer[10] << 16 | buffer[11] << 8 | buffer[12]);
+		demux[demux_id].tsid = (buffer[13] << 8 | buffer[14]);
+		demux[demux_id].onid = (buffer[15] << 8 | buffer[16]);
+	}
+	else {
 	demux[demux_id].enigma_namespace = 0;
 	demux[demux_id].tsid = 0;
 	demux[demux_id].onid = 0;
-	demux[demux_id].pmtpid = pmtpid;
+	}
+
+#if defined(WITH_HISILICON)
+	DVBICS_csdescriptor_parse(demux_id, program_info_length-1, buffer+7);
+#endif
 
 	if(pmtfile)
 	{
@@ -2709,39 +3264,34 @@
 	uint32_t es_info_length = 0, vpid = 0;
 	struct s_dvbapi_priority *addentry;
 
-	const char *stream_in_text = NULL;
-	
+#if defined(WITH_HISILICON)
+	vpid = demux[demux_id].cs_vidpid;
+#endif
+	MYDVB_TRACE("mydvb:program_info(%d, %d)\n", program_info_length, length);
 	for(i = program_info_length + 6; i < length; i += es_info_length + 5)
 	{
-		uint32_t stream_type = buffer[i];
+		int32_t  stream_type = buffer[i];
 		uint16_t elementary_pid = b2i(2, buffer + i + 1)&0x1FFF;
 		es_info_length = b2i(2, buffer + i +3)&0x0FFF;
-		if(stream_type < (sizeof(streamtxt) / sizeof(const char *)))
-		{
-			stream_in_text = streamtxt[stream_type];
-		}
-		else
-		{
-			stream_in_text = "";
-		}
-		cs_log_dbg(D_DVBAPI, "Demuxer %d stream %s(type: %02x pid: %04x length: %d)", demux_id, stream_in_text, stream_type, elementary_pid, es_info_length);
-
-		if(demux[demux_id].STREAMpidcount >= ECM_PIDS)
-		{
-			break;
-		}
+		mycs_trace(D_ADB, "mypmt:--- elementary:%02X,%04X{%d}", stream_type, elementary_pid, es_info_length);
+		cs_log_dbg(D_DVBAPI, "Found stream_type: %02x pid: %04x length: %d", stream_type, elementary_pid, es_info_length);
 
+		if (demux[demux_id].STREAMpidcount >= ECM_PIDS) break;
 		demux[demux_id].STREAMpids[demux[demux_id].STREAMpidcount++] = elementary_pid;
+#if defined(WITH_HISILICON)
+		// elementary_pid: tvheadend capmt sequence number.
+#else
 		// find and register videopid
-		if(!vpid && (stream_type == 01 || stream_type == 02 || stream_type == 0x10 || stream_type == 0x1B)) { vpid = elementary_pid; }
-
-		if(es_info_length != 0 && es_info_length < length)
-		{
+		if (!vpid && (stream_type == 01 || stream_type == 02 || stream_type == 0x10 || stream_type == 0x1B)) {
+			vpid = elementary_pid;
+		}
+#endif
+		// sky(tvheadend)
+		if (es_info_length != 0 && (i+5+es_info_length) < length) {
 			dvbapi_parse_descriptor(demux_id, es_info_length, buffer + i + 5);
 		}
-		else
-		{
-			for(addentry = dvbapi_priority; addentry != NULL; addentry = addentry->next)
+		else {
+			for (addentry=dvbApi_priority; addentry != NULL; addentry=addentry->next)
 			{
 				if(addentry->type != 'a'
 						|| (addentry->ecmpid && pmtpid && addentry->ecmpid != pmtpid) // ecmpid is misused to hold pmtpid in case of A: rule
@@ -2763,14 +3313,19 @@
 
 	getDemuxOptions(demux_id, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
 	char channame[32];
-	get_servicename(dvbapi_client, demux[demux_id].program_number, demux[demux_id].ECMpidcount > 0 ? demux[demux_id].ECMpids[0].CAID : NO_CAID_VALUE, channame);
+	get_servicename(dvbApi_client, demux[demux_id].program_number, demux[demux_id].ECMpidcount > 0 ? demux[demux_id].ECMpids[0].CAID : NO_CAID_VALUE, channame);
 	cs_log("Demuxer %d serving srvid %04X (%s) on adapter %04X camask %04X index %04X pmtpid %04X", demux_id,
 		   demux[demux_id].program_number, channame, adapter_index, ca_mask, demux_index, pmtpid); 
 
 	demux[demux_id].adapter_index = adapter_index;
 	demux[demux_id].ca_mask = ca_mask;
 	demux[demux_id].rdr = NULL;
+	// sky(powervu)
+	#if defined(WITH_HISILICON)
+		demux[demux_id].demux_index = demux_id;
+	#else
 	demux[demux_id].demux_index = demux_index;
+	#endif
 	demux[demux_id].socket_fd = connfd;
 	demux[demux_id].stopdescramble = 0; // remove deletion mark!
 
@@ -2779,12 +3334,44 @@
 			if (unassoc_fd[j] == connfd)
 					unassoc_fd[j] = 0;
 
+	demux[demux_id].scrambled_counter = 0;
+	demux[demux_id].cs_soleMatch 	 	 = 0;
+	demux[demux_id].cs_ecmRequisite 	 = -1;
+	demux[demux_id].cs_filtnum     	 = 0;
+	demux[demux_id].cs_subsequence    = 0;
+	demux[demux_id].constcw_fbiss     = 0;
+	MYDVB_TRACE("mydvb:capmt{%d,%d,%d}{%d, %dEA}\n", demux_id, adapter_index, demux_index, program_number, demux[demux_id].ECMpidcount);
+
 	dvbapi_capmt_notify(&demux[demux_id]);
 
+// sky.futures(cas noinfromation)
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM) || defined(MODULE_CONSTCW)
+	DVBICS_ChDescrambled(demux_id, false);
+	#if defined(MODULE_CONSTCW)
+	if (demux[demux_id].ECMpidcount==0)
+	{
+		if (CSREADER_IsFTAbiss(demux[demux_id].cs_degree,
+				demux[demux_id].cs_frequency,
+				demux[demux_id].program_number,
+				vpid))
+		{
+			mycs_log("mydvb:fta{%d}", program_number);
+			demux[demux_id].ECMpids[0].CAID    = 0x2600;
+			demux[demux_id].ECMpids[0].PROVID  = cs_i2BCD(demux[demux_id].cs_frequency);
+			demux[demux_id].ECMpids[0].ECM_PID = cs_i2BCD(demux[demux_id].cs_degree);
+			demux[demux_id].ECMpids[0].VPID    = vpid;
+			demux[demux_id].ECMpids[0].constcw = 1;
+			demux[demux_id].ECMpidcount   = 1;
+			demux[demux_id].constcw_fbiss = 9;
+		}
+	}
+	#endif
+#endif
+
 	struct s_dvbapi_priority *xtraentry;
 	int32_t k, l, m, xtra_demux_id;
 
-	for(xtraentry = dvbapi_priority; xtraentry != NULL; xtraentry = xtraentry->next)
+	for (xtraentry=dvbApi_priority; xtraentry != NULL; xtraentry=xtraentry->next)
 	{
 		if(xtraentry->type != 'x') { continue; }
 
@@ -2813,13 +3400,19 @@
 			demux[xtra_demux_id].STREAMpidcount = 0;
 			demux[xtra_demux_id].program_number = demux[demux_id].program_number;
 			demux[xtra_demux_id].pmtpid = demux[demux_id].pmtpid;
+			// sky(powervu)
+			#if defined(WITH_HISILICON)
+				demux[xtra_demux_id].demux_index = xtra_demux_id;
+			#else
 			demux[xtra_demux_id].demux_index = demux_index;
+			#endif
 			demux[xtra_demux_id].adapter_index = adapter_index;
 			demux[xtra_demux_id].ca_mask = ca_mask;
 			demux[xtra_demux_id].socket_fd = connfd;
 			demux[xtra_demux_id].stopdescramble = 0; // remove deletion mark!
 			demux[xtra_demux_id].rdr = NULL;
 			demux[xtra_demux_id].curindex = -1;
+			demux[xtra_demux_id].cs_cwidx 		= -1;
 
 			// add streams to xtra demux
 			for(k = 0; k < demux[demux_id].STREAMpidcount; ++k)
@@ -2878,13 +3471,23 @@
 		}
 	}
 
+	myprintf("mydvb:start emmxxx{%d,%d}\n", demux[demux_id].running, (int)demux[demux_id].emmstart.time);
 	if(cfg.dvbapi_au > 0 && demux[demux_id].EMMpidcount == 0) // only do emm setup if au enabled and not running!
 	{
 		demux[demux_id].emm_filter = -1; // to register first run emmfilter start
 		if(demux[demux_id].emmstart.time == 1)   // irdeto fetch emm cat direct!
 		{
 			cs_ftime(&demux[demux_id].emmstart); // trick to let emm fetching start after 30 seconds to speed up zapping
-			dvbapi_start_filter(demux_id, demux[demux_id].pidindex, 0x001, 0x001, 0x01, 0x01, 0xFF, 0, TYPE_EMM); //CAT
+			myprintf("mydvb:start CAT\n");
+		   dvbapi_start_filter(demux_id,
+					   demux[demux_id].pidindex,
+					   CAT_PID,
+					   0x001,
+					   0x01,
+					   0x01,
+					   0xFF,
+					   0,
+					   TYPE_EMM); // CAT
 		}
 		else { cs_ftime(&demux[demux_id].emmstart); } // for all other caids delayed start!
 	}
@@ -2902,10 +3505,10 @@
 				cs_log_dbg(D_DVBAPI, "Demuxer %d/%d lets start descrambling (srvid = %04X fd = %d ecmpids = %d)", j, MAX_DEMUX,
 					demux[j].program_number, connfd, demux[j].ECMpidcount);
 				demux[j].running = 1;  // mark channel as running
-				openxcas_set_sid(demux[j].program_number);
+			//	openxcas_set_sid(demux[j].program_number);
 				demux[j].decodingtries = -1;
 				dvbapi_resort_ecmpids(j);
-				dvbapi_try_next_caid(j, 0);
+				dvbapi_try_next_caid(j, 0, 1);
 				cs_sleepms(1);
 			}
 			else if(demux[j].ECMpidcount == 0) //fta do logging and part of ecmhandler since there will be no ecms asked!
@@ -2915,10 +3518,10 @@
 				demux[j].running = 0; // reset running flag
 				demux[demux_id].pidindex = -1; // reset ecmpid used for descrambling
 				dvbapi_stop_filter(j, TYPE_ECM);
-				if(cfg.usrfileflag) { cs_statistics(dvbapi_client);} // add to user log previous channel + time on channel
-				dvbapi_client->last_srvid = demux[demux_id].program_number; // set new channel srvid
-				dvbapi_client->last_caid = NO_CAID_VALUE; // FTA channels have no caid!
-				dvbapi_client->lastswitch = dvbapi_client->last = time((time_t *)0); // reset idle-Time & last switch
+				if (cfg.usrfileflag) { cs_statistics(dvbApi_client);} // add to user log previous channel + time on channel
+				dvbApi_client->last_srvid = demux[demux_id].program_number; // set new channel srvid
+				dvbApi_client->last_caid  = NO_CAID_VALUE; // FTA channels have no caid!
+				dvbApi_client->lastswitch = dvbApi_client->last = time((time_t *)0); // reset idle-Time & last switch
 			}
 		}
 	}
@@ -2930,7 +3533,7 @@
 {
 	uint32_t val = 0, size = 0, i, k;
 
-	for(k = 0; k < len; k += 3 + size + val)
+	for (k = 0; k < len; k += (3 + size + val))
 	{
 		if(buffer[0 + k] != 0x9F || buffer[1 + k] != 0x80)
 		{
@@ -2938,28 +3541,30 @@
 			break;
 		}
 
-		if(k > 0)
+		if (k > 0) {
 			cs_log_dump_dbg(D_DVBAPI, buffer + k, len - k, "Parsing next PMT object:");
-
-		if(buffer[3 + k] & 0x80)
-		{
+		}
+		if (buffer[3+k] & 0x80) {
 			val = 0;
 			size = buffer[3 + k] & 0x7F;
 			for(i = 0; i < size; i++)
-				{ val = (val << 8) | buffer[i + 1 + 3 + k]; }
+				val = (val << 8) | buffer[i + 1 + 3 + k];
 			size++;
 		}
-		else
-		{
+		else {
 			val = buffer[3 + k] & 0x7F;
 			size = 1;
 		}
-		switch(buffer[2 + k])
-		{
+		switch (buffer[2+k]) {
 		case 0x32:
+				MYDVB_TRACE("mydvb:capmt{k=%d}\n", k);
+			 	MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+			 	MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+			 	MYDVB_TRACE("mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
 			dvbapi_parse_capmt(buffer + size + 3 + k, val, connfd, NULL);
 			break;
 		case 0x3f:
+				MYDVB_TRACE("mydvb:capmt.3f{k=%d}\n", k);
 			// 9F 80 3f 04 83 02 00 <demux index>
 			cs_log_dump_dbg(D_DVBAPI, buffer, len, "capmt 3f:");
 			// ipbox fix
@@ -3018,8 +3623,8 @@
 
 int32_t dvbapi_init_listenfd(void)
 {
-	int32_t clilen, listenfd;
 	struct sockaddr_un servaddr;
+	int32_t clilen, listenfd;
 
 	memset(&servaddr, 0, sizeof(struct sockaddr_un));
 	servaddr.sun_family = AF_UNIX;
@@ -3039,14 +3644,15 @@
 	// this will allow oscam to run as root if needed
 	// and still allow non root client to connect to the socket
 	chmod(devices[selected_box].cam_socket_path, S_IRWXU | S_IRWXG | S_IRWXO);
+	MYDVB_TRACE("camsocket:%s\n", devices[selected_box].cam_socket_path);
 
-	return listenfd;
+	return (listenfd);
 }
 
 int32_t dvbapi_net_init_listenfd(void)
 {
-	int32_t listenfd;
 	struct SOCKADDR servaddr;
+	int32_t listenfd;
 
 	memset(&servaddr, 0, sizeof(servaddr));
 	SIN_GET_FAMILY(servaddr) = DEFAULT_AF;
@@ -3083,21 +3689,26 @@
 	DIR *dirp;
 	struct dirent entry, *dp = NULL;
 	int32_t i, pmt_fd;
+	int32_t retstatus;
 	uchar mbuf[2048]; // dirty fix: larger buffer needed for CA PMT mode 6 with many parallel channels to decode
-	if(dvbapi_client != cur_client()) { return; }
+
+//	MYDVB_TRACE("mydvb:event_handler\n");
+	if (dvbApi_client != cur_client()) return;
 
 	pthread_mutex_lock(&event_handler_lock);
 
 	if(cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
-		{ pausecam = 0; }
-	else
-	{
+		pausecam = 0;
+#if defined(WITH_HISILICON)
+	else if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON)
+		pausecam = 0;
+#endif
+	else {
 		int32_t standby_fd = open(STANDBY_FILE, O_RDONLY);
 		pausecam = (standby_fd > 0) ? 1 : 0;
-		if(standby_fd > 0)
-		{
-			int32_t ret = close(standby_fd);
-			if(ret < 0) { cs_log("ERROR: Could not close standby fd (errno=%d %s)", errno, strerror(errno)); }
+		if (standby_fd > 0) {
+			retstatus = close(standby_fd);
+			if (retstatus < 0) cs_log("ERROR: Could not close standby fd (errno=%d %s)", errno, strerror(errno));
 		}
 	}
 
@@ -3109,26 +3720,23 @@
 
 	for(i = 0; i < MAX_DEMUX; i++)
 	{
-		if(demux[i].pmt_file[0] != 0)
-		{
+		if (demux[i].pmt_file[0] != 0) {
 			snprintf(dest, sizeof(dest), "%s%s", TMPDIR, demux[i].pmt_file);
 			pmt_fd = open(dest, O_RDONLY);
 			if(pmt_fd > 0)
 			{
-				if(fstat(pmt_fd, &pmt_info) != 0)
-				{
-					int32_t ret = close(pmt_fd);
-					if(ret < 0) { cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno)); }
+				if (fstat(pmt_fd, &pmt_info) != 0) {
+					retstatus = close(pmt_fd);
+					if (retstatus < 0) cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno));
 					continue;
 				}
 
-				if((time_t)pmt_info.st_mtime != demux[i].pmt_time)
-				{
+				if ((time_t)pmt_info.st_mtime != demux[i].pmt_time) {
 					dvbapi_stop_descrambling(i);
 				}
 
-				int32_t ret = close(pmt_fd);
-				if(ret < 0) { cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno)); }
+				retstatus = close(pmt_fd);
+				if (retstatus < 0) cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno));
 				continue;
 			}
 			else
@@ -3139,15 +3747,13 @@
 		}
 	}
 
-	if(disable_pmt_files)
-	{
+	if (disable_pmt_files) {
 		pthread_mutex_unlock(&event_handler_lock);
 		return;
 	}
 
 	dirp = opendir(TMPDIR);
-	if(!dirp)
-	{
+	if (!dirp) {
 		cs_log_dbg(D_DVBAPI, "opendir failed (errno=%d %s)", errno, strerror(errno));
 		pthread_mutex_unlock(&event_handler_lock);
 		return;
@@ -3155,7 +3761,7 @@
 
 	while(!cs_readdir_r(dirp, &entry, &dp))
 	{
-		if(!dp) { break; }
+		if (!dp) break;
 
 		if(strlen(dp->d_name) < 7)
 			{ continue; }
@@ -3163,14 +3769,12 @@
 			{ continue; }
 #ifdef WITH_STAPI
 		struct s_dvbapi_priority *p;
-		for(p = dvbapi_priority; p != NULL; p = p->next)  // stapi: check if there is a device connected to this pmt file!
-		{
-			if(p->type != 's') { continue; }  // stapi rule?
-			if(strcmp(dp->d_name, p->pmtfile) != 0) { continue; }  // same file?
+		for (p=dvbApi_priority; p != NULL; p=p->next) { // stapi: check if there is a device connected to this pmt file!
+			if (p->type!='s') continue; // stapi rule?
+			if (strcmp(dp->d_name, p->pmtfile)!=0) continue; // same file?
 			break; // found match!
 		}
-		if(p == NULL)
-		{
+		if (p == NULL) {
 			cs_log_dbg(D_DVBAPI, "No matching S: line in oscam.dvbapi for pmtfile %s -> skip!", dp->d_name);
 			continue;
 		}
@@ -3178,15 +3782,15 @@
 		snprintf(dest, sizeof(dest), "%s%s", TMPDIR, dp->d_name);
 		pmt_fd = open(dest, O_RDONLY);
 		if(pmt_fd < 0)
-			{ continue; }
+			continue;
 
-		if(fstat(pmt_fd, &pmt_info) != 0)
-		{
-			int32_t ret = close(pmt_fd);
-			if(ret < 0) { cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno)); }
+		if (fstat(pmt_fd, &pmt_info) != 0) {
+			retstatus = close(pmt_fd);
+			if (retstatus < 0) cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno));
 			continue;
 		}
 
+		MYDVB_TRACE("mydvb:pmtfile{%s}\n", dest);
 		int32_t found = 0;
 		for(i = 0; i < MAX_DEMUX; i++)
 		{
@@ -3199,10 +3803,9 @@
 				}
 			}
 		}
-		if(found)
-		{
-			int32_t ret = close(pmt_fd);
-			if(ret < 0) { cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno)); }
+		if (found) {
+			retstatus = close(pmt_fd);
+			if (retstatus < 0) cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno));
 			continue;
 		}
 
@@ -3210,11 +3813,10 @@
 		cs_sleepms(100);
 
 		uint32_t len = read(pmt_fd, mbuf, sizeof(mbuf));
-		int32_t ret = close(pmt_fd);
-		if(ret < 0) { cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno)); }
+		retstatus = close(pmt_fd);
+		if (retstatus < 0) cs_log("ERROR: Could not close PMT fd (errno=%d %s)", errno, strerror(errno));
 
-		if(len < 1)
-		{
+		if (len < 1) {
 			cs_log_dbg(D_DVBAPI, "pmt file %s have invalid len!", dest);
 			continue;
 		}
@@ -3225,8 +3827,7 @@
 		uint32_t j1, j2;
 		// QboxHD pmt.tmp is the full capmt written as a string of hex values
 		// pmt.tmp must be longer than 3 bytes (6 hex chars) and even length
-		if((len < 6) || ((len % 2) != 0) || ((len / 2) > sizeof(dest)))
-		{
+		if ((len<6) || ((len%2) != 0) || ((len/2)>sizeof(dest))) {
 			cs_log_dbg(D_DVBAPI, "error parsing QboxHD pmt.tmp, incorrect length");
 			continue;
 		}
@@ -3249,13 +3850,11 @@
 		cs_log_dump_dbg(D_DVBAPI, (unsigned char *)dest, len / 2, "QboxHD pmt.tmp:");
 		pmt_id = dvbapi_parse_capmt((unsigned char *)dest + 4, (len / 2) - 4, -1, dp->d_name);
 #else
-		if(len > sizeof(dest))
-		{
+		if (len>sizeof(dest)) {
 			cs_log_dbg(D_DVBAPI, "event_handler() dest buffer is to small for pmt data!");
 			continue;
 		}
-		if(len < 16)
-		{
+		if (len<16) {
 			cs_log_dbg(D_DVBAPI, "event_handler() received pmt is too small! (%d < 16 bytes!)", len);
 			continue;
 		}
@@ -3269,18 +3868,16 @@
 		dest[6] = 0;
 
 		memcpy(dest + 7, mbuf + 12, len - 12 - 4);
-
+//		MYDVB_TRACE("mydvb:sockmsg{dp=%s}\n", dp->d_name);
 		pmt_id = dvbapi_parse_capmt((uchar *)dest, 7 + len - 12 - 4, -1, dp->d_name);
 #endif
 
-		if(pmt_id >= 0)
-		{
+		if (pmt_id>=0) {
 			cs_strncpy(demux[pmt_id].pmt_file, dp->d_name, sizeof(demux[pmt_id].pmt_file));
 			demux[pmt_id].pmt_time = (time_t)pmt_info.st_mtime;
 		}
 
-		if(cfg.dvbapi_pmtmode == 3)
-		{
+		if (cfg.dvbapi_pmtmode == 3) {
 			disable_pmt_files = 1;
 			break;
 		}
@@ -3294,8 +3891,7 @@
 	struct s_client *client = (struct s_client *) cli;
 	pthread_setspecific(getclient, client);
 	set_thread_name(__func__);
-	while(1)
-	{
+	while (1) {
 		cs_sleepms(750);
 		event_handler(0);
 	}
@@ -3303,35 +3899,75 @@
 	return NULL;
 }
 
-void dvbapi_process_input(int32_t demux_id, int32_t filter_num, uchar *buffer, int32_t len)
+void dvbapi_process_input(int32_t demux_id, int32_t filnum, uchar *buffer, int32_t bufsize)
 {	
-	int32_t pid = demux[demux_id].demux_fd[filter_num].pidindex;
-	struct s_ecmpids *curpid = NULL;
-	if(pid != -1)
+	int32_t pidx = demux[demux_id].demux_fd[filnum].pidindex;
+	struct s_ecmpids *curpids = NULL;
+	if (pidx != -1)
 	{
-		curpid = &demux[demux_id].ECMpids[pid];
+		curpids = &demux[demux_id].ECMpids[pidx];
 	}	
+
 	uint32_t chid = 0x10000;
-	uint32_t ecmlen = (b2i(2, buffer + 1)&0xFFF)+3;
+	int32_t  ecmlen = (b2i(2, buffer + 1)&0xFFF)+3;
+	uint32_t crcval = (uint32_t)-1;
+	int32_t  bAlternation;
 	ECM_REQUEST *er;
 	
-	if(demux[demux_id].demux_fd[filter_num].type == TYPE_ECM)
+	myprintf("mtdvb:DVBAPI_PROCESS_INPUT(%d:%d, %d, %02X}\n", demux_id, filnum, demux[demux_id].demux_fd[filnum].type, buffer[0]);
+	if (bufsize != SCT_LEN(buffer)) {
+		cs_log_dbg(D_DVBAPI, "[DVBAPI] Received an ECM with invalid length!");
+		return;
+	}
+	if (demux[demux_id].demux_fd[filnum].type == TYPE_ECM)
 	{
-		if(len != 0)  // len = 0 receiver encountered an internal bufferoverflow!
+		if (bufsize != 0)  // len = 0 receiver encountered an internal bufferoverflow!
 		{
-			cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d fetched ECM data (ecmlength = %03X)", demux_id, filter_num + 1, ecmlen);
-			if((uint) len  < ecmlen) // invalid CAT length
+		   if (bufsize < ecmlen) // invalid CAT length
 			{
-				cs_log_dbg(D_DVBAPI, "Received data with total length %03X but ECM length is %03X -> invalid CAT length!", len, ecmlen);
+				cs_log_dbg(D_DVBAPI, "Received data with length %03X but ECM length is %03X", bufsize, ecmlen);
+			   return;
+		   }
+		   if (bufsize >= MAX_ECM_SIZE) {
+				cs_log_dbg(D_DVBAPI, "Received data with length %03X but ECM length is %03X", bufsize, ecmlen);
+			   return;
+		   }
+
+//			cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d fetched ECM data (ecmlength = %03X)", demux_id, filter_num + 1, ecmlen);
+		   if (!curpids) {
+				cs_log_dbg(D_DVBAPI, "curpids is 0 -> ignoring!");
 				return;
 			}
 
 			if(!(buffer[0] == 0x80 || buffer[0] == 0x81))
 			{
+				// sky(dvn) /* tableid:0x50 */
+				if (caid_is_dvn(curpids->CAID)) {
+				}
+				else {
 				cs_log_dbg(D_DVBAPI, "Received an ECM with invalid ecmtable ID %02X -> ignoring!", buffer[0]);
 				return;
 			}
+		   }
 
+		   // sky(n)
+		   // wait for odd / even ecm change (only not for irdeto!)
+#if 1
+			myprintf("curpids->table:%02x,%02x!", curpids->table, buffer[0]);
+			if (curpids->table == buffer[0]) {
+				// sky(dvn) /* tableid:0x50 */
+				uint16_t	casysid = curpids->CAID;
+				if (caid_is_dvn(casysid)) {
+					uint32_t	crcv;
+					crcv = crc32(0L, buffer, bufsize);
+					if (curpids->crcprevious == crcv) return;
+					curpids->crcprevious = crcv;
+				}
+				else {
+					if (!caid_is_irdeto(casysid)) return;
+				}
+			}
+#else
 			if(curpid->table == buffer[0] && !caid_is_irdeto(curpid->CAID))  // wait for odd / even ecm change (only not for irdeto!)
 			{ 
 				
@@ -3340,6 +3976,7 @@
 					return;
 				}
 
+				er->dmuxid 	= demux_id;// sky(powervu)
 				er->srvid = demux[demux_id].program_number;
 
 				er->tsid = demux[demux_id].tsid;
@@ -3355,31 +3992,38 @@
 				memcpy(er->ecm, buffer, er->ecmlen);
 				chid = get_subid(er); // fetch chid or fake chid
 				er->chid = chid;
-				dvbapi_set_section_filter(demux_id, er, filter_num);
+				dvbapi_set_section_filter(demux_id, er, filnum);
 				NULLFREE(er);
 				return; 
 			}
+#endif
 
-			if(caid_is_irdeto(curpid->CAID))
+#if defined(__DVCCRC_AVAILABLE__)
+		   bool bAdded  = 1;
+		   bAdded = DVBCRC_Addon(curpids, buffer, bufsize, &crcval);
+		   if (IS_IRDETO(curpids->CAID)) {
+			   if (!bAdded) return;
+		   }
+#endif
+
+		   myprintf("ECM:%02X:%02X:%02X%02X{%08X}\n", buffer[0], buffer[4], buffer[6], buffer[7], crcval);
+		   bAlternation = 1;
+		   curpids->tableid = buffer[0];
+			if (caid_is_irdeto(curpids->CAID))
 			{
 				// 80 70 39 53 04 05 00 88
 				// 81 70 41 41 01 06 00 13 00 06 80 38 1F 52 93 D2
 				//if (buffer[5]>20) return;
-				if(curpid->irdeto_maxindex != buffer[5])    //6, register max irdeto index
-				{
+			   if (curpids->irdeto_maxindex != buffer[5]) { // 6, register max irdeto index
 					cs_log_dbg(D_DVBAPI, "Found %d IRDETO ECM CHIDs", buffer[5] + 1);
-					curpid->irdeto_maxindex = buffer[5]; // numchids = 7 (0..6)
+				   curpids->irdeto_maxindex = buffer[5]; // numchids = 7 (0..6)
 				}
 			}
 		}
 		
-		if(!(er = get_ecmtask()))
-		{ 
-			return;
-		}
-
+		if (!(er = get_ecmtask())) return;
+		er->dmuxid = demux_id;// sky(powervu)
 		er->srvid = demux[demux_id].program_number;
-
 		er->tsid = demux[demux_id].tsid;
 		er->onid = demux[demux_id].onid;
 		er->pmtpid = demux[demux_id].pmtpid;
@@ -3384,50 +4028,75 @@
 		er->onid = demux[demux_id].onid;
 		er->pmtpid = demux[demux_id].pmtpid;
 		er->ens = demux[demux_id].enigma_namespace;
-
-		er->caid  = curpid->CAID;
-		er->pid   = curpid->ECM_PID;
-		er->prid  = curpid->PROVID;
-		er->vpid  = curpid->VPID;
+		er->caid   = curpids->CAID;
+		er->pid    = curpids->ECM_PID;
+		er->prid   = curpids->PROVID;
+		er->vpid   = curpids->VPID;
 		er->ecmlen = ecmlen;
 		memcpy(er->ecm, buffer, er->ecmlen);
 
-		chid = get_subid(er); // fetch chid or fake chid
-		er->chid = chid;
+		er->ecm_crc = (uint32_t)crcval;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+		er->chSets.muxid	 	= demux_id;
+		er->chSets.degree		= demux[demux_id].cs_degree;
+		er->chSets.frequency = demux[demux_id].cs_frequency;
+		er->chSets.vpid	 	= demux[demux_id].cs_vidpid;
+		er->chSets.srvid  	= demux[demux_id].program_number;
+#endif
 		
-		if(len == 0) // only used on receiver internal bufferoverflow to get quickly fresh ecm filterdata otherwise freezing! 
+		chid = get_subid(er); // fetch chid or fake chid
+		er->chid   = (chid) ? chid : 0x10000; // if not zero apply, otherwise use no chid value 0x10000
+#if defined(MODULE_AVAMGCAMD)
+		er->exprid = er->prid;
+		if (IS_IRDETO(er->caid)) {
+			er->exprid = (er->chid << 8) | (((er->onid>>8)&0xff) ^ ((er->onid)&0xff));
+		}
+#endif
+		if (bufsize == 0) // only used on receiver internal bufferoverflow to get quickly fresh ecm filterdata otherwise freezing!
 		{
-			curpid->table = 0;
-			dvbapi_set_section_filter(demux_id, er, filter_num);
+			curpids->table = 0;
+			dvbapi_set_section_filter(demux_id, er, filnum);
 			NULLFREE(er);
 			return;
 		}
 
-		if(caid_is_irdeto(curpid->CAID))
+		if (caid_is_irdeto(curpids->CAID))
 		{
+			cs_log_dbg(D_DVBAPI,"[DVBAPI] Demuxer %d ECMTYPE %02X CAID %04X PROVID %06X ECMPID %04X IRDETO INDEX %02X MAX INDEX %02X CHID %04X CYCLE %02X",
+					demux_id, er->ecm[0], er->caid, er->prid, er->pid, er->ecm[4], er->ecm[5], er->chid, curpids->irdeto_cycle);
 
-			if(curpid->irdeto_curindex != buffer[4])   // old style wrong irdeto index
+			if (curpids->irdeto_curindex != buffer[4]) // old style wrong irdeto index
 			{	
-				if(curpid->irdeto_curindex == 0xFE)  // check if this ecmfilter just started up
+				if (curpids->irdeto_curindex == 0xfe) // check if this ecmfilter just started up
 				{
-					curpid->irdeto_curindex = buffer[4]; // on startup set the current index to the irdeto index of the ecm
+					curpids->irdeto_curindex = buffer[4];// on startup set the current index to the irdeto index of the ecm
 				}
+				// sky(a)
 				else   // we are already running and not interested in this ecm
+				if (curpids->CHID == 0x10000)
 				{
-					if(curpid->table != buffer[0]) curpid->table = 0; // fix for receivers not supporting section filtering
-					dvbapi_set_section_filter(demux_id, er, filter_num); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
+				   bAlternation = 0;
+					curpids->irdeto_curindex = buffer[4];// on startup set the current index to the irdeto index of the ecm
+				}
+				else // we are already running and not interested in this ecm
+				{
+//					curpids->table = 0;
+					if (curpids->table != buffer[0]) curpids->table = 0; // fix for receivers not supporting section filtering
+					dvbapi_set_section_filter(demux_id, er, filnum); 	// set ecm filter to odd + even since this ecm doesnt match with current irdeto index
 					NULLFREE(er);
+					MYDVB_TRACE("11111 {%02X,%02X}{%4X}\n", buffer[4], curpids->irdeto_curindex, curpids->CHID);
 					return;
 				}
 			}
 			else //fix for receivers not supporting section filtering
 			{
-				if(curpid->table == buffer[0]){
+				if (curpids->table == buffer[0]){
 					NULLFREE(er);
 					return;
 				}
 			}
-			cs_log_dbg(D_DVBAPI, "Demuxer %d ECMTYPE %02X CAID %04X PROVID %06X ECMPID %04X IRDETO INDEX %02X MAX INDEX %02X CHID %04X CYCLE %02X VPID %04X", demux_id, er->ecm[0], er->caid, er->prid, er->pid, er->ecm[4], er->ecm[5], er->chid, curpid->irdeto_cycle, er->vpid);
+			cs_log_dbg(D_DVBAPI, "Demuxer %d ECMTYPE %02X CAID %04X PROVID %06X ECMPID %04X IRDETO INDEX %02X MAX INDEX %02X CHID %04X CYCLE %02X VPID %04X",
+					demux_id, er->ecm[0], er->caid, er->prid, er->pid, er->ecm[4], er->ecm[5], er->chid, curpids->irdeto_cycle, er->vpid);
 		}
 		else
 		{
@@ -3436,54 +4105,52 @@
 		}
 
 		// check for matching chid (unique ecm part in case of non-irdeto cas) + added fix for seca2 monthly changing fakechid 
-		if((curpid->CHID < 0x10000) && !((chid == curpid->CHID) || ((curpid->CAID >> 8 == 0x01) && (chid&0xF0FF) == (curpid->CHID&0xF0FF)) ) )  
+		if ((curpids->CHID < 0x10000) && !((chid == curpids->CHID) || ((curpids->CAID >> 8 == 0x01) && (chid&0xF0FF) == (curpids->CHID&0xF0FF)) ) )
 		{
-			if(caid_is_irdeto(curpid->CAID))
+			if (caid_is_irdeto(curpids->CAID))
 			{
 			
-				if((curpid->irdeto_cycle < 0xFE) && (curpid->irdeto_cycle == curpid->irdeto_curindex))   // if same: we cycled all indexes but no luck!
+				if ((curpids->irdeto_cycle < 0xfe) && (curpids->irdeto_cycle == curpids->irdeto_curindex)) // if same: we cycled all indexes but no luck!
 				{
-					struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pid, 'p');
+					struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pidx, 'p');
 					if(!forceentry || !forceentry->force)   // forced pid? keep trying the forced ecmpid, no force kill ecm filter
 					{
-						if(curpid->checked == 2) { curpid->checked = 4; }
-						if(curpid->checked == 1)
-						{
-							curpid->checked = 2;
-							curpid->CHID = 0x10000;
+						if (curpids->checked == 2) curpids->checked = 4;
+						if (curpids->checked == 1) {
+							 curpids->checked  = 2;
+							 curpids->CHID = 0x10000;
 						}
-						dvbapi_stop_filternum(demux_id, filter_num); // stop this ecm filter!
+						dvbapi_stop_filternum(demux_id, filnum); // stop this ecm filter!
 						NULLFREE(er);
 						return;
 					}
 				}
 				
-				curpid->irdeto_curindex++; // set check on next index
-				if(curpid->irdeto_cycle == 0xFE) curpid->irdeto_cycle = buffer[4]; // on startup set to current irdeto index
-				if(curpid->irdeto_curindex > curpid->irdeto_maxindex) { curpid->irdeto_curindex = 0; }  // check if we reached max irdeto index, if so reset to 0
+				curpids->irdeto_curindex++; // set check on next index
+				if (curpids->irdeto_cycle == 0xFE) curpids->irdeto_cycle = buffer[4]; // on startup set to current irdeto index
+				if (curpids->irdeto_curindex > curpids->irdeto_maxindex) curpids->irdeto_curindex = 0; // check if we reached max irdeto index, if so reset to 0
+				MYDVB_TRACE("22222 {%04X,%04X, %02X}\n", chid, curpids->CHID, curpids->irdeto_curindex);
 
-				curpid->table = 0;
-				dvbapi_set_section_filter(demux_id, er, filter_num); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
+				curpids->table = 0;
+				dvbapi_set_section_filter(demux_id, er, filnum); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
 				NULLFREE(er);
 				return;
 			}
 			else  // all nonirdeto cas systems
 			{
-				struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pid, 'p');
-				curpid->table = 0;
-				dvbapi_set_section_filter(demux_id, er, filter_num); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
-				if(forceentry && forceentry->force)
-				{
+				struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pidx, 'p');
+				curpids->table = 0;
+				dvbapi_set_section_filter(demux_id, er, filnum); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
+				if (forceentry && forceentry->force) {
 					NULLFREE(er);
 					return; // forced pid? keep trying the forced ecmpid!
 				}
-				if(curpid->checked == 2) { curpid->checked = 4; }
-				if(curpid->checked == 1)
-				{
-					curpid->checked = 2;
-					curpid->CHID = 0x10000;
+				if (curpids->checked == 2) curpids->checked = 4;
+				if (curpids->checked == 1) {
+					 curpids->checked  = 2;
+					 curpids->CHID = 0x10000;
 				}
-				dvbapi_stop_filternum(demux_id, filter_num); // stop this ecm filter!
+				dvbapi_stop_filternum(demux_id, filnum); // stop this ecm filter!
 				NULLFREE(er);
 				return;
 			}
@@ -3491,113 +4158,121 @@
 
 		struct s_dvbapi_priority *p;
 
-		for(p = dvbapi_priority; p != NULL; p = p->next)
+		for (p = dvbApi_priority; p != NULL; p = p->next)
 		{
 			if(p->type != 'l'
-					|| (p->caid && p->caid != curpid->CAID)
-					|| (p->provid && p->provid != curpid->PROVID)
-					|| (p->ecmpid && p->ecmpid != curpid->ECM_PID)
+				|| (p->caid   && p->caid   != curpids->CAID)
+				|| (p->provid && p->provid != curpids->PROVID)
+				|| (p->ecmpid && p->ecmpid != curpids->ECM_PID)
 					|| (p->srvid && p->srvid != demux[demux_id].program_number))
-				{ continue; }
+				continue;
 
-			if((uint)p->delay == ecmlen && p->force < 6)
-			{
+			if (p->delay == ecmlen && p->force < 6) {
 				p->force++;
 				NULLFREE(er);
 				return;
 			}
-			if(p->force >= 6)
-				{ p->force = 0; }
+			if (p->force >= 6) p->force = 0;
 		}
 
-		if(!curpid->PROVID)
-			{ curpid->PROVID = chk_provid(buffer, curpid->CAID); }
+		if (!curpids->PROVID)
+			curpids->PROVID = chk_ecm_provid(buffer, curpids->CAID);
 
-		if(caid_is_irdeto(curpid->CAID))   // irdeto: wait for the correct index
+		if (caid_is_irdeto(curpids->CAID))   // irdeto: wait for the correct index
 		{
-			if(buffer[4] != curpid->irdeto_curindex)
+			if (buffer[4] != curpids->irdeto_curindex)
 			{
-				curpid->table = 0;
-				dvbapi_set_section_filter(demux_id, er, filter_num); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
+				curpids->table = 0;
+				dvbapi_set_section_filter(demux_id, er, filnum); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
 				NULLFREE(er);
+				MYDVB_TRACE("33333 {%02X,%02X}\n", buffer[4], curpids->irdeto_curindex);
 				return;
 			}
 		}
 		// we have an ecm with the correct irdeto index (or fakechid)
-		for(p = dvbapi_priority; p != NULL ; p = p->next)  // check for ignore!
+		for (p = dvbApi_priority; p != NULL; p = p->next) // check for ignore!
 		{
 			if((p->type != 'i')
-					|| (p->caid && p->caid != curpid->CAID)
-					|| (p->provid && p->provid != curpid->PROVID)
-					|| (p->ecmpid && p->ecmpid != curpid->ECM_PID)
-					|| (p->pidx && p->pidx-1 != pid) 
+				|| (p->caid   && p->caid   != curpids->CAID)
+				|| (p->provid && p->provid != curpids->PROVID)
+				|| (p->ecmpid && p->ecmpid != curpids->ECM_PID)
+				|| (p->pidx   && p->pidx-1 != pidx)
 					|| (p->srvid && p->srvid != demux[demux_id].program_number))
-				{ continue; }
+				continue;
 
 			if(p->type == 'i' && (p->chid < 0x10000 && p->chid == chid))    // found a ignore chid match with current ecm -> ignoring this irdeto index
 			{
-				curpid->irdeto_curindex++;
-				if(curpid->irdeto_cycle == 0xFE) curpid->irdeto_cycle = buffer[4]; // on startup set to current irdeto index
-				if(curpid->irdeto_curindex > curpid->irdeto_maxindex)    // check if curindex is over the max
-				{
-					curpid->irdeto_curindex = 0;
+				curpids->irdeto_curindex++;
+				if (curpids->irdeto_cycle == 0xFE) curpids->irdeto_cycle = buffer[4]; // on startup set to current irdeto index
+				if (curpids->irdeto_curindex > curpids->irdeto_maxindex) { // check if curindex is over the max
+					curpids->irdeto_curindex = 0;
 				}
-				curpid->table = 0;
-				if(caid_is_irdeto(curpid->CAID) && (curpid->irdeto_cycle != curpid->irdeto_curindex))   // irdeto: wait for the correct index + check if we cycled all
+				curpids->table = 0;
+				if (caid_is_irdeto(curpids->CAID) && (curpids->irdeto_cycle != curpids->irdeto_curindex))   // irdeto: wait for the correct index
 				{
-					dvbapi_set_section_filter(demux_id, er, filter_num); // set ecm filter to odd + even since this chid has to be ignored!
+					dvbapi_set_section_filter(demux_id, er, filnum); // set ecm filter to odd + even since this chid has to be ignored!
 				}
 				else // this fakechid has to be ignored, kill this filter!
 				{
-					if(curpid->checked == 2) { curpid->checked = 4; }
-					if(curpid->checked == 1)
+					if (curpids->checked == 2) { curpids->checked = 4; }
+					if (curpids->checked == 1)
 					{
-						curpid->checked = 2;
-						curpid->CHID = 0x10000;
+						curpids->checked = 2;
+						curpids->CHID = 0x10000;
 					}
-					dvbapi_stop_filternum(demux_id, filter_num); // stop this ecm filter!
+					dvbapi_stop_filternum(demux_id, filnum); // stop this ecm filter!
 				}
 				NULLFREE(er);
 				return;
 			}
 		}
-		
-		if(er)
-		{
-			curpid->table = er->ecm[0];
+		// sky(a)
+		if (er) {
+			curpids->table = (bAlternation) ? er->ecm[0] : 0;
 		}
-		
-		request_cw(dvbapi_client, er, demux_id, 1); // register this ecm for delayed ecm response check
+		dvbapi_request_cw(dvbApi_client, er, demux_id, filnum, 1); // register this ecm for delayed ecm response check
 		return; // end of ecm filterhandling!
 	}
 
-	if(demux[demux_id].demux_fd[filter_num].type == TYPE_EMM && len != 0)  // len = 0 receiver encountered an internal bufferoverflow!
+	if (demux[demux_id].demux_fd[filnum].type == TYPE_EMM && bufsize != 0)  // len = 0 receiver encountered an internal bufferoverflow!
 	{
-		if(demux[demux_id].demux_fd[filter_num].pid == 0x01) // CAT
+		if (demux[demux_id].demux_fd[filnum].pid == 0x01) // CAT
 		{
+			myascdump("CAT", buffer, bufsize);
 			cs_log_dbg(D_DVBAPI, "receiving cat");
-			dvbapi_parse_cat(demux_id, buffer, len);
+			dvbapi_parse_cat(demux_id, buffer, bufsize);
 
-			dvbapi_stop_filternum(demux_id, filter_num);
+			dvbapi_stop_filternum(demux_id, filnum);
 			return;
 		}
-		dvbapi_process_emm(demux_id, filter_num, buffer, len);
+		if (bufsize >= MAX_EMM_SIZE) {
+			cs_log_dbg(D_DVBAPI, "Received an EMM invalid length{%d}!\n", bufsize);
+			return;
+		}
+		dvbapi_process_emm(demux_id, filnum, buffer, bufsize);
 	}
 }
 
+#if defined(WITH_HISILICON)
+#define PMT_SERVER_SOCKET "/var/.listen.camd.socket"
+#else
+#define PMT_SERVER_SOCKET "/tmp/.listen.camd.socket"
+#endif
+
 static void *dvbapi_main_local(void *cli)
 {
+	static int32_t next_scrambled_tries = 0;
 	int32_t i, j;
 	struct s_client *client = (struct s_client *) cli;
 	client->thread = pthread_self();
 	pthread_setspecific(getclient, cli);
 
-	dvbapi_client = cli;
+	dvbApi_client  = cli;
+	MYDVB_TRACE("mydvb:dvbapi_main_local{%d,%p}\n", cfg.dvbapi_pmtmode, dvbApi_client);
 
 	int32_t maxpfdsize = (MAX_DEMUX * maxfilter) + MAX_DEMUX + 2;
 	struct pollfd pfd2[maxpfdsize];
 	struct timeb start, end;  // start time poll, end time poll
-#define PMT_SERVER_SOCKET "/tmp/.listen.camd.socket"
 	struct sockaddr_un saddr;
 	saddr.sun_family = AF_UNIX;
 	strncpy(saddr.sun_path, PMT_SERVER_SOCKET, 107);
@@ -3610,7 +4285,7 @@
 	uchar mbuf[1024];
 
 	struct s_auth *account;
-	int32_t ok = 0;
+	int32_t 	ok = 0, retstatus;
 	for(account = cfg.account; account != NULL; account = account->next)
 	{
 		if((ok = is_dvbapi_usr(account->usr)))
@@ -3636,7 +4311,8 @@
 		{ disable_pmt_files = 1; }
 
 	int32_t listenfd = -1;
-	if(cfg.dvbapi_boxtype != BOXTYPE_IPBOX_PMT && cfg.dvbapi_pmtmode != 2 && cfg.dvbapi_pmtmode != 5 && cfg.dvbapi_pmtmode != 6)
+	if (cfg.dvbapi_boxtype != BOXTYPE_IPBOX_PMT &&
+		 cfg.dvbapi_pmtmode != 2 && cfg.dvbapi_pmtmode != 5 && cfg.dvbapi_pmtmode != 6)
 	{
 		if (!cfg.dvbapi_listenport)
 			listenfd = dvbapi_init_listenfd();
@@ -3655,6 +4331,7 @@
 	{
 		demux[i].pidindex = -1;
 		demux[i].curindex = -1;
+		demux[i].cs_cwidx  = -1;
 	}
 
 	if(cfg.dvbapi_pmtmode != 4 && cfg.dvbapi_pmtmode != 5 && cfg.dvbapi_pmtmode != 6)
@@ -3676,14 +4353,11 @@
 	else
 	{
 		pthread_t event_thread;
-		int32_t ret = pthread_create(&event_thread, NULL, dvbapi_event_thread, (void *) dvbapi_client);
-		if(ret)
-		{
-			cs_log("ERROR: Can't create dvbapi event thread (errno=%d %s)", ret, strerror(ret));
+		retstatus = pthread_create(&event_thread, NULL, dvbapi_event_thread, (void *)dvbApi_client);
+		if (retstatus) {
+			cs_log("ERROR: Can't create dvbapi event thread (errno=%d %s)", retstatus, strerror(retstatus));
 			return NULL;
 		}
-		else
-			{ pthread_detach(event_thread); }
 	}
 
 	if(listenfd != -1)
@@ -3741,14 +4413,15 @@
 				type[pfdcount++] = 1;
 			}
 
-			if(demux[i].program_number == 0) { continue; }  // only evalutate demuxers that have channels assigned
+			if (demux[i].program_number == 0) continue; // only evalutate demuxers that have channels assigned
 			
 			uint32_t ecmcounter = 0, emmcounter = 0;
 			for(g = 0; g < maxfilter; g++)
 			{
 				if(demux[i].demux_fd[g].fd <= 0) continue; // deny obvious invalid fd!
-				
-				if(!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && selected_api != STAPI && selected_api != COOLAPI)
+// sky(!)
+//				if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && selected_api != STAPI && selected_api != COOLAPI)
+				if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && selected_api != STAPI && selected_api != COOLAPI && selected_api != HISILICONAPI)
 				{
 					pfd2[pfdcount].fd = demux[i].demux_fd[g].fd;
 					pfd2[pfdcount].events = (POLLIN | POLLPRI);
@@ -3761,8 +4434,8 @@
 			}
 			if(ecmcounter != demux[i].old_ecmfiltercount || emmcounter != demux[i].old_emmfiltercount)   // only produce log if something changed
 			{
-				cs_log_dbg(D_DVBAPI, "Demuxer %d has %d ecmpids, %d streampids, %d ecmfilters and %d of max %d emmfilters", i, demux[i].ECMpidcount,
-							  demux[i].STREAMpidcount, ecmcounter, emmcounter, demux[i].max_emm_filter);
+			//	cs_log_dbg(D_DVBAPI, "Demuxer %d has %d ecmpids, %d streampids, %d ecmfilters and %d of max %d emmfilters", i, demux[i].ECMpidcount,
+			//				  demux[i].STREAMpidcount, ecmcounter, emmcounter, demux[i].max_emm_filter);
 				demux[i].old_ecmfiltercount = ecmcounter; // save new amount of ecmfilters
 				demux[i].old_emmfiltercount = emmcounter; // save new amount of emmfilters
 			}
@@ -3772,12 +4445,26 @@
 			struct timeb now;
 			cs_ftime(&now);
 			
+			// sky(!)
+			//	myprintf("mydvb:CAT{%d}{%d,%d,%d}\n", cfg.dvbapi_au, demux[i].emm_filter, demux[i].EMMpidcount, emmcounter);
 			if(cfg.dvbapi_au > 0 && demux[i].emm_filter == -1 && demux[i].EMMpidcount == 0 && emmcounter == 0)
 			{
 				int64_t gone = comp_timeb(&now, &demux[i].emmstart);
-				if(gone > 30*1000){
+				//	myprintf("mydvb:gone{%lld}\n", gone);
+				if (gone > 10*1000LL) { // sky(30->10)
 					cs_ftime(&demux[i].emmstart); // trick to let emm fetching start after 30 seconds to speed up zapping
-					dvbapi_start_filter(i, demux[i].pidindex, 0x001, 0x001, 0x01, 0x01, 0xFF, 0, TYPE_EMM); //CAT
+				   dvbapi_stop_filter(demux[i].demux_index, TYPE_EMM);
+					myprintf("mydvb:start CAT\n");
+				   dvbapi_start_filter(i,
+							   demux[i].pidindex,
+							   CAT_PID,
+							   0x001,
+							   0x01,
+							   0x01,
+							   0xFF,
+							   0,
+							   TYPE_EMM); 	// CAT
+				//	continue; // proceed with next demuxer
 				}
 			}
 
@@ -3793,30 +4480,36 @@
 				else
 				{
 					int64_t gone = comp_timeb(&now, &demux[i].emmstart);
-					if(gone > 30*1000)
+					if (gone > 10*1000) // sky(30->10)
 					{
 						demux[i].emmstart = now;
 						dvbapi_start_emm_filter(i); // start emmfiltering delayed if filters already were running
 						rotate_emmfilter(i); // rotate active emmfilters
 					}
 				}
+			//	if (emmstarted != demux[i].emm_filter && !emmcounter) { continue; }  // proceed with next demuxer if no emms where running before
 			}
-
-			if(ecmcounter == 0 && demux[i].ECMpidcount > 0)   // Restart decoding all caids we have ecmpids but no ecm filters!
+			next_scrambled_tries++;
+			if (!(next_scrambled_tries%4) && ecmcounter == 0 && demux[i].ECMpidcount > 0) // Restart decoding all caids we have ecmpids but no ecm filters!
 			{
-
 				int32_t started = 0;
 
+#if defined(WITH_HISILICON)
+// test.futures
+//				if (chk_av_descrambling(client)) continue;
+#endif
+
 				for(g = 0; g < demux[i].ECMpidcount; g++)  // avoid race: not all pids are asked and checked out yet!
 				{
 					if(demux[i].ECMpids[g].checked == 0 && demux[i].ECMpids[g].status >= 0)  // check if prio run is done
 					{
-						dvbapi_try_next_caid(i, 0); // not done, so start next prio pid
+						MYDVB_TRACE("mydvb:eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee TRY{%d}\n", next_scrambled_tries);
+						dvbapi_try_next_caid(i, 0, 0); // not done, so start next prio pid
 						started = 1;
 						break;
 					}
 				}
-				if(started) { continue; }  // if started a filter proceed with next demuxer
+				if (started) continue; // if started a filter proceed with next demuxer
 
 				if(g == demux[i].ECMpidcount)   // all usable pids (with prio) are tried, lets start over again without prio!
 				{
@@ -3824,36 +4517,40 @@
 					{
 						if(demux[i].ECMpids[g].checked == 2 && demux[i].ECMpids[g].status >= 0)  // check if noprio run is done
 						{
-							demux[i].ECMpids[g].irdeto_curindex = 0xFE;
+							demux[i].ECMpids[g].irdeto_curindex	= 0xfe;
 							demux[i].ECMpids[g].irdeto_maxindex = 0;
-							demux[i].ECMpids[g].irdeto_cycle = 0xFE;
-							demux[i].ECMpids[g].tries = 0xFE;
+							demux[i].ECMpids[g].irdeto_cycle		= 0xfe;
+							demux[i].ECMpids[g].tries = 0xfe;
 							demux[i].ECMpids[g].table = 0;
 							demux[i].ECMpids[g].CHID = 0x10000; // remove chid prio
-							dvbapi_try_next_caid(i, 2); // not done, so start next no prio pid
+							MYDVB_TRACE("mydvb:cccccccccccccccccccccccccccccccccccccccc TRY{%d}\n", next_scrambled_tries);
+							dvbapi_try_next_caid(i, 2, 0); // not done, so start next no prio pid
 							started = 1;
 							break;
 						}
 					}
 				}
-				if(started) { continue; }  // if started a filter proceed with next demuxer
+				if (started) continue; // if started a filter proceed with next demuxer
 
 				if(g == demux[i].ECMpidcount)   // all usable pids are tried, lets start over again!
 				{
 					if(demux[i].decodingtries == -1) // first redecoding attempt?
 					{
 						cs_ftime(&demux[i].decstart);
+					   demux[i].scrambled_counter = (demux[i].scrambled_counter+1)%10;
+					   if (demux[i].scrambled_counter==0) {
 						for(g = 0; g < demux[i].ECMpidcount; g++)  // reinit some used things from second run (without prio)
 						{
 							demux[i].ECMpids[g].checked = 0;
-							demux[i].ECMpids[g].irdeto_curindex = 0xFE;
+							   demux[i].ECMpids[g].irdeto_curindex = 0xfe;
 							demux[i].ECMpids[g].irdeto_maxindex = 0;
-							demux[i].ECMpids[g].irdeto_cycle = 0xFE;
+							   demux[i].ECMpids[g].irdeto_cycle		= 0xfe;
 							demux[i].ECMpids[g].table = 0;
 							demux[i].decodingtries = 0;
 							dvbapi_edit_channel_cache(i, g, 0); // remove this pid from channelcache since we had no founds on any ecmpid!
 						}
 					}
+					}
 					uint8_t number_of_enabled_pids = 0;
 					demux[i].decodingtries++;
 					dvbapi_resort_ecmpids(i);
@@ -3877,7 +4574,8 @@
 						int64_t gone = comp_timeb(&demux[i].decend, &demux[i].decstart);
 						cs_log("Demuxer %d restarting decodingrequests after %"PRId64" ms with %d enabled and %d disabled ecmpids!", i, gone, number_of_enabled_pids,
 							(demux[i].ECMpidcount-number_of_enabled_pids));
-						dvbapi_try_next_caid(i, 0);
+						MYDVB_TRACE("mydvb:ssssssssssssssssssssssssssssssssssssssss TRY{%d}\n", next_scrambled_tries);
+						dvbapi_try_next_caid(i, 0, 1);
 					}
 				}
 			}
@@ -3893,7 +4591,7 @@
 						break;
 					}
 				}
-				if(rc == 1) { continue; }
+				if (rc==1) continue;
 
 				pfd2[pfdcount].fd = demux[i].socket_fd;
 				pfd2[pfdcount].events = (POLLIN | POLLPRI);
@@ -3902,12 +4600,13 @@
 			}
 		}
 
-		while(1)
+		rc = 0;
+		while (!(listenfd == -1 && cfg.dvbapi_pmtmode == 6))
 		{
 			rc = poll(pfd2, pfdcount, 300);
-			if(listenfd == -1 && cfg.dvbapi_pmtmode == 6) { break; }
-			if(rc < 0)
-				{ continue; }
+			if (rc < 0) {
+				if (errno == EINTR || errno == EAGAIN) continue; // try again in case of interrupt
+			}
 			break;
 		}
 
@@ -3916,7 +4615,13 @@
 			cs_ftime(&end); // register end time
 			int64_t timeout = comp_timeb(&end, &start);
 			if (timeout < 0) {
-				cs_log("*** WARNING: BAD TIME AFFECTING WHOLE OSCAM ECM HANDLING ****");
+				cs_log("*** WARNING: BAD TIME AFFECTING WHOLE OSCAM ECM HANDLING ***");
+				// sky(a)
+				if (cs_timefaults) {
+					cs_log("*** OSCAM LOGIN_TIME CHANGE ***");
+					cs_timefaults = 0;
+					first_client->login = time((time_t *)0);
+				}
 			}
 			cs_log_dbg(D_TRACE, "New events occurred on %d of %d handlers after %"PRId64" ms inactivity", rc, pfdcount, timeout);
 			cs_ftime(&start); // register new start time for next poll
@@ -3926,7 +4631,7 @@
 		{
 			if(pfd2[i].revents == 0) { continue; }  // skip sockets with no changes
 			rc--; //event handled!
-			cs_log_dbg(D_TRACE, "Now handling fd %d that reported event %d", pfd2[i].fd, pfd2[i].revents);
+			cs_log_dbg(D_TRACE, "Now handling fd %d that reported event %x(%d)", pfd2[i].fd, pfd2[i].revents, type[i]);
 
 			if(pfd2[i].revents & (POLLHUP | POLLNVAL | POLLERR))
 			{
@@ -3934,8 +4639,8 @@
 				{
 					for(j = 0; j < MAX_DEMUX; j++)
 					{
-						if(demux[j].socket_fd == pfd2[i].fd)  // if listenfd closes stop all assigned decoding!
-						{
+						if (demux[j].socket_fd==pfd2[i].fd) { // if listenfd closes stop all assigned decoding!
+							mycs_debug(D_DVBAPI, "stop pfd(%d.%d, %X)(%d) closed !!!\n", pfd2[i].fd, listenfd, pfd2[i].revents, pfdcount);
 							dvbapi_stop_descrambling(j);
 						}
 					}
@@ -3952,14 +4657,20 @@
 					int32_t n = fdn[i];
 					dvbapi_stop_filternum(demux_index, n); // stop filter since its giving errors and wont return anything good.
 				}
+				// sky()
+				if (pfd2[i].revents & (POLLNVAL)) {
+					usleep(100 * 1000);
+				}
 				continue; // continue with other events
 			}
 
 			if(pfd2[i].revents & (POLLIN | POLLPRI))
 			{
-				if(type[i] == 1 && pmthandling == 0)
+				if (type[i]==1 && pmt_handling == 0)
 				{
-					pmthandling = 1;     // pmthandling in progress!
+					pmt_handling = 1; // pmthandling in progress!
+					pmt_stopmarking = 0; // to stop_descrambling marking in PMT 6 mode
+
 					connfd = -1;         // initially no socket to read from
 					int add_to_poll = 0; // we may need to additionally poll this socket when no PMT data comes in
 
@@ -3968,10 +4679,11 @@
 						if (cfg.dvbapi_pmtmode == 6) {
 							connfd = listenfd;
 							disable_pmt_files = 1;
-						} else {
+						}
+						else {
 							clilen = sizeof(servaddr);
 							connfd = accept(listenfd, (struct sockaddr *)&servaddr, (socklen_t *)&clilen);
-							cs_log_dbg(D_DVBAPI, "new socket connection fd: %d", connfd);
+							cs_log_dbg(D_DVBAPI, "new socket connection fd: %d(%d)", connfd, listenfd);
 							if (cfg.dvbapi_listenport)
 							{
 								//update webif data
@@ -3982,10 +4694,11 @@
 
 							if(cfg.dvbapi_pmtmode == 3 || cfg.dvbapi_pmtmode == 0) { disable_pmt_files = 1; }
 
-							if(connfd <= 0)
+							if (connfd <= 0) {
 								cs_log_dbg(D_DVBAPI, "accept() returns error on fd event %d (errno=%d %s)", pfd2[i].revents, errno, strerror(errno));
 						}
 					}
+					}
 					else
 					{
 						cs_log_dbg(D_DVBAPI, "PMT Update on socket %d.", pfd2[i].fd);
@@ -3999,8 +4712,8 @@
 						int tries = 100;
 						do {
 							len = recv(connfd, mbuf + pmtlen, sizeof(mbuf) - pmtlen, MSG_DONTWAIT);
-							if (len > 0)
-								pmtlen += len;
+							if (len > 0) pmtlen += len;
+
 							if ((cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX) &&
 								(len == 0 || (len == -1 && (errno != EINTR && errno != EAGAIN))))
 							{
@@ -4011,11 +4724,9 @@
 								{
 									if (demux[j].socket_fd == connfd)
 										dvbapi_stop_descrambling(j);
-									else if (demux[j].socket_fd)
-										active_conn++;
+									else if (demux[j].socket_fd) active_conn++;
 									// remove from unassoc_fd when necessary
-									if (unassoc_fd[j] == connfd)
-										unassoc_fd[j] = 0;
+									if (unassoc_fd[j] == connfd) unassoc_fd[j] = 0;
 								}
 								close(connfd);
 								connfd = -1;
@@ -4023,7 +4734,8 @@
 								if (!active_conn) //last connection closed
 								{
 									client_proto_version = 0;
-									if (client_name)
+									if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) {}
+									else if (client_name)
 									{
 										free(client_name);
 										client_name = NULL;
@@ -4095,15 +4807,16 @@
 									if ((opcode & 0xFFFFF000) == DVBAPI_AOT_CA)
 									{
 										cs_log_dump_dbg(D_DVBAPI, mbuf, chunksize, "Parsing PMT object %d:", chunks_processed);
+										mycs_debug(D_DVBAPI,"tvh:handlesockmsg{%x}{%d}{size=%d}\n", opcode, connfd, pmtlen);
 										dvbapi_handlesockmsg(mbuf, chunksize, connfd);
 										add_to_poll = 0;
-										if (cfg.dvbapi_listenport && opcode == DVBAPI_AOT_CA_STOP)
-											add_to_poll = 1;
+										if (cfg.dvbapi_listenport && opcode == DVBAPI_AOT_CA_STOP) add_to_poll = 1;
 									}
 									else switch (opcode)
 									{
 										case DVBAPI_FILTER_DATA:
 										{
+											if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) break;
 											int32_t demux_index = mbuf[4];
 											int32_t filter_num = mbuf[5];
 											dvbapi_process_input(demux_index, filter_num, mbuf + 6, data_len + 3);
@@ -4111,11 +4824,11 @@
 										}
 										case DVBAPI_CLIENT_INFO:
 										{
+											if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) break;
 											uint16_t client_proto_ptr;
 											memcpy(&client_proto_ptr, &mbuf[4], 2);
 											uint16_t client_proto = ntohs(client_proto_ptr);
-											if (client_name)
-												free(client_name);
+											if (client_name) free(client_name);
 											if (cs_malloc(&client_name, data_len + 1))
 											{
 												memcpy(client_name, &mbuf[7], data_len);
@@ -4150,8 +4863,7 @@
 									// remove from unassoc_fd if the socket fd is invalid
 									if (errno == EBADF)
 										for (j = 0; j < MAX_DEMUX; j++)
-											if (unassoc_fd[j] == connfd)
-												unassoc_fd[j] = 0;
+											if (unassoc_fd[j] == connfd) unassoc_fd[j] = 0;
 									cs_sleepms(20);
 									continue;
 								}
@@ -4161,7 +4873,7 @@
 						// if the connection is new and we read no PMT data, then add it to the poll,
 						// otherwise this socket will not be checked with poll when data arives
 						// because fd it is not yet assigned with the demux
-						if (add_to_poll) {
+						if (add_to_poll && !pmtlen && !chunks_processed) {
 							for (j = 0; j < MAX_DEMUX; j++) {
 								if (!unassoc_fd[j]) {
 									unassoc_fd[j] = connfd;
@@ -4171,17 +4883,21 @@
 						}
 
 						if (pmtlen > 0) {
-							if (pmtlen < 3)
+							if (pmtlen < 3) {
 								cs_log_dbg(D_DVBAPI, "CA PMT server message too short!");
-							else {
-								if (pmtlen >= sizeof(mbuf))
+							}
+							else
+							{
+								if (pmtlen >= sizeof(mbuf)) {
 									cs_log("***** WARNING: PMT BUFFER OVERFLOW, PLEASE REPORT! ****** ");
+								}
 								cs_log_dump_dbg(D_DVBAPI, mbuf, pmtlen, "New PMT info from socket (total size: %d)", pmtlen);
+								mycs_debug(D_DVBAPI,"tvh:handlesockmsg{%d}{size=%d}\n", connfd, pmtlen);
 								dvbapi_handlesockmsg(mbuf, pmtlen, connfd);
 							}
 						}
 					}
-					pmthandling = 0; // pmthandling done!
+					pmt_handling = 0; // pmthandling done!
 					continue; // continue with other events!
 				}
 				else     // type==0
@@ -4203,7 +4919,8 @@
 						memset(mbuf, 0, sizeof(mbuf));
 					}
 
-					dvbapi_process_input(demux_index, n, mbuf, len);
+  					myprintf("tvh::process_input len=%d\n", (int)len);
+					dvbapi_process_input(demux_index, n, mbuf, (int32_t)len);
 				}
 				continue; // continue with other events!
 			}
@@ -4211,17 +4928,25 @@
 	}
 	return NULL;
 }
-
-void dvbapi_write_cw(int32_t demux_id, uchar *cw, int32_t pid)
+// sky(powervu)
+void dvbapi_write_cw(int32_t demux_id, uchar *cw, CWEXTENTION *cwEx, int32_t pidx, int cwdesalgo)
 {
+	ca_descr_t ca_descr;
+	ca_exdescr_t ca_exdescr; // sky(powervu)
 	int32_t n;
 	int8_t cwEmpty = 0;
-	unsigned char nullcw[8];
-	memset(nullcw, 0, 8);
-	ca_descr_t ca_descr;
+	uint8_t nullcw[8];
 
+	memset(nullcw, 0, 8);
 	memset(&ca_descr, 0, sizeof(ca_descr));
+	memset(&ca_exdescr,0,sizeof(ca_exdescr_t));
 
+	mycs_debug(D_DVBAPI,"mydvb:dvbapi_write_cw{%d,%04X,%d, %04X}{%02X%02X...%02X%02X}\n",
+			demux_id,
+			demux[demux_id].ca_mask,
+			demux[demux_id].adapter_index,
+			pidx,
+			cw[0], cw[7], cw[8], cw[15]);
 	if(memcmp(demux[demux_id].lastcw[0], nullcw, 8) == 0
 			&& memcmp(demux[demux_id].lastcw[1], nullcw, 8) == 0)
 		{ cwEmpty = 1; } // to make sure that both cws get written on constantcw
@@ -4234,10 +4959,11 @@
 		cs_hexdump(0, demux[demux_id].lastcw[n], 8, lastcw, sizeof(lastcw));
 		cs_hexdump(0, cw + (n * 8), 8, newcw, sizeof(newcw));
 
-		if((memcmp(cw + (n * 8), demux[demux_id].lastcw[n], 8) != 0 || cwEmpty)
+		if (((memcmp(cw+(n*8), demux[demux_id].lastcw[n],8) != 0) || cwEmpty)
 				&& memcmp(cw + (n * 8), nullcw, 8) != 0) // check if already delivered and new cw part is valid!
 		{
-			int32_t idx = dvbapi_ca_setpid(demux_id, pid);  // prepare ca
+			int32_t idx = dvbapi_ca_setpid(demux_id, pidx); // prepare ca
+			mycs_debug(D_DVBAPI,"mydvb:dvbapi_write_cw{idx=%d}\n", idx);
 			if (idx == -1) return; // return on no index!
 
 #ifdef WITH_COOLAPI
@@ -4252,10 +4978,18 @@
 			for(i = 0; i < MAX_DEMUX; i++)
 			{
 				if(!(demux[demux_id].ca_mask & (1 << i))) continue; // ca not in use by this demuxer!
-				
+				// sky(constant.cw)
+				if (demux[demux_id].constcw_fbiss)
+				{
+					cs_log_dbg(D_DVBAPI,"Demuxer %d ca%d is ftacas", demux_id, i);
+					write_cw = 1;
+				}
+				else if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) write_cw = 1; // always
+				else {
+					// sky(future test...)
 				for(j = 0; j < demux[demux_id].STREAMpidcount; j++)
 				{
-					if(!demux[demux_id].ECMpids[pid].streams || ((demux[demux_id].ECMpids[pid].streams & (1 << j)) == (uint) (1 << j)))
+						if (!demux[demux_id].ECMpids[pidx].streams || ((demux[demux_id].ECMpids[pidx].streams & (1 << j)) == (uint) (1 << j)))
 					{
 						int32_t usedidx = is_ca_used(i, demux[demux_id].STREAMpids[j]);
 						if(idx != usedidx)
@@ -4270,31 +5004,82 @@
 						}
 					}
 				}
+				}
 				if(!write_cw) { continue; } // no need to write the cw since this ca isnt using it!
-				
-				ca_descr.index = idx;
+				ca_descr.index  = idx & 0x7f;
 				ca_descr.parity = n;
 				memcpy(demux[demux_id].lastcw[n], cw + (n * 8), 8);
 				memcpy(ca_descr.cw, cw + (n * 8), 8);
-				cs_log_dbg(D_DVBAPI, "Demuxer %d writing %s part (%s) of controlword, replacing expired (%s)", demux_id, (n == 1 ? "even" : "odd"), newcw, lastcw);
+				cs_log_dbg(D_DVBAPI, "Demuxer %d writing %4s part (%s) of controlword, replacing expired (%s)", demux_id, (n == 1 ? "even" : "odd"), newcw, lastcw);
 				cs_log_dbg(D_DVBAPI, "Demuxer %d write cw%d index: %d (ca%d)", demux_id, n, ca_descr.index, i);
 
 				if(cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
 					dvbapi_net_send(DVBAPI_CA_SET_DESCR, demux[demux_id].socket_fd, demux_id, -1 /*unused*/, (unsigned char *) &ca_descr, NULL, NULL);
 				else
 				{
+#if defined(WITH_HISILICON)
+					if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON)
+					{
+						// sky(powervu)
+	          		int32_t request = CA_SET_DESCR;
+						ca_descr.index |= (demux[demux_id].program_number << 16);
+						ca_descr.index |= (demux[demux_id].adapter_index  << 12);
+						if (cwdesalgo) ca_descr.index |= 0x100;
+
+					   if (ca_fd[i]<= 0)
+					   {
+						   ca_fd[i] = dvbapi_open_netdevice(1, i, demux[demux_id].adapter_index);
+						   if (ca_fd[i] <= 0) { continue; }
+					   }
+
+					   if (cwEx && cwEx->type == CW_MULTIPLE)
+					   {
+					   	request = CA_SET_EXDESCR;
+					   	ca_exdescr.parity = ca_descr.parity;
+					   	ca_exdescr.index  = ca_descr.index;
+					   	ca_exdescr.type	= cwEx->type;
+					   	ca_exdescr.algo	= cwEx->algo;
+					   	ca_exdescr.cipher	= cwEx->cipher;
+							memcpy(ca_exdescr.cw, cw + (n * 8), 8);
+							memcpy(ca_exdescr.a0, cwEx->audio[0] + (n * 8), 8);
+							memcpy(ca_exdescr.a1, cwEx->audio[1] + (n * 8), 8);
+							memcpy(ca_exdescr.a2, cwEx->audio[2] + (n * 8), 8);
+							memcpy(ca_exdescr.a3, cwEx->audio[3] + (n * 8), 8);
+							memcpy(ca_exdescr.data, cwEx->data + (n * 8), 8);
+							memcpy(ca_exdescr.vbi,  cwEx->vbi  + (n * 8), 8);
+	                  unsigned char packet[sizeof(request) + sizeof(ca_exdescr)];
+	                  memcpy(&packet, &request, sizeof(request));
+	                  memcpy(&packet[sizeof(request)], &ca_exdescr, sizeof(ca_exdescr));
+	                  // sending data(MSG_NOSIGNAL)
+	                  send(ca_fd[i], &packet, sizeof(packet), 0);
+	                  mycs_trace(D_ADB, "mydvb:tvheadend sending cwex%d data{%x,%d}", n, ca_exdescr.index, ca_exdescr.parity);
+					   }
+					   else
+					   {
+					   	request = CA_SET_DESCR;
+	                  unsigned char packet[sizeof(request) + sizeof(ca_descr)];
+	                  memcpy(&packet, &request, sizeof(request));
+	                  memcpy(&packet[sizeof(request)], &ca_descr, sizeof(ca_descr));
+	                  // sending data(MSG_NOSIGNAL)
+	                  send(ca_fd[i], &packet, sizeof(packet), 0);
+	                  mycs_trace(D_ADB, "mydvb:tvheadend sending cw%d data{%x,%d}", n, ca_descr.index, ca_descr.parity);
+                  }
+					}
+					else
+#endif
+					{
 					if(ca_fd[i] <= 0)
 					{
 						ca_fd[i] = dvbapi_open_device(1, i, demux[demux_id].adapter_index);
 						if(ca_fd[i] <= 0) { continue; } 
 					}
-					if (dvbapi_ioctl(ca_fd[i], CA_SET_DESCR, &ca_descr) < 0)
-					{
+					 	if (dvbapi_ioctl(ca_fd[i], CA_SET_DESCR, &ca_descr) < 0) {
 						cs_log("ERROR: ioctl(CA_SET_DESCR): %s", strerror(errno));
 					}
 				}
 			}
-#endif
+			}
+#endif	// #if defined(WITH_COOLAPI)
 		}
 	}
 }
@@ -4317,31 +5102,68 @@
 {
 	int32_t i, j, handled = 0;
 
+	MYDVB_TRACE("mydvb:dvbapi_send_dcw{%d}{%04X:%06X,%d}{%04x}.%s(%d)(%d)\n",
+			 er->rc,
+			 er->caid, er->prid, er->srvid, er->pid,
+			(er->selected_reader) ? er->selected_reader->label : "unk",
+			 er->ecm_bypass,
+			 er->cwdesalgo);
+
+
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (er->ecm_useless) {
+		mycs_trace(D_ADB, "mydvb:??? skip ecm_useless");
+		return;
+	}
+#endif
+
 	for(i = 0; i < MAX_DEMUX; i++)
 	{
 		uint32_t nocw_write = 0; // 0 = write cw, 1 = dont write cw to hardware demuxer
-		if(demux[i].program_number == 0) { continue; }  // ignore empty demuxers
-		if(demux[i].program_number != er->srvid) { continue; }  // skip ecm response for other srvid
+		if (demux[i].program_number == 0) continue; // ignore empty demuxers
+		if (demux[i].program_number != er->srvid) continue; // skip ecm response for other srvid
 		demux[i].rdr = er->selected_reader;
+
 		for(j = 0; j < demux[i].ECMpidcount; j++)  // check for matching ecmpid
 		{
-			if((demux[i].ECMpids[j].CAID == er->caid || demux[i].ECMpids[j].CAID == er->ocaid)
-					&& demux[i].ECMpids[j].ECM_PID == er->pid
-					&& demux[i].ECMpids[j].PROVID == er->prid
-					&& demux[i].ECMpids[j].VPID == er->vpid)
-				{ break; }
+			if ((demux[i].ECMpids[j].CAID == er->caid || demux[i].ECMpids[j].CAID == er->ocaid) &&
+				 (demux[i].ECMpids[j].ECM_PID == er->pid) &&
+//				 (demux[i].ECMpids[j].VPID    == er->vpid) &&
+				 (demux[i].ECMpids[j].PROVID  == er->prid))
+				break;
+		}
+		MYDVB_TRACE("mydvb:    ecmpid{%d}{%d,%d}{%d,%d}(%s)\n",
+						i,
+						demux[i].pidindex,
+						demux[i].curindex,
+						j,
+						demux[i].ECMpidcount,
+						demux[i].rdr ? demux[i].rdr->label : "UNK");
+		if (!demux[i].rdr)
+		{
+			MYDVB_TRACE("mydvb:    ecmpid.unk readers\n");
+			continue; // ecm response srvid ok but no matching ecmpid, perhaps this for other demuxer
+		}
+		if (j == demux[i].ECMpidcount)
+		{
+			MYDVB_TRACE("mydvb:    ecmpid.non matching\n");
+			continue; // ecm response srvid ok but no matching ecmpid, perhaps this for other demuxer
 		}
-		if(j == demux[i].ECMpidcount) { continue; }  // ecm response srvid ok but no matching ecmpid, perhaps this for other demuxer
 
-		cs_log_dbg(D_DVBAPI, "Demuxer %d %scontrolword received for PID %d CAID %04X PROVID %06X ECMPID %04X CHID %04X VPID %04X", i,
-					  (er->rc >= E_NOTFOUND ? "no " : ""), j, er->caid, er->prid, er->pid, er->chid, er->vpid);
+		cs_log_dbg(D_DVBAPI,"Demuxer %d %scontrolword received for PID %d CAID %04X PROVID %06X ECMPID %04X CHID %04X", i,
+				(er->rc >= E_NOTFOUND ? "no ":""), j,
+				 er->caid, er->prid, er->pid, er->chid);
 
+// sky(?)
+//		if (er->rc < E_NOTFOUND) // check for delayed response on already expired ecmrequest
+		{
 		uint32_t status = dvbapi_check_ecm_delayed_delivery(i, er);
 
 		uint32_t comparecw0 = 0, comparecw1 = 0;
 		char ecmd5[17 * 3];
 		cs_hexdump(0, er->ecmd5, 16, ecmd5, sizeof(ecmd5));
 
+			MYDVB_TRACE("mydvb:    ecm_delayed_delivery{%d}\n", status);
 		if(status == 1 && er->rc)   // wrong ecmhash
 		{
 			cs_log_dbg(D_DVBAPI, "Demuxer %d not interested in response ecmhash %s (requested different one)", i, ecmd5);
@@ -4356,7 +5178,11 @@
 		{
 			cs_log_dbg(D_DVBAPI, "Demuxer %d not interested in response ecmhash %s (delivered cw is empty!)", i, ecmd5);
 			nocw_write = 1;
-			if(er->rc < E_NOTFOUND) { er->rc = E_NOTFOUND; }
+				if (er->rc < E_NOTFOUND) {
+					// sky(powervu)
+					if (caid_is_powervu(er->caid)) continue;
+					er->rc = E_NOTFOUND;
+				}
 		}
 
 		if((status == 0 || status == 3 || status == 4) && er->rc < E_NOTFOUND)   // 0=matching ecm hash, 2=no filter, 3=table reset, 4=cache-ex response
@@ -4372,6 +5198,7 @@
 			if(comparecw0 == 1 || comparecw1 == 1)
 			{
 				cs_log_dbg(D_DVBAPI, "Demuxer %d duplicate controlword ecm response hash %s (duplicate controlword!)", i, ecmd5);
+					mycs_trace(D_ADB, "mydvb:    cw.same!!{%02x...%02x, %02x...%02x}", er->cw[0],er->cw[7], er->cw[8],er->cw[15]);
 				nocw_write = 1;
 			}
 		}
@@ -4385,12 +5212,13 @@
 		{
 			cs_log_dbg(D_DVBAPI, "Demuxer %d new controlword from cache-ex reader (no ecmhash check possible)", i);
 		}
+		}
 		
 		handled = 1; // mark this ecm response as handled
 		if(er->rc < E_NOTFOUND && cfg.dvbapi_requestmode == 0 && (demux[i].pidindex == -1) && er->caid != 0)
 		{
-			demux[i].ECMpids[j].tries = 0xFE; // reset timeout retry flag
-			demux[i].ECMpids[j].irdeto_cycle = 0xFE; // reset irdetocycle
+			demux[i].ECMpids[j].tries = 0xfe; // reset timeout retry flag
+			demux[i].ECMpids[j].irdeto_cycle = 0xfe; // reset irdetocycle
 			demux[i].pidindex = j; // set current index as *the* pid to descramble
 			demux[i].ECMpids[j].checked = 4;
 			cs_log_dbg(D_DVBAPI, "Demuxer %d descrambling PID %d CAID %04X PROVID %06X ECMPID %04X CHID %02X VPID %04X",
@@ -4426,8 +5254,9 @@
 
 				for(o = 0; o < maxfilter; o++) if(demux[i].demux_fd[o].type == TYPE_ECM) { ecmcounter++; }   // count all ecmfilters
 
-				demux[i].ECMpids[j].tries = 0xFE; // reset timeout retry flag
-				demux[i].ECMpids[j].irdeto_cycle = 0xFE; // reset irdetocycle
+				demux[i].ECMpids[j].tries = 0xfe; // reset timeout retry flag
+				demux[i].ECMpids[j].irdeto_cycle = 0xfe; // reset irdetocycle
+				demux[i].pidindex = j; // set current index as *the* pid to descramble
 
 				if(ecmcounter == 1)   // if total found running ecmfilters is 1 -> we found the "best" pid
 				{
@@ -4435,8 +5264,8 @@
 					demux[i].ECMpids[j].checked = 4; // mark best pid last ;)
 				}
 
-				cs_log_dbg(D_DVBAPI, "Demuxer %d descrambling PID %d CAID %04X PROVID %06X ECMPID %04X CHID %02X VPID %04X",
-					i, demux[i].pidindex, er->caid, er->prid, er->pid, er->chid, er->vpid);
+				cs_log_dbg(D_DVBAPI,"Demuxer %d descrambling PID %d CAID %04X PROVID %06X ECMPID %04X CHID %02X",
+							i, demux[i].curindex, er->caid, er->prid, er->pid, er->chid);
 			}
 			pthread_mutex_unlock(&demux[i].answerlock); // and release it!
 		}
@@ -4448,7 +5277,9 @@
 				dvbapi_stop_descrambling(i);
 				return;
 			}
-			
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+			if (er->ecm_bypass) continue;
+#endif
 			struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(i, j, 'p');
 
 			if(forceentry && forceentry->force)   // forced pid? keep trying the forced ecmpid!
@@ -4461,7 +5292,7 @@
 				}
 				else   // irdeto cas without chid prio forced
 				{
-					if(demux[i].ECMpids[j].irdeto_curindex == 0xFE) { demux[i].ECMpids[j].irdeto_curindex = 0x00; }  // init irdeto current index to first one
+					if (  demux[i].ECMpids[j].irdeto_curindex == 0xfe) { demux[i].ECMpids[j].irdeto_curindex = 0x00; }  // init irdeto current index to first one
 					if(!(demux[i].ECMpids[j].irdeto_curindex + 1 > demux[i].ECMpids[j].irdeto_maxindex))  // check for last / max chid
 					{
 						cs_log_dbg(D_DVBAPI, "Demuxer %d trying next irdeto chid of FORCED PID %d CAID %04X PROVID %06X ECMPID %04X", i,
@@ -4475,8 +5306,22 @@
 			}
 
 			// in case of timeout or fatal LB event give this pid another try but no more than 1 try
-			if((er->rc == E_TIMEOUT || (er->rcEx && er->rcEx <= E2_CCCAM_NOCARD)) && demux[i].ECMpids[j].tries == 0xFE)
+			if ((er->rc == E_TIMEOUT || (er->rcEx && er->rcEx <= E2_CCCAM_NOCARD)) && demux[i].ECMpids[j].tries == 0xfe)
 			{
+#if defined(MODULE_XCAMD)
+				MYDVB_TRACE("mydvb:    ecm.cw %s timeout{%d, %04X:%04X:%04X}\n",
+						(demux[i].rdr) ? demux[i].rdr->label : "UNK",
+						 er->ecm_bypass,
+						 er->chid,
+						 demux[i].ECMpids[j].CHID,
+						 demux[i].ECMpids[j].iks_irdeto_chid);
+				if (IS_ICS_READERS(demux[i].rdr)) {
+					if ((er->caid>>8) == 0x06) {
+						if (demux[i].ECMpids[j].CHID < 0x10000) continue;
+						if (demux[i].ECMpids[j].CHID != er->chid) continue;
+					}
+				}
+#endif
 				demux[i].ECMpids[j].tries = 1;
 				demux[i].ECMpids[j].table = 0;
 				dvbapi_set_section_filter(i, er, -1);
@@ -4484,22 +5329,35 @@
 			}
 			else  // all not found responses exception: first timeout response and first fatal loadbalancer response
 			{
+				MYDVB_TRACE("mydvb:    ecm.cw %s failure{%d,%d, %02X}\n",
+						(demux[i].rdr) ? demux[i].rdr->label : "UNK",
+						 er->rc, er->rcEx,
+						 demux[i].ECMpids[j].tries);
 				demux[i].ECMpids[j].CHID = 0x10000; // get rid of this prio chid since it failed!
-				demux[i].ECMpids[j].tries = 0xFE; // reset timeout retry
+				demux[i].ECMpids[j].tries = 0xfe; 	 // reset timeout retry
 			}
 
 			if(caid_is_irdeto(er->caid))
 			{
-				if(demux[i].ECMpids[j].irdeto_curindex == 0xFE) { demux[i].ECMpids[j].irdeto_curindex = 0x00; }  // init irdeto current index to first one
+				if (demux[i].ECMpids[j].irdeto_curindex == 0xfe) { demux[i].ECMpids[j].irdeto_curindex = 0x00; }  // init irdeto current index to first one
 				if(!(demux[i].ECMpids[j].irdeto_curindex + 1 > demux[i].ECMpids[j].irdeto_maxindex))  // check for last / max chid
 				{
 					cs_log_dbg(D_DVBAPI, "Demuxer %d trying next irdeto chid of PID %d CAID %04X PROVID %06X ECMPID %04X VPID %04X", i,
 								  j, er->caid, er->prid, er->pid, er->vpid);
 					demux[i].ECMpids[j].irdeto_curindex++; // irdeto index one up
 					demux[i].ECMpids[j].table = 0;
+					mycs_trace(D_ADB, "mydvb:    irdeto_curindex increase{%d}", demux[i].ECMpids[j].irdeto_curindex);
 					dvbapi_set_section_filter(i, er, -1);
 					continue;
 				}
+				// sky(a)
+				else if (++demux[i].ECMpids[j].irdeto_cycling < 3)
+				{
+					demux[i].ECMpids[j].irdeto_curindex = 0;
+					demux[i].ECMpids[j].table = 0;
+					mycs_trace(D_ADB, "mydvb:    irdeto_cycling increase{%d}", demux[i].ECMpids[j].irdeto_curindex);
+					continue;
+				}
 			}
 
 			dvbapi_edit_channel_cache(i, j, 0); // remove this pid from channelcache
@@ -4508,9 +5366,9 @@
 				demux[i].pidindex = -1; // current pid delivered a notfound so this pid isnt being used to descramble any longer-> clear pidindex
 			}
 			demux[i].ECMpids[j].irdeto_maxindex = 0;
-			demux[i].ECMpids[j].irdeto_curindex = 0xFE;
-			demux[i].ECMpids[j].tries = 0xFE; // reset timeout retry flag
-			demux[i].ECMpids[j].irdeto_cycle = 0xFE; // reset irdetocycle
+			demux[i].ECMpids[j].irdeto_curindex = 0xfe;
+			demux[i].ECMpids[j].irdeto_cycle 	= 0xfe; // reset irdetocycle
+			demux[i].ECMpids[j].tries 	 = 0xfe; // reset timeout retry flag
 			demux[i].ECMpids[j].table = 0;
 			demux[i].ECMpids[j].checked = 4; // flag ecmpid as checked
 			demux[i].ECMpids[j].status = -1; // flag ecmpid as unusable
@@ -4526,6 +5384,7 @@
 					int32_t fd = demux[i].demux_fd[filternum].fd;
 					if(fd > 0)  // in case valid fd
 					{
+						mycs_trace(D_ADB, "mydvb:    ecm filternum{%d}", filternum);
 						dvbapi_stop_filternum(i, filternum); // stop ecmfilter
 						found = 1;
 					}
@@ -4538,26 +5397,58 @@
 						int32_t fd = demux[i].demux_fd[filternum].fd;
 						if(fd > 0)  // in case valid fd
 						{
+							mycs_trace(D_ADB, "mydvb:    irdeto emm filternum{%d}", filternum);
 							dvbapi_stop_filternum(i, filternum); // stop emmfilter
 							found = 1;
 						}
 					}
 				}
 			}
-
+		//	emux[i].ECMpids[j].CHID = 0x10000; // get rid of this prio chid since it obvious failed!
+		//	if (cfg.dvbapi_requestmode == 0) dvbapi_try_next_caid(i, 0, 0); // in case of requestmode 0 start descrambling of next ecmpid
 			continue;
 		}
 
 
 		// below this should be only run in case of ecm answer is found
-
+#if defined(MODULE_XCAMD)
+		if (er->ecm_bypass)
+		{
+			MYDVB_TRACE("mydvb:    ecm_bypass{%d,%d}\n", demux[i].curindex, demux[i].cs_soleMatch);
+			if ((IS_IRDETO(er->caid)) &&
+				 (demux[i].cs_soleMatch) &&
+				 (demux[i].ECMpids[j].iks_irdeto_chid < 0x10000))
+			{
+				demux[i].ECMpids[j].CHID = demux[i].ECMpids[j].iks_irdeto_chid;
+				MYDVB_TRACE("mydvb:    csxir_cw?{%02X.%04X}\n", demux[i].ECMpids[j].iks_irdeto_pi, demux[i].ECMpids[j].iks_irdeto_chid);
+				if (nocw_write) continue;
+			}
+		}
+		else
+#endif
+		{
 		uint32_t chid = get_subid(er); // derive current chid in case of irdeto, or a unique part of ecm on other cas systems
+
+#if defined(MODULE_XCAMD)
+			if ((IS_IRDETO(er->caid)) &&
+				 (er->ecm_cssolo) &&
+				 (demux[i].ECMpids[j].iks_irdeto_chid < 0x10000))
+			{
+				demux[i].ECMpids[j].CHID = demux[i].ECMpids[j].iks_irdeto_chid;
+				MYDVB_TRACE("mydvb:    csxir_cw?{%02X.%04X:%04X}\n", demux[i].ECMpids[j].iks_irdeto_pi, demux[i].ECMpids[j].iks_irdeto_chid, demux[i].ECMpids[j].CHID);
+			}
+			else
+#endif
+			{
 		demux[i].ECMpids[j].CHID = (chid != 0 ? chid : 0x10000); // if not zero apply, otherwise use no chid value 0x10000
+			}
 		dvbapi_edit_channel_cache(i, j, 1); // do it here to here after the right CHID is registered
-
-		//dvbapi_set_section_filter(i, er);  is not needed anymore (unsure)
-		demux[i].ECMpids[j].tries = 0xFE; // reset timeout retry flag
-		demux[i].ECMpids[j].irdeto_cycle = 0xFE; // reset irdeto cycle
+		// sky()
+		// is not needed anymore (unsure)
+		//	dvbapi_set_section_filter(i, er);
+			demux[i].ECMpids[j].tries = 0xfe; // reset timeout retry flag
+			demux[i].ECMpids[j].irdeto_cycle = 0xfe; // reset irdeto cycle
+			MYDVB_TRACE("mydvb:    write_cw(%d.%d) {%d,%04X.%04X}\n", j, nocw_write, demux[i].curindex, chid, demux[i].ECMpids[j].CHID);
 
 		if(nocw_write || demux[i].pidindex != j) { continue; }  // cw was already written by another filter or current pid isnt pid used to descramble so it ends here!
 
@@ -4572,6 +5463,7 @@
 		}
 
 		delayer(er);
+		}
 
 		switch(selected_api)
 		{
@@ -4581,13 +5473,32 @@
 			break;
 #endif
 		default:
-			dvbapi_write_cw(i, er->cw, j);
+				dvbapi_write_cw(i, er->cw, &er->cwEx, j, er->cwdesalgo);
 			break;
 		}
 
 		// reset idle-Time
 		client->last = time((time_t *)0); // ********* TO BE FIXED LATER ON ******
+#if defined(MODULE_XCAMD)
+		if (demux[i].cs_soleMatch)
+		{
+			int16_t current = demux[i].curindex;
+			int16_t iksidx  = demux[i].cs_cwidx;
+			if (iksidx != -1 && current != iksidx) {
+				MYDVB_TRACE("mydvb:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx TRY{%d,%d}\n", current, iksidx);
+				dvbapi_stop_filter(i, TYPE_ECM);
+				dvbapi_try_goto_caid(i, 0, iksidx); // start descrambling of direct ecmpid
+				return;
+			}
+		}
+#endif
 
+#if defined(WITH_HISILICON)
+		//
+		// UNAVAILABLE...
+		//
+#else
+	#ifdef WITH_DEBUG
 		FILE *ecmtxt = NULL;
 		if (cfg.dvbapi_listenport && client_proto_version >= 2)
 			dvbapi_net_send(DVBAPI_ECM_INFO, demux[i].socket_fd, i, 0, NULL, client, er);
@@ -4640,8 +5551,10 @@
 			if(ret < 0) { cs_log("ERROR: Could not close ecmtxt fd (errno=%d %s)", errno, strerror(errno)); }
 			ecmtxt = NULL;
 		}
-
+	#endif
+#endif	// defined(WITH_HISILICON)
 	}
+
 	if(handled == 0)
 	{
 		cs_log_dbg(D_DVBAPI, "Unhandled ECM response received for CAID %04X PROVID %06X ECMPID %04X CHID %04X VPID %04X",
@@ -4650,7 +5563,7 @@
 
 }
 
-void *dvbapi_start_handler(struct s_client *cl, uchar *UNUSED(mbuf), int32_t module_idx, void * (*_main_func)(void *))
+static void *dvbapi_handler(struct s_client *cl, uchar* UNUSED(mbuf), int32_t module_idx)
 {
 	// cs_log("dvbapi loaded fd=%d", idx);
 	if(cfg.dvbapi_enabled == 1)
@@ -4658,33 +5571,29 @@
 		cl = create_client(get_null_ip());
 		cl->module_idx = module_idx;
 		cl->typ = 'c';
-		int32_t ret = pthread_create(&cl->thread, NULL, _main_func, (void *) cl);
-		if(ret)
-		{
+		int32_t ret = pthread_create(&cl->thread, NULL, dvbapi_main_local, (void *) cl);
+		if (ret) {
 			cs_log("ERROR: Can't create dvbapi handler thread (errno=%d %s)", ret, strerror(ret));
 			return NULL;
 		}
-		else
-			{ pthread_detach(cl->thread); }
+		else {
+			pthread_detach(cl->thread);
 	}
-
-	return NULL;
 }
 
-void *dvbapi_handler(struct s_client *cl, uchar *mbuf, int32_t module_idx)
-{
-	return dvbapi_start_handler(cl, mbuf, module_idx, dvbapi_main_local);
+	return NULL;
 }
 
 int32_t dvbapi_set_section_filter(int32_t demux_index, ECM_REQUEST *er, int32_t n)
 {
-	if(!er) { return -1; }
-
-	if(selected_api != DVBAPI_3 && selected_api != DVBAPI_1 && selected_api != STAPI)   // only valid for dvbapi3, dvbapi1 and STAPI
-	{
+//	if (cfg.dvbapi_requestmode == 1) return 0; // no support for requestmode 1
+// sky(a)
+	if (selected_api == HISILICONAPI) return 0;
+	if (selected_api != DVBAPI_3 && selected_api != DVBAPI_1 && selected_api != STAPI) { // only valid for dvbapi3 && dvbapi1
 		return 0;
 	}
-	
+	if (!er) return -1;
+	mycs_trace(D_ADB, "mydvb:dvbapi_set_section_filter{%04X:%08X: %04x}(%d)", er->caid, er->prid, er->pid, er->rc);
 	if(n == -1)
 	{
 		n = dvbapi_get_filternum(demux_index, er, TYPE_ECM);
@@ -4696,42 +5605,39 @@
 	if(fd < 1) { return -1 ; }  // in case no valid fd
 
 	uchar filter[16];
-	uchar mask[16];
+	uchar fimask[16];
 	memset(filter, 0, 16);
-	memset(mask, 0, 16);
+	memset(fimask,0,16);
 
-	struct s_ecmpids *curpid = NULL;
-	int32_t pid = demux[demux_index].demux_fd[n].pidindex;
-	if(pid != -1)
-	{
-		curpid = &demux[demux_index].ECMpids[pid];
-	}
-	if(curpid->table != er->ecm[0] && curpid->table != 0) { return -1; }  // if current ecmtype differs from latest requested ecmtype do not apply section filtering!
+	struct s_ecmpids *curpids = NULL;
+	int32_t pidx = demux[demux_index].demux_fd[n].pidindex;
+	if (pidx == -1) { return -1 ; }
+	curpids = &demux[demux_index].ECMpids[pidx];
+	if (curpids->table != er->ecm[0] && curpids->table != 0) return -1; // if current ecmtype differs from latest requested ecmtype do not apply section filtering!
 	uint8_t ecmfilter = 0;
 
-	if(er->ecm[0] == 0x80) { ecmfilter = 0x81; }  // current processed ecm is even, next will be filtered for odd
-	else { ecmfilter = 0x80; } // current processed ecm is odd, next will be filtered for even
+	if (er->ecm[0]==0x80) ecmfilter = 0x81; // current processed ecm is even, next will be filtered for odd
+	else ecmfilter = 0x80; // current processed ecm is odd, next will be filtered for even
 
-	if(curpid->table != 0)   // cycle ecmtype from odd to even or even to odd
-	{
+	if (curpids->table != 0) { // cycle ecmtype from odd to even or even to odd
 		filter[0] = ecmfilter; // only accept new ecms (if previous odd, filter for even and visaversa)
-		mask[0] = 0xFF;
+		fimask[0] = 0xFF;
 		cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d set ecmtable to %s (CAID %04X PROVID %06X FD %d)", demux_index, n + 1,
-					  (ecmfilter == 0x80 ? "EVEN" : "ODD"), curpid->CAID, curpid->PROVID, fd);
+				(ecmfilter == 0x80?"EVEN":"ODD"), curpids->CAID, curpids->PROVID, fd);
 	}
-	else  // not decoding right now so we are interessted in all ecmtypes!
-	{
+	else { // not decoding right now so we are interessted in all ecmtypes!
 		filter[0] = 0x80; // set filter to wait for any ecms
-		mask[0] = 0xF0;
+		fimask[0] = 0xF0;
 		cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d set ecmtable to ODD+EVEN (CAID %04X PROVID %06X FD %d)", demux_index, n + 1,
-					  curpid->CAID, curpid->PROVID, fd);
+				curpids->CAID, curpids->PROVID, fd);
 	}
-	uint32_t offset = 0, extramask = 0xFF;
+	uint32_t offset = 0;
+	uint32_t extramask = 0xFF;
 
-	struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_index, pid, 'p');
-	//cs_log("**** curpid->CHID %04X, checked = %d, er->chid = %04X *****", curpid->CHID, curpid->checked, er->chid);
+	struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_index, pidx, 'p');
+//	cs_log("**** curpids->CHID %04X, checked = %d, er->chid = %04X *****", curpids->CHID, curpids->checked, er->chid);
 	// checked 4 to make sure we dont set chid filter and no such ecm in dvbstream except for forced pids!
-	if(curpid->CHID < 0x10000 && (curpid->checked == 4 || (forceentry && forceentry->force)))
+	if (curpids->CHID < 0x10000 && (curpids->checked==4 || (forceentry && forceentry->force)))
 	{
 
 		switch(er->caid >> 8)
@@ -4757,26 +5663,26 @@
 	}
 
 	int32_t irdetomatch = 1; // check if wanted irdeto index is the one the delivers current chid!
-	if(caid_is_irdeto(curpid->CAID))
+	if (caid_is_irdeto(curpids->CAID))
 	{
-		if(curpid->irdeto_curindex == er->ecm[4]) { irdetomatch = 1; }  // ok apply chid filtering
-		else { irdetomatch = 0; } // skip chid filtering but apply irdeto index filtering
+		if (curpids->irdeto_curindex == er->ecm[4]) irdetomatch = 1; // ok apply chid filtering
+		else irdetomatch = 0; // skip chid filtering but apply irdeto index filtering
 	}
 
 	if(offset && irdetomatch)  // we have a cas with chid or unique part in checked ecm
 	{
-		i2b_buf(2, curpid->CHID, filter + (offset - 2));
-		mask[(offset - 2)] = 0xFF&extramask; // additional mask seca2 chid can be FC10 or FD10 varies each month so only apply F?10
-		mask[(offset - 1)] = 0xFF;
-		cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d set chid to %04X on fd %d", demux_index, n + 1, curpid->CHID, fd);
+		i2b_buf(2, curpids->CHID, filter + (offset-2));
+		fimask[(offset - 2)] = 0xFF&extramask; // additional mask seca2 chid can be FC10 or FD10 varies each month so only apply F?10
+		fimask[(offset - 1)] = 0xFF;
+		cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d set chid to %04X on fd %d", demux_index, n + 1, curpids->CHID, fd);
 	}
 	else
 	{
-		if(caid_is_irdeto(curpid->CAID) && (curpid->irdeto_curindex < 0xFE))  // on irdeto we can always apply irdeto index filtering!
+		if (caid_is_irdeto(curpids->CAID) && (curpids->irdeto_curindex < 0xfe)) // on irdeto we can always apply irdeto index filtering!
 		{
-			filter[2] = curpid->irdeto_curindex;
-			mask[2] = 0xFF;
-			cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d set irdetoindex to %d on fd %d", demux_index, n + 1, curpid->irdeto_curindex, fd);
+			filter[2] = curpids->irdeto_curindex;
+			fimask[2] = 0xFF;
+			cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d set irdetoindex to %d on fd %d", demux_index, n + 1, curpids->irdeto_curindex, fd);
 		}
 		else  // all other cas systems also cas systems without chid or unique ecm part
 		{
@@ -4784,7 +5690,7 @@
 		}
 	}
 
-	int32_t ret = dvbapi_activate_section_filter(demux_index, n, fd, curpid->ECM_PID, filter, mask);
+	int32_t ret = dvbapi_activate_section_filter(demux_index, n, fd, curpids->ECM_PID, filter, fimask);
 	if(ret < 0)   // something went wrong setting filter!
 	{
 		cs_log("Demuxer %d Filter %d (fd %d) error setting section filtering -> stop filter!", demux_index, n + 1, fd);
@@ -4797,7 +5703,7 @@
 		}
 		return -1;
 	}
-	return n;
+	return (n);
 }
 
 int32_t dvbapi_activate_section_filter(int32_t demux_index, int32_t num, int32_t fd, int32_t pid, uchar *filter, uchar *mask)
@@ -4818,13 +5723,13 @@
 		{
 			//DeepThought: on dgs/cubestation and neumo images, perhaps others
 			//the following code is needed to descramble
-			sFP2.filter.filter[0] = filter[0];
+				sFP2.filter.filt[0]=filter[0];
 			sFP2.filter.mask[0] = mask[0];
-			sFP2.filter.filter[1] = 0;
+				sFP2.filter.filt[1]=0;
 			sFP2.filter.mask[1] = 0;
-			sFP2.filter.filter[2] = 0;
+				sFP2.filter.filt[2]=0;
 			sFP2.filter.mask[2] = 0;
-			memcpy(sFP2.filter.filter + 3, filter + 1, 16 - 3);
+				memcpy(sFP2.filter.filt+3,filter+1,16-3);
 			memcpy(sFP2.filter.mask + 3, mask + 1, 16 - 3);
 			//DeepThought: in the drivers of the dgs/cubestation and neumo images,
 			//dvbapi 1 and 3 are somehow mixed. In the kernel drivers, the DMX_SET_FILTER
@@ -4838,7 +5743,7 @@
 		}
 		else
 		{
-			memcpy(sFP2.filter.filter, filter, 16);
+				memcpy(sFP2.filter.filt,filter,16);
 			memcpy(sFP2.filter.mask, mask, 16);
 			if (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
 				ret = dvbapi_net_send(DVBAPI_DMX_SET_FILTER, demux[demux_index].socket_fd, demux_index, num, (unsigned char *) &sFP2, NULL, NULL);
@@ -4855,7 +5760,7 @@
 		sFP1.pid = pid;
 		sFP1.timeout = 0;
 		sFP1.flags = DMX_IMMEDIATE_START;
-		memcpy(sFP1.filter.filter, filter, 16);
+		    memcpy(sFP1.filter.filt,filter,16);
 		memcpy(sFP1.filter.mask, mask, 16);
 		ret = dvbapi_ioctl(fd, DMX_SET_FILTER1, &sFP1);
 		break;
@@ -4867,13 +5772,18 @@
 		break;
 	}
 #endif
-	/*#ifdef WITH_COOLAPI    ******* NOT IMPLEMENTED YET ********
+/*
+#ifdef WITH_COOLAPI ******* NOT IMPLEMENTED YET ********
 	        case COOLAPI: {
 	            coolapi_set_filter(demux[demux_id].demux_fd[n].fd, n, pid, filter, mask, TYPE_ECM);
 	            break;
 	        }
 	#endif
 	*/
+#ifdef WITH_HISILICON
+		case HISILICONAPI:
+			break;
+#endif
 	default:
 		break;
 	}
@@ -4884,19 +5794,29 @@
 int32_t dvbapi_check_ecm_delayed_delivery(int32_t demux_index, ECM_REQUEST *er)
 {
 	char nullcw[CS_ECMSTORESIZE];
+
 	memset(nullcw, 0, CS_ECMSTORESIZE);
-	if(memcmp(er->cw, nullcw, 8) == 0 && memcmp(er->cw+8, nullcw, 8) == 0) {return 5;} // received a null cw -> not usable!
+	if (memcmp(er->cw, nullcw, 8) == 0 && memcmp(er->cw+8, nullcw, 8) == 0) return 5; // received a null cw -> not usable!
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (demux[demux_index].constcw_fbiss) return 9;
+	if (caid_is_biss(er->caid)) return 9;
+	if (er->ecm_bypass) { return 0; }
+#endif
 	int32_t filternum = dvbapi_get_filternum(demux_index, er, TYPE_ECM);
-	if(filternum < 0) { return 2; }  // if no matching filter act like ecm response is delayed
-	struct s_ecmpids *curpid = NULL;
-	int32_t pid = demux[demux_index].demux_fd[filternum].pidindex;
-	if(pid !=-1)
+	if (filternum < 0) {
+		MYDVB_TRACE("mydvb:    unk.filter(?%d)\n", filternum);
+		return 2; // if no matching filter act like ecm response is delayed
+	}
+
+	struct s_ecmpids *curpids = NULL;
+	int32_t pidx = demux[demux_index].demux_fd[filternum].pidindex;
+	if(pidx != -1)
 	{
-		curpid = &demux[demux_index].ECMpids[pid];
-		if(curpid->table == 0) { return 3; }  // on change table act like ecm response is found
+		curpids = &demux[demux_index].ECMpids[pidx];
+		if (curpids->table == 0) return 3; // on change table act like ecm response is found
 	}
 	
-	if(er->rc == E_CACHEEX) { return 4; }  // on cache-ex response act like ecm response is found
+	if (er->rc == E_CACHEEX) return 4; // on cache-ex response act like ecm response is found
 	
 	if(memcmp(demux[demux_index].demux_fd[filternum].ecmd5, nullcw, CS_ECMSTORESIZE))
 	{
@@ -4905,12 +5825,12 @@
 		cs_log_dbg(D_DVBAPI, "Demuxer %d requested controlword for ecm %s on fd %d", demux_index, ecmd5, demux[demux_index].demux_fd[filternum].fd);
 		return memcmp(demux[demux_index].demux_fd[filternum].ecmd5, er->ecmd5, CS_ECMSTORESIZE); // 1 = no response on the ecm we request last for this fd!
 	}
-	else { return 0; }
+	else return 0;
 }
 
 int32_t dvbapi_get_filternum(int32_t demux_index, ECM_REQUEST *er, int32_t type)
 {
-	if(!er) { return -1; }
+	if (!er) return -2;
 
 	int32_t n;
 	int32_t fd = -1;
@@ -4929,29 +5849,29 @@
 			}
 		}
 	}
-	if(fd > 0 && demux[demux_index].demux_fd[n].provid == 0) { demux[demux_index].demux_fd[n].provid = er->prid; }  // hack to fill in provid into demuxer
+	if (fd > 0 && demux[demux_index].demux_fd[n].provid == 0) demux[demux_index].demux_fd[n].provid = er->prid; // hack to fill in provid into demuxer
 
 	return (fd > 0 ? n : fd); // return -1(fd) on not found, on found return filternumber(n)
 }
 
-int32_t dvbapi_ca_setpid(int32_t demux_index, int32_t pid)
+int32_t dvbapi_ca_setpid(int32_t demux_index, int32_t pidk)
 {
 	int32_t idx = -1, n;
-	if(pid == -1 || pid > demux[demux_index].ECMpidcount) return -1;
+	if (pidk == -1 || pidk > demux[demux_index].ECMpidcount) return -1;
 	
-	idx = demux[demux_index].ECMpids[pid].index;
+	idx = demux[demux_index].ECMpids[pidk].index;
 
 	if(!idx)   // if no indexer for this pid get one!
 	{
 		idx = dvbapi_get_descindex(demux_index);
-		demux[demux_index].ECMpids[pid].index = idx;
-		cs_log_dbg(D_DVBAPI, "Demuxer %d PID: %d CAID: %04X ECMPID: %04X is using index %d", demux_index, pid,
-					  demux[demux_index].ECMpids[pid].CAID, demux[demux_index].ECMpids[pid].ECM_PID, idx - 1);
+		demux[demux_index].ECMpids[pidk].index= idx;
+		cs_log_dbg(D_DVBAPI,"Demuxer %d PID: %d CAID: %04X ECMPID: %04X is using index %d", demux_index, pidk,
+			demux[demux_index].ECMpids[pidk].CAID, demux[demux_index].ECMpids[pidk].ECM_PID, idx-1);
 	}
 
 	for(n = 0; n < demux[demux_index].STREAMpidcount; n++)
 	{
-		if(!demux[demux_index].ECMpids[pid].streams || ((demux[demux_index].ECMpids[pid].streams & (1 << n)) == (uint) (1 << n))){
+		if (!demux[demux_index].ECMpids[pidk].streams || (demux[demux_index].ECMpids[pidk].streams & (1 << n))) {
 			dvbapi_set_pid(demux_index, n, idx - 1, true); // enable streampid
 		}
 		else{
@@ -5151,7 +6071,7 @@
 		return;
 	}
 
-	if(demux[demux_index].emm_filter < demux[demux_index].max_emm_filter) // can this filter be started?
+	if (demux[demux_index].emm_filter < demux[demux_index].max_emmfilters) // can this filter be started? if not add to list of inactive emmfilters
 	{
 		// try to activate this emmfilter
 		ret = dvbapi_set_filter(demux_index, selected_api, demux[demux_index].EMMpids[l].PID, demux[demux_index].EMMpids[l].CAID,
@@ -5190,9 +6110,9 @@
 
 	uint32_t filter_count = ll_count(ll_emm_active_filter) + ll_count(ll_emm_inactive_filter);
 
-	if(demux[demux_id].max_emm_filter > 0
+	if (demux[demux_id].max_emmfilters > 0
 			&& ll_count(ll_emm_inactive_filter) > 0
-			&& filter_count > demux[demux_id].max_emm_filter)
+			&& filter_count > demux[demux_id].max_emmfilters)
 	{
 
 		int32_t filter_queue = ll_count(ll_emm_inactive_filter);
@@ -5261,12 +6181,285 @@
 	return client_proto_version;
 }
 
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#if defined(MODULE_CONSTCW) || defined(MODULE_XCAS) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+void DVBICS_ChSettings(int32_t demux_id, int chstages)
+{
+	mycs_debug(D_ADB, "myics:requests{%d}...", chstages);
+}
+
+void DVBICS_ChCloser(int32_t demux_id)
+{
+	mycs_debug(D_ADB, "myics:closer...");
+	#if defined(MODULE_XCAS)
+		CSREADER_ChCloser(demux_id, &demux[demux_id], R_XCAS);
+	#endif
+	#if defined(MODULE_CONSTCW)
+		CSREADER_ChCloser(demux_id, &demux[demux_id], R_CONSTCW);
+	#endif
+}
+
+bool DVBICS_ChRetuning(int32_t demux_id, int32_t typ)
+{
+	bool bRetune = 0;
+
+	if (demux[demux_id].curindex < 0)
+	{
+		MYDVB_TRACE("mydvb:rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr TRY\n");
+		mycs_debug(D_ADB, "mycsdvb:cwRetune{%02X}", typ);
+		dvbapi_try_next_caid(demux_id, 0, 1);
+		bRetune = 2;
+	}
+	else
+	{
+		mycs_debug(D_ADB, "mycsdvb:cwRetuning{%02X}", typ);
+		bRetune = CSREADER_ChRetuning(demux_id, &demux[demux_id], typ);
+	}
+	return (bRetune);
+}
+
+void DVBICS_ChDescrambled(int32_t demux_id, int descramble)
+{
+	#if defined(MODULE_XCAS)
+		CSREADER_ChDescrambled(R_XCAS, descramble);
+	#endif
+	#if defined(MODULE_CONSTCW)
+		CSREADER_ChDescrambled(R_CONSTCW, descramble);
+	#endif
+}
+
+
+int32_t DVBICS_ChkEcmReaders(int32_t demux_index)
+{
+	struct s_reader *rdr;
+	ECM_REQUEST ere;
+	int32_t n;
+	int32_t othersfound = 0;
+	int32_t xcamfound = 0;
+
+	for (n = 0; n < demux[demux_index].ECMpidcount; n++)
+	{
+		ere.dmuxid = demux_index;// sky(powervu)
+		ere.caid   = ere.ocaid = demux[demux_index].ECMpids[n].CAID;
+		ere.prid   = demux[demux_index].ECMpids[n].PROVID;
+		ere.pid    = demux[demux_index].ECMpids[n].ECM_PID;
+		ere.srvid  = demux[demux_index].program_number;
+		ere.onid   = demux[demux_index].onid;
+#if defined(MODULE_AVAMGCAMD)
+		ere.exprid = ere.prid;
+		if (IS_IRDETO(ere.caid)) {
+			ere.exprid = (((ere.onid>>8)&0xff) ^ ((ere.onid)&0xff));
+		}
+#endif
+		ere.client = cur_client();
+		for (rdr=first_active_reader; rdr; rdr=rdr->next)
+		{
+			if (matching_reader(&ere, rdr, -1))
+			{
+				if (IS_ICS_READERS(rdr))
+				{
+					xcamfound++;
+				}
+				else othersfound++;
+			}
+		}
+	}
+
+	if (!othersfound && xcamfound) {
+		mycs_trace(D_ADB, "mydvb:cs_soleMatch");
+		demux[demux_index].cs_soleMatch = 1;
+		return 1;
+	}
+	return 0;
+}
+
+
+int32_t
+DVBICS_ChkEcmPids(int32_t demux_id, uint16_t srvid, uint16_t casid, uint32_t prid)
+{
+	int32_t n;
+
+	if (!casid) return 0;
+	if (demux[demux_id].program_number != srvid) return 0;
+	for (n=0; n<demux[demux_id].ECMpidcount; n++)
+	{
+		struct s_ecmpids *epids = &(demux[demux_id].ECMpids[n]);
+		if (epids->CAID == casid && epids->PROVID == prid)
+		{
+			demux[demux_id].cs_cwidx = n;
+			demux[demux_id].cs_ecmRequisite = n;
+			mycs_trace(D_ADB, "mydvb:--- ch.epid{%d.%04X}", n, epids->ECM_PID);
+			return 1;
+		}
+	}
+	return 0;
+}
+#endif	// defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+
+
+#if defined(__DVCCRC_AVAILABLE__)
+bool
+DVBCRC_Addon(struct s_ecmpids *curpids, uint8_t *ecm, uint16_t ecmlen, uint32_t *crcval)
+{
+	uint32_t chid = 0x10000;
+	uint8_t  ixpi = 0xfe;
+	uint32_t	crcv;
+	int32_t  i, bAdded = 1;
+
+	if (!curpids) return 0;
+	if ((crcv = crc32(0L, ecm, ecmlen))==0) return 0;
+	for (i=0; i<MAX_CSCRC_CACHES; i++) {
+		if (curpids->cc.ctab[i].crc == crcv) bAdded = 0;
+	}
+
+	chid = get_ecm_subid(ecm, curpids->CAID);
+	ixpi = (IS_IRDETO(curpids->CAID)) ? ecm[4] : 0xfe;
+	curpids->cc.current = (curpids->cc.current+1) % MAX_CSCRC_CACHES;
+	curpids->cc.ctab[curpids->cc.current].chid = chid;
+	curpids->cc.ctab[curpids->cc.current].pi   = ixpi;
+	curpids->cc.ctab[curpids->cc.current].crc  = crcv;
+//	curpids->cc.rto = time(NULL);
+//	MYDVB_TRACE("mydvb:    crc{%02X,%04X}{%08X}\n", ixpi, chid, crcv);
+	if (curpids->tableid && curpids->tableid != ecm[0]) {
+		if (!curpids->cc.cwjustice) curpids->cc.cwjustice = 1;
+	}
+#if defined(MODULE_XCAMD)
+	if (curpids->cc.cwcrc == crcv)	{
+		if (IS_IRDETO(curpids->CAID))	{
+			if (curpids->cc.cwjustice != 2) {
+				curpids->cc.cwjustice   = 2;
+				curpids->iks_irdeto_pi   = ixpi;
+				curpids->iks_irdeto_chid = chid;
+				curpids->irdeto_curindex = ixpi;
+//				MYDVB_TRACE("mydvb:--- crc.chkAdd{%02X,%04X}{%08X}\n", ixpi, chid, crcv);
+			}
+		}
+	}
+#endif
+	*crcval = crcv;
+	return (bAdded);
+}
+
+void
+DVBCRC_Clean(struct s_ecmpids *epids)
+{
+	int32_t i;
+
+	if (!epids) return;
+	epids->cc.cwcrc = 0;
+	epids->cc.current = 0;
+	epids->cc.cwjustice = 0;
+	for (i=0; i<MAX_CSCRC_CACHES; i++) {
+		epids->cc.ctab[i].chid = 0x10000;
+		epids->cc.ctab[i].pi   = 0xfe;
+		epids->cc.ctab[i].crc  = 0x0;
+	}
+//	epids->cc.rto = time(NULL);
+#if defined(MODULE_XCAMD)
+	epids->iks_irdeto_pi = 0xfe;
+	epids->iks_irdeto_chid = 0x10000;
+#endif
+}
+
+void
+DVBCRC_Remove(int32_t demux_id, int32_t ecmpid)
+{
+	struct s_ecmpids *epids;
+	int32_t n;
+
+	for (n=0; n<demux[demux_id].ECMpidcount; n++) {
+		epids = &demux[demux_id].ECMpids[n];
+		if (ecmpid == 0x0)
+		{
+			DVBCRC_Clean(epids);
+		}
+		else
+		if (epids->ECM_PID == ecmpid) {
+			DVBCRC_Clean(epids);
+			break;
+		}
+	}
+}
+
+
+int32_t
+DVBCRC_ChkMatched(struct s_reader *rdr, int32_t demux_id, uint16_t casid, uint32_t prid, uint32_t ecmcrc)
+{
+	struct s_ecmpids *epids;
+	int32_t  ccidx, ccfound = 0;
+	int32_t  n, i;
+
+	// CHINASAT Channel
+	if (ecmcrc == 0) return -2;
+	if (ecmcrc == (uint32_t)-1) return -1;
+	if (demux[demux_id].curindex == -1) return -1;
+
+	for (n=0; n<demux[demux_id].ECMpidcount; n++)
+	{
+		epids = &(demux[demux_id].ECMpids[n]);
+
+		if (epids->CAID == casid && epids->PROVID == prid)
+		{
+			epids->cc.cwcrc = ecmcrc;
+			for (i=epids->cc.current; !ccfound && i>=0; i--)
+			{
+			//	MYDVB_TRACE("mydvb:CRC{%2d:%04X.%08X}\n", n, ecmcrc, epids->cc.ctab[i].crc);
+				if (epids->cc.ctab[i].crc == ecmcrc) {
+					ccidx = i;
+					ccfound = 1;
+					break;
+				}
+			}
+			for (i=(MAX_CSCRC_CACHES-1); !ccfound && i>epids->cc.current; i--)
+			{
+			//	MYDVB_TRACE("mydvb:CRC{%2d:%04X.%08X}\n", n, ecmcrc, epids->cc.ctab[i].crc);
+				if (epids->cc.ctab[i].crc == ecmcrc) {
+					ccidx = i;
+					ccfound = 1;
+					break;
+				}
+			}
+			if (ccfound)
+			{
+#if defined(MODULE_XCAMD)
+				if (IS_IRDETO(epids->CAID)) {
+					uint32_t chid = epids->cc.ctab[ccidx].chid;
+					uint8_t  ixpi = epids->cc.ctab[ccidx].pi;
+					epids->iks_irdeto_pi   = ixpi;
+					epids->iks_irdeto_chid = chid;
+					epids->irdeto_curindex = ixpi;
+					MYDVB_TRACE("mydvb:--- crc.irdeto{%d:%02X.%04X}{%08X}\n", n, ixpi, chid, ecmcrc);
+				}
+#endif // defined(MODULE_XCAMD)
+				epids->cc.cwjustice = 2;
+				if (ccidx==epids->cc.current) return 2;
+//				int32_t tdiff;
+//				time_t  now = time(0);
+//				tdiff = abs(now - epids->cc.rto);
+//				if (tdiff > 30) {
+//					MYDVB_TRACE("mydvb:--- crc.bygone...\n");
+//					return 0;
+//				}
+				return 1;
+			}
+			if (epids->cc.cwjustice == 0) return -1;
+//			if (casid == 0x09CD) return 99;
+			return 0;
+		}
+	}
+	return -1;
+}
+#endif // defined(__DVCCRC_AVAILABLE__)
+
 /*
  *  protocol structure
  */
 
 void module_dvbapi(struct s_module *ph)
 {
+	MYDVB_TRACE("module_dvbapi...\n");
 	ph->desc = "dvbapi";
 	ph->type = MOD_CONN_SERIAL;
 	ph->listenertype = LIS_DVBAPI;
@@ -5282,4 +6475,4 @@
 	ph->send_dcw = dvbapi_send_dcw;
 #endif
 }
-#endif // HAVE_DVBAPI
+#endif // HAVE_DVBAP
Index: module-dvbapi.h
===================================================================
--- module-dvbapi.h	(revision 10670)
+++ module-dvbapi.h	(working copy)
@@ -6,23 +6,36 @@
 
 #define TYPE_ECM 1
 #define TYPE_EMM 2
+#define TYPE_CAT 				3
+#define CAT_PID 				0x1
 
-//api
+// demux api
 #define DVBAPI_3    0
 #define DVBAPI_1    1
 #define STAPI       2
 #define COOLAPI     3
+#define HISILICONAPI			4
 
+#define PORT					9000
+
+#if defined(WITH_HISILICON)
+	#define TMPDIR				"/var/"
+	#define STANDBY_FILE		"/var/.pauseoscam"
+	#define ECMINFO_FILE		"/var/ecm.info"
+#else
 #define TMPDIR  "/tmp/"
 #define STANDBY_FILE    "/tmp/.pauseoscam"
 #define ECMINFO_FILE    "/tmp/ecm.info"
+#endif
 
 #define MAX_DEMUX 16
 #define MAX_CAID 50
 #define ECM_PIDS 30
+#define EMM_PIDS 				30
 #define MAX_FILTER 24
 
-#define BOX_COUNT 6
+// WITH_HISILICON)
+#define BOX_COUNT 			7
 
 #define BOXTYPE_DREAMBOX    1
 #define BOXTYPE_DUCKBOX 2
@@ -35,9 +48,12 @@
 #define BOXTYPE_COOLSTREAM  9
 #define BOXTYPE_NEUMO   10
 #define BOXTYPE_PC      11
-#define BOXTYPE_PC_NODMX    12
-#define BOXTYPES        12
-#define DMXMD5HASHSIZE  16  // use MD5() 
+// WITH_HISILICON)
+//	\C7\F6\C0\E7 CAPMT\B4\C2 BOXTYPE_PC\B7\CE \C1\ED\C0\D6\C0\BD.
+#define BOXTYPE_HISILICON	12	// = BOXTYPE_PC
+#define BOXTYPE_PC_NODMX 	13
+#define BOXTYPES				13
+
 #define REMOVED_STREAMPID_INDEX 1
 #define REMOVED_STREAMPID_LASTINDEX 2
 #define REMOVED_DECODING_STREAMPID_INDEX 3
@@ -49,7 +65,7 @@
 #define DUMMY_FD    0xFFFF
 
 //constants used int socket communication:
-#define DVBAPI_PROTOCOL_VERSION         2
+#define DVBAPI_PROTOCOL_VERSION         1
 
 #define DVBAPI_CA_SET_PID      0x40086f87
 #define DVBAPI_CA_SET_DESCR    0x40106f86
@@ -74,6 +90,31 @@
 	char *cam_socket_path;
 	int8_t api;
 };
+//
+//
+// sky(n)
+#if defined(MODULE_XCAMD)
+	#define __DVCCRC_AVAILABLE__
+#endif
+
+#if defined(__DVCCRC_AVAILABLE__)
+#define MAX_CSCRC_CACHES	32
+struct s_crctab
+{
+	uint32_t chid;
+	uint16_t	pi;
+	uint32_t crc;
+};
+
+struct s_crccaches
+{
+	int32_t 	cwjustice;
+	int32_t 	current;
+	uint32_t	cwcrc;
+	time_t	rto;	// last received
+	struct 	s_crctab	ctab[MAX_CSCRC_CACHES];
+};
+#endif
 
 struct s_ecmpids
 {
@@ -86,12 +127,25 @@
 	uint8_t irdeto_maxindex; // max irdeto indexes always fresh fetched from current ecm
 	uint8_t irdeto_curindex; // current irdeto index we want to handle
 	uint8_t irdeto_cycle; // temp var that holds the irdeto index we started with to detect if we cycled trough all indexes
+	uint32_t irdeto_cycling;	// sky(a)
+#if defined(MODULE_XCAMD)
+	uint32_t iks_irdeto_chid;	// sky(n.for xcamd)
+	uint8_t 	iks_irdeto_pi;
+#endif
+	int8_t   constcw;
 	int8_t checked;
 	int8_t status;
 	uint8_t tries;
-	unsigned char table;
+	uint8_t 	table;
+	uint8_t 	tableid;
 	int8_t index;
 	uint32_t streams;
+	// sky(dvn) /* tableid:0x50 */
+	uint32_t crcprevious;
+// sky(n)
+#if defined(__DVCCRC_AVAILABLE__)
+	struct s_crccaches cc;
+#endif
 };
 
 typedef struct filter_s
@@ -121,6 +175,14 @@
 
 #define PTINUM 10
 #define SLOTNUM 20
+#define DMXMD5HASHSIZE  	16  // use MD5()
+// sky(n)
+enum polarisation {
+	POLARISATION_HORIZONTAL     = 0x00,
+	POLARISATION_VERTICAL       = 0x01,
+	POLARISATION_CIRCULAR_LEFT  = 0x02,
+	POLARISATION_CIRCULAR_RIGHT = 0x03
+};
 
 typedef struct demux_s
 {
@@ -130,11 +192,11 @@
 	int8_t adapter_index;
 	int32_t socket_fd;
 	int8_t ECMpidcount;
+	int8_t   EMMpidcount;
 	struct timeb emmstart; // last time emm cat was started
 	struct s_ecmpids ECMpids[ECM_PIDS];
-	int8_t EMMpidcount;
-	struct s_emmpids EMMpids[ECM_PIDS];
-	uint16_t max_emm_filter;
+	struct s_emmpids EMMpids[EMM_PIDS];
+	uint16_t max_emmfilters;
 	int8_t STREAMpidcount;
 	uint16_t STREAMpids[ECM_PIDS];
 	int16_t pidindex;
@@ -144,8 +206,23 @@
 	uint16_t onid;
 	uint16_t tsid;
 	uint16_t pmtpid;
+
+	//	MODULE_XCAMD/MODULE_MORECAM
+	int16_t  cs_cwidx;
+	uint16_t cs_degree;
+	uint16_t cs_frequency;
+	uint16_t cs_symbolrate;
+	uint16_t cs_polarisation;
+	uint16_t cs_vidpid;
+	int16_t  cs_ecmRequisite;
+	uint16_t cs_soleMatch;
+	uint32_t cs_filtnum;
+	uint32_t cs_subsequence;
+	int16_t  constcw_fbiss;
+	uint32_t scrambled_counter;
+
 	uint32_t enigma_namespace;
-	unsigned char lastcw[2][8];
+	uint8_t 	lastcw[2][8];
 	int8_t emm_filter;
 	uchar hexserial[8];
 	struct s_reader *rdr;
@@ -202,7 +279,7 @@
 //dvbapi 1
 typedef struct dmxFilter
 {
-	uint8_t     filter[DMX_FILTER_SIZE];
+	uint8_t 	filt[DMX_FILTER_SIZE];
 	uint8_t     mask[DMX_FILTER_SIZE];
 } dmxFilter_t;
 
@@ -228,7 +305,7 @@
 //dbox2+ufs
 typedef struct dmx_filter
 {
-	uint8_t  filter[DMX_FILTER_SIZE];
+	uint8_t  filt	[DMX_FILTER_SIZE];
 	uint8_t  mask[DMX_FILTER_SIZE];
 	uint8_t  mode[DMX_FILTER_SIZE];
 } dmx_filter_t;
@@ -246,25 +323,53 @@
 #define DMX_KERNEL_CLIENT   0x8000
 };
 
-typedef struct ca_descr
-{
+typedef struct ca_descr {
 	uint32_t index;
 	uint32_t parity;    /* 0 == even, 1 == odd */
-	unsigned char cw[8];
+	uint8_t 	cw[8];
 } ca_descr_t;
 
-typedef struct ca_pid
-{
+typedef struct ca_pid {
 	uint32_t pid;
 	int32_t index;      /* -1 == disable*/
 } ca_pid_t;
 
+// sky(powervu)
+enum ca_descr_algo {
+	CA_ALGO_DVBCSA,
+	CA_ALGO_DES,
+	CA_ALGO_AES128,
+};
+enum ca_descr_cipher_mode {
+	CA_MODE_ECB,
+	CA_MODE_CBC,
+};
+#define CW_SINGLE	 	0
+#define CW_MULTIPLE	1
+#define MAX_EXAUDIO	4
+typedef struct ca_exdescr {
+	unsigned int  	index;
+	unsigned int  	parity;	/* 0 == even, 1 == odd */
+	unsigned int	type;
+	unsigned int	algo;
+	unsigned int	cipher;
+	unsigned char 	cw[8]; /* use video */
+	unsigned char	a0[8];
+	unsigned char	a1[8];
+	unsigned char	a2[8];
+	unsigned char	a3[8];
+	unsigned char	data[8];
+	unsigned char	vbi [8];
+} ca_exdescr_t;
+
 #define DMX_START       _IO('o', 41)
 #define DMX_STOP        _IO('o', 42)
 #define DMX_SET_FILTER  _IOW('o', 43, struct dmx_sct_filter_params)
 
 #define CA_SET_DESCR        _IOW('o', 134, ca_descr_t)
 #define CA_SET_PID      _IOW('o', 135, ca_pid_t)
+// sky(powervu)
+#define CA_SET_EXDESCR 	_IOW('o',140, ca_exdescr_t)
 // --------------------------------------------------------------------
 
 void dvbapi_stop_descrambling(int);
@@ -273,12 +378,15 @@
 int32_t dvbapi_open_device(int32_t, int32_t, int);
 int32_t dvbapi_stop_filternum(int32_t demux_index, int32_t num);
 int32_t dvbapi_stop_filter(int32_t demux_index, int32_t type);
-struct s_dvbapi_priority *dvbapi_check_prio_match(int32_t demux_id, int32_t pidindex, char type);
 void dvbapi_send_dcw(struct s_client *client, ECM_REQUEST *er);
-void dvbapi_write_cw(int32_t demux_id, uchar *cw, int32_t idx);
+void 		dvbapi_write_cw(int32_t demux_id, uchar *cw, CWEXTENTION *cwEx, int32_t idx, int cwdesalgo); // sky(powervu)
 int32_t dvbapi_parse_capmt(unsigned char *buffer, uint32_t length, int32_t connfd, char *pmtfile);
-void request_cw(struct s_client *client, ECM_REQUEST *er, int32_t demux_id, uint8_t delayed_ecm_check);
-void dvbapi_try_next_caid(int32_t demux_id, int8_t checked);
+void 		dvbapi_request_cw(struct s_client *client, ECM_REQUEST *er, int32_t demux_id, int32_t num, uint8_t delayed_ecm_check);
+void 		dvbapi_try_next_caid(int32_t demux_id, int8_t checked, int32_t atfirst);
+// sky(n,chknum)
+void 		dvbapi_try_goto_caid(int32_t demux_id, int8_t checked, int32_t chknum);
+void 		dvbapi_try_stop_caid(int32_t demux_id, int8_t checked);
+
 void dvbapi_read_priority(void);
 int32_t dvbapi_set_section_filter(int32_t demux_index, ECM_REQUEST *er, int32_t n);
 int32_t dvbapi_activate_section_filter(int32_t demux_index, int32_t num, int32_t fd, int32_t pid, uchar *filter, uchar *mask);
@@ -293,24 +402,35 @@
 const char *dvbapi_get_client_name(void);
 void rotate_emmfilter(int32_t demux_id);
 uint16_t dvbapi_get_client_proto_version(void);
-void delayer(ECM_REQUEST *er);
 void check_add_emmpid(int32_t demux_index, uchar *filter, int32_t l, int32_t emmtype);
-void *dvbapi_start_handler(struct s_client *cl, uchar *mbuf, int32_t module_idx, void * (*_main_func)(void *));
 
-#if defined(WITH_AZBOX) || defined(WITH_MCA)
-#define USE_OPENXCAS 1
-extern int32_t openxcas_provid;
-extern uint16_t openxcas_sid, openxcas_caid, openxcas_ecm_pid;
-static inline void openxcas_set_caid(uint16_t _caid) { openxcas_caid = _caid; }
-static inline void openxcas_set_ecm_pid(uint16_t _pid) { openxcas_ecm_pid = _pid; }
-static inline void openxcas_set_sid(uint16_t _sid) { openxcas_sid = _sid; }
-static inline void openxcas_set_provid(uint32_t _provid) { openxcas_provid = _provid; }
-#else
-#define USE_OPENXCAS 0
-static inline void openxcas_set_caid(uint16_t UNUSED(_caid)) { }
-static inline void openxcas_set_ecm_pid(uint16_t UNUSED(_pid)) { }
-static inline void openxcas_set_sid(uint16_t UNUSED(_sid)) { }
-static inline void openxcas_set_provid(uint32_t UNUSED(_provid)) { }
+int32_t 	dvbapi_constcw_afterwards(int32_t typ, int32_t demux_id, int16_t direction);
+
+#if defined(__DVCCRC_AVAILABLE__)
+bool		DVBCRC_Addon(struct s_ecmpids *stpids, uint8_t *ecm, uint16_t ecmlen, uint32_t *crcval);
+void 		DVBCRC_Remove(int32_t demux_id, int32_t ecmpid);
+void 		DVBCRC_Clean(struct s_ecmpids *curpid);
+#if defined(MODULE_XCAMD)
+int32_t 	DVBCRC_ChkMatched(struct s_reader *rdr, int32_t demux_id, uint16_t caid, uint32_t prid, uint32_t chkcrc);
+#endif
+#endif
+
+#if defined(MODULE_CONSTCW) || defined(MODULE_XCAS) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+bool		DVBICS_ChRetuning(int32_t demux_id, int32_t typ);
+void		DVBICS_ChSettings(int32_t demux_id, int chstages);
+void		DVBICS_ChCloser(int32_t demux_id);
+void 		DVBICS_ChDescrambled(int32_t demux_id, int descramble);
+int32_t 	DVBICS_ChkEcmReaders(int32_t demux_id);
+int32_t	DVBICS_ChkEcmPids(int32_t demux_id, uint16_t srvid, uint16_t casid, uint32_t prid);
+#endif // defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+
+#ifdef DVBAPI_LOG_PREFIX
+#undef 	cs_log
+#define 	cs_log(fmt, params...)   cs_log_txt(MODULE_LOG_PREFIX, "dvbapi: " fmt, ##params)
+#ifdef WITH_DEBUG
+	#undef	cs_log_dbg
+	#define 	cs_log_dbg(mask, fmt, params...) do { if (config_enabled(WITH_DEBUG) && ((mask) & cs_dblevel)) cs_log_txt(MODULE_LOG_PREFIX, "dvbapi: " fmt, ##params); } while(0)
+#endif
 #endif
 
 bool is_dvbapi_usr(char *usr);
Index: module-gbox.c
===================================================================
--- module-gbox.c	(revision 10670)
+++ module-gbox.c	(working copy)
@@ -849,7 +849,7 @@
 		if(cli->ecmtask[i].idx == idx)
 		{
 			cli->pending--;
-			casc_check_dcw(cli->reader, i, rc, dcw);
+			casc_check_dcw(cli->reader, i, rc, dcw, NULL);
 			return 0;
 		}
 	}
@@ -1290,7 +1290,7 @@
 	if(!cli->gbox || !cli->reader->tcp_connected)
 	{
 		cs_log_dbg(D_READER, "%s server not init!", cli->reader->label);
-		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL);
+		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL, NULL);
 		return -1;
 	}
 
@@ -1300,14 +1300,14 @@
 	if(!peer->filtered_cards)
 	{
 		cs_log_dbg(D_READER, "%s NO CARDS!", cli->reader->label);
-		write_ecm_answer(cli->reader, er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL);
+		write_ecm_answer(cli->reader, er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL, NULL);
 		return -1;
 	}
 
 	if(!peer->online)
 	{
 		cs_log_dbg(D_READER, "peer is OFFLINE!");
-		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL);
+		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL, NULL);
 		//      gbox_send_hello(cli,0);
 		return -1;
 	}
@@ -1321,7 +1321,7 @@
 	if(er->gbox_ecm_id == peer->gbox.id)
 	{
 		cs_log_dbg(D_READER, "%s provided ecm", cli->reader->label);
-		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL);
+		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL, NULL);
 		return 0;
 	}
 
@@ -1371,7 +1371,7 @@
 	if(!cont_card_1 && er->gbox_ecm_status == GBOX_ECM_NOT_ASKED)
 	{
 		cs_log_dbg(D_READER, "no valid card found for CAID: %04X PROVID: %04X", er->caid, er->prid);
-		write_ecm_answer(cli->reader, er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL);
+		write_ecm_answer(cli->reader, er, E_NOTFOUND, E2_CCCAM_NOCARD, NULL, NULL, NULL);
 		return -1;
 	}
 	if(cont_card_1)
Index: module-ird-guess.c
===================================================================
--- module-ird-guess.c	(revision 10670)
+++ module-ird-guess.c	(working copy)
@@ -7,8 +7,7 @@
 #include "oscam-string.h"
 #include "oscam-conf.h"
 
-struct s_irdeto_quess
-{
+struct s_irdeto_quess {
 	int32_t         b47;
 	uint16_t        caid;
 	uint16_t        sid;
@@ -21,7 +20,7 @@
 {
 	FILE *fp = open_config_file("oscam.ird");
 	if(!fp)
-		{ return 1; }
+    return 1;
 
 	int32_t i, j, skip;
 	int32_t b47;
@@ -31,37 +30,29 @@
 	uint16_t caid, sid;
 	struct s_irdeto_quess *ird_row, *head;
 
-	if(!cs_malloc(&itab, sizeof(struct s_irdeto_quess *) * 0xff))
-	{
+  if (!cs_malloc(&itab, sizeof(struct s_irdeto_quess *) * 0xff)) {
 		fclose(fp);
 		return 0;
 	}
 
 	while(fgets(token, sizeof(token), fp))
 	{
-		if(strlen(token) < 20) { continue; }
+    if ( strlen(token)<20 ) continue;
 		for(i = b3 = b47 = caid = sid = skip = 0, ptr = strtok_r(token, ":", &saveptr1); (i < 4) && (ptr); ptr = strtok_r(NULL, ":", &saveptr1), i++)
 		{
 			trim(ptr);
-			if(*ptr == ';' || *ptr == '#' || *ptr == '-')
-			{
+      if ( *ptr==';' || *ptr=='#' || *ptr=='-' ) {
 				skip = 1;
 				break;
 			}
 			switch(i)
 			{
-			case 0:
-				b3   = a2i(ptr, 2);
-				break;
-			case 1:
-				b47  = a2i(ptr, 8);
-				break;
-			case 2:
-				caid = a2i(ptr, 4);
-				break;
+        case 0: b3   = a2i(ptr, 2); break;
+        case 1: b47  = a2i(ptr, 8); break;
+        case 2: caid = a2i(ptr, 4); break;
 			case 3:
 				for(j = 0; j < 4; j++)
-					{ zSid[j] = ptr[j]; }
+            zSid[j]=ptr[j];
 				zSid[4] = 0;
 				sid  = a2i(zSid, 4);
 				break;
@@ -69,8 +60,7 @@
 		}
 		if(!skip)
 		{
-			if(!cs_malloc(&ird_row, sizeof(struct s_irdeto_quess)))
-			{
+      if (!cs_malloc(&ird_row, sizeof(struct s_irdeto_quess))) {
 				fclose(fp);
 				return (1);
 			}
@@ -79,14 +69,13 @@
 			ird_row->sid  = sid;
 
 			head = itab[b3];
-			if(head)
-			{
+      if ( head ) {
 				while(head->next)
-					{ head = head->next; }
+          head=head->next;
 				head->next = ird_row;
 			}
 			else
-				{ itab[b3] = ird_row; }
+        itab[b3]=ird_row;
 			//cs_log_dbg(D_CLIENT, "%02X:%08X:%04X:%04X", b3, b47, caid, sid);
 		}
 	}
@@ -109,7 +98,7 @@
 {
 	uint8_t i;
 	if(!itab)
-		{ return; }
+    return;
 	for(i = 0; i < 0xff; i++)
 	{
 		struct s_irdeto_quess *head = itab[i];
@@ -131,11 +120,10 @@
 	struct s_irdeto_quess *ptr;
 
 	if(!itab)
-		{ return; }
+    return;
 	b3  = er->ecm[3];
 	ptr = itab[b3];
-	if(!ptr)
-	{
+  if ( !ptr ) {
 		cs_log_dbg(D_TRACE, "unknown irdeto byte 3: %02X", b3);
 		return;
 	}
Index: module-ird-guess.h
===================================================================
--- module-ird-guess.h	(revision 10670)
+++ module-ird-guess.h	(working copy)
@@ -6,10 +6,7 @@
 void guess_irdeto(ECM_REQUEST *er);
 void free_irdeto_guess_tab(void);
 #else
-static inline int32_t init_irdeto_guess_tab(void)
-{
-	return 0;
-}
+static inline int32_t init_irdeto_guess_tab(void) { return 0; }
 static inline void guess_irdeto(ECM_REQUEST *UNUSED(er)) { }
 static inline void free_irdeto_guess_tab(void) { }
 #endif
Index: module-lcd.c
===================================================================
--- module-lcd.c	(revision 10670)
+++ module-lcd.c	(working copy)
@@ -18,21 +18,17 @@
 
 static int8_t running;
 
-static void refresh_lcd_file(void)
-{
+static void refresh_lcd_file(void) {
 	char targetfile[256];
 	char temp_file[256];
 	char channame[32];
 
 	set_thread_name(__func__);
 
-	if(cfg.lcd_output_path == NULL)
-	{
+	if (cfg.lcd_output_path == NULL) {
 		get_tmp_dir_filename(targetfile, sizeof(targetfile), "oscam.lcd");
 		get_tmp_dir_filename(temp_file, sizeof(temp_file), "oscam.lcd.tmp");
-	}
-	else
-	{
+	} else {
 		snprintf(targetfile, sizeof(targetfile), "%s%s", cfg.lcd_output_path, "/oscam.lcd");
 		snprintf(temp_file, sizeof(temp_file), "%s%s.tmp", cfg.lcd_output_path, "/oscam.lcd");
 	}
@@ -42,14 +38,12 @@
 	time_t now;
 
 
-	while(running)
-	{
+	while (running) {
 		now = time((time_t *)0);
 		int16_t cnt = 0, idx = 0, count_r = 0, count_p = 0, count_u = 0;
 		FILE *fpsave;
 
-		if((fpsave = fopen(temp_file, "w")))
-		{
+		if ((fpsave = fopen(temp_file, "w"))) {
 
 			idx = 0;
 			int16_t i;
@@ -58,21 +52,14 @@
 			char *status;
 
 			// Statuslines start
-			secs = 0;
-			fullmins = 0;
-			mins = 0;
-			fullhours = 0;
-			hours = 0;
-			days = 0;
+			secs = 0; fullmins = 0; mins = 0; fullhours = 0; hours = 0; days = 0;
 
 			seconds = now - first_client->login;
 			secs = seconds % 60;
-			if(seconds > 60)
-			{
+			if (seconds > 60) {
 				fullmins = seconds / 60;
 				mins = fullmins % 60;
-				if(fullmins > 60)
-				{
+				if (fullmins > 60) {
 					fullhours = fullmins / 60;
 					hours = fullhours % 24;
 					days = fullhours / 24;
@@ -82,9 +69,9 @@
 			fprintf(fpsave, "Version: %s\n", CS_VERSION);
 			fprintf(fpsave, "Revision: %s\n", CS_SVN_VERSION);
 			if(days == 0)
-				{ fprintf(fpsave, "up: %02d:%02d:%02d\n", hours, mins, secs); }
+				fprintf(fpsave, "up: %02d:%02d:%02d\n", hours, mins, secs);
 			else
-				{ fprintf(fpsave, "up: %02dd %02d:%02d:%02d\n", days, hours, mins, secs); }
+				fprintf(fpsave, "up: %02dd %02d:%02d:%02d\n", days, hours, mins, secs);
 			fprintf(fpsave, "totals: %d/%d/%d/%d/%d/%d\n", first_client->cwfound, first_client->cwnot, first_client->cwignored, first_client->cwtout, first_client->cwcache, first_client->cwtun);
 			fprintf(fpsave, "uptime: %d\n", seconds);
 			// Statuslines end
@@ -96,54 +83,43 @@
 			struct s_client *cl;
 
 			// Reader/Proxy table start
-			for(i = 0, cl = first_client; cl ; cl = cl->next, i++)
-			{
+			for ( i=0, cl=first_client; cl ; cl=cl->next, i++) {
 
-				if((cl->typ == 'r' || cl->typ == 'p') && ((now - cl->last) < 20 || !cfg.lcd_hide_idle))
-				{
+				if ((cl->typ=='r' || cl->typ=='p') && ((now - cl->last) < 20 || !cfg.lcd_hide_idle)) {
 					type = "";
 					label = "";
 					status = "OFF";
-					secs = 0;
-					fullmins = 0;
-					mins = 0;
-					fullhours = 0;
-					hours = 0;
-					days = 0;
+					secs = 0; fullmins = 0; mins = 0; fullhours = 0; hours = 0; days = 0;
 
 					seconds = now - cl->last;
 
-					if(cl->typ == 'r')
-					{
+					if (cl->typ == 'r') {
 						type = "R";
 						idx = count_r;
 						label = cl->reader->label;
 						if(cl->reader->card_status == CARD_INSERTED)
-							{ status = "OK"; }
+							status = "OK";
 						count_r++;
 					}
 
-					else if(cl->typ == 'p')
-					{
+					else if (cl->typ == 'p') {
 						type = "P";
 						iscccam = strncmp(client_get_proto(cl), "cccam", 5) == 0;
 						idx = count_p;
 						label = cl->reader->label;
 
 						if(cl->reader->card_status == CARD_INSERTED)
-							{ status = "CON"; }
+							status = "CON";
 
 						count_p++;
 					}
 
 
 					secs = seconds % 60;
-					if(seconds > 60)
-					{
+					if (seconds > 60) {
 						fullmins = seconds / 60;
 						mins = fullmins % 60;
-						if(fullmins > 60)
-						{
+						if (fullmins > 60) {
 							fullhours = fullmins / 60;
 							hours = fullhours % 24;
 							days = fullhours / 24;
@@ -153,10 +129,8 @@
 					int16_t written = 0, skipped = 0, blocked = 0, error = 0;
 
 					char emmtext[16] = "               ";
-					if(cl->typ == 'r' || !iscccam)
-					{
-						for(i = 0; i < 4; i++)
-						{
+						if (cl->typ == 'r' || !iscccam ) {
+							for (i=0; i<4; i++) {
 							error += cl->reader->emmerror[i];
 							blocked += cl->reader->emmblocked[i];
 							skipped += cl->reader->emmskipped[i];
@@ -168,20 +142,16 @@
 								 blocked > 999 ? 999 : blocked,
 								 error > 999 ? 999 : error);
 					}
-					else if(cl->typ == 'p' && iscccam)
-					{
+						else if (cl->typ == 'p' && iscccam ) {
 						if(!cccam_snprintf_cards_stat(cl, emmtext, 16))
-							{ snprintf(emmtext, 16, "   No cards    "); }
+								snprintf(emmtext, 16, "   No cards    ");
 					}
 
-					if(days == 0)
-					{
+					if (days == 0) {
 						fprintf(fpsave, "%s%d | %-10.10s |     %02d:%02d:%02d |%s| %s\n",
 								type, idx, label, hours, mins,
 								secs, emmtext, status);
-					}
-					else
-					{
+					} else {
 						fprintf(fpsave, "%s%d | %-10.10s |% 3dd %02d:%02d:%02d |%s| %s\n",
 								type, idx, label, days, hours, mins,
 								secs, emmtext, status);
@@ -209,13 +179,11 @@
 
 			*/
 
-			for(i = 0, cl = first_client; cl ; cl = cl->next, i++)
-			{
+			for ( i=0, cl=first_client; cl ; cl=cl->next, i++) {
 
 				seconds = now - cl->lastecm;
 
-				if(cl->typ == 'c' && seconds < 15)
-				{
+				if (cl->typ == 'c' && seconds < 15) {
 					type = "U";
 					idx = count_u;
 					label = cl->account->usr;
@@ -241,23 +209,20 @@
 		cnt++;
 
 		if(rename(temp_file, targetfile) < 0)
-			{ cs_log("An error occured while writing oscam.lcd file %s.", targetfile); }
+			cs_log("An error occured while writing oscam.lcd file %s.", targetfile);
 
 	}
 
 }
 
-void lcd_thread_start(void)
-{
-	if(cfg.enablelcd)
-	{
+void lcd_thread_start(void) {
+	if (cfg.enablelcd) {
 		running = 1;
 		start_thread((void *) &refresh_lcd_file, "LCD");
 	}
 }
 
-void lcd_thread_stop(void)
-{
+void lcd_thread_stop(void) {
 	running = 0;
 }
 
Index: module-led.c
===================================================================
--- module-led.c	(revision 10670)
+++ module-led.c	(working copy)
@@ -9,8 +9,7 @@
 #include "oscam-time.h"
 
 #if defined(__arm__)
-struct s_arm_led
-{
+struct s_arm_led {
 	int32_t led;
 	int32_t action;
 	time_t start_time;
@@ -22,53 +21,41 @@
 #define ARM_LED_TYPES 3
 #define ARM_LED_FILES 4
 
-struct arm_leds
-{
+struct arm_leds {
 	char *machine;
-	struct led_file
-	{
+	struct led_file {
 		uint8_t id;
 		char    *file;
 	} leds[ARM_LED_FILES];
 };
 
-static const struct arm_leds arm_leds[ARM_LED_TYPES] =
-{
-	{
-		"nslu2", {
+static const struct arm_leds arm_leds[ARM_LED_TYPES] = {
+	{ "nslu2", {
 			{ LED1A, "red:status" },
 			{ LED1B, "green:ready" },
 			{ LED2,  "green:disk-1" },
-			{ LED3,  "green:disk-2" }
+		{ LED3,  "green:disk-2" } },
 		},
-	},
-	{
-		"dockstar", {
+	{ "dockstar", {
 			{ LED1A, "orange:misc" },
 			{ LED1B, "green:health" },
 			{ LED2,  "green:health" },
-			{ LED3,  "orange:misc" }
-		},
+		{ LED3,  "orange:misc" } },
 	},
-	{
-		"wrt350nv2", {
+	{ "wrt350nv2", {
 			{ LED1A, "orange:power" },
 			{ LED1B, "green:power" },
 			{ LED2,  "green:wireless" },
-			{ LED3,  "green:security" }
-		},
+		{ LED3,  "green:security" } },
 	}
 };
 
-static int32_t arm_init_led_file(uint8_t led_type, uint8_t led_no, char *buf, int32_t buflen)
-{
+static int32_t arm_init_led_file(uint8_t led_type, uint8_t led_no, char *buf, int32_t buflen) {
 	uint8_t i;
-	if(led_type >= ARM_LED_TYPES) { return 0; }
-	if(led_no >= ARM_LED_FILES) { return 0; }
-	for(i = 0; i < ARM_LED_FILES; i++)
-	{
-		if(arm_leds[led_type].leds[i].id == led_no)
-		{
+	if (led_type >= ARM_LED_TYPES) return 0;
+	if (led_no >= ARM_LED_FILES) return 0;
+	for (i = 0; i < ARM_LED_FILES; i++) {
+		if (arm_leds[led_type].leds[i].id == led_no) {
 			return snprintf(buf, buflen, "/sys/class/leds/%s:%s/brightness",
 							arm_leds[led_type].machine, arm_leds[led_type].leds[i].file);
 		}
@@ -79,42 +66,34 @@
 #define LED_TYPE_UNKNOWN 0xff
 static uint8_t arm_led_type = LED_TYPE_UNKNOWN;
 
-static void arm_detect_led_type(void)
-{
+static void arm_detect_led_type(void) {
 	uint8_t i;
 	char led_file[256];
-	for(i = 0; i < ARM_LED_TYPES; i++)
-	{
+	for (i = 0; i < ARM_LED_TYPES; i++) {
 		if(!arm_init_led_file(i, 0, led_file, sizeof(led_file)))
-			{ break; }
-		if(access(led_file, W_OK) == 0)
-		{
+			break;
+		if (access(led_file, W_OK) == 0) {
 			arm_led_type = i;
 			cs_log("LED support for %s is activated.", arm_leds[arm_led_type].machine);
 			break;
 		}
 	}
 	if(arm_led_type == LED_TYPE_UNKNOWN)
-		{ cs_log("LED support is not active. Can't detect machine type."); }
+		cs_log("LED support is not active. Can't detect machine type.");
 }
 
-static void arm_switch_led_from_thread(int32_t led, int32_t action)
-{
-	if(action < 2)    // only LED_ON and LED_OFF
-	{
+static void arm_switch_led_from_thread(int32_t led, int32_t action) {
+	if (action < 2) { // only LED_ON and LED_OFF
 		char led_file[256];
 		if(!arm_init_led_file(arm_led_type, led, led_file, sizeof(led_file)))
-			{ return; }
+			return;
 		FILE *f = fopen(led_file, "w");
 		if(!f)
-			{ return; }
+			return;
 		fprintf(f, "%d", action);
 		fclose(f);
-	}
-	else     // LED Macros
-	{
-		switch(action)
-		{
+	} else { // LED Macros
+		switch (action) {
 		case LED_DEFAULT:
 			arm_switch_led_from_thread(LED1A, LED_OFF);
 			arm_switch_led_from_thread(LED1B, LED_OFF);
@@ -135,16 +114,13 @@
 	}
 }
 
-static void *arm_led_thread_main(void *UNUSED(thread_data))
-{
+static void *arm_led_thread_main(void *UNUSED(thread_data)) {
 	uint8_t running = 1;
 	set_thread_name(__func__);
-	while(running)
-	{
+	while (running) {
 		LL_ITER iter = ll_iter_create(arm_led_actions);
 		struct s_arm_led *arm_led;
-		while((arm_led = ll_iter_next(&iter)))
-		{
+		while ((arm_led = ll_iter_next(&iter))) {
 			int32_t led, action;
 			time_t now, start;
 			led = arm_led->led;
@@ -152,18 +128,15 @@
 			now = time((time_t)0);
 			start = arm_led->start_time;
 			ll_iter_remove_data(&iter);
-			if(action == LED_STOP_THREAD)
-			{
+			if (action == LED_STOP_THREAD) {
 				running = 0;
 				break;
 			}
-			if(now - start < ARM_LED_TIMEOUT)
-			{
+			if (now - start < ARM_LED_TIMEOUT) {
 				arm_switch_led_from_thread(led, action);
 			}
 		}
-		if(running)
-		{
+		if (running) {
 			sleep(60);
 		}
 	}
@@ -172,14 +145,12 @@
 	return NULL;
 }
 
-static void arm_led_start_thread(void)
-{
+static void arm_led_start_thread(void) {
 	arm_detect_led_type();
 	if(!cfg.enableled || arm_led_type == LED_TYPE_UNKNOWN)
-		{ return; }
+		return;
 	// call this after signal handling is done
-	if(!arm_led_actions)
-	{
+	if (!arm_led_actions) {
 		arm_led_actions = ll_create("arm_led_actions");
 	}
 	pthread_attr_t attr;
@@ -187,46 +158,38 @@
 	cs_log("starting thread arm_led_thread");
 	pthread_attr_setstacksize(&attr, PTHREAD_STACK_SIZE);
 	int32_t ret = pthread_create(&arm_led_thread, &attr, arm_led_thread_main, NULL);
-	if(ret)
-	{
+	if (ret) {
 		cs_log("ERROR: can't create arm_led_thread thread (errno=%d %s)", ret, strerror(ret));
-	}
-	else
-	{
+	} else {
 		cs_log("arm_led_thread thread started");
 		pthread_detach(arm_led_thread);
 	}
 	pthread_attr_destroy(&attr);
 }
 
-static void arm_led(int32_t led, int32_t action)
-{
+static void arm_led(int32_t led, int32_t action) {
 	struct s_arm_led *data;
 	if(!cfg.enableled || arm_led_type == LED_TYPE_UNKNOWN)
-		{ return; }
-	if(!arm_led_actions)
-	{
+		return;
+	if (!arm_led_actions) {
 		arm_led_actions = ll_create("arm_led_actions");
 	}
-	if(cs_malloc(&data, sizeof(struct s_arm_led)))
-	{
+	if (cs_malloc(&data, sizeof(struct s_arm_led))) {
 		data->start_time = time((time_t)0);
 		data->led = led;
 		data->action = action;
 		ll_append(arm_led_actions, (void *)data);
 	}
-	if(arm_led_thread)
-	{
+	if (arm_led_thread) {
 		// arm_led_thread_main is not started at oscam startup
 		// when first arm_led calls happen
 		pthread_kill(arm_led_thread, OSCAM_SIGNAL_WAKEUP);
 	}
 }
 
-static void arm_led_stop_thread(void)
-{
+static void arm_led_stop_thread(void) {
 	if(!cfg.enableled || arm_led_type == LED_TYPE_UNKNOWN)
-		{ return; }
+		return;
 	arm_led(0, LED_STOP_THREAD);
 }
 #else
@@ -237,20 +200,16 @@
 
 
 #ifdef QBOXHD
-static void qboxhd_led_blink(int32_t color, int32_t duration)
-{
+static void qboxhd_led_blink(int32_t color, int32_t duration) {
 	int32_t f;
 	if(cfg.enableled != 2)
-		{ return; }
+		return;
 	// try QboxHD-MINI first
-	if((f = open(QBOXHDMINI_LED_DEVICE, O_RDWR | O_NONBLOCK)) > -1)
-	{
+	if ((f = open(QBOXHDMINI_LED_DEVICE, O_RDWR|O_NONBLOCK)) > -1) {
 		qboxhdmini_led_color_struct qbminiled;
 		uint32_t qboxhdmini_color = 0x000000;
-		if(color != QBOXHD_LED_COLOR_OFF)
-		{
-			switch(color)
-			{
+		if (color != QBOXHD_LED_COLOR_OFF) {
+			switch (color) {
 			case QBOXHD_LED_COLOR_RED:
 				qboxhdmini_color = QBOXHDMINI_LED_COLOR_RED;
 				break;
@@ -280,12 +239,9 @@
 		qbminiled.blue = 0;
 		ioctl(f, QBOXHDMINI_IOSET_RGB, &qbminiled);
 		close(f);
-	}
-	else if((f = open(QBOXHD_LED_DEVICE, O_RDWR | O_NONBLOCK)) > -1)
-	{
+	} else if ((f = open(QBOXHD_LED_DEVICE, O_RDWR |O_NONBLOCK)) > -1) {
 		qboxhd_led_color_struct qbled;
-		if(color != QBOXHD_LED_COLOR_OFF)
-		{
+		if (color != QBOXHD_LED_COLOR_OFF) {
 			// set LED on with color
 			qbled.H = color;
 			qbled.S = 99;
@@ -305,17 +261,14 @@
 static inline void qboxhd_led_blink(int32_t UNUSED(color), int32_t UNUSED(duration)) { }
 #endif
 
-void led_status_stopping(void)
-{
-	if(cfg.enableled == 1)
-	{
+void led_status_stopping(void) {
+	if (cfg.enableled == 1) {
 		arm_led(LED1B, LED_OFF);
 		arm_led(LED2,  LED_OFF);
 		arm_led(LED3,  LED_OFF);
 		arm_led(LED1A, LED_ON);
 	}
-	if(cfg.enableled == 2)
-	{
+	if (cfg.enableled == 2) {
 		qboxhd_led_blink(QBOXHD_LED_COLOR_YELLOW,  QBOXHD_LED_BLINK_FAST);
 		qboxhd_led_blink(QBOXHD_LED_COLOR_RED,     QBOXHD_LED_BLINK_FAST);
 		qboxhd_led_blink(QBOXHD_LED_COLOR_GREEN,   QBOXHD_LED_BLINK_FAST);
@@ -324,28 +277,22 @@
 	}
 }
 
-void led_status_cw_not_found(ECM_REQUEST *er)
-{
+void led_status_cw_not_found(ECM_REQUEST *er) {
 	if(!er->rc)
-		{ arm_led(LED2, LED_BLINK_OFF); }
-	if(er->rc < E_NOTFOUND)
-	{
+		arm_led(LED2, LED_BLINK_OFF);
+	if (er->rc < E_NOTFOUND) {
 		qboxhd_led_blink(QBOXHD_LED_COLOR_GREEN, QBOXHD_LED_BLINK_MEDIUM);
-	}
-	else if(er->rc <= E_STOPPED)
-	{
+	} else if (er->rc <= E_STOPPED) {
 		qboxhd_led_blink(QBOXHD_LED_COLOR_RED, QBOXHD_LED_BLINK_MEDIUM);
 	}
 }
 
-void led_status_default(void)
-{
+void led_status_default(void) {
 	arm_led(LED1A, LED_DEFAULT);
 	arm_led(LED1A, LED_ON);
 }
 
-void led_status_starting(void)
-{
+void led_status_starting(void) {
 	arm_led(LED1A, LED_OFF);
 	arm_led(LED1B, LED_ON);
 	qboxhd_led_blink(QBOXHD_LED_COLOR_YELLOW,  QBOXHD_LED_BLINK_FAST);
@@ -355,47 +302,39 @@
 	qboxhd_led_blink(QBOXHD_LED_COLOR_MAGENTA, QBOXHD_LED_BLINK_FAST);
 }
 
-void led_status_card_activation_error(void)
-{
+void led_status_card_activation_error(void) {
 	qboxhd_led_blink(QBOXHD_LED_COLOR_MAGENTA, QBOXHD_LED_BLINK_MEDIUM);
 }
 
-void led_status_found_cardsystem(void)
-{
+void led_status_found_cardsystem(void) {
 	qboxhd_led_blink(QBOXHD_LED_COLOR_YELLOW, QBOXHD_LED_BLINK_MEDIUM);
 	qboxhd_led_blink(QBOXHD_LED_COLOR_GREEN,  QBOXHD_LED_BLINK_MEDIUM);
 	qboxhd_led_blink(QBOXHD_LED_COLOR_YELLOW, QBOXHD_LED_BLINK_MEDIUM);
 	qboxhd_led_blink(QBOXHD_LED_COLOR_GREEN,  QBOXHD_LED_BLINK_MEDIUM);
 }
 
-void led_status_unsupported_card_system(void)
-{
+void led_status_unsupported_card_system(void) {
 	qboxhd_led_blink(QBOXHD_LED_COLOR_MAGENTA, QBOXHD_LED_BLINK_MEDIUM);
 }
 
-void led_status_card_detected(void)
-{
+void led_status_card_detected(void) {
 	qboxhd_led_blink(QBOXHD_LED_COLOR_YELLOW, QBOXHD_LED_BLINK_SLOW);
 }
 
-void led_status_card_ejected(void)
-{
+void led_status_card_ejected(void) {
 	qboxhd_led_blink(QBOXHD_LED_COLOR_RED, QBOXHD_LED_BLINK_SLOW);
 }
 
-void led_status_emm_ok(void)
-{
+void led_status_emm_ok(void) {
 	arm_led(LED3, LED_BLINK_ON);
 	qboxhd_led_blink(QBOXHD_LED_COLOR_BLUE, QBOXHD_LED_BLINK_MEDIUM);
 }
 
-void led_init(void)
-{
+void led_init(void) {
 	arm_led_start_thread();
 }
 
-void led_stop(void)
-{
+void led_stop(void) {
 	arm_led_stop_thread();
 }
 
Index: module-led.h
===================================================================
--- module-led.h	(revision 10670)
+++ module-led.h	(working copy)
@@ -14,15 +14,13 @@
 #define  ARM_LED_TIMEOUT 3 //Dont blink for actions which are < ARM_LED_TIMEOUT seconds ago
 
 // QBOX led structures
-typedef struct
-{
+typedef struct {
 	uint16_t H;                                     // range 0-359
 	unsigned char S;                                // range 0-99
 	unsigned char V;                                // range 0-99
 } qboxhd_led_color_struct;
 
-typedef struct
-{
+typedef struct {
 	unsigned char red;                              // first 5 bit used (&0x1F)
 	unsigned char green;                            // first 5 bit used (&0x1F)
 	unsigned char blue;                             // first 5 bit used (&0x1F)
Index: module-monitor.h
===================================================================
--- module-monitor.h	(revision 10670)
+++ module-monitor.h	(working copy)
@@ -4,10 +4,7 @@
 #ifdef MODULE_MONITOR
 int32_t monitor_send_idx(struct s_client *cl, char *txt);
 #else
-int32_t monitor_send_idx(struct s_client *UNUSED(cl), char *UNUSED(txt))
-{
-	return 0;
-}
+int32_t monitor_send_idx(struct s_client *UNUSED(cl), char *UNUSED(txt)) { return 0; }
 #endif
 
 #endif
Index: module-newcamd.c
===================================================================
--- module-newcamd.c	(revision 10670)
+++ module-newcamd.c	(working copy)
@@ -6,6 +6,7 @@
 #include "cscrypt/md5.h"
 #include "module-newcamd.h"
 #include "oscam-array.h"
+#include "oscam-config.h"
 #include "oscam-conf-chk.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -15,8 +16,8 @@
 #include "oscam-reader.h"
 #include "oscam-string.h"
 #include "oscam-time.h"
-
-#define CWS_NETMSGSIZE 400  //csp 0.8.9 (default: 400). This is CWS_NETMSGSIZE. The old default was 240
+// csp 0.8.9 (default: 400). This is CWS_NETMSGSIZE. The old default was 240
+#define CWS_NETMSGSIZE 	400
 #define NCD_CLIENT_ID 0x8888
 
 #define CWS_FIRSTCMDNO 0xe0
@@ -69,6 +70,35 @@
 
 #define REQ_SIZE  2
 
+#if defined(MODULE_AVAMGCAMD)
+static int32_t avatarcamd_activation(struct s_reader *reader);
+#endif
+
+// sky(n)
+int32_t network_recvpoll(int32_t handle, uint8_t *buf, int32_t len)
+{
+	struct pollfd pfd;
+	int32_t rc;
+
+	while (1)
+	{
+		pfd.fd = handle;
+		pfd.events = POLLIN | POLLPRI;
+		rc = poll(&pfd, 1, 3000);
+		if (rc < 0) {
+			if (errno==EINTR) continue;
+			return (-1); // error!!
+		}
+
+		if (rc == 1) {
+			if (pfd.revents & POLLHUP) return (-1); //hangup = error!!
+			break;
+		}
+		return (-2); // timeout!!
+	}
+	return recv(handle, buf, len, MSG_WAITALL);
+}
+
 static int32_t network_message_send(int32_t handle, uint16_t *netMsgId, uint8_t *buffer,
 									int32_t len, uint8_t *deskey, comm_type_t commType,
 									uint16_t sid, custom_data_t *cd)
@@ -80,31 +110,32 @@
 	head_size = (cl->ncd_proto == NCD_524) ? 8 : 12;
 
 	if(len < 3 || len + head_size > CWS_NETMSGSIZE || handle < 0)
-		{ return -1; }
+		return -1;
 	buffer[1] = (buffer[1] & 0xf0) | (((len - 3) >> 8) & 0x0f);
 	buffer[2] = (len - 3) & 0xff;
 	memcpy(netbuf + head_size, buffer, len);
 	len += head_size;
-	if(netMsgId)
-	{
-		if(commType == COMMTYPE_CLIENT) { (*netMsgId)++; }
+	if (netMsgId) {
+		if (commType==COMMTYPE_CLIENT) (*netMsgId)++;
 		netbuf[2] = (*netMsgId) >> 8;
 		netbuf[3] = (*netMsgId) & 0xff;
 	}
-	else
-		{ netbuf[2] = netbuf[3] = 0; }
+	else {
+		netbuf[2] = netbuf[3] = 0;
+	}
 	memset(netbuf + 4, 0, (cl->ncd_proto == NCD_524) ? 4 : 8);
 	if(sid)
 	{
 		if(cl->reader && cl->reader->ncd_disable_server_filt &&
-				sid != NCD_CLIENT_ID && cl->ncd_proto != NCD_524) //mgclient send header
-		{
+			sid != NCD_CLIENT_ID && cl->ncd_proto != NCD_524)
+		{	// mgclient send header
 			memcpy(netbuf + 4, cl->ncd_header + 4, 7);
 		}
 		netbuf[(cl->ncd_proto == NCD_524) ? 6 : 4] = (uchar)(sid >> 8); //sid
 		netbuf[(cl->ncd_proto == NCD_524) ? 7 : 5] = (uchar)(sid);
 	}
-	//if ((!ncd_proto==NCD_524) && (buffer[0] >= 0xd1) && (buffer[0]<= 0xd8)) { // extended proto for mg
+//	if ((!ncd_proto==NCD_524) && (buffer[0] >= 0xd1) && (buffer[0]<= 0xd8)) // extended proto for mg
+//	{
 	//cs_log_dbg(D_CLIENT, "newcamd: extended: msg");
 	if(cd)
 	{
@@ -113,7 +144,7 @@
 		netbuf[5] = cd->sid & 0xff;
 		netbuf[6] = cd->caid >> 8;
 		netbuf[7] = cd->caid & 0xff;
-		netbuf[8] = (cd->provid >> 16) & 0xFF;
+		  netbuf[ 8] =(cd->provid >> 16) & 0xff;
 		netbuf[9] = (cd->provid >> 8) & 0xff;
 		netbuf[10] = cd->provid & 0xff;
 	}
@@ -134,11 +165,20 @@
 	//        netbuf[11] = 0x11; //From ChameleonCwsConnector.java CSP line 59-61 run()
 	//    }
 
+#if defined(MODULE_AVAMGCAMD)
+	if (buffer[0]==MSG_CLIENT_2_SERVER_LOGIN && IS_AVATARCAMD(cl->reader->ncd_exprotocol))
+	{
+		memset(netbuf+4, 0, 8);
+		netbuf[4] = 0x76; // client ID
+		netbuf[5] = 0x45; // client ID
+	}
+#endif
+
 	netbuf[0] = (len - 2) >> 8;
 	netbuf[1] = (len - 2) & 0xff;
 	cs_log_dump_dbg(D_CLIENT, netbuf, len, "send %d bytes to %s", len, remote_txt());
-	if((len = des_encrypt(netbuf, len, deskey)) < 0)
-		{ return -1; }
+	if ((len = des_encrypt(netbuf, len, deskey)) < 0) return -1;
+
 	netbuf[0] = (len - 2) >> 8;
 	netbuf[1] = (len - 2) & 0xff;
 	return send(handle, netbuf, len, 0);
@@ -167,6 +207,7 @@
 	/*memset(mbuf, 0, sizeof(mbuf));*/ // not nessesery
 
 	for(nr = 0, sidtab = cfg.sidtab; sidtab; sidtab = sidtab->next, nr++)
+	{
 		if((cl->sidtabs.no & ((SIDTABBITS)1 << nr)) && (sidtab->num_caid | sidtab->num_provid | sidtab->num_srvid))
 		{
 			for(n = 0; n < pfilts[0].nprids; n++)
@@ -206,7 +247,7 @@
 				}
 			}
 		}
-
+	}
 	if(portion_sid_num)
 	{
 		++portion_num;
@@ -231,48 +272,42 @@
 	struct s_client *cl = cur_client();
 
 	if(!buffer || handle < 0)
-		{ return -1; }
+		return -1;
 	len = recv(handle, netbuf, 2, 0);
 	cs_log_dbg(D_CLIENT, "nmr(): len=%d, errno=%d", len, (len == -1) ? errno : 0);
-	if(!len)
-	{
+	if (!len) {
 		cs_log_dbg(D_CLIENT, "nmr: 1 return 0");
 		if(commType == COMMTYPE_CLIENT)
-			{ network_tcp_connection_close(cl->reader, "receive error1"); }
+			network_tcp_connection_close(cl->reader, "receive error1");
 		else
-			{ cs_disconnect_client(cl); }
+			cs_disconnect_client(cl);
 		return 0;
 	}
-	if(len != 2)
-	{
+	if (len != 2) {
 		cs_log_dbg(D_CLIENT, "nmr: len!=2");
 		if(commType == COMMTYPE_CLIENT)
-			{ network_tcp_connection_close(cl->reader, "receive error2"); }
+			network_tcp_connection_close(cl->reader, "receive error2");
 		else
-			{ cs_disconnect_client(cl); }
+			cs_disconnect_client(cl);
 		return -1;
 	}
-	if(((netbuf[0] << 8) | netbuf[1]) > CWS_NETMSGSIZE - 2)
-	{
+	if (((netbuf[0] << 8) | netbuf[1]) > CWS_NETMSGSIZE - 2) {
 		cs_log_dbg(D_CLIENT, "nmr: received data len=%d lonage than CWS_NETMSGSIZE=%d", ((netbuf[0] << 8) | netbuf[1]), CWS_NETMSGSIZE);
 		cs_log_dbg(D_CLIENT, "nmr: 1 return -1");
 		return -1;
 	}
 
 	len = recv(handle, netbuf + 2, (netbuf[0] << 8) | netbuf[1], 0);
-	if(!len)
-	{
+	if (!len) {
 		cs_log_dbg(D_CLIENT, "nmr: 2 return 0");
 		return 0;
 	}
-	if(len != ((netbuf[0] << 8) | netbuf[1]))
-	{
+	if (len != ((netbuf[0] << 8) | netbuf[1])) {
 		cs_log_dbg(D_CLIENT, "nmr: 2 return -1");
 		return -1;
 	}
 	len += 2;
-	if((len = des_decrypt(netbuf, len, deskey)) < 11)      // 15(newcamd525) or 11 ???
-	{
+	if ((len = des_decrypt(netbuf, len, deskey)) < 11) {  // 15(newcamd525) or 11 ???
 		cs_log_dbg(D_CLIENT, "nmr: can't decrypt, invalid des key?");
 		cs_sleepms(2000);
 		return -1;
@@ -280,18 +315,16 @@
 	//cs_log_dump_dbg(D_CLIENT, netbuf, len, "nmr: decrypted data, len=%d", len);
 	msgid = (netbuf[2] << 8) | netbuf[3];
 
-	if(cl->ncd_proto == NCD_AUTO)
-	{
+	if (cl->ncd_proto==NCD_AUTO) {
 		// auto detect
 		int32_t l5 = (((netbuf[13] & 0x0f) << 8) | netbuf[14]) + 3;
 		int32_t l4 = (((netbuf[9] & 0x0f) << 8) | netbuf[10]) + 3;
 
 		if((l5 <= len - 12) && ((netbuf[12] & 0xF0) == 0xE0 || (netbuf[12] & 0xF0) == 0x80))
-			{ cl->ncd_proto = NCD_525; }
+			cl->ncd_proto = NCD_525;
 		else if((l4 <= len - 8) && ((netbuf[8] & 0xF0) == 0xE0 || (netbuf[9] & 0xF0) == 0x80))
-			{ cl->ncd_proto = NCD_524; }
-		else
-		{
+			cl->ncd_proto = NCD_524;
+		else {
 			cs_log_dbg(D_CLIENT, "nmr: 4 return -1");
 			return -1;
 		}
@@ -302,8 +335,7 @@
 	ncd_off = (cl->ncd_proto == NCD_525) ? 4 : 0;
 
 	returnLen = (((netbuf[9 + ncd_off] & 0x0f) << 8) | netbuf[10 + ncd_off]) + 3;
-	if(returnLen > (len - (8 + ncd_off)))
-	{
+	if (returnLen > (len-(8+ncd_off))) {
 		cs_log_dbg(D_CLIENT, "nmr: 4 return -1");
 		return -1;
 	}
@@ -366,18 +398,179 @@
 	uint8_t buffer[CWS_NETMSGSIZE];
 
 	if(network_message_receive(handle, netMsgId, buffer, deskey, commType) != 3 + 2)
-		{ return -1; }
+		return -1;
 	return buffer[2];
 }
 
-void newcamd_reply_ka(void)
+
+#if defined(MODULE_AVAMGCAMD)
+int32_t mavatarcamd_cas_addfilters(struct s_reader *rdr, uint16_t casid, uint32_t prid)
+{
+	int add = 0;
+	int i, k;
+
+//	if (IS_IRDETO(casid)) prid = 0x0;
+	if (IS_VIACESS(casid) && prid==0) return 0;
+	if (IS_SEKA(casid) && prid==0) return 0;
+
+	for (i=0; i<rdr->ftab.nfilts; i++)
+	{
+		if (rdr->ftab.filts[i].caid == casid) break;
+	}
+	if (i==rdr->ftab.nfilts)
+	{
+	//	if (i>(CS_MAXFILTERS-1)) break;
+		if (i>(CS_MAXFILTERS-1))
+		{
+			mycs_debug(D_ADB, "ftabs:CA{%04X.%08X} CS_MAXFILTERS exceed", casid, prid);
+			return -1;
+		}
+		rdr->ftab.filts[i].caid = casid;
+		rdr->ftab.filts[i].prids[0] = prid;
+		rdr->ftab.filts[i].nprids = 1;
+		rdr->ftab.nfilts++;
+		add = 1;
+	}
+	else
+	{
+		for (k=0; k<rdr->ftab.filts[i].nprids; k++)
+		{
+			if (rdr->ftab.filts[i].prids[k] == prid) return -1;
+		}
+		if (k==rdr->ftab.filts[i].nprids)
+		{
+		//	if (k>(CS_MAXPRFLT-1)) continue;
+			if (k>(CS_MAXPRFLT-1))
+			{
+				mycs_debug(D_ADB, "ftabs:CA{%04X.%08X} CS_MAXPRFLT exceed", casid, prid);
+				return -1;
+			}
+			rdr->ftab.filts[i].prids[k] = prid;
+			rdr->ftab.filts[i].nprids++;
+			add = 1;
+		}
+	}
+	return (add);
+}
+
+static int32_t mavatarcamd_cas_inforeceive(int32_t handle, uint16_t *netMsgId, uint8_t *buffer,
+	uint8_t  *deskey, comm_type_t commType,
+	uint16_t *pcaid, uint32_t *pprid, uint16_t *pportnum)
 {
+	int32_t  len, msgid;
+	uint8_t  netbuf[CWS_NETMSGSIZE];
+	int32_t  returnLen;
+	uint16_t casid, portno;
+	uint32_t ppid;
 	struct s_client *cl = cur_client();
 
-	if(!cl) { return; }
+	if (!buffer || handle < 0) return -1;
+	len = recv(handle, netbuf, 2, 0);
+	cs_log_dbg(D_CLIENT, "mgA(): len=%d, errno=%d", len, (len==-1)  ?errno : 0);
+	if (!len) {
+		cs_log_dbg(D_CLIENT, "nmr: 1 return 0");
+		if (commType == COMMTYPE_CLIENT)
+			network_tcp_connection_close(cl->reader, "receive error1");
+		else
+			cs_disconnect_client(cl);
+		return 0;
+	}
+	if (len != 2) {
+		cs_log_dbg(D_CLIENT, "mgA: len!=2");
+		if (commType == COMMTYPE_CLIENT)
+			network_tcp_connection_close(cl->reader, "receive error2");
+		else
+			cs_disconnect_client(cl);
+		return -1;
+	}
+	if (((netbuf[0] << 8) | netbuf[1]) > CWS_NETMSGSIZE - 2) {
+		cs_log_dbg(D_CLIENT, "mgA: received data len=%d lonage than CWS_NETMSGSIZE=%d", ((netbuf[0] << 8) | netbuf[1]),CWS_NETMSGSIZE);
+		cs_log_dbg(D_CLIENT, "mgA: 1 return -1");
+		return -1;
+	}
+
+	len = recv(handle, netbuf+2, (netbuf[0] << 8) | netbuf[1], 0);
+	if (!len) {
+		cs_log_dbg(D_CLIENT, "mgA: 2 return 0");
+		return 0;
+	}
+	if (len != ((netbuf[0] << 8) | netbuf[1])) {
+		cs_log_dbg(D_CLIENT, "mgA: 2 return -1");
+		return -1;
+	}
+	len += 2;
+	if ((len = des_decrypt(netbuf, len, deskey)) < 11) {  // 15(newcamd525) or 11 ???
+		cs_log_dbg(D_CLIENT, "mgA: can't decrypt, invalid des key?");
+		cs_sleepms(2000);
+		return -1;
+	}
+//	cs_log_dump_dbg(D_CLIENT, netbuf, len, "mgA: decrypted data, len=%d", len);
+  	msgid = (netbuf[2] << 8) | netbuf[3];
+	returnLen = (((netbuf[13] & 0x0f) << 8) | netbuf[14]) + 3;
+	if (returnLen > (len-12)) {
+		cs_log_dbg(D_CLIENT, "mgA: 4 return -1");
+		return -1;
+	}
+	if (netbuf[12] == MSG_SERVER_2_CLIENT_OSD) {
+		memcpy(cl->reader->ncd_clientmessages, &netbuf[15], netbuf[14]);
+		cl->reader->ncd_clientmessages[netbuf[14]+1] = 0;
+		myprintf("ncd_clientmessages = %s\n", (char *)cl->reader->ncd_clientmessages);
+	}
+	portno = b2i(2, &netbuf[4]);
+	casid  = b2i(2, &netbuf[6]);
+	ppid   = b2i(3, &netbuf[8]);
+	mycs_debug(D_CLIENT, "mgA: cas: %04x.%06x(%d)", casid, ppid, portno);
+//	cs_log_dump_dbg(D_CLIENT, netbuf, len, "mgA: decrypted data");
+	if (netMsgId)
+	{
+		switch (commType)
+		{
+			case COMMTYPE_SERVER:
+				*netMsgId = msgid;
+				break;
+
+			case COMMTYPE_CLIENT:
+				if (*netMsgId != ((netbuf[2] << 8) | netbuf[3])) {
+					cs_log_dbg(D_CLIENT, "mgA: netMsgId=%d, from server=%d, ", *netMsgId, msgid);
+					return -2;
+				}
+				break;
+
+			default:
+				cs_log_dbg(D_CLIENT, "mgA: 5 return -1");
+				return -1;
+				break;
+		}
+	}
+	switch (commType)
+	{
+		case COMMTYPE_SERVER:
+			memcpy(cl->ncd_header, netbuf, 12);
+			buffer[0]=netbuf[4]; // sid
+			buffer[1]=netbuf[5];
+			break;
+		case COMMTYPE_CLIENT:
+			memcpy(cl->ncd_header, netbuf, 12);
+			buffer[0]=netbuf[2]; // msgid
+			buffer[1]=netbuf[3];
+			break;
+	}
+	memcpy(buffer+2, netbuf+12, returnLen);
+	if (!portno && !casid && !ppid) return -1;
+	*pcaid    = casid;
+	*pprid    = ppid;
+	*pportnum = portno;
+	return returnLen+2;
+}
+#endif
 
-	if(!cl->udp_fd)
+void newcamd_reply_ka(void)
 	{
+	struct s_client *cl = cur_client();
+
+	if (!cl) return;
+
+	if (!cl->udp_fd) {
 		cs_log_dbg(D_CLIENT, "invalid client fd=%d", cl->udp_fd);
 		return;
 	}
@@ -385,18 +578,20 @@
 	cs_log_dbg(D_CLIENT, "send keepalive to client fd=%d", cl->udp_fd);
 
 	if(cl->reader)
-		{ cl->reader->last_s = time((time_t *)0); }
+		cl->reader->last_s = time((time_t *)0);
 
 	network_cmd_no_data_send(cl->udp_fd, &cl->ncd_msgid, MSG_KEEPALIVE, cl->ncd_skey, COMMTYPE_SERVER);
 }
 
-static int32_t connect_newcamd_server(void)
+static int32_t newcamd_connect_server(void)
 {
 	int32_t i;
 	uint8_t buf[CWS_NETMSGSIZE];
-	uint8_t keymod[14];
 	uint8_t key[16];
+	uint8_t keymod[64]; // 14
 	int32_t handle = 0;
+	int32_t keymodsize=14;
+	int32_t len=0;
 
 	uint32_t idx;
 	uchar passwdcrypt[120];
@@ -404,22 +599,55 @@
 	int32_t bytes_received;
 	struct s_client *cl = cur_client();
 
+	memset(cl->reader->ncd_version,0,sizeof(cl->reader->ncd_version));
 	if(cl->reader->device[0] == 0 || cl->reader->r_pwd[0] == 0 ||
-			cl->reader->r_usr[0] == 0 || cl->reader->r_port == 0)
-		{ return -5; }
-
+		 cl->reader->r_usr [0] == 0 || cl->reader->r_port == 0) {
+		return -5;
+	}
 	// 1. Connect
 	handle = network_tcp_connection_open(cl->reader);
-	if(handle < 0) { return -1; }
+	if (handle < 0) return -1;
 
 	// 2. Get init sequence
 	cl->ncd_msgid = 0;
-	if(read(handle, keymod, sizeof(keymod)) != sizeof(keymod))
-	{
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_AVATARCAMD(cl->reader->ncd_exprotocol)) keymodsize = 64;
+#endif
+
+#if defined(WITH_HISILICON)
+	i = network_recvpoll(handle, keymod, keymodsize);
+	if (i < 0) return -1; // errors during receive!
+	if (i != keymodsize) {
 		cs_log("server does not return 14 bytes");
 		network_tcp_connection_close(cl->reader, "connect error");
 		return -2;
 	}
+#else
+	if (read(handle, keymod, keymodsize) != keymodsize) {
+		cs_log("server does not return 14 bytes");
+		network_tcp_connection_close(cl->reader, "connect error");
+		return -2;
+	}
+#endif
+
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_AVATARCAMD(cl->reader->ncd_exprotocol)) {
+		keymod[ 0] = keymod[ 5];
+		keymod[ 1] = keymod[ 8];
+		keymod[ 2] = keymod[14];
+		keymod[ 3] = keymod[19];
+		keymod[ 4] = keymod[24];
+		keymod[ 5] = keymod[26];
+		keymod[ 6] = keymod[28];
+		keymod[ 7] = keymod[32];
+		keymod[ 8] = keymod[34];
+		keymod[ 9] = keymod[42];
+		keymod[10] = keymod[48];
+		keymod[11] = keymod[53];
+		keymod[12] = keymod[57];
+		keymod[13] = keymod[61];
+	}
+#endif
 	cs_log_dump_dbg(D_CLIENT, keymod, sizeof(cl->reader->ncd_key), "server init sequence:");
 	des_login_key_get(keymod, cl->reader->ncd_key, sizeof(cl->reader->ncd_key), key);
 
@@ -431,8 +659,20 @@
 	__md5_crypt(cl->reader->r_pwd, "$1$abcdefgh$", (char *)passwdcrypt);
 	idx += strlen(cl->reader->r_usr) + 1;
 	cs_strncpy((char *)buf + idx, (const char *)passwdcrypt, sizeof(buf) - idx);
-
-	network_message_send(handle, 0, buf, idx + strlen((char *)passwdcrypt) + 1, key,
+	len  = idx+strlen((char *)passwdcrypt)+1;
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_AVATARCAMD(cl->reader->ncd_exprotocol))
+	{
+		buf[len+0] = 0x76; 	// client ID
+		buf[len+1] = 0x45;	// client ID
+		buf[len+2] = 0x0;
+		buf[len+3] = 0x24;	// device ID
+		buf[len+4] = 0x84;	// device ID
+		buf[len+5] = 0x0;
+		len += 6;
+	}
+#endif
+	network_message_send(handle, 0, buf, len, key,
 						 COMMTYPE_CLIENT, NCD_CLIENT_ID, NULL);
 
 	// 3.1 Get login answer
@@ -440,7 +680,12 @@
 				   key, COMMTYPE_CLIENT);
 	if(login_answer == MSG_CLIENT_2_SERVER_LOGIN_NAK)
 	{
-		cs_log("login failed for user '%s'", cl->reader->r_usr);
+		if (cfg.logsvrsecrete) {
+			cs_log_sensitive("login failed for user {%s}", cl->reader->r_usr);
+		}
+		else {
+			cs_log("login failed for user %s", cl->reader->r_usr);
+		}
 		network_tcp_connection_close(cl->reader, "login error1");
 		return -3;
 	}
@@ -453,6 +698,7 @@
 	}
 
 	// 3.2 Set connection info
+	cl->reader->ftab.nfilts = 0;
 	cl->reader->tcp_connected = 1;
 	cl->crypted = 1;
 
@@ -470,14 +716,27 @@
 		network_tcp_connection_close(cl->reader, "receive error");
 		return -4;
 	}
-
+	cs_prdump("MSG_CARD_DATA_REQ", buf, bytes_received);
 	// 5. Parse CAID and PROVID(s)
 	cl->reader->caid = (uint16_t)((buf[6] << 8) | buf[7]);
 
 	/* handle special serial format in newcamd. See newcamd_auth_client */
 	newcamd_to_hexserial(buf + 10, cl->reader->hexserial, cl->reader->caid);
-	cs_log("Newcamd Server: %s:%d - UserID: %i", cl->reader->device, cl->reader->r_port, buf[3 + 2]);
-	cs_log("CAID: %04X - UA: %02X%02X%02X%02X%02X%02X%02X%02X - Provider # %i", cl->reader->caid, cl->reader->hexserial[0], cl->reader->hexserial[1], cl->reader->hexserial[2], cl->reader->hexserial[3], cl->reader->hexserial[4], cl->reader->hexserial[5], cl->reader->hexserial[6], cl->reader->hexserial[7], buf[14 + 2]);
+	if (cfg.logsvrsecrete) {
+		rdr_log_tildes(cl->reader, "%s Server: {%s},{%d} - UserID: %i",
+				reader_get_type_desc(cl->reader,1),
+				cl->reader->device, cl->reader->r_port, buf[3+2]);
+	}
+	else {
+		rdr_log(cl->reader, "%s Server: %s:%d - UserID: %i",
+				reader_get_type_desc(cl->reader,1),
+				cl->reader->device, cl->reader->r_port, buf[3+2]);
+	}
+	rdr_log_sensitive(cl->reader, "CAID: %04X - UA: {%02X%02X%02X%02X%02X%02X%02X%02X} - Provider # %i",
+			cl->reader->caid,
+			cl->reader->hexserial[0], cl->reader->hexserial[1], cl->reader->hexserial[2], cl->reader->hexserial[3], cl->reader->hexserial[4], cl->reader->hexserial[5], cl->reader->hexserial[6], cl->reader->hexserial[7],
+			buf[14+2]);
+
 	cl->reader->nprov = buf[14 + 2];
 	memset(cl->reader->prid, 0x00, sizeof(cl->reader->prid));
 	for(i = 0; i < cl->reader->nprov; i++)
@@ -493,8 +752,41 @@
 			cl->reader->prid[i][3] = buf[17 + 2 + 11 * i];
 		}
 		memcpy(&cl->reader->sa[i], buf + 22 + 2 + 11 * i, 4); // the 4 first bytes are not read
-		cs_log("Provider ID: %02X%02X%02X - SA: %02X%02X%02X%02X", cl->reader->prid[i][1],  cl->reader->prid[i][2], cl->reader->prid[i][3], cl->reader->sa[i][0], cl->reader->sa[i][1], cl->reader->sa[i][2], cl->reader->sa[i][3]);
+		rdr_log_sensitive(cl->reader, "Provider ID: %02X%02X%02X - SA: {%02X%02X%02X%02X}",
+				cl->reader->prid[i][1], cl->reader->prid[i][2], cl->reader->prid[i][3],
+				cl->reader->sa[i][0], cl->reader->sa[i][1], cl->reader->sa[i][2], cl->reader->sa[i][3]);
+	}
+
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_MAVATARCAMD(cl->reader->ncd_exprotocol)) {
+		uint16_t casid, portno;
+		uint32_t ppid;
+
+		cl->ncd_proto = NCD_525;
+		for (i=0; i< 256; i++) {
+			bytes_received = mavatarcamd_cas_inforeceive(handle, &cl->ncd_msgid, buf,
+	                           key, COMMTYPE_CLIENT,
+										&casid, &ppid, &portno);
+			if (bytes_received <= 0) break;
+			mavatarcamd_cas_addfilters(cl->reader, casid, ppid);
+		}
+		#if __ADB_TRACE__
+			for (i=0; i<cl->reader->ftab.nfilts; i++) {
+				if (cl->reader->ftab.filts[i].nprids < 2) {
+					myprintf("%3d. CASID: %04X:%06X\n", i, cl->reader->ftab.filts[i].caid, cl->reader->ftab.filts[i].prids[0]);
+				}
+				else {
+					myprintf("%3d. CASID: %04X\n", i, cl->reader->ftab.filts[i].caid);
+					int k;
+					for (k=0; k<cl->reader->ftab.filts[i].nprids; k++) {
+						myprintf("            :%06X\n", cl->reader->ftab.filts[i].prids[k]);
 	}
+				}
+			}
+		#endif
+	}
+#endif
+
 	memcpy(cl->reader->ncd_skey, key, 16);
 
 	// 6. Set card inserted
@@ -505,12 +797,15 @@
 	// Only after connect() on cl->udp_fd (Linux)
 	cl->pfd = cl->udp_fd;
 
-	if(cl->reader->ncd_disable_server_filt)    //act like mgclient
-	{
-		network_cmd_no_data_send(handle, &cl->ncd_msgid, MSG_SERVER_2_CLIENT_GET_VERSION,
-								 key, COMMTYPE_CLIENT);
-	}
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_MAVATARCAMD(cl->reader->ncd_exprotocol)) return 0;
+#endif
 
+	if (cl->reader->ncd_disable_server_filt) { // act like mgclient
+// sky(2016.03.07)
+//		network_cmd_no_data_send(handle, &cl->ncd_msgid, MSG_SERVER_2_CLIENT_GET_VERSION,
+//	                          key, COMMTYPE_CLIENT);
+	}
 	return 0;
 }
 
@@ -518,12 +813,21 @@
 {
 	struct s_client *cl = cur_client();
 
-	if(cl->reader->tcp_connected < 2 && connect_newcamd_server() < 0)
-		{ return 0; }
-
-	if(!cl->udp_fd)
-		{ return 0; }
-
+	if (cl->reader->tcp_connected < 2) {
+#if defined(MODULE_AVAMGCAMD)
+//		myprintf("xxx=%d, %d\n", cl->reader->ncd_exprotocol, cl->reader->ncd_exregistration);
+		if (IS_AVATARCAMD(cl->reader->ncd_exprotocol))
+		{
+			if (!cs_Isxx(cl->reader->ncd_exkey, 5)) return 0;
+			if (!chk_reader_devices(cl->reader)) cl->reader->ncd_exregistration = 0;
+			if (!cl->reader->ncd_exregistration) {
+				if (!avatarcamd_activation(cl->reader)) return 0;
+			}
+		}
+#endif
+		if (newcamd_connect_server() < 0) return 0;
+	}
+	if (!cl->udp_fd) return 0;
 	return 1;
 }
 
@@ -532,13 +836,23 @@
 {
 	struct s_client *cl = cur_client();
 
-	if(!newcamd_connect())
-		{ return (-1); }
+	if (!newcamd_connect()) return (-1);
 
 	return (network_message_send(cl->udp_fd, &cl->ncd_msgid,
 								 buf, ml, cl->reader->ncd_skey, COMMTYPE_CLIENT, sid, NULL));
 }
 
+
+static int32_t newcamd_sendto(uchar *buf, int32_t ml, uint16_t sid, custom_data_t *cd)
+{
+	struct s_client *cl = cur_client();
+
+	if (!newcamd_connect()) return (-1);
+
+	return (network_message_send(cl->udp_fd, &cl->ncd_msgid,
+					buf, ml, cl->reader->ncd_skey, COMMTYPE_CLIENT, sid, cd));
+}
+
 static int32_t newcamd_recv(struct s_client *client, uchar *buf, int32_t UNUSED(l))
 {
 	int32_t rc, rs;
@@ -551,14 +865,14 @@
 	}
 	else
 	{
-		if(!client->udp_fd) { return (-1); }
+		if (!client->udp_fd) return (-1);
 		rs = network_message_receive(client->udp_fd,
 									 &client->ncd_msgid, buf,
 									 client->reader->ncd_skey, COMMTYPE_CLIENT);
 	}
 
-	if(rs < 5) { rc = (-1); }
-	else { rc = rs; }
+	if (rs<5) rc=(-1);
+	else rc=rs;
 
 	cs_log_dump_dbg(D_CLIENT, buf, rs, "received %d bytes from %s", rs, remote_txt());
 	client->last = time((time_t *) 0);
@@ -566,9 +880,9 @@
 	if(rc == -1)
 	{
 		if(rs > 0)
-			{ cs_log("packet is too small (%d bytes)", rs); }
+			cs_log("packet is too small (%d bytes)", rs);
 		else
-			{ cs_log("Connection closed to %s", remote_txt()); }
+			cs_log("Connection closed to %s", remote_txt());
 	}
 	return (rc);
 }
@@ -784,11 +1098,12 @@
 	if(cl->ncd_client_id == 0x4453)     // DiabloWifi has problems with TCPKeepAlive
 	{
 		int32_t flag = 600;
-		if(setsockopt(cl->udp_fd, IPPROTO_TCP, TCP_KEEPIDLE, &flag, sizeof(flag)) && errno != EBADF)    //send first keepalive packet after 600 seconds of last package received (keepalive packets included)
-		{
+		if (setsockopt(cl->udp_fd, IPPROTO_TCP, TCP_KEEPIDLE, &flag, sizeof(flag)) && errno != EBADF) {	//send first keepalive packet after 600 seconds of last package received (keepalive packets included)
 			cs_log("Setting TCP_KEEPIDLE failed, errno=%d, %s", errno, strerror(errno));
 		}
-		else { cs_log("WARNING: Setting TCP_KEEPIDLE to 10 minutes for bugged DiabloWifi. Note that this might lead to not detected broken connections or multiple connections."); }
+		else {
+			cs_log("WARNING: Setting TCP_KEEPIDLE to 10 minutes for bugged DiabloWifi. Note that this might lead to not detected broken connections or multiple connections.");
+		}
 	}
 #endif
 
@@ -810,8 +1125,7 @@
 				cl->crypted = 1;
 				char e_txt[20];
 				snprintf(e_txt, 20, "%s:%d", "newcamd", cfg.ncd_ptab.ports[cl->port_idx].s_port);
-				if((rc = cs_auth_client(cl, account, e_txt)) == 2)
-				{
+				if ((rc = cs_auth_client(cl, account, e_txt)) == 2) {
 					cs_log("hostname or ip mismatch for user %s (%s)", usr, client_name);
 					break;
 				}
@@ -827,8 +1141,9 @@
 					break;
 				}
 			}
-			else
-				{ cs_log("user %s is providing a wrong password (%s)", usr, client_name); }
+			else {
+				cs_log("user %s is providing a wrong password (%s)", usr, client_name);
+			}
 		}
 	}
 
@@ -839,14 +1154,11 @@
 	}
 
 	// check for non ready reader and reject client
-	for(rdr = first_active_reader; rdr ; rdr = rdr->next)
-	{
+	for (rdr=first_active_reader; rdr; rdr=rdr->next) {
 		if(!cfg.ncd_ptab.ports[cl->port_idx].ncd)
-			{ continue; }
-		if(rdr->caid == cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].caid)
-		{
-			if(rdr->card_status == CARD_NEED_INIT)
-			{
+			continue;
+		if (rdr->caid==cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].caid) {
+			if (rdr->card_status == CARD_NEED_INIT) {
 				cs_log("init for reader %s not finished -> reject client", rdr->label);
 				ok = 0;
 			}
@@ -861,25 +1173,22 @@
 		{
 			int32_t n;
 			if(!cfg.ncd_ptab.ports[cl->port_idx].ncd)
-				{ continue; }
+				continue;
 			for(n = 0; n < cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].nprids; n++)
 			{
-				if(emm_reader_match(rdr, cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].caid, cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].prids[n]))
-				{
+				if (emm_reader_match(rdr, cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].caid, cfg.ncd_ptab.ports[cl->port_idx].ncd->ncd_ftab.filts[0].prids[n])) {
 					aureader = rdr;
 					break;
 				}
 			}
 			if(aureader)
-				{ break; }
+				break;
 		}
 
-		if(aureader)
-		{
+		if (aureader) {
 			cs_log("AU enabled for user %s on reader %s", usr, aureader->label);
 		}
-		else
-		{
+		else {
 			cs_log("AU disabled for user %s", usr);
 		}
 	}
@@ -1052,8 +1361,7 @@
 	uint16_t cl_msgid;
 	uchar mbuf[19];
 
-	if(!client->udp_fd)
-	{
+	if (!client->udp_fd) {
 		cs_log_dbg(D_CLIENT, "ncd_send_dcw: error: client->udp_fd=%d", client->udp_fd);
 		return;
 	}
@@ -1083,8 +1391,7 @@
 	int32_t pi;
 	ECM_REQUEST *er;
 
-	if(!(er = get_ecmtask()))
-	{
+	if (!(er = get_ecmtask())) {
 		return;
 	}
 	// save client ncd_msgid
@@ -1094,11 +1401,10 @@
 	er->srvid = cl->ncd_header[4] << 8 | cl->ncd_header[5];
 	er->caid = cl->ncd_header[6] << 8 | cl->ncd_header[7];
 	er->prid = cl->ncd_header[8] << 16 | cl->ncd_header[9] << 8 | cl->ncd_header[10];
-	if(!er->caid)
-	{
+	if (!er->caid) {
 		pi = cl->port_idx;
 		if(cfg.ncd_ptab.nports && cfg.ncd_ptab.nports >= pi && cfg.ncd_ptab.ports[pi].ncd)
-			{ er->caid = cfg.ncd_ptab.ports[pi].ncd->ncd_ftab.filts[0].caid; }
+		  	er->caid=cfg.ncd_ptab.ports[pi].ncd->ncd_ftab.filts[0].caid;
 	}
 	memcpy(er->ecm, buf + 2, er->ecmlen);
 	get_cw(cl, er);
@@ -1143,11 +1449,11 @@
 	    }
 	    if( !ok ) cs_log("only EMM-S supported");
 	  }
-	  else*/
-
+	else
+*/
 	memcpy(epg.emm, buf, epg.emmlen);
 	if(ok)
-		{ do_emm(cl, &epg); }
+		do_emm(cl, &epg);
 
 	// Should always send an answer to client (also if au is disabled),
 	// some clients will disconnect if they get no answer
@@ -1163,7 +1469,7 @@
 	uint8_t buf[512];
 	custom_data_t *cd;
 	if(!cs_malloc(&cd, sizeof(struct custom_data)))
-		{ return; }
+		return;
 	memset(buf, 0, sizeof(buf));
 
 	cd->sid = cfg.ncd_ptab.ports[client->port_idx].s_port;
@@ -1173,7 +1479,7 @@
 	for(rdr = first_active_reader; rdr ; rdr = rdr->next)
 	{
 		int32_t flt = 0;
-		if(!(rdr->grp & client->grp)) { continue; }  //test - skip unaccesible readers
+		if (!(rdr->grp & client->grp)) continue; //test - skip unaccesible readers
 		if(rdr->ftab.filts)
 		{
 			for(j = 0; j < rdr->ftab.nfilts; j++)
@@ -1181,14 +1487,12 @@
 				if(rdr->ftab.filts[j].caid)
 				{
 					cd->caid = rdr->ftab.filts[j].caid;
-					if(!rdr->ftab.filts[j].nprids)
-					{
+					if (!rdr->ftab.filts[j].nprids) {
 						cd->provid = 0;
 						cs_log_dbg(D_CLIENT, "newcamd: extended: report card %04X:%06X svc", cd->caid, cd->provid);
 						network_message_send(client->udp_fd, &client->ncd_msgid, buf, 3, client->ncd_skey, COMMTYPE_SERVER, 0, cd);
 					}
-					for(k = 0; k < rdr->ftab.filts[j].nprids; k++)
-					{
+					for (k=0; k<rdr->ftab.filts[j].nprids; k++) {
 						cd->provid = rdr->ftab.filts[j].prids[k];
 						cs_log_dbg(D_CLIENT, "newcamd: extended: report card %04X:%06X svc", cd->caid, cd->provid);
 						network_message_send(client->udp_fd, &client->ncd_msgid, buf, 3, client->ncd_skey, COMMTYPE_SERVER, 0, cd);
@@ -1253,26 +1557,22 @@
 	client->ncd_server = 1;
 	cs_log("client connected to %d port", cfg.ncd_ptab.ports[client->port_idx].s_port);
 
-	if(cfg.ncd_ptab.ports[client->port_idx].ncd && cfg.ncd_ptab.ports[client->port_idx].ncd->ncd_key_is_set)
-	{
+	if (cfg.ncd_ptab.ports[client->port_idx].ncd && cfg.ncd_ptab.ports[client->port_idx].ncd->ncd_key_is_set) {
 		//port has a des key specified
 		res = newcamd_auth_client(client->ip, cfg.ncd_ptab.ports[client->port_idx].ncd->ncd_key);
 	}
-	else
-	{
+	else {
 		//default global des key
 		res = newcamd_auth_client(client->ip, cfg.ncd_key);
 	}
 
-	if(res == -1)
-	{
+	if (res == -1) {
 		cs_disconnect_client(client);
 		return;
 	}
 
 	// report all cards if using extended mg proto
-	if(cfg.ncd_mgclient)
-	{
+	if (cfg.ncd_mgclient) {
 		cs_log_dbg(D_CLIENT, "newcamd: extended: report all available cards");
 		newcamd_report_cards(client);
 	}
@@ -1299,12 +1599,11 @@
 	// befor client was disconnected. If keepalive was disabled, exit after clienttimeout
 
 	if(len < 3)
-		{ return NULL; }
+		return NULL;
 
 	cs_log_dbg(D_CLIENT, "newcamd: got cmd %d", mbuf[2]);
 
-	switch(mbuf[2])
-	{
+	switch (mbuf[2]) {
 	case 0x80:
 	case 0x81:
 		newcamd_process_ecm(client, mbuf, len);
@@ -1321,9 +1620,8 @@
 
 	default:
 		if(mbuf[2] > 0x81 && mbuf[2] < 0x90)
-			{ newcamd_process_emm(mbuf + 2); }
-		else
-		{
+				newcamd_process_emm(mbuf+2);
+			else {
 			cs_log_dbg(D_CLIENT, "unknown newcamd command! (%d)", mbuf[2]);
 		}
 	}
@@ -1336,25 +1634,22 @@
 	struct s_client *client = cur_client();
 	struct s_reader *rdr = client->reader;
 
-	if(!rdr) { return; }
+	if (!rdr) return;
 
-	if(rdr->tcp_ito > 0)
-	{
+	if (rdr->tcp_ito > 0) {
 		// inactivitytimeout > 0 enables protocol keepalive packages
 		time_t now;
 		int32_t time_diff;
 		time(&now);
 		time_diff = llabs(now - rdr->last_s);
-		if(time_diff > (rdr->tcp_ito))
-		{
+		if (time_diff>(rdr->tcp_ito)) {
 			if(client->ncd_keepalive)
-				{ newcamd_reply_ka(); }
+				newcamd_reply_ka();
 			else
-				{ network_tcp_connection_close(client->reader, "inactivity"); }
+				network_tcp_connection_close(client->reader, "inactivity");
 		}
 	}
-	else if(rdr->tcp_ito == -1)
-	{
+	else if (rdr->tcp_ito == -1) {
 		// idle reconnect
 		newcamd_connect();
 	}
@@ -1371,14 +1666,21 @@
 
 	client->ncd_proto = client->reader->ncd_proto;
 
-	cs_log("proxy %s:%d newcamd52%d (fd=%d%s)",
+	if (cfg.logsvrsecrete) {
+		cs_log_sensitive("proxy {%s},{%d} newcamd52%d (fd=%d%s)",
 		   client->reader->device, client->reader->r_port,
 		   (client->reader->ncd_proto == NCD_525) ? 5 : 4, client->udp_fd, ptxt);
-
+	}
+	else {
+		cs_log("proxy %s,%d newcamd52%d (fd=%d%s)",
+		       client->reader->device, client->reader->r_port,
+		      (client->reader->ncd_proto==NCD_525)?5:4, client->udp_fd, ptxt);
+	}
+	cs_log("  newcamd:%d,%d", client->reader->ncd_connect_on_init, client->reader->tcp_ito);
 	// try to connect. ignore possible failures
 	// idle reconnect (tcp_ito = -1) will trigger an additional connect anyway
 	if(client->reader->ncd_connect_on_init && client->reader->tcp_ito != -1)
-		{ newcamd_connect(); }
+		newcamd_connect();
 
 	return (0);
 }
@@ -1386,13 +1688,12 @@
 static int32_t newcamd_send_ecm(struct s_client *client, ECM_REQUEST *er, uchar *buf)
 {
 	struct s_reader *rdr = client->reader;
+	int returnval;
 
-	if(!newcamd_connect())
-		{ return (-1); }
+  	if (!newcamd_connect()) return (-1);
 
 	// check server filters
-	if(!chk_rsfilter(rdr, er))
-		{ return (-1); }
+	if (!chk_rsfilter(rdr, er)) return (-2);
 
 	memcpy(buf, er->ecm, er->ecmlen);
 
@@ -1403,8 +1704,20 @@
 	client->ncd_header[8] = er->prid >> 16;
 	client->ncd_header[9] = er->prid >> 8;
 	client->ncd_header[10] = er->prid & 0xFF;
-
-	return ((newcamd_send(buf, er->ecmlen, er->srvid) < 1) ? (-1) : 0);
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_MAVATARCAMD(rdr->ncd_exprotocol)) {
+		custom_data_t cd;
+		cd.sid    = er->srvid;
+		cd.caid   = er->caid;
+		cd.provid = er->exprid;
+		returnval = newcamd_sendto(buf, er->ecmlen, er->srvid, &cd);
+	}
+	else
+#endif
+	{
+		returnval = newcamd_send(buf, er->ecmlen, er->srvid);
+	}
+	return ((returnval < 1) ? (-1) : 0);
 }
 
 
@@ -1413,7 +1726,7 @@
 	uchar buf[ep->emmlen];
 
 	if(!newcamd_connect())
-		{ return (-1); }
+		return (-1);
 
 	memcpy(buf, ep->emm, ep->emmlen);
 	return ((newcamd_send(buf, ep->emmlen, 0) < 1) ? 0 : 1);
@@ -1422,25 +1735,23 @@
 static int32_t newcamd_recv_chk(struct s_client *client, uchar *dcw, int32_t *rc, uchar *buf, int32_t n)
 {
 	uint16_t idx = -1;
+	int lenn;
 
 	if(n < 5)
-		{ return -1; }
+		return -1;
 
-	switch(buf[2])
-	{
+	switch (buf[2]) {
 	case 0x80:
 	case 0x81:
 		idx = (buf[0] << 8) | buf[1];
-		if(n == 5)  //not found on server
-		{
+		  	if (n==5) { //not found on server
 			*rc = 0;
 			memset(dcw, 0, 16);
 			break;
 		}
 
-		if(n < 21)
-		{
-			cs_log_dbg(D_CLIENT, "invalid newcamd answer");
+		  	if (n<21) {
+		    	cs_log_dbg(D_CLIENT, "invalid newcamd cw answer");
 			return (-1);
 		}
 
@@ -1452,35 +1763,251 @@
 		return -1;
 
 	case MSG_SERVER_2_CLIENT_ADDCARD:
-		if(client->reader)
-		{
+			if (client->reader) {
 			client->reader->ncd_disable_server_filt = 1;
 		}
 		return -1;
+		// sky()
+		case MSG_SERVER_2_CLIENT_GET_VERSION: // 0xD6
+			lenn = (buf[3]<<8) | buf[4];
+			if (lenn>EXT_VERSION_LEN) lenn = EXT_VERSION_LEN;
+			strncpy(client->reader->ncd_version, (char *)&buf[5], lenn);
+			client->reader->ncd_version[lenn] = 0;
+		  	cs_log_dbg(D_CLIENT, "newcamd version %s from server", client->reader->ncd_version);
+		  	return -1;
+
+		case MSG_SERVER_2_CLIENT_OSD:
+#if defined(MODULE_AVAMGCAMD)
+			if (IS_MAVATARCAMD(client->reader->ncd_exprotocol)) {
+				memcpy(client->reader->ncd_clientmessages, &buf[5], buf[4]);
+				client->reader->ncd_clientmessages[buf[4]+1] = 0;
+				myprintf("ncd_clientmessages = %s\n", (char *)client->reader->ncd_clientmessages);
+			}
+#endif
+			return -1; // 0xD1
 
 	default:
-		if(buf[2] > 0x81 && buf[2] < 0x90)  //answer to emm
-		{
+		  	if (buf[2]>0x81 && buf[2]<0x90) { // answer to emm
 			return -1;
 		}
-		cs_log_dbg(D_CLIENT, "unknown newcamd command from server");
+		  	cs_log_dbg(D_CLIENT, "unknown newcamd command{%02X} from server", buf[2]);
 		return -1;
 	}
 	return (idx);
 }
 
+
+// sky(n)
+int32_t newcamd_cAvailable(struct s_reader *rdr, int32_t checktype, ECM_REQUEST *er)
+{
+	if (!er)  return 0;
+	if (!rdr) return 0;
+	if (checktype == AVAIL_CHECK_CONNECTED) {
+//		#if defined(MODULE_AVAMGCAMD)
+//		if (IS_MAVATARCAMD(rdr->ncd_exprotocol)) return 1;
+//		#endif
+//		if (rdr->ncd_connect_on_init) {
+//			if (!rdr->ncd_disable_server_filt) {
+//				if (!chk_cafilters(rdr, er)) return 0;
+//			}
+//		}
+	}
+	return 1;
+}
+
+#if defined(MODULE_AVAMGCAMD)
+//	#define	__AVATAR_SIMULATION__
+#ifdef __AVATAR_SIMULATION__
+static uint8_t avatar_simulation_message[0x186] = {
+							0xe3,0xee,0xe7,0xfd,0xe0,0xf7,0xf5,0xbb,0xa1,0xfa,0xa1,0xb8,0xa1,0xfc,0xa1,0xfa,
+							0xa1,0xb0,0xb6,0xb0,0xb8,0xb8,0xa1,0xfc,0xa1,0xfa,0xa1,0xed,0xe0,0xf2,0xf5,0xe5,
+							0xf3,0xe4,0xe0,0xec,0xaf,0xe0,0xf7,0xe0,0xf5,0xe0,0xf3,0xe2,0xe0,0xec,0xe9,0xe5,
+							0xaf,0xe2,0xee,0xec,0xa1,0xfc,0xa1,0xfa,0xa1,0xeb,0xee,0xef,0xe4,0xe4,0xf5,0xe4,
+							0xf2,0xf5,0xb1,0xb1,0xb1,0xb1,0xb4,0xa1,0xfc,0xa1,0xfa,0xa1,0xb9,0xb4,0xb7,0xb7,
+							0xb7,0xb6,0xb5,0xb2,0xb5,0xb0,0xa1,0xfc,0xa1,0xfa,0xa1,0xb0,0xb0,0xa1,0xb1,0xb3,
+							0xa1,0xb0,0xb2,0xa1,0xb1,0xb5,0xa1,0xb0,0xb4,0xa1,0xb1,0xb7,0xa1,0xb0,0xb6,0xa1,
+							0xb1,0xb9,0xa1,0xb0,0xb8,0xa1,0xb0,0xb1,0xa1,0xb3,0xb0,0xa1,0xb0,0xb3,0xa1,0xb3,
+							0xb2,0xa1,0xb0,0xb5,0xa1,0xfc,0xa1,0xfa,0xa1,0xb1,0xa1,0xfc,0xfd,0xe7,0xf5,0xf1,
+							0xbb,0xa1,0xfa,0xa1,0xb0,0xa1,0xfc,0xa1,0xfa,0xa1,0xb3,0xb0,0xa1,0xfc,0xa1,0xfa,
+							0xa1,0xe7,0xf5,0xf1,0xaf,0xe2,0xee,0xec,0xe8,0xf9,0xac,0xe5,0xf7,0xe3,0xaf,0xe2,
+							0xee,0xec,0xa1,0xfc,0xa1,0xa1,0xfa,0xa1,0xe0,0xef,0xee,0xef,0xf8,0xec,0xee,0xf4,
+							0xf2,0xa1,0xfc,0xa1,0xfa,0xa1,0xf4,0xf2,0xe4,0xf3,0xc1,0xe9,0xee,0xf2,0xf5,0xa1,
+							0xfc,0xa1,0xfa,0xa1,0xe2,0xee,0xec,0xe8,0xf9,0xa1,0xfc,0xa1,0xfa,0xa1,0xb0,0xa1,
+							0xfc,0xfd,0xf6,0xe9,0xe5,0xbb,0xfa,0xa1,0xb0,0xa1,0xfc,0xa1,0xfa,0xa1,0xb1,0xa1,
+							0xfc,0xa1,0xfa,0xa1,0xec,0xe4,0xe5,0xe8,0xe0,0xaf,0xe2,0xee,0xec,0xe8,0xf9,0xac,
+							0xe5,0xf7,0xe3,0xaf,0xe2,0xee,0xec,0xae,0xe2,0xee,0xec,0xe8,0xf9,0xa1,0xfc,0xa1,
+							0xfa,0xa1,0xe2,0xee,0xec,0xe8,0xf9,0xa1,0xfc,0xa1,0xfa,0xa1,0xe2,0xee,0xec,0xe8,
+							0xf9,0xb8,0xb8,0xb8,0xe9,0xe5,0xa1,0xfc,0xa1,0xfa,0xa1,0xb1,0xb1,0xa1,0xfc,0xa1,
+							0xfa,0xa1,0xb0,0xa1,0xfc,0xfd,0xe0,0xe2,0xf5,0xbb,0xfa,0xa1,0xb0,0xa1,0xfc,0xa1,
+							0xfa,0xa1,0xb0,0xb3,0xb4,0xb0,0xb3,0xa1,0xfc,0xa1,0xfa,0xa1,0xe0,0xe2,0xf5,0xe8,
+							0xf7,0xe4,0xaf,0xe2,0xee,0xec,0xe8,0xf9,0xac,0xe5,0xf7,0xe3,0xaf,0xe2,0xee,0xec,
+							0xa1,0xfc,0xa1,0xfa,0xa1,0xb1,0xb1,0xa1,0xfc,0xa1,0xfa,0xa1,0xb1,0xb1,0xa1,0xfc,
+							0xa1,0xfa,0xa1,0xb1,0xb1,0xa1,0xfc,0xa1,0xfa,0xa1,0xb0,0xa1,0xfc,0xfd,0xe4,0xee,
+							0xe7,0xfd,0xe4,0xee,0xf2,0x0d,
+};
+#endif
+
+static int32_t
+avatarcamd_register_parser(struct s_reader *reader, char *messages, int msgsize)
+{
+	int  start, end;
+	int  i, j,k;
+	int  Avtidx = 0;
+	int  Avtfound = 0;
+	int  Avtcompleted = 0;
+
+	start = end = 0;
+	for (i=0; i<msgsize; i++)
+	{
+		/* "avt:", "ftp:", "whd:", "act:" ....*/
+		if (!strncmp(&messages[i],"avt:",4))
+		{
+			myprintf("avtarcamd:FIND Avt packet.\n");
+			Avtfound = 1;
+		}
+		else if (messages[i]=='{')
+		{
+			start = i;
+		}
+		else if (messages[i]=='}')
+		{
+			end = i;
+			Avtidx++;
+			myascdump("avtarcamd:parse", &messages[start], end-start+1);
+			switch (Avtidx)
+			{
+				case 1:
+					break;
+				case 2:
+					if (!Avtfound) break;
+					reader->r_port = cs_a2i(&messages[start+2], end-start-1);
+					myprintf("avtarcamd:server Port : %d\n", reader->r_port);
+					break;
+				case 3:
+					if (!Avtfound) break;
+					memcpy(reader->device, &messages[start+2], end-start-1);
+					reader->device[end-(start+3)] = 0;
+					myprintf("avtarcamd:server hostname : %s\n", reader->device);
+					break;
+				case 4:
+					if (!Avtfound) break;
+					memcpy(reader->r_usr, &messages[start+2], end-start-1);
+					reader->r_usr[end-(start+3)] = 0;
+					myprintf("avtarcamd:server username : %s\n", reader->r_usr);
+					break;
+				case 5:
+					if (!Avtfound) break;
+					memcpy(reader->r_pwd, &messages[start+2], end-start-1);
+					reader->r_pwd[end-(start+3)] = 0;
+					myprintf("avtarcamd:server password : %s\n", reader->r_pwd);
+					break;
+				case 6:
+					if (!Avtfound) break;
+					for(k=0,j=start+2; j<end; j+=3, k++){
+						cs_atob(&reader->ncd_key[k], &messages[j], 1);
+					}
+					Avtcompleted = 1;
+					myprdump("avtarcamd:server DESKEY : ", reader->ncd_key, 14);
+					break;
+				default:
+					break;
+
+			}
+			if (Avtcompleted) break;
+		}
+	}
+	return Avtfound;
+}
+
+static int32_t
+avatarcamd_registration(struct s_reader *reader, int32_t sockfd)
+{
+	uint32_t	ip = 0;
+	uint8_t 	macaddress[6];
+	uint8_t	securityid[32];
+	char 		activecode[256];
+	uint8_t	recvbuf[512];
+	int 		lenn,i;
+	int 		returncode = 0;
+
+//	Read_SD_ID(securityid); put own your device ID.
+	memset(securityid,0,32);
+	memset(macaddress, 0, sizeof(macaddress));
+	network_chk_intefaces(&ip, macaddress);
+	sprintf(activecode,
+				"%02x%02x%02x%02x%02x|absm%02x%02x%02x%02x%02x%02x%02x%02x|%02x%02x%02x%02x%02x%02x|C5",
+				reader->ncd_exkey[0],
+				reader->ncd_exkey[1],
+				reader->ncd_exkey[2],
+				reader->ncd_exkey[3],
+				reader->ncd_exkey[4],
+				securityid[0],securityid[1],securityid[2],securityid[3],securityid[4],securityid[5],securityid[6],securityid[7],
+				macaddress[0],macaddress[1],macaddress[2],macaddress[3],macaddress[4],macaddress[5]);
+	myprintf("avtarcamd:Avart KEY : %s\n", activecode);
+	for(i=0; i<(int)strlen(activecode); i++) {
+		activecode[i] = activecode[i]^0x81;
+	}
+
+	if ((lenn = send(sockfd, activecode, sizeof(activecode),0)) < 0) {
+		myprintf("avatarcamd:register send failure\n");
+		return -1;
+	}
+	lenn = network_recvpoll(sockfd, recvbuf, sizeof(recvbuf)-1);
+	if (lenn <= 0) {
+		myprintf("avatarcamd:register recv failure\n");
+		return -1;
+	}
+	#ifdef __AVATAR_SIMULATION__
+		lenn = sizeof(avatar_simulation_message);
+		memcpy(recvbuf, avatar_simulation_message, sizeof(avatar_simulation_message));
+	#endif
+//	myprdump("RANDOM DATA", recvbuf, lenn);
+	for (i=0; i<lenn; i++) {
+		recvbuf[i] = recvbuf[i]^0x81;
+	}
+	recvbuf[lenn] = 0;
+	myascdump("RANDOM decode", recvbuf, lenn);
+	returncode = avatarcamd_register_parser(reader, (char *)recvbuf, lenn);
+	if (returncode==0) {
+		mycs_trace(D_TRACE, "avatarcamd:activation failure");
+		return -1;
+	}
+	return returncode;
+}
+
+static int32_t
+avatarcamd_activation(struct s_reader *reader)
+{
+	const char register_server[32] = "hybrid.crombocode.com";
+	int32_t register_port = 12512;
+	int32_t sockfd;
+	int32_t registered = 0;
+
+	mycs_trace(D_TRACE, "avatarcamd:avatarcamd_activation");
+	sockfd = network_tcp_socket_open(reader, (char *)register_server, register_port);
+	if (sockfd <= 0) return 0;
+	registered = avatarcamd_registration(reader, sockfd);
+	network_tcp_socket_close(reader, sockfd);
+	if (registered < 1) {
+		reader->card_status = CARD_UNREGISTER;
+		return 0;
+	}
+	reader->ncd_exregistration = 1;
+	write_server();
+	return 1;
+}
+#endif
+
 /*
  * resolve client type for newcamd protocol
  */
 const char *newcamd_get_client_name(uint16_t client_id)
 {
 	// When adding new entries keep the list sorted!
-	static const struct
-	{
+	static const struct {
 		uint16_t id;
 		const char *client;
-	} ncd_service_ids[] =
-	{
+	} ncd_service_ids[] = {
 		{ 0x0000, "generic" },
 		{ 0x02C2, "Opticum" },
 		{ 0x0665, "rq-sssp-client-CS" },
@@ -1509,6 +2036,7 @@
 		{ 0x6B63, "kpcs" },
 		{ 0x6D63, "mpcs" },
 		{ 0x6D67, "mgcamd" },
+		{ 0x7645, "avatarcamd" },
 		{ 0x6E65, "NextYE2k" },
 		{ 0x6E73, "NewCS" },
 		{ 0x7264, "radegast" },
@@ -1549,6 +2077,8 @@
 	ph->c_send_ecm = newcamd_send_ecm;
 	ph->c_send_emm = newcamd_send_emm;
 	ph->c_idle = newcamd_idle;
+	// sky(n)
+	ph->c_available = newcamd_cAvailable;
 	ph->num = R_NEWCAMD;
 }
 #endif
Index: module-pandora.c
===================================================================
--- module-pandora.c	(revision 10670)
+++ module-pandora.c	(working copy)
@@ -17,11 +17,10 @@
 static void simple_crypt(uchar *buf, int len, uchar *key, int key_len)
 {
 	int i, x;
-	for(i = 0, x = 0; i < len; i++)
-	{
+	for (i = 0, x = 0; i < len; i++) {
 		buf[i] ^= key[x++];
 		if(x >= key_len)
-			{ x = 0; }
+			x = 0;
 	}
 }
 
@@ -32,37 +31,34 @@
 	uchar md5tmp[MD5_DIGEST_LENGTH];
 
 	if(!(er = get_ecmtask()))
-		{ return; }
+		return;
 	er->caid = b2i(2, buf + 1);
 	er->srvid = b2i(2, buf + 3);
 	er->prid = b2i(4, buf + 5);
 	//er->ecmcrc32 = crc32(0L, buf+10, CS_ECMSTORESIZE);
 	er->chid = b2i(2, buf + 10 + CS_ECMSTORESIZE);
 
-	if(l > 12 + CS_ECMSTORESIZE + 16)
-	{
+	if (l > 12 + CS_ECMSTORESIZE + 16) {
 		ecmlen = b2i(2, buf + 12 + CS_ECMSTORESIZE);
 		if((ecmlen > 320) || cl->pand_ignore_ecm)
-			{ er->ecmlen = 0; }
-		else
-		{
+			er->ecmlen = 0;
+		else {
 			if(!memcmp(buf + 10,
 					   MD5(buf + 14 + CS_ECMSTORESIZE, ecmlen, md5tmp),
-					   CS_ECMSTORESIZE))
-			{
+					CS_ECMSTORESIZE)) {
 				er->ecmlen = ecmlen;
 				memcpy(er->ecm, buf + 14 + CS_ECMSTORESIZE, ecmlen);
 				//set_ecmhash(cl, er);
 			}
 			else
-				{ er->ecmlen = 0; }
+				er->ecmlen = 0;
 		}
 	}
 	else
-		{ er->ecmlen = 0; }
+		er->ecmlen = 0;
 
 	if(!er->ecmlen)
-		{ usleep(cl->pand_autodelay); }
+		usleep(cl->pand_autodelay);
 	get_cw(cl, er);
 }
 
@@ -71,21 +67,20 @@
 	int ret;
 
 	if(!cl->udp_fd)
-		{ return (-9); }
+		return (-9);
 	if(cl->typ != 'c')
-		{ ret = recv_from_udpipe(buf); }
-	else
-	{
+		ret = recv_from_udpipe(buf);
+	else {
 		ret = recvfrom(cl->udp_fd, buf, l, 0, (struct sockaddr *)&cl->udp_sa, &cl->udp_sa_len);
 	}
 	if(ret < 1)
-		{ return (-1); }
+		return (-1);
 
 	simple_crypt(buf, ret, cl->pand_md5_key, 16);
 	cl->last = time((time_t *) 0);
 
 	if(cl->typ != 'c')
-		{ pandora_process_request(cl, buf, ret); }
+		pandora_process_request(cl, buf, ret);
 	return (ret);
 }
 
@@ -93,27 +88,23 @@
 {
 	uchar msgbuf[CWS_NETMSGSIZE], len;
 	if(cfg.pand_skip_send_dw)
-		{ return; }
-	if(er->rc < E_NOTFOUND)
-	{
+		return;
+	if (er->rc < E_NOTFOUND) {
 		msgbuf[0] = 2; //DW_FOUND
 		memcpy(&msgbuf[1], er->cw, 16);
 		len = 1 + 16;
 		cl->pand_autodelay = START_TIME;
-	}
-	else
-	{
+	} else {
 		msgbuf[0] = 0xFF; //DW_NOT_FOUND
 		len = 1;
 		if(cl->pand_autodelay < MAX_TIME)
-			{ cl->pand_autodelay += 100000; }
+			cl->pand_autodelay += 100000;
 	}
 	simple_crypt(msgbuf, len, cl->pand_md5_key, 16);
 	sendto(cl->udp_fd, msgbuf, len, 0, (struct sockaddr *) &cl->udp_sa, cl->udp_sa_len);
 }
 
-int pandora_auth_client(struct s_client *cl, IN_ADDR_T ip)
-{
+int pandora_auth_client(struct s_client *cl, IN_ADDR_T ip) {
 	int ok;
 	struct s_auth *account;
 
@@ -121,29 +112,26 @@
 	// FIXME: Add IPv6 support
 	(void)ip; // Prevent warning about unused var "ip"
 #else
-	if(!cl->pand_ignore_ecm && cfg.pand_allowed)
-	{
+	if (!cl->pand_ignore_ecm && cfg.pand_allowed) {
 		struct s_ip *p_ip;
 		for(ok = 0, p_ip = cfg.pand_allowed; (p_ip) && (!ok); p_ip
 				= p_ip->next)
-			{ ok = ((ip >= p_ip->ip[0]) && (ip <= p_ip->ip[1])); }
+			ok = ((ip >= p_ip->ip[0]) && (ip <= p_ip->ip[1]));
 
-		if(!ok)
-		{
+		if (!ok) {
 			cs_auth_client(cl, (struct s_auth *) 0, "IP not allowed");
 			return 0;
 		}
 	}
 #endif
 
-	for(ok = 0, account = cfg.account; cfg.pand_usr && account && !ok; account = account->next)
-	{
+	for (ok = 0, account = cfg.account; cfg.pand_usr && account && !ok; account = account->next) {
 		ok = streq(cfg.pand_usr, account->usr);
 		if(ok && cs_auth_client(cl, account, NULL))
-			{ cs_disconnect_client(cl); }
+			cs_disconnect_client(cl);
 	}
 	if(!ok)
-		{ cs_auth_client(cl, (struct s_auth *)(-1), NULL); }
+		cs_auth_client(cl, (struct s_auth *) (-1), NULL);
 	return ok;
 }
 
@@ -151,10 +139,8 @@
 							int32_t UNUSED(len))
 {
 	uchar md5tmp[MD5_DIGEST_LENGTH];
-	if(!cl->init_done)
-	{
-		if(cfg.pand_pass)
-		{
+	if (!cl->init_done) {
+		if (cfg.pand_pass) {
 			cl->pand_autodelay = 150000;
 			memcpy(cl->pand_md5_key,
 				   MD5((uchar *)cfg.pand_pass, strlen(cfg.pand_pass), md5tmp), 16);
@@ -163,8 +149,7 @@
 			pandora_auth_client(cl, cl->ip);
 			cl->init_done = 1;
 		}
-		else
-		{
+		else {
 			cs_log("Password for Pandora share MUST be set !!!");
 		}
 	}
@@ -183,8 +168,7 @@
 	uchar md5tmp[MD5_DIGEST_LENGTH];
 
 	cl->pfd = 0;
-	if(rdr->r_port <= 0)
-	{
+	if (rdr->r_port <= 0) {
 		cs_log("invalid port %d for server %s", rdr->r_port, rdr->device);
 		return (1);
 	}
@@ -195,13 +179,12 @@
 	loc_sa.sin_family = AF_INET;
 
 	if(IP_ISSET(cfg.srvip))
-		{ IP_ASSIGN(SIN_GET_ADDR(loc_sa), cfg.srvip); }
+		IP_ASSIGN(SIN_GET_ADDR(loc_sa), cfg.srvip);
 	else
-		{ loc_sa.sin_addr.s_addr = INADDR_ANY; }
+		loc_sa.sin_addr.s_addr = INADDR_ANY;
 	loc_sa.sin_port = htons(rdr->l_port);
 
-	if((cl->udp_fd = socket(PF_INET, SOCK_DGRAM, p_proto)) < 0)
-	{
+	if ((cl->udp_fd = socket(PF_INET, SOCK_DGRAM, p_proto)) < 0) {
 		cs_log("Socket creation failed (errno=%d)", errno);
 		return 1;
 	}
@@ -213,10 +196,8 @@
 
 	set_socket_priority(cl->udp_fd, cfg.netprio);
 
-	if(rdr->l_port > 0)
-	{
-		if(bind(cl->udp_fd, (struct sockaddr *) &loc_sa, sizeof(loc_sa)) < 0)
-		{
+	if (rdr->l_port > 0) {
+		if (bind(cl->udp_fd, (struct sockaddr *) &loc_sa, sizeof(loc_sa)) < 0) {
 			cs_log("bind failed (errno=%d)", errno);
 			close(cl->udp_fd);
 			return (1);
@@ -224,7 +205,7 @@
 		snprintf(ptxt, sizeof(ptxt), ", port=%d", rdr->l_port);
 	}
 	else
-		{ ptxt[0] = '\0'; }
+		ptxt[0] = '\0';
 
 	memcpy(cl->pand_md5_key, MD5((uchar *)rdr->r_pwd, strlen(rdr->r_pwd), md5tmp), 16);
 	cl->crypted = 1;
@@ -271,8 +252,7 @@
 	msgbuf[10 + CS_ECMSTORESIZE] = er->chid >> 8;
 	msgbuf[11 + CS_ECMSTORESIZE] = er->chid & 0xFF;
 	len = 12 + CS_ECMSTORESIZE;
-	if(cl->pand_send_ecm)
-	{
+	if (cl->pand_send_ecm) {
 		msgbuf[12 + CS_ECMSTORESIZE] = er->ecmlen >> 8;
 		msgbuf[13 + CS_ECMSTORESIZE] = er->ecmlen & 0xFF;
 		memcpy(&msgbuf[14 + CS_ECMSTORESIZE], er->ecm, er->ecmlen);
@@ -287,7 +267,7 @@
 							uchar *buf, int UNUSED(n))
 {
 	if(buf[0] != 0x2)
-		{ return (-1); }
+		return (-1);
 	*rc = 1;
 	memcpy(dcw, buf + 1, 16);
 	return (0);
Index: module-serial.c
===================================================================
--- module-serial.c	(revision 10670)
+++ module-serial.c	(working copy)
@@ -44,6 +44,7 @@
 static const char *const dsrproto_txt[] = {"unknown", "samsung", "openbox", "pioneer",
 		"extended", "unknown"
 										  };
+static const char *const incomplete = "incomplete request (%d bytes)";
 
 typedef struct s_gbox
 {
@@ -688,7 +689,7 @@
 				cs_log("ferguson powered on");  // this is nice to ;)
 			}
 			else
-				cs_log("incomplete request (%d bytes)", n);
+				{ cs_log(incomplete, n); }
 		}
 		break;
 	case(-2):
@@ -907,7 +908,7 @@
 
 	if(l < 16)
 	{
-		cs_log("incomplete request (%d bytes)", l);
+		cs_log(incomplete, l);
 		return (1);
 	}
 
@@ -970,7 +971,7 @@
 		er->caid  = b2i(2, buf + 3);
 		if((er->ecmlen != l - 5) || (er->ecmlen > 257))
 		{
-			cs_log("incomplete request (%d bytes)", l);
+			cs_log(incomplete, l);
 			return (1);
 		}
 		memcpy(er->ecm, buf + 5, er->ecmlen);
Index: module-stat.c
===================================================================
--- module-stat.c	(revision 10670)
+++ module-stat.c	(working copy)
@@ -472,6 +472,8 @@
 	// 12= disabled    #
 	// 13= stopped     #
 	// 100= unhandled  #
+	// 101 = ALREADY_SENT#
+	// 102 = WAITING		#
 	//        + = adds statistic values
 	//        # = ignored because of duplicate values, temporary failures or softblocks
 	//        - = causes loadbalancer to block this reader for this caid/prov/sid
@@ -736,7 +738,8 @@
         }
     }
     return 0; //No match!
-}*/
+}
+*/
 
 static int32_t get_retrylimit(ECM_REQUEST *er)
 {
@@ -1428,9 +1431,9 @@
 				break;
 			}
 
-			if(cfg.lb_mode != LB_OLDEST_READER_FIRST)    //Adjust selection to reader load:
-			{
-				/*    if (rdr->ph.c_available && !rdr->ph.c_available(rdr, AVAIL_CHECK_LOADBALANCE, er)) {
+			if (cfg.lb_mode != LB_OLDEST_READER_FIRST) { //Adjust selection to reader load:
+				/*
+				if (rdr->ph.c_available && !rdr->ph.c_available(rdr, AVAIL_CHECK_LOADBALANCE, er)) {
 				  current=current*2;
 				}
 
@@ -1970,7 +1973,7 @@
 	{
 		uint16_t save_caid = er->caid;
 		er->caid = caid;
-		match = matching_reader(er, rdr); //matching
+		match = matching_reader(er, rdr, 2); //matching
 		er->caid = save_caid;
 	}
 	return match;
@@ -2080,8 +2083,8 @@
 
 void send_reader_stat(struct s_reader *rdr, ECM_REQUEST *er, struct s_ecm_answer *ea, int8_t rc)
 {
-	if(rc >= E_99 || cacheex_reader(rdr))
-		{ return; }
+	if (!rdr) return;
+	if ( rc >= E_99 || cacheex_reader(rdr)) return;
 
 	int32_t ecm_time = cfg.ctimeout;
 	if(ea->ecm_time && ea->rc <= E_NOTFOUND)
Index: module-webif-tpl.c
===================================================================
--- module-webif-tpl.c	(revision 10670)
+++ module-webif-tpl.c	(working copy)
@@ -396,6 +396,8 @@
 											size_t len = strlen(ptr2);
 											check_conf(WITH_CARDREADER, ptr2);
 											check_conf(CARDREADER_PHOENIX, ptr2);
+											// sky(n)
+											check_conf(CARDREADER_INTERNAL_HISKY, ptr2);
 											check_conf(CARDREADER_INTERNAL_AZBOX, ptr2);
 											check_conf(CARDREADER_INTERNAL_COOLAPI, ptr2);
 											check_conf(CARDREADER_INTERNAL_SCI, ptr2);
@@ -427,6 +429,10 @@
 											check_conf(MODULE_GHTTP, ptr2);
 											check_conf(MODULE_MONITOR, ptr2);
 											check_conf(MODULE_NEWCAMD, ptr2);
+											// sky(n)
+											check_conf(MODULE_XCAMD, ptr2);
+											check_conf(MODULE_MORECAM, ptr2);
+											check_conf(MODULE_XCAS, ptr2);
 											check_conf(MODULE_PANDORA, ptr2);
 											check_conf(MODULE_RADEGAST, ptr2);
 											check_conf(MODULE_SERIAL, ptr2);
Index: module-webif.c
===================================================================
--- module-webif.c	(revision 10670)
+++ module-webif.c	(working copy)
@@ -42,7 +42,7 @@
 extern char *entitlement_type[];
 extern char *RDR_CD_TXT[];
 extern char *loghist;
-extern char *loghistid;
+extern uint64_t	*loghistid;	// sky(!)
 extern char *loghistptr;
 
 int32_t ssl_active = 0;
@@ -60,6 +60,12 @@
 
 static pthread_t httpthread;
 static int32_t sock;
+// sky(n)
+#if defined(WITH_HISILICON)
+static char 		stRDR_status [256];
+static char 		stMYSKY_level[256];
+#endif
+
 enum refreshtypes { REFR_ACCOUNTS, REFR_READERS, REFR_CLIENTS, REFR_SERVER, REFR_ANTICASC, REFR_SERVICES };
 
 //initialize structs for calculating cpu-usage depending on time between refresh of status_page
@@ -78,7 +84,10 @@
 #define MNU_SCRIPT 8
 #define MNU_SHUTDOWN 9
 #define MNU_LIVELOG 10
-#define MNU_TOTAL_ITEMS 11 // sum of items above
+// sky(n.11)
+#define MNU_MYSTATUS 			11
+#define MNU_TOTAL_ITEMS 		12 // sum of items above
+
 /* constants for submenuactivating */
 #define MNU_CFG_GLOBAL 0
 #define MNU_CFG_LOADBAL 1
@@ -112,10 +121,22 @@
 #define MNU_CFG_CACHE 24
 #define MNU_CFG_WHITELIST 25
 #define MNU_CFG_RATELIMIT 26
-#define MNU_CFG_FCSS 27
-#define MNU_CFG_TOTAL_ITEMS 28 // sum of items above. Use it for "All inactive" in function calls too.
+// sky(n.27~)
+#define MNU_CFG_FSMARTCARD		27
+#define MNU_CFG_FSCAMKEY 		28
+#define MNU_CFG_FCONSTCW 		29
+
+#define MNU_CFG_FCSS 			30
+#define MNU_CFG_TOTALITEMS 	31	// sum of items above. Use it for "All inactive" in function calls too.
+
+#if defined(WITH_HISILICON)
+extern uint16_t HISCIAPI_ChkCardstatus (struct s_reader *reader);
+extern char *   HISCIAPI_ChkCardsystem (struct s_reader *reader);
+extern bool     HISCIAPI_SaveCardstatus(struct s_reader *reader);
+#endif
 
-static void set_status_info_var(struct templatevars *vars, char *varname, int no_data, char *fmt, double value) {
+static void set_status_info_var(struct templatevars *vars, char *varname, int no_data, char *fmt, double value)
+{
 	if (no_data)
 		tpl_addVar(vars, TPLADD, varname, "N/A");
 	else
@@ -133,7 +154,8 @@
 * oscam	8 vsize & rssize, 9 cpu user, 10 cpu sys, 11 cpu sum, 12 cpu refreshtime
 * unused 13 - 15
 */
-static void set_status_info(struct templatevars *vars, struct pstat stats){
+static void set_status_info(struct templatevars *vars, struct pstat stats)
+{
 	set_status_info_var(vars, "MEM_CUR_TOTAL",  stats.check_available & (1 << 0), PRINTF_LOCAL_MB , (double)stats.mem_total/(1024.0*1024.0));
 	set_status_info_var(vars, "MEM_CUR_FREE",   stats.check_available & (1 << 1), PRINTF_LOCAL_MB , (double)stats.mem_free/(1024.0*1024.0));
 	set_status_info_var(vars, "MEM_CUR_USED",   stats.check_available & (1 << 1), PRINTF_LOCAL_MB , (double)stats.mem_used/(1024.0*1024.0));
@@ -444,7 +466,7 @@
 static void setActiveSubMenu(struct templatevars *vars, int8_t active)
 {
 	int8_t i;
-	for(i = 0; i < MNU_CFG_TOTAL_ITEMS; i++)
+	for (i = 0; i < MNU_CFG_TOTALITEMS; i++)
 	{
 		tpl_printf(vars, TPLADD, "TMP", "CMENUACTIVE%d", i);
 		if(i == active)
@@ -456,13 +478,19 @@
 
 static void webif_save_config(char *section, struct templatevars *vars, struct uriparams *params)
 {
-	if(!streq(getParam(params, "action"), "execute"))
-		{ return; }
+	// sky(a)
+	int exchange = 0;
+
+	if (streq(getParam(params, "action"), "exchange")) exchange = 1;
+	else if (!streq(getParam(params,"action"), "execute")) return;
+
 	if(cfg.http_readonly)
 	{
+		if (streq(getParam(params,"action"), "execute")) {
 		tpl_addMsg(vars, "WebIf is in readonly mode. No changes are possible!");
 		return;
 	}
+	}
 	int i;
 	int cnt = (*params).paramcount;
 	for(i = 0; i < cnt; i++)
@@ -472,6 +500,13 @@
 		if(!streq(token, "part") && !streq(token, "action"))
 			{ config_set(section, token, value); }
 	}
+
+	if (exchange) {
+#ifdef MODULE_CCCAM
+		if (streq(section, "cccam")) cc_update_nodeid();
+#endif
+	}
+
 	if(write_config() == 0)
 	{
 		tpl_addMsg(vars, "Configuration was saved.");
@@ -841,6 +876,11 @@
 {
 	int32_t i;
 
+	// sky(a)
+	if (strcmp(getParam(params, "action"), "exchange") == 0)
+	{
+		mycs_trace(D_ADB, "myweb:newcamd conf exchange");
+	}
 	setActiveSubMenu(vars, MNU_CFG_NEWCAMD);
 
 	webif_save_config("newcamd", vars, params);
@@ -929,7 +969,11 @@
 #ifdef MODULE_CCCAM
 static char *send_oscam_config_cccam(struct templatevars *vars, struct uriparams *params)
 {
-
+	// sky(a)
+	if (strcmp(getParam(params, "action"), "exchange") == 0)
+	{
+		mycs_trace(D_ADB, "myweb:cccam conf exchange");
+	}
 	setActiveSubMenu(vars, MNU_CFG_CCCAM);
 
 	if(strcmp(getParam(params, "button"), "Refresh list") == 0)
@@ -1030,6 +1074,11 @@
 {
 	int32_t i;
 
+	// sky(a)
+	if (strcmp(getParam(params, "action"), "exchange") == 0)
+	{
+		mycs_trace(D_ADB, "myweb:webif conf exchange");
+	}
 	setActiveSubMenu(vars, MNU_CFG_WEBIF);
 
 	webif_save_config("webif", vars, params);
@@ -1215,7 +1264,7 @@
 #endif
 
 #ifdef HAVE_DVBAPI
-extern const char *boxdesc[];
+extern const char *boxtype_desc[];
 
 static char *send_oscam_config_dvbapi(struct templatevars *vars, struct uriparams *params)
 {
@@ -1237,7 +1286,7 @@
 	tpl_printf(vars, TPLADD, "BOXTYPE", "<option value=\"\"%s>None</option>\n", cfg.dvbapi_boxtype == 0 ? " selected" : "");
 	for(i = 1; i <= BOXTYPES; i++)
 	{
-		tpl_printf(vars, TPLAPPEND, "BOXTYPE", "<option%s>%s</option>\n", cfg.dvbapi_boxtype == i ? " selected" : "", boxdesc[i]);
+		tpl_printf(vars, TPLAPPEND, "BOXTYPE", "<option%s>%s</option>\n", cfg.dvbapi_boxtype == i ? " selected" : "", boxtype_desc[i]);
 	}
 
 	tpl_addVar(vars, TPLADD, "USERNAME", xml_encode(vars, cfg.dvbapi_usr));
@@ -1392,9 +1442,11 @@
 
 static char *send_oscam_reader(struct templatevars *vars, struct uriparams *params, int32_t apicall)
 {
-	struct s_reader *rdr;
-	int32_t i;
+	struct s_reader *rdr, *rdr2 = 0;
+	char  *labelname, *labels2  = 0;
 	unsigned char md5tmp[MD5_DIGEST_LENGTH];
+	int32_t i;
+	int32_t bReadonly = 0;
 
 	if(!apicall) { setActiveMenu(vars, MNU_READERS); }
 	if(!apicall)
@@ -1416,48 +1468,193 @@
 		if(!cfg.http_readonly)
 			{ refresh_oscam(REFR_READERS); }
 	}
-	if((strcmp(getParam(params, "action"), "disable") == 0) || (strcmp(getParam(params, "action"), "enable") == 0))
+
+	bReadonly = cfg.http_readonly;
+	labelname = getParam(params, "label");
+	// sky(a)
+	if ( (labels2 = strchr(labelname, ',')))
 	{
-		if(cfg.http_readonly)
+		*labels2++ = '\0';
+		myprintf("myweb:send_oscam_reader:%s,%s\n", labelname, labels2);
+		rdr2 = get_reader_by_label(labels2);
+	}
+	rdr = get_reader_by_label(labelname);
+// sky(n)
+// for xbmc
+// http://192.168.0.6:8888/readers.html?label=myxcamd&action=start
+// http://192.168.0.6:8888/readers.html?label=myxcamd&action=stop
+// http://192.168.0.6:8888/readers.html?label=myxcamd&action=remove
+// http://192.168.0.6:8888/readers.html?label=myhisky&action=restart
+// http://192.168.0.6:8888/readers.html?label=myxcamd&action=status
+#if defined(WITH_HISILICON)
+	if ((strcmp(getParam(params, "action"), "status") == 0))
 		{
-			tpl_addMsg(vars, "WebIf is in readonly mode. Enabling or disabling readers is not possible!");
+		int32_t status;
+
+		status = CSREADER_Chkstatus(rdr);
+		if (IS_XCAMD_READERS(rdr))
+		{
+			struct tm stime, etime;
+			if (rdr->start_time && rdr->close_time)
+			{
+				cs_gmtime_r((time_t *)&rdr->start_time, &stime);
+				cs_gmtime_r((time_t *)&rdr->close_time, &etime);
+				sprintf(stRDR_status, "READER:%s status: %d, %02d/%02d/%04d %02d:%02d ~ %02d/%02d/%04d %02d:%02d",
+						labelname,
+						status,
+						stime.tm_mon+1,stime.tm_mday ,stime.tm_year+1900, stime.tm_hour,stime.tm_min,
+						etime.tm_mon+1,etime.tm_mday ,etime.tm_year+1900, etime.tm_hour,etime.tm_min);
 		}
 		else
 		{
-			rdr = get_reader_by_label(getParam(params, "label"));
-			if(rdr)
+				sprintf(stRDR_status, "READER:%s status: %d", labelname, status);
+			}
+		}
+		else
 			{
-				if(strcmp(getParam(params, "action"), "enable") == 0)
+			sprintf(stRDR_status, "READER:%s status: %d", labelname, status);
+		}
+		mycs_trace(D_ADB, "myweb:%10s status=%d", labelname, status);
+		return (stRDR_status);
+	}
+
+	if ((strcmp(getParam(params, "action"), "start") == 0) ||
+		 (strcmp(getParam(params, "action"), "restart") == 0))
 				{
-					if(!rdr->enable)
+		bReadonly = 0;
+		if (rdr) {
+			mycs_trace(D_ADB, "!!! reader_start(update,%s)", rdr->label);
+			init_myrdrdb_update_simples(rdr, labelname);
+		}
+		else if (!labelname) {
+			mycs_trace(D_ADB, "!!! reader label fail");
+			if (!apicall)
 					{
-						rdr->enable = 1;
+				return tpl_getTpl(vars, "READERS");
+			}
+			else {
+				return tpl_getTpl(vars, "APIREADERS");
+			}
+		}
+		else
+		{
+			mycs_trace(D_ADB, "!!! reader_start(Add,%s)", labelname);
+			rdr = (struct s_reader *)init_myrdrdb_add_simples(labelname);
+		}
+		chk_group_violation(rdr);
+	}
+	else
+	if ((strcmp(getParam(params, "action"), "stop") == 0))
+	{
+		bReadonly = 0;
+		if (rdr) {
+			mycs_trace(D_ADB, "!!! reader_stop(%s)", rdr->label);
 					}
 				}
 				else
+	if ((strcmp(getParam(params, "action"), "remove") == 0))
 				{
-					if(rdr->enable)
+		bReadonly = 0;
+		if (rdr) {
+			mycs_trace(D_ADB, "!!! reader_remove(%s)", rdr->label);
+		}
+	}
+	else
+	if ((strcmp(getParam(params, "action"), "cleanup") == 0))
+	{
+		bReadonly = 0;
+		// sky(a)
+		if (rdr2) {
+			mycs_trace(D_ADB, "!!! reader_cleanup(%s)", rdr2->label);
+			if (rdr2->ph.c_Cleanup) {
+				 rdr2->ph.c_Cleanup(rdr2->client);
+			}
+		}
+		if (rdr) {
+			mycs_trace(D_ADB, "!!! reader_cleanup(%s)", rdr->label);
+			if (rdr->ph.c_Cleanup) {
+				 rdr->ph.c_Cleanup(rdr->client);
+			}
+		}
+	}
+#endif
+
+	if ((strcmp(getParam(params, "action"), "start") == 0) ||
+		 (strcmp(getParam(params, "action"), "stop")  == 0) ||
+		 (strcmp(getParam(params, "action"), "disable") == 0) ||
+		 (strcmp(getParam(params, "action"), "enable")  == 0))
+	{
+		if (bReadonly) {
+			tpl_addMsg(vars, "WebIf is in readonly mode. Enabling or disabling readers is not possible!");
+		}
+		else
+		{
+		// sky(a)
+		if (rdr2) {
+			if ((strcmp(getParam(params, "action"), "enable") == 0) ||
+				 (strcmp(getParam(params, "action"), "start") == 0))
+			{
+				if (!rdr2->enable) rdr2->enable = 1;
+			}
+			else {
+				if ( rdr2->enable) rdr2->enable = 0;
+			}
+			restart_cardreader(rdr2, 1);
+		}
+		if (rdr) {
+			if ((strcmp(getParam(params, "action"), "enable") == 0) ||
+				 (strcmp(getParam(params, "action"), "start") == 0))
 					{
-						rdr->enable = 0;
+				if (!rdr->enable) rdr->enable = 1;
 					}
+			else {
+				if ( rdr->enable) rdr->enable = 0;
 				}
 				restart_cardreader(rdr, 1);
-				if(write_server() != 0) { tpl_addMsg(vars, "Write Config failed!"); }
+			if (write_server() != 0) tpl_addMsg(vars, "Write Config failed!");
 			}
 		}
 	}
 
-	if(strcmp(getParam(params, "action"), "delete") == 0)
+// sky(n)
+#if defined(WITH_HISILICON)
+	if ((strcmp(getParam(params, "action"), "restart") == 0))
 	{
-		if(cfg.http_readonly)
+		if (rdr) {
+			if (IS_CARD_READER(rdr)) {
+				mycs_log("webif:Reader %s restarting", rdr->label);
+				restart_cardreader(rdr, 1);
+			}
+			else {
+				mycs_log("webif:Reader %s restarting", rdr->label);
+				add_job(rdr->client, ACTION_READER_RESTART, NULL, 0);
+			}
+		}
+		if (rdr2) {
+			if (IS_CARD_READER(rdr2)) {
+				mycs_log("webif:Reader %s restarting", rdr2->label);
+				restart_cardreader(rdr2, 1);
+			}
+			else {
+				mycs_log("webif:Reader %s restarting", rdr2->label);
+				add_job(rdr2->client, ACTION_READER_RESTART, NULL, 0);
+			}
+		}
+	}
+#endif
+
+	if ((strcmp(getParam(params, "action"), "delete") == 0) ||
+		 (strcmp(getParam(params, "action"), "remove") == 0))
 		{
+		if (bReadonly) {
 			tpl_addMsg(vars, "WebIf is in readonly mode. No deletion will be made!");
 		}
 		else
-		{
-			rdr = get_reader_by_label(getParam(params, "label"));
-			if(rdr)
-			{
+		if (rdr) {
+			if (IS_CARD_READER(rdr)) {
+				mycs_log("webif:Reader %s nonallowed", rdr->label);
+			}
+			else {
 				inactivate_reader(rdr);
 				ll_remove(configured_readers, rdr);
 
@@ -1470,7 +1667,6 @@
 
 	if(strcmp(getParam(params, "action"), "reread") == 0)
 	{
-		rdr = get_reader_by_label(getParam(params, "label"));
 		if(rdr)
 		{
 			struct s_client *cl = rdr->client;
@@ -1654,6 +1850,14 @@
 
 	if(!apicall)
 	{
+#ifdef MODULE_NEWCAMD
+		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>newcamd</option>\n");
+#endif
+
+#ifdef MODULE_CCCAM
+		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>cccam</option>\n");
+#endif
+
 #ifdef MODULE_CAMD33
 		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>camd33</option>\n");
 #endif
@@ -1664,12 +1868,14 @@
 		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>cs378x</option>\n");
 #endif
 #ifdef MODULE_NEWCAMD
-		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>newcamd</option>\n");
 		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>newcamd524</option>\n");
 #endif
-#ifdef MODULE_CCCAM
-		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>cccam</option>\n");
+
+#if defined(MODULE_AVAMGCAMD)
+		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>mgcamd</option>\n");
+		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>avatarcamd</option>\n");
 #endif
+
 #ifdef MODULE_GBOX
 		tpl_addVar(vars, TPLAPPEND, "ADDPROTOCOL", "<option>gbox</option>\n");
 #endif
@@ -1707,17 +1913,24 @@
 
 static char *send_oscam_reader_config(struct templatevars *vars, struct uriparams *params)
 {
-	int32_t i;
-	int32_t apicall = 0;
-	char *reader_ = getParam(params, "label");
+	char *cfglabel;
 	char *value;
+	int32_t apicall = 0;
+	int32_t i;
 
 	struct s_reader *rdr;
-
+	cfglabel = getParam(params, "label");
 	if(!apicall) { setActiveMenu(vars, MNU_READERS); }
 
 	if(strcmp(getParam(params, "action"), "Add") == 0)
 	{
+		// sky(a)
+		rdr = chk_sole_reader_protocols(getParam(params, "protocol"));
+		if (rdr) {
+			cfglabel = rdr->label;
+			mycs_trace(D_ADB, "myrdr:sole_reader{%s}", rdr->label);
+		}
+		else {
 		// Add new reader
 		struct s_reader *newrdr;
 		if(!cs_malloc(&newrdr, sizeof(struct s_reader))) { return "0"; }
@@ -1727,20 +1940,33 @@
 				{ chk_reader((*params).params[i], (*params).values[i], newrdr); }
 		}
 		module_reader_set(newrdr);
-		reader_ = newrdr->label;
+			cfglabel = newrdr->label;
 		reader_set_defaults(newrdr);
 		newrdr->enable = 0; // do not start the reader because must configured before
+
+#if defined(MODULE_AVAMGCAMD)
+			if (IS_MGCAMD(newrdr->ncd_exprotocol)) {
+				newrdr->ftab.nfilts = 0;
+				newrdr->ncd_proto   = NCD_525;
+			}
+			if (IS_AVATARCAMD(newrdr->ncd_exprotocol)) {
+				strcpy(newrdr->device, "none");
+				newrdr->ftab.nfilts = 0;
+				newrdr->ncd_proto   = NCD_525;
+			}
+#endif
 		ll_append(configured_readers, newrdr);
 		tpl_addMsg(vars, "New Reader has been added with default settings");
 	}
+	}
 	else if(strcmp(getParam(params, "action"), "Save") == 0)
 	{
 
 		rdr = get_reader_by_label(getParam(params, "label"));
-		if(!rdr)
-			{ return NULL; }
-		//if (is_network_reader(rdr))
+		if (!rdr) { return NULL; }
+	//	if (is_network_reader(rdr)) {
 		//  inactivate_reader(rdr); //Stop reader before reinitialization
+	//	}
 		char servicelabels[1024] = "";
 		char servicelabelslb[1024] = "";
 
@@ -1760,17 +1986,74 @@
 		}
 		chk_reader("services", servicelabels, rdr);
 		chk_reader("lb_whitelist_services", servicelabelslb, rdr);
+#if defined(MODULE_AVAMGCAMD)
+		if (streq(getParam(params, "protocol"), "avatarcamd")) {
+			rdr->ncd_exregistration = 0;
+		}
+#endif
 
-		if(is_network_reader(rdr))    //physical readers make trouble if re-started
-		{
+		chk_group_violation(rdr);
+		if (is_network_reader(rdr)) { //physical readers make trouble if re-started
 			restart_cardreader(rdr, 1);
 		}
 
-		if(write_server() != 0) { tpl_addMsg(vars, "Write Config failed!"); } else { tpl_addMsg(vars, "Reader config updated and saved"); }
+		if (write_server() != 0) {
+			tpl_addMsg(vars, "Write Config failed!");
+		}
+		else {
+			tpl_addMsg(vars, "Reader config updated and saved");
+		}
+
+	}
+	// sky(a)
+	else if (strcmp(getParam(params, "action"), "exchange") == 0)
+	{
+		int32_t prvtype;
+		rdr = get_reader_by_label(getParam(params, "label"));
+		if (!rdr)
+		{
+			// Add new reader
+			struct s_reader *newrdr;
+			if (!cs_malloc(&newrdr, sizeof(struct s_reader))) return "0";
+
+			reader_set_defaults(newrdr);
+			for (i = 0; i < (*params).paramcount; ++i) {
+				if (strcmp((*params).params[i], "action"))
+					chk_reader((*params).params[i], (*params).values[i], newrdr);
+			}
+			rdr = newrdr;
+			cfglabel = newrdr->label;
+			module_reader_set(newrdr);
+			ll_append(configured_readers, newrdr);
+			mycs_trace(D_ADB, "myweb:send_oscam_reader_config exchange(add)");
+			prvtype = rdr->typ;
+		}
+		else
+		{
+			prvtype = rdr->typ;
+			for (i = 0; i < (*params).paramcount; ++i)
+			{
+				myprintf("myweb:exchange::%s=%s\n", (*params).params[i], (*params).values[i]);
+				if ((strcmp((*params).params[i], "reader")) && (strcmp((*params).params[i], "action")))
+				{
+					if (!strcmp((*params).params[i], "services")) continue;
+					if (!strcmp((*params).params[i], "lb_whitelist_services")) continue;
+				/* if (strlen((*params).values[i]) > 0) */
+					chk_reader((*params).params[i], (*params).values[i], rdr);
+				}
+			}
+			mycs_trace(D_ADB, "myweb:send_oscam_reader_config exchange(update) {%02x:%02x}", prvtype, rdr->typ);
+		}
+		if (prvtype != rdr->typ) module_reader_set(rdr);
+		chk_group_violation(rdr);
+		if (is_network_reader(rdr)) { // physical readers make trouble if re-started
+			restart_cardreader(rdr, 1);
+		}
 
+		if (write_server() != 0) tpl_addMsg(vars, "Write Config failed!");
 	}
 
-	rdr = get_reader_by_label(reader_);
+	rdr = get_reader_by_label(cfglabel);
 	if(!rdr)
 		{ return NULL; }
 
@@ -1795,7 +2078,10 @@
 	// Key Newcamd
 	for(i = 0; i < (int32_t)sizeof(rdr->ncd_key); i++)
 		{ tpl_printf(vars, TPLAPPEND, "NCD_KEY", "%02X", rdr->ncd_key[i]); }
-
+#if defined(MODULE_AVAMGCAMD)
+	for (i = 0; i < (int32_t)sizeof(rdr->ncd_exkey); i++)
+		{ tpl_printf(vars, TPLAPPEND, "NCD_EXKEY", "%02X", rdr->ncd_exkey[i]); }
+#endif
 	// Pincode
 	tpl_addVar(vars, TPLADD, "PINCODE", rdr->pincode);
 
@@ -2108,24 +2394,22 @@
 	tpl_printf(vars, TPLADD, "MHZ", "%d", rdr->mhz);
 	tpl_printf(vars, TPLADD, "CARDMHZ", "%d", rdr->cardmhz);
 
-	// Device
-	if(!apicall)
-	{
-		tpl_addVar(vars, TPLADD, "DEVICE", xml_encode(vars, rdr->device));
+	// sky(n)
+	if (!apicall) {
+		tpl_addVar(vars, TPLADD, "DEVICE", xml_encode(vars, T_READER_DEVICES(rdr)));
 	}
-	else
-	{
-		tpl_addVar(vars, TPLADD, "DEVICE", rdr->device);
+	else {
+		tpl_addVar(vars, TPLADD, "DEVICE", T_READER_DEVICES(rdr));
 	}
 
 	if(rdr->r_port)
-		{ tpl_printf(vars, TPLAPPEND, "DEVICE", ",%d", rdr->r_port); }
+		{ tpl_printf(vars, TPLAPPEND, "DEVICE", ",%d", T_READER_RPORTS(rdr)); }
 	if(rdr->l_port)
 	{
 		if(rdr->r_port)
-			{ tpl_printf(vars, TPLAPPEND, "DEVICE", ",%d", rdr->l_port); }
+			{ tpl_printf(vars, TPLAPPEND, "DEVICE",  ",%d", T_READER_LPORTS(rdr)); }
 		else
-			{ tpl_printf(vars, TPLAPPEND, "DEVICE", ",,%d", rdr->l_port); }
+			{ tpl_printf(vars, TPLAPPEND, "DEVICE", ",,%d", T_READER_LPORTS(rdr)); }
 	}
 
 	// Group
@@ -2319,7 +2603,6 @@
 	// Show only parameters which needed for the reader
 	switch(rdr->typ)
 	{
-	case R_CONSTCW:
 	case R_DB2COM1:
 	case R_DB2COM2:
 	case R_MOUSE :
@@ -2350,6 +2633,13 @@
 		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGGBOXBIT"));
 		break;
 	case R_NEWCAMD:
+#if defined(MODULE_AVAMGCAMD)
+			if (IS_AVATARCAMD(rdr->ncd_exprotocol))
+			{
+				tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGNCDAVATARBIT"));
+			}
+			else
+#endif
 		if(rdr->ncd_proto == NCD_525)
 		{
 			tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGNCD525BIT"));
@@ -2364,15 +2654,34 @@
 		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGCCCAMBIT"));
 		break;
 #endif
+#if defined(MODULE_XCAS)
+		case R_XCAS:
+			tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGIXCASBIT"));
+			break;
+#endif
+// sky(!)
+#if defined(MODULE_CONSTCW)
+		case R_CONSTCW:
+			tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGICONSTCWBIT"));
+			break;
+#endif
 	default :
 		tpl_addMsg(vars, "Error: protocol not resolvable");
 		break;
 
 	}
 
-#ifdef MODULE_CCCAM
-	if(rdr->typ != R_CCCAM)
+// sky(n)
+	if (rdr->typ == R_INTERNAL || rdr->typ == R_CONSTCW || rdr->typ == R_XCAS)
 	{
+	}
+	else
+	if (IS_ICS_READERS(rdr))
+	{
+	}
+#ifdef MODULE_CCCAM
+	else
+	if (rdr->typ != R_CCCAM) {
 		tpl_printf(vars, TPLADD, "CCCHOP", "%d", rdr->cc_hop);
 		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGHOPBIT"));
 	}
@@ -2412,8 +2721,8 @@
 	char *stxt[] = {"found", "cache1", "cache2", "cache3",
 					"not found", "timeout", "sleeping",
 					"fake", "invalid", "corrupt", "no card", "expdate",
-					"disabled", "stopped"
-				   };
+						"disabled", "stopped",
+						"const",};
 
 	if(strcmp(getParam(params, "action"), "resetstat") == 0)
 	{
@@ -2682,7 +2991,7 @@
 		}
 	}
 
-	tpl_printf(vars, TPLADD, "TOTALECM", "%'" PRIu64, ecmcount);
+	tpl_printf(vars, TPLADD, "TOTALECM", "%" PRIu64, ecmcount);
 
 	if(!apicall)
 		{ return tpl_getTpl(vars, "READERSTATS"); }
@@ -3896,13 +4205,14 @@
 static char *send_oscam_entitlement(struct templatevars *vars, struct uriparams *params, int32_t apicall)
 {
 	if(!apicall) { setActiveMenu(vars, MNU_READERS); }
-	char *reader_ = getParam(params, "label");
+	char *entitlelabel = getParam(params, "label");
+	struct s_reader *rdr;
 #ifdef MODULE_CCCAM
 	char *sharelist_ = getParam(params, "globallist");
 	int32_t show_global_list = sharelist_ && sharelist_[0] == '1';
 
-	struct s_reader *rdr = get_reader_by_label(getParam(params, "label"));
-	if(show_global_list || strlen(reader_) || (rdr && rdr->typ == R_CCCAM))
+	rdr = get_reader_by_label(getParam(params, "label"));
+	if (show_global_list || strlen(entitlelabel) || (rdr && rdr->typ == R_CCCAM))
 	{
 
 		if(show_global_list || (rdr && rdr->typ == R_CCCAM && rdr->enable))
@@ -3955,17 +4265,14 @@
 
 		}
 		else
-		{
 #else
-	if(strlen(reader_))
-	{
-		{
-			struct s_reader *rdr;
+		if (strlen(entitlelabel))
 #endif
+		{
 			tpl_addVar(vars, TPLADD, "LOGHISTORY", "->");
 			// normal non-cccam reader
 
-			rdr = get_reader_by_label(reader_);
+			rdr = get_reader_by_label(entitlelabel);
 
 			if(rdr)
 			{
@@ -3988,15 +4295,15 @@
 						localtime_r(&item->end, &end_t);
 
 						if(!apicall)
-							{ strftime(tbuffer, 30, "%Y-%m-%d", &start_t); }
+							strftime(tbuffer, 30, "%d-%m-%Y", &start_t);
 						else
-							{ strftime(tbuffer, 30, "%Y-%m-%dT%H:%M:%S%z", &start_t); }
+							strftime(tbuffer, 30, "%Y-%m-%dT%H:%M:%S%z", &start_t);
 						tpl_addVar(vars, TPLADD, "ENTSTARTDATE", tbuffer);
 
 						if(!apicall)
-							{ strftime(tbuffer, 30, "%Y-%m-%d", &end_t); }
+							strftime(tbuffer, 30, "%d-%m-%Y", &end_t);
 						else
-							{ strftime(tbuffer, 30, "%Y-%m-%dT%H:%M:%S%z", &end_t); }
+							strftime(tbuffer, 30, "%Y-%m-%dT%H:%M:%S%z", &end_t);
 						tpl_addVar(vars, TPLADD, "ENTENDDATE", tbuffer);
 
 						tpl_addVar(vars, TPLADD, "ENTEXPIERED", item->end > now ? "e_valid" : "e_expired");
@@ -4144,8 +4451,9 @@
 				tpl_addMsg(vars, "Reader does not exist or is not started!");
 			}
 		}
-
+#ifdef MODULE_CCCAM
 	}
+#endif
 	else
 	{
 		tpl_addVar(vars, TPLADD, "ENTITLEMENTCONTENT", tpl_getTpl(vars, "ENTITLEMENTGENERICBIT"));
@@ -4176,8 +4484,9 @@
 	{
 		lastid = strtoull(getParam(params, "lastid"), NULL, 10);
 	}
-
-	char *dot = ""; //Delimiter
+//	myprintf("lastid=%lld\n", lastid);
+// sky(!)
+	int dot = 0; //Delimiter
 
 #ifdef WITH_DEBUG
 	char *debuglvl = getParam(params, "debug");
@@ -4188,13 +4497,13 @@
 			cs_log("%s debug_level=%d", "all", cs_dblevel);
 		}
 	}
-	tpl_printf(vars, TPLAPPEND, "DATA","%s\"debug\":\"%d\"", dot, cs_dblevel);
-	dot = ",";
-	tpl_printf(vars, TPLAPPEND, "DATA","%s\"maxdebug\":\"%d\"",dot, MAX_DEBUG_LEVELS);
+	tpl_printf(vars, TPLAPPEND, "DATA", "%s\"debug\":\"%d\"", dot ? "," : "", cs_dblevel);
+	dot++;
+	tpl_printf(vars, TPLAPPEND, "DATA", "%s\"maxdebug\":\"%d\"", dot ? "," : "", MAX_DEBUG_LEVELS);
 #endif
 
 	if(cfg.loghistorysize == 0){
-		tpl_printf(vars, TPLAPPEND, "DATA","%s\"logdisabled\":\"1\"",dot);
+		tpl_printf(vars, TPLAPPEND, "DATA", "%s\"logdisabled\":\"1\"", dot ? "," : "");
 		return tpl_getTpl(vars, "POLL");
 	}
 
@@ -4202,12 +4511,13 @@
 	if(loghistptr >= loghist + (cfg.loghistorysize) - 1)
 		{ t_loghistptr = loghist; }
 	
-	int32_t i, d = 0, l1 = strlen(t_loghistptr + 1) + 2;
+	int32_t d = 0, l1 = strlen(t_loghistptr + 1) + 2;
 	char *lastpos = loghist + (cfg.loghistorysize) - 1;
 	
-	tpl_printf(vars, TPLAPPEND, "DATA", "%s\"lines\":[", dot);
+	tpl_printf(vars, TPLAPPEND, "DATA", "%s\"lines\":[", dot ? "," : "");
 
-	dot = "";
+	int i;
+	dot = 0;
 	for(ptr1 = t_loghistptr + l1, i = 0; i < 200; i++, ptr1 = ptr1 + l1)
 	{
 		l1 = strlen(ptr1) + 1;
@@ -4230,7 +4540,12 @@
 		pos1 = strcspn(p_txt, "\n") + 1;
 		char str_out[pos1];
 		cs_strncpy(str_out, p_txt, pos1);
-		uint64_t id = b2ll(8, (uchar *) (loghistid + ((ptr1-loghist)/3)));
+		// sky(!)
+		uint64_t uid;
+		uint64_t *puid;
+		puid = (uint64_t *)(loghistid + (ptr1-loghist)/8);
+		uid  = *puid;
+//		uid  = b2ll(8, (uchar *) (loghistid + ((ptr1-loghist)/3)));
 
 		size_t b64_str_in = strlen(xml_encode(vars, str_out));
 		size_t b64_str_out = 32 + BASE64_LENGTH(b64_str_in);
@@ -4239,13 +4554,13 @@
 			{ continue; }
 		base64_encode(xml_encode(vars, str_out), b64_str_in, b64_str_out_buf, b64_str_out);
 
-		if(id > lastid){
+		if (uid > lastid) {
 			tpl_printf(vars, TPLAPPEND, "DATA","%s{\"id\":\"%" PRIu64 "\",\"usr\":\"%s\",\"line\":\"%s\"}",
-									dot,
-									id,
+									dot ? "," : "",
+									uid,
 									urlencode(vars, xml_encode(vars, p_usr)),
 									b64_str_out_buf);
-			dot = ","; // next in Array with leading delimiter
+			dot = 1; // next in Array with leading delimiter
 		}
 		NULLFREE(b64_str_out_buf);
 	}
@@ -4254,6 +4569,94 @@
 }
 #endif
 
+#if defined(WITH_HISILICON)
+static char *send_oscam_mystatus(struct templatevars *vars, struct uriparams *params, int32_t apicall)
+{
+	if (strcmp(strtolower(getParam(params, "action")), "cardstatus") == 0)
+	{
+		sprintf(stRDR_status, "CARDSTATUS: %d", HISCIAPI_ChkCardstatus(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "cardsystem") == 0)
+	{
+		sprintf(stRDR_status, "%s", HISCIAPI_ChkCardsystem(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "oscamversion") == 0)
+	{
+		#if defined(__HISILICON_MANUFACTORY__)
+			sprintf(stRDR_status, "v%s.Rev%s (f)\n", CS_VERSION, CS_SVN_VERSION);
+		#else
+			sprintf(stRDR_status, "v%s.Rev%s\n", CS_VERSION, CS_SVN_VERSION);
+		#endif
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "level") == 0)
+	{
+		sprintf(stMYSKY_level, "SKYLEVEL:%d", cs_dblevel);
+		return (stMYSKY_level);
+	}
+
+	char *mylvl = getParam(params, "level");
+	if (mylvl && strlen(mylvl) > 0)
+	{
+		int32_t dblvl = atoi(mylvl);
+		if (dblvl >= 0 && dblvl <= 65535) cs_dblevel = dblvl;
+		cs_log("%s debug_level=%d", "all", cs_dblevel);
+	}
+
+	int i;
+	if (!apicall) setActiveMenu(vars, MNU_MYSTATUS);
+	if (cfg.loghistorysize)
+	{
+		char *t_loghistptr = loghistptr, *ptr1 = NULL;
+		if (loghistptr >= loghist + (cfg.loghistorysize) - 1) t_loghistptr = loghist;
+		int32_t d = 0, l1 = strlen(t_loghistptr+1) + 2;
+		char *lastpos = loghist + (cfg.loghistorysize)-1;
+
+		for (ptr1 = t_loghistptr + l1, i=0; i<200; i++, ptr1 = ptr1+l1) {
+			l1 = strlen(ptr1)+1;
+			if (!d && ((ptr1 >= lastpos) || (l1 < 2))) {
+				ptr1 = loghist;
+				l1 = strlen(ptr1)+1;
+				d++;
+			}
+
+			if (d && ((ptr1 >= t_loghistptr) || (l1 < 2))) break;
+
+			char p_usr[32];
+			size_t pos1 = strcspn(ptr1, "\t")+1;
+			cs_strncpy(p_usr, ptr1, pos1 > sizeof(p_usr) ? sizeof(p_usr) : pos1);
+
+			char *p_txt = ptr1 + pos1;
+
+			if (apicall == 0) {
+				if (p_txt[0]) {
+				//	myprintf("%3d! %s,%s", i, xml_encode(vars, p_usr), xml_encode(vars, p_txt));
+					tpl_printf(vars, TPLAPPEND, "LOGHISTORY",
+							   "\t\t<SPAN CLASS=\"%s\">%s\t\t</SPAN><BR>\n", xml_encode(vars, p_usr), xml_encode(vars, p_txt));
+				}
+			}
+			else
+			if (apicall == 1) {
+				if (strcmp(getParam(params, "appendlog"), "1") == 0) {
+				//	myprintf("%3d? %s", i, p_txt);
+					tpl_addVar(vars, TPLAPPEND, "LOGHISTORY", p_txt + 1);
+				}
+			}
+		}
+	}
+	else {
+		tpl_addVar(vars, TPLADD, "LOGHISTORY", "loghistorysize is set to 0 in your configuration<BR>\n");
+	}
+
+	if (apicall) {
+		return tpl_getTpl(vars, "APIMYSTATUS");
+	}
+	return tpl_getTpl(vars, "MYSTATUS");
+}
+#endif
+
 static char *send_oscam_status(struct templatevars * vars, struct uriparams * params, int32_t apicall)
 {
 	int32_t i;
@@ -4399,8 +4802,9 @@
 	{
 		if(cl->kill) { continue; }
 #ifdef CS_CACHEEX
-		if(get_module(cl)->listenertype != LIS_CSPUDP)
-		{
+		int16_t listenertype;
+		listenertype = get_module(cl)->listenertype;
+		if (listenertype != LIS_CSPUDP) {
 #endif
 
 			// Reset template variables
@@ -4633,8 +5037,15 @@
 						else { tpl_addVar(vars, TPLADD, "CLIENTCRYPTED", ""); }
 					}
 					else { tpl_printf(vars, TPLADD, "CLIENTCRYPTED", "%d", cl->crypted); }
+					// sky(!)
+					if (IS_ICS_READERS(cl->reader)) {
+						tpl_addVar(vars, TPLADD, "CLIENTIP", T_IPEMBEDDED);
+						tpl_printf(vars, TPLADD, "CLIENTPORT", "%d", T_PORTEMBEDDED);
+					}
+					else {
 					tpl_addVar(vars, TPLADD, "CLIENTIP", cs_inet_ntoa(cl->ip));
 					tpl_printf(vars, TPLADD, "CLIENTPORT", "%d", cl->port);
+					}
 					const char *proto = client_get_proto(cl);
 					webif_add_client_proto(vars, cl, proto, apicall);
 
@@ -4694,7 +5105,7 @@
 								}
 								tpl_addVar(vars, TPLAPPEND, "CLIENTLBVALUE", tpl_getTpl(vars, "CLIENTLBLVALUEBIT"));
 #else
-								tpl_printf(vars, TPLAPPEND, "CLIENTLBVALUE", "%s (%'d ms)", xml_encode(vars, cl->lastreader), cl->cwlastresptime);
+								tpl_printf(vars, TPLAPPEND, "CLIENTLBVALUE", "%s (%d ms)", xml_encode(vars, cl->lastreader), cl->cwlastresptime);
 #endif
 							}
 							if(cl->last_caid == NO_CAID_VALUE || isec > cfg.hideclient_to) tpl_addVar(vars, TPLADD, "CLIENTLBVALUE", "");
@@ -4812,12 +5223,10 @@
 									txt = "CCcam CacheEX";
 								}
 								else
-								{
 #endif
+								{
 									txt = "NEEDINIT";
-#ifdef CS_CACHEEX
 								}
-#endif
 								break;
 							case CARD_INSERTED:
 								if(cl->typ == 'p')
@@ -5565,6 +5974,30 @@
 			{ return tpl_getTpl(vars, "APICONFIRMATION"); }
 
 	}
+//	sky(n)
+#if 0
+#if defined(WITH_HISILICON)
+	else if (strcmp(strtolower(getParam(params, "action")), "cardstatus") == 0)
+	{
+		sprintf(stRDR_status, "CARDSTATUS: %d", HISCIAPI_ChkCardstatus(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "cardsystem") == 0)
+	{
+		sprintf(stRDR_status, "%s", HISCIAPI_ChkCardsystem(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "oscamversion") == 0)
+	{
+		#if defined(__HISILICON_MANUFACTORY__)
+			sprintf(stRDR_status, "v%s.Rev%s (f)\n", CS_VERSION, CS_SVN_VERSION);
+		#else
+			sprintf(stRDR_status, "v%s.Rev%s\n", CS_VERSION, CS_SVN_VERSION);
+		#endif
+		return (stRDR_status);
+	}
+#endif
+#endif
 	else
 	{
 		return tpl_getTpl(vars, "PRESHUTDOWN");
@@ -5770,8 +6203,8 @@
 	}
 	tpl_addVar(vars, TPLADD, "FILTERFORM", tpl_getTpl(vars, "FILTERFORM"));
 }
-
-enum file_types { FTYPE_CONFIG, FTYPE_VERSION, FTYPE_ANTICASC, FTYPE_LOGFILE, FTYPE_USERFILE };
+// sky(n,FTYPE_INFORMATION)
+enum file_types { FTYPE_CONFIG, FTYPE_VERSION, FTYPE_ANTICASC, FTYPE_LOGFILE, FTYPE_USERFILE, FTYPE_INFORMATION };
 
 struct files
 {
@@ -5797,6 +6230,16 @@
 		{ "oscam.tiers",     MNU_CFG_FTIERS,    FTYPE_CONFIG },
 		{ "oscam.ratelimit", MNU_CFG_RATELIMIT, FTYPE_CONFIG },
 		{ "css_file_name",   MNU_CFG_FCSS,      FTYPE_CONFIG },
+// sky(n)
+#if defined(WITH_HISILICON)
+		{ cs_SMCINFORMATION, MNU_CFG_FSMARTCARD, FTYPE_INFORMATION },
+#endif
+#if defined(MODULE_XCAS)
+		{ "oscam.keys",      MNU_CFG_FSCAMKEY,   FTYPE_CONFIG },
+#endif
+#if defined(MODULE_CONSTCW)
+		{ "constant.cw",     MNU_CFG_FCONSTCW,   FTYPE_CONFIG },
+#endif
 #ifdef HAVE_DVBAPI
 		{ "oscam.dvbapi",    MNU_CFG_FDVBAPI,   FTYPE_CONFIG },
 #endif
@@ -5844,12 +6287,12 @@
 #endif
 	}
 	// Process config files
-	char *file = getParam(params, "file");
+	char *parmfile = getParam(params, "file");
 	char targetfile[256] = { 0 };
 	int menu_id = 0;
 	for(entry = config_files; entry->file; entry++)
 	{
-		if(streq(file, entry->file))
+		if (streq(parmfile, entry->file))
 		{
 			if(!apicall) { setActiveSubMenu(vars, entry->menu_id); }
 			menu_id  = entry->menu_id;
@@ -5860,6 +6303,10 @@
 				writable = 1;
 				get_config_filename(targetfile, sizeof(targetfile), entry->file);
 				break;
+			   // sky(n)
+			   case FTYPE_INFORMATION:
+				   get_information_filename(targetfile, sizeof(targetfile), entry->file);
+				   break;
 			case FTYPE_VERSION:
 				get_tmp_dir_filename(targetfile, sizeof(targetfile), entry->file);
 				break;
@@ -5925,8 +6372,11 @@
 					case MNU_CFG_WHITELIST:
 						global_whitelist_read();
 						break;
-					default:
-						break;
+#if defined(MODULE_XCAS)
+						case MNU_CFG_FSCAMKEY:	CSREADER_Restart(R_XCAS); break;
+						case MNU_CFG_FCONSTCW:	CSREADER_Restart(R_CONSTCW); break;
+#endif
+						default: break;
 					}
 				}
 			}
@@ -5955,7 +6405,7 @@
 		tpl_addVar(vars, TPLAPPEND, "FILECONTENT", "File not valid!");
 	}
 
-	tpl_addVar(vars, TPLADD, "PART", file);
+	tpl_addVar(vars, TPLADD, "PART", parmfile);
 
 	if(!writable)
 	{
@@ -6420,6 +6870,8 @@
 {
 	uint64_t node = 0x00;
 	struct s_module *module = (cl->reader ? &cl->reader->ph : get_module(cl));
+
+	if (!module) return 0;
 #ifdef MODULE_CCCAM
 	if(module->num == R_CCCAM && cl->cc)
 	{
@@ -6838,6 +7290,23 @@
 		}
 
 	}
+//	sky(n)
+#if defined(WITH_HISILICON)
+	else if (strcmp(getParam(params, "part"), "mystatus") == 0)
+	{
+		if ((strcmp(strtolower(getParam(params, "action")), "cardstatus") == 0) ||
+			 (strcmp(strtolower(getParam(params, "action")), "cardsystem") == 0) ||
+			 (strcmp(strtolower(getParam(params, "action")), "oscamversion") == 0) ||
+			 (strcmp(strtolower(getParam(params, "action")), "logstatus") == 0))
+		{
+			return send_oscam_mystatus(vars, params, 1);
+		}
+		else {
+			tpl_addVar(vars, TPLADD, "APIERRORMESSAGE", "missing parameter action");
+			return tpl_getTpl(vars, "APIERROR");
+		}
+	}
+#endif
 	else
 	{
 		tpl_addVar(vars, TPLADD, "APIERRORMESSAGE", "part not found");
@@ -7148,6 +7617,10 @@
 
 static int8_t check_valid_origin(IN_ADDR_T addr)
 {
+	// sky(n)
+	if (check_LOCALHOST_ip(addr)) return 2;
+	// sky(sim)
+	if (g_factoy_products) return 0;
 
 	// check whether requesting IP is in allowed IP ranges
 	if(check_ip(cfg.http_allowed, addr))
@@ -7247,9 +7720,9 @@
 		bufsize += n;
 
 		//max request size 100kb
-		if(bufsize > 102400)
-		{
-			cs_log("error: too much data received from %s", cs_inet_ntoa(in));
+		// sky(102400->196608(192kB))
+		if (bufsize>196608) {
+			cs_log("error: too much data(%d) received from %s", bufsize, cs_inet_ntoa(in));
 			NULLFREE(*result);
 			*result = NULL;
 			return -1;
@@ -7284,6 +7757,7 @@
 static int32_t process_request(FILE * f, IN_ADDR_T in)
 {
 	int32_t ok = 0;
+	int32_t bypassAuthorize = 0;
 	int8_t *keepalive = (int8_t *)pthread_getspecific(getkeepalive);
 	IN_ADDR_T addr = GET_IP();
 
@@ -7297,7 +7771,9 @@
 
 		// at this point we do all checks related origin IP, ranges and dyndns stuff
 		ok = check_valid_origin(addr);
-		cs_log_dbg(D_TRACE, "WebIf: Origin checked. Result: access from %s => %s", cs_inet_ntoa(addr), (!ok) ? "forbidden" : "allowed");
+		// sky(a)
+		if (ok==2) bypassAuthorize = 1;
+//		cs_log_dbg(D_TRACE, "WebIf: Origin checked. Result: access from %s => %s", cs_inet_ntoa(addr), (!ok)? "forbidden" : "allowed");
 
 		// based on the failed origin checks we send a 403 to calling browser
 		if(!ok)
@@ -7314,39 +7790,41 @@
 		char *method, *path, *protocol, *str1, *saveptr1 = NULL, *authheader = NULL, *extraheader = NULL, *filebuf = NULL;
 		char *pch, *tmp, *buf, *nameInUrl, subdir[32];
 		/* List of possible pages */
-		char *pages[] =
-		{
-			"/config.html",
-			"/readers.html",
-			"/entitlements.html",
-			"/status.html",
-			"/userconfig.html",
-			"/readerconfig.html",
-			"/services.html",
-			"/user_edit.html",
-			"/site.css",
-			"/services_edit.html",
-			"/savetemplates.html",
-			"/shutdown.html",
-			"/script.html",
-			"/scanusb.html",
-			"/files.html",
-			"/readerstats.html",
-			"/failban.html",
-			"/oscam.js",
-			"/oscamapi.html",
-			"/image",
-			"/favicon.ico",
-			"/graph.svg",
-			"/oscamapi.xml",
-			"/cacheex.html",
-			"/oscamapi.json",
-			"/emm.html",
-			"/emm_running.html",
-			"/robots.txt",
-			"/ghttp.html",
-			"/logpoll.html",
-			"/jquery.js",
+		char *pages[]= {
+					"/config.html",			/*  0 */
+					"/readers.html",			/*  1 */
+					"/entitlements.html",	/*  2 */
+					"/status.html",			/*  3 */
+					"/userconfig.html",		/*  4 */
+					"/readerconfig.html",	/*  5 */
+					"/services.html",			/*  6 */
+					"/user_edit.html",		/*  7 */
+					"/site.css",				/*  8 */
+					"/services_edit.html",	/*  9 */
+					"/savetemplates.html",	/* 10 */
+					"/shutdown.html",			/* 11 */
+					"/script.html",			/* 12 */
+					"/scanusb.html",			/* 13 */
+					"/files.html",				/* 14 */
+					"/readerstats.html",		/* 15 */
+					"/failban.html",			/* 16 */
+					"/oscam.js",				/* 17 */
+					"/oscamapi.html",			/* 18 */
+					"/image",					/* 19 */
+					"/favicon.ico",			/* 20 */
+					"/graph.svg",				/* 21 */
+					"/oscamapi.xml",			/* 22 */
+					"/cacheex.html",			/* 23 */
+					"/oscamapi.json",			/* 24 */
+					"/emm.html",				/* 25 */
+					"/emm_running.html",		/* 26 */
+					"/robots.txt",				/* 27 */
+					"/ghttp.html",				/* 28 */
+			      "/logpoll.html",			/* 29 */
+			      "/jquery.js",				/* 30 */
+#if defined(WITH_HISILICON)
+					"/mystatus.html",			/* 31 */
+#endif
 		};
 
 		int32_t pagescnt = sizeof(pages) / sizeof(char *); // Calculate the amount of items in array
@@ -7441,6 +7919,8 @@
 
 		parseParams(&params, pch);
 
+		// sky(a)
+		if (bypassAuthorize) authok = 1;
 		if(!cfg.http_user || !cfg.http_pwd)
 			{ authok = 1; }
 
@@ -7484,6 +7964,11 @@
 			}
 		}
 
+		// sky(a)
+		if (bypassAuthorize) {
+			NULLFREE(authheader);
+		}
+		else
 		if(cfg.http_user && cfg.http_pwd)
 		{
 			if(!authok || strlen(opaque) != MD5_DIGEST_LENGTH * 2) { calculate_opaque(addr, opaque); }
@@ -7552,7 +8037,9 @@
 			time(&t);
 
 			localtime_r(&t, &lt);
-
+//			myprintf("myweb::(%s)\n", pages[pgidx]);
+			if (pgidx != 31) // !mystatus.html
+			{
 			tpl_addVar(vars, TPLADD, "CS_VERSION", CS_VERSION);
 			tpl_addVar(vars, TPLADD, "CS_SVN_VERSION", CS_SVN_VERSION);
 			tpl_addVar(vars, TPLADD, "CS_TARGET", CS_TARGET);
@@ -7648,7 +8135,7 @@
 			i = ll_count(cfg.v_list);
 			if(i > 0) { tpl_printf(vars, TPLADD, "FAILBANNOTIFIER", "<SPAN CLASS=\"span_notifier\">%d</SPAN>", i); }
 			tpl_printf(vars, TPLADD, "FAILBANNOTIFIERPOLL", "%d", i);
-
+			}  // sky()
 			char *result = NULL;
 
 			// WebIf allows modifying many things. Thus, all pages except images/css/static are expected to be non-threadsafe!
@@ -7748,6 +8235,11 @@
 				result = send_oscam_logpoll(vars, &params);
 				break;
 #endif				
+#if defined(WITH_HISILICON)
+				case 31:
+					result = send_oscam_mystatus(vars, &params, 0);
+					break;
+#endif
 			default:
 				result = send_oscam_status(vars, &params, 0);
 				break;
@@ -7768,6 +8260,22 @@
 					{ send_headers(f, 200, "OK", extraheader, "text/html", 0, strlen(result), NULL, 0); }
 				webif_write(result, f);
 			}
+			// sky(n)
+			else if (strncmp(result, "CARDSTATUS", 9))
+			{
+				send_headers(f, 200, "OK", NULL, "text/plain", 0, strlen(result), NULL, 0);
+				webif_write(result, f);
+			}
+			else if (strncmp(result, "READER", 6))
+			{
+				send_headers(f, 200, "OK", NULL, "text/plain", 0, strlen(result), NULL, 0);
+				webif_write(result, f);
+			}
+			else if (strncmp(result, "SKYLEVEL", 7))
+			{
+				send_headers(f, 200, "OK", NULL, "text/plain", 0, strlen(result), NULL, 0);
+				webif_write(result, f);
+			}
 			tpl_clear(vars);
 		}
 		NULLFREE(filebuf);
@@ -8107,6 +8615,7 @@
 #endif
 	cs_log("HTTP Server stopped");
 	free_client(cl);
+	shutdown(sock, SHUT_RDWR); /* sky */
 	close(sock);
 	return NULL;
 }
@@ -8186,4 +8695,4 @@
 	pthread_join(httpthread, NULL);
 }
 
-#endif
+#endif // #ifdef WEBIF
Index: module-xcas.c
===================================================================
--- module-xcas.c	(nonexistent)
+++ module-xcas.c	(working copy)
@@ -0,0 +1,300 @@
+#define MODULE_LOG_PREFIX "xcas"
+#include "globals.h"
+#if defined(MODULE_XCAS)
+#include "oscam-client.h"
+#include "oscam-ecm.h"
+#include "oscam-chk.h"
+#include "oscam-net.h"
+#include "oscam-string.h"
+#include "module-dvbapi.h"
+#include "module-xcas.h"
+
+extern struct s_client	*dvbApi_client;
+static int32_t 			pserver;
+
+// sky(powervu)
+bool
+xcas_IsAuAvailable(struct s_reader *rdr, uint16_t casid, uint32_t provid)
+{
+	#if defined(__XCAS_AUTOROLL__)
+		if (IS_EMU_READERS(rdr)) {
+		//	if (casid==0x500 && provid==0x030B00) return 1; /* dead */
+			if (casid==0xE00) return 1;
+		}
+	#endif
+	return 0;
+}
+// sky(powervu)
+bool
+xcas_IsEmmAvailable(struct s_reader *rdr, EMM_PACKET *ep)
+{
+	#if defined(__XCAS_AUTOROLL__)
+		uint16_t casid = b2i(2, ep->caid);
+		if (IS_EMU_READERS(rdr)) {
+		//	if (casid==0x500 && provid==0x030B00) return 1; /* dead */
+			if (casid==0xE00) return 1;
+		}
+	#endif
+	return 0;
+}
+//**********************************************************************
+//* client/server common functions
+//**********************************************************************
+static int32_t
+xcas_recv(struct s_client *client, uchar *buf, int32_t l)
+{
+	int32_t ret;
+
+	MYXCAS_TRACE("xcas:xcas_recv{%p}\n", client);
+	if (!client->udp_fd) return -9;
+	ret = read(client->udp_fd, buf, l);
+	if (ret < 1) return(-1);
+	client->last = time(NULL);
+	return (ret);
+}
+
+//**********************************************************************
+//*       client functions
+//**********************************************************************
+int32_t
+xcas_clinit(struct s_client *client)
+{
+	int32_t fdp[2];
+
+	MYXCAS_TRACE("xcas:xcas_clinit{%p}\n", client);
+	client->pfd = 0;
+	if (socketpair(PF_LOCAL, SOCK_STREAM, 0, fdp))
+	{
+		cs_log("xcas:xcas_clinit failed (%s)", strerror(errno));
+		return 1;
+	}
+	client->udp_fd = fdp[0];
+	client->pfd = client->udp_fd;
+	client->emu_casid = 0;
+	pserver = fdp[1];
+
+	memset((char *) &client->udp_sa, 0, sizeof(client->udp_sa));
+	SIN_GET_FAMILY(client->udp_sa) = AF_INET;
+
+	if (XEMUKEY_Initialize(client->reader))
+	{
+		mycs_log("xcas:file(%s)", client->reader->device);
+		client->reader->card_status = CARD_INSERTED;
+	}
+	else
+	{
+		mycs_log("xcas:non file(%s)", client->reader->device);
+		client->reader->card_status = CARD_FAILURE;
+	}
+	client->reader->tcp_ito = 0;
+	client->reader->last_s 	= client->reader->last_g = time(NULL);
+	return 0;
+}
+
+// return 1 if we are able to send requests
+int32_t
+xcas_clAvailable(struct s_reader *reader, int32_t checktype, ECM_REQUEST *er)
+{
+	if (!er) return 0;
+	if (!reader) return 0;
+	if ( reader->card_status != CARD_INSERTED) return 0;
+	if (checktype == AVAIL_CHECK_CHANNEL || checktype == AVAIL_CHECK_ECM)
+	{
+		if (!XEMUKEY_IsAvailable(reader, er->caid, er->prid)) return 0;
+	}
+	return 1;
+}
+
+
+void
+xcas_clidle(void)
+{
+	struct s_client *client = cur_client();
+	time_t  now;
+	int32_t time_diff;
+
+	if (!client) return;
+	if (!client->reader) return;
+	if (!client->reader->enable) return;
+	if (!IS_BISS(client->emu_casid)) return;
+	if ( client->reader->ch_descramble) return;
+
+	time(&now);
+	time_diff = now - client->reader->last_s;
+	if (time_diff > 12)
+	{
+	#if defined(WITH_HISILICON)
+		if (chk_av_descrambling(client)) {
+			client->reader->ch_descramble = 1;
+			client->reader->tcp_ito = 0;
+			mycs_debug(D_ADB, "xcas:descrambling");
+		}
+		else {
+			mycs_debug(D_ADB, "xcas:scrambled");
+			dvbapi_constcw_afterwards(R_XCAS, client->ch_ics.muxid, 1);
+		}
+	#endif
+	}
+}
+
+
+static int32_t
+xcas_send_ecm(struct s_client *client, ECM_REQUEST *er, uchar *UNUSED(msgbuf))
+{
+	CWEXTENTION cwEx;
+	uint8_t cw[16];
+	time_t  now;
+	int cwisextend = 0;
+	int cwfound = 0;
+
+	if (!er) return 0;
+	if (!client->reader) return 0;
+	if ( client->reader->card_status != CARD_INSERTED) return 0;
+	client->reader->tcp_ito = 0;
+	client->reader->audisabled = 1;
+	if (xcas_IsAuAvailable(client->reader, er->caid, er->prid)) client->reader->audisabled = 0;
+	client->emu_casid = er->caid;
+	switch (er->caid & 0xff00)
+	{
+	#if defined(__XCAS_SEKA__)
+		case 0x0100:
+			mycs_debug(D_ADB, "xcas:send_ecm.seka{%04X}", er->caid);
+			cwfound = XSEKA_Process(client->reader, er, cw);
+			break;
+	#endif
+	#if defined(__XCAS_VIACESS__)
+		case 0x0500:
+			mycs_debug(D_ADB, "xcas:send_ecm.viacess{%04X}", er->caid);
+			cwfound = XVIACESS_Process(client->reader, er, cw);
+			break;
+	#endif
+	#if defined(__XCAS_BISS__)
+		case 0x2600:
+			mycs_debug(D_ADB, "xcas:send_ecm.biss{%04X.%d}", er->caid, er->constAfterwards);
+			cwfound = XBISS_Process(client->reader, er, cw);
+			client->reader->tcp_ito = 10;
+			break;
+	#endif
+	#if defined(__XCAS_CRYPTOWORKS__)
+		case 0x0D00:
+			mycs_debug(D_ADB, "xcas:send_ecm.cryptoworks{%04X}", er->caid);
+			cwfound = XCRYPTOWORKS_Process(client->reader, er, cw);
+			break;
+	#endif
+	#if defined(__XCAS_POWERVU__)
+		case 0x0E00:
+			mycs_debug(D_ADB, "xcas:send_ecm.powervu{%04X}", er->caid);
+			cwisextend = 1;
+			cwfound = XPVU_Process(client->reader, er, cw, &cwEx);
+			break;
+	#endif
+		default:
+			mycs_debug(D_ADB, "xcas:send_ecm.failed{%04X}", er->caid);
+			break;
+	}
+
+	if (cwfound > 0)
+	{
+		write_ecm_answer(client->reader, er, E_FOUND, 0, cw,
+					(cwisextend) ? &cwEx : NULL, NULL);
+	}
+	else if (cwfound == 0)
+	{
+		write_ecm_answer(client->reader, er, E_NOTFOUND, (E1_READER<<4 | E2_SID), NULL, NULL, NULL);
+	}
+	now = time(NULL);
+	client->last = now;
+	client->reader->last_s = client->reader->last_g = now;
+	return 0;
+}
+
+static int32_t
+xcas_send_emm(struct emm_packet_t *emm)
+{
+	int found = 0;
+	#if defined(__XCAS_AUTOROLL__)
+		uint16_t caid   = b2i(2, emm->caid);
+		uint32_t provid = b2i(4, emm->provid);
+
+		mycs_debug(D_ADB, "xcas:send_emm{%02X.%06X}", caid, provid);
+		switch (caid)
+		{
+		#if defined(__XCAS_VIACESS__)
+			case 0x0500:
+				found = XVIACESS_EmmProcess(emm->client->reader, emm->emm, emm->emmlen, provid);
+				break;
+		#endif
+		#if defined(__XCAS_POWERVU__)
+			case 0x0E00:
+				found = XPVU_EmmProcess(emm->client->reader, emm->emm, emm->emmlen);
+				break;
+		#endif
+			default:
+				break;
+		}
+	#endif
+	return found;
+}
+
+static int32_t
+xcas_recv_chk(struct s_client *UNUSED(client), uchar *UNUSED(dcw), int32_t *rc, uchar *UNUSED(buf), int32_t UNUSED(n))
+{
+	MYXCAS_TRACE("xcas:recv_chk\n");
+	*rc = 0;
+	return -1;
+}
+
+static int32_t
+xcas_ChCloser(struct s_client *client, int muxid)
+{
+	MYXCAS_TRACE("xcas:chstop\n");
+	if (!client) return -1;
+	if (!client->reader) return -1;
+	client->emu_casid = 0;
+	client->reader->tcp_ito = 0;
+	client->reader->ch_descramble = 0;
+	XEMUKEY_Cleanup(client->reader);
+	return 1;
+}
+
+static int32_t
+xcas_Cleanup(struct s_client *client)
+{
+	MYXCAS_TRACE("xcas:cleanup\n");
+	if (!client) return -1;
+	if (!client->reader) return -1;
+	if (XEMUKEY_Initialize(client->reader))
+	{
+		mycs_log("xcas:file(%s)", client->reader->device);
+		client->reader->card_status = CARD_INSERTED;
+	}
+	else
+	{
+		mycs_log("xcas:non file(%s)", client->reader->device);
+		client->reader->card_status = CARD_FAILURE;
+	}
+	return 1;
+}
+
+void
+MODULE_xcas(struct s_module *ph)
+{
+	MYXCAS_TRACE("MODULE_xcas...\n");
+	ph->desc 		 	= "xcas";
+	ph->type 		 	= MOD_NO_CONN;
+	ph->listenertype	= LIS_XCAS;
+	ph->c_available 	= xcas_clAvailable;
+	ph->c_init 		 	= xcas_clinit;
+	ph->c_idle			= xcas_clidle;
+	ph->recv 		 	= xcas_recv;
+	ph->c_recv_chk  	= xcas_recv_chk;
+	ph->c_send_ecm  	= xcas_send_ecm;
+	ph->c_send_emm  	= xcas_send_emm;
+	ph->c_ChCloser		= xcas_ChCloser;
+	ph->c_Cleanup		= xcas_Cleanup;
+	ph->num			 	= R_XCAS;
+	ph->large_ecm_support = 1;
+}
+
+#endif	// #if defined(MODULE_XCAS)
+
Index: module-xcas.h
===================================================================
--- module-xcas.h	(nonexistent)
+++ module-xcas.h	(working copy)
@@ -0,0 +1,101 @@
+#ifndef MODULE_XCAS_H_
+#define MODULE_XCAS_H_
+#if defined(MODULE_XCAS)
+//
+//
+//
+#if 1
+	#define	MYXCAS_TRACE	myprintf
+	#define	MYEMU_TRACE		myprintf
+#else
+	#define	MYXCAS_TRACE(...)
+	#define	MYEMU_TRACE(...)
+#endif
+//
+//
+//
+//
+//
+//
+	#define	__XCAS_BISS__
+	#define	__XCAS_VIACESS__
+	#define	__XCAS_SEKA__
+	#define	__XCAS_CRYPTOWORKS__
+	#define	__XCAS_POWERVU__	/* sky(2016.03.07) */
+
+// futures...
+//	#define	__XCAS_XIRDETO__
+//	#define	__XCAS_XBETACRYPT__
+//	#define	__XCAS_XNAGRA__
+//	#define	__XCAS_XCONAX__
+//	#define	__XCAS_XNDS__
+//
+//	#define	__XCAS_AUTOROLL__	// E00,500:030B00 /* sky(powervu) */
+//
+//
+//
+//
+//
+#define MAXMULTIKEY			32
+
+#define CASS_NAGRA			'N'
+#define CASS_VIACCESS		'V'
+#define CASS_IRDETO			'I'
+#define CASS_SEKA				'S'
+#define CASS_CRYPTOWORKS	'W'
+#define CASS_BISS				'B'
+#define CASS_CONSTANT		'F'
+#define CASS_POWERVU			'P'
+
+#define EMU_BISS				0x1
+#define EMU_VIACESS			0x2
+#define EMU_CRYPTOWORKS		0x4
+#define EMU_SEKA				0x8
+#define EMU_CONSTANT			0x10
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+int	XEMUKEY_Initialize	(struct s_reader *rdr);
+void	XEMUKEY_Cleanup		(struct s_reader *rdr); // sky(powervu)
+bool	XEMUKEY_IsExistance	(struct s_reader *rdr, uint8_t  cCAS, uint32_t ppid);
+int	XEMUKEY_ChLfsSearch	(struct s_reader *rdr, uint8_t  cCAS, uint32_t frequency, uint32_t symrate, uint8_t *kbufs, uint16_t klenn);
+int	XEMUKEY_SpecialSearch(struct s_reader *rdr, uint8_t  cCAS, uint32_t ppid, char *kstr,  uint8_t *kbufs, uint16_t klenn);
+int	XEMUKEY_MultiSearch	(struct s_reader *rdr, uint8_t  cCAS, uint32_t ppid, uint8_t knr, uint8_t *kbufs, uint16_t klenn);
+int	XEMUKEY_Searchkey		(struct s_reader *rdr, uint8_t  cCAS, uint32_t ppid, uint8_t knr, uint8_t *kbufs, uint16_t klenn);
+int	XEMUKEY_IndexedSearch(struct s_reader *rdr, uint8_t  cCAS, uint32_t ppid, uint8_t knr, uint8_t *kbufs, uint16_t klenn, int *pfoundindex);
+int	XEMUKEY_IsAvailable	(struct s_reader *rdr, uint16_t caid, uint32_t prid);
+int	XEMUKEY_PidsSearch	(struct s_reader *rdr, uint8_t  cCAS, uint32_t *ppids, uint32_t ppnum, uint8_t knr, uint8_t *kbufs, uint16_t klenn, int *pfoundindex);
+int	XEMUKEY_Savekey      (struct s_reader *rdr, uint8_t  cCAS, uint32_t ppid, char *kNstr, uint8_t *kBufs,	uint16_t ksize);
+// viacess
+// biss
+// cryptoworks
+// seca
+#if defined(__XCAS_VIACESS__)
+int	XVIACESS_EmmProcess	(struct s_reader *rdr, unsigned char *emm, int emmlen, unsigned long provid);
+int	XVIACESS_Process		(struct s_reader *rdr, ECM_REQUEST *er, uint8_t *cw);
+void	XVIACESS_Cleanup		(void);
+#endif
+#if defined(__XCAS_BISS__)
+int	XBISS_Process			(struct s_reader *rdr, ECM_REQUEST *er, uint8_t *cw);
+void	XBISS_Cleanup			(void);
+#endif
+#if defined(__XCAS_SEKA__)
+int	XSEKA_Process			(struct s_reader *rdr, ECM_REQUEST *er, uint8_t *cw);
+void	XSEKA_Cleanup			(void);;
+#endif
+#if defined(__XCAS_CRYPTOWORKS__)
+int	XCRYPTOWORKS_Process	(struct s_reader *rdr, ECM_REQUEST *er, uint8_t *cw);
+void	XCRYPTOWORKS_Cleanup	(void);
+#endif
+#if defined(__XCAS_CRYPTOWORKS__)
+int	XPVU_Process			(struct s_reader *rdr, ECM_REQUEST *er, uint8_t *cw, CWEXTENTION *cwEx);
+int	XPVU_EmmProcess		(struct s_reader *rdr, unsigned char *emm, int emmlen);
+void	XPVU_Cleanup			(struct s_reader *rdr);
+#endif
+// sky(powervu)
+bool	xcas_IsAuAvailable	(struct s_reader *rdr, uint16_t casid, uint32_t prid);
+bool	xcas_IsEmmAvailable	(struct s_reader *rdr, EMM_PACKET *ep);
+
+#endif	// defined(MODULE_XCAS)
+#endif	// #ifndef MODULE_XCAS_H_
+
Index: modules.h
===================================================================
--- modules.h	(revision 10670)
+++ modules.h	(working copy)
@@ -17,4 +17,14 @@
 void module_csp(struct s_module *);
 void module_dvbapi(struct s_module *);
 
+#if defined(MODULE_XCAS)
+void MODULE_xcas(struct s_module *);
+#endif	// #if defined(MODULE_XCAMD)
+#if defined(MODULE_XCAMD)
+void MODULE_xcamd(struct s_module *);
+#endif	// #if defined(MODULE_XCAMD)
+#if defined(MODULE_MORECAM)
+void MODULE_morecam(struct s_module *);
+#endif	// #if defined(MODULE_MORECAM)
+
 #endif
Index: oscam-aes.c
===================================================================
--- oscam-aes.c	(revision 10670)
+++ oscam-aes.c	(working copy)
@@ -22,8 +22,7 @@
 void aes_decrypt(struct aes_keys *aes, uchar *buf, int32_t n)
 {
 	int32_t i;
-	for(i = 0; i < n; i += 16)
-	{
+	for (i=0; i<n; i+=16) {
 		AES_decrypt(buf + i, buf + i, &aes->aeskey_decrypt);
 	}
 }
@@ -31,8 +30,7 @@
 void aes_encrypt_idx(struct aes_keys *aes, uchar *buf, int32_t n)
 {
 	int32_t i;
-	for(i = 0; i < n; i += 16)
-	{
+	for (i=0; i<n; i+=16) {
 		AES_encrypt(buf + i, buf + i, &aes->aeskey_encrypt);
 	}
 }
@@ -44,27 +42,24 @@
 
 	// create the AES key entry for the linked list
 	if(!cs_malloc(&new_entry, sizeof(AES_ENTRY)))
-		{ return; }
+		return;
 
 	memcpy(new_entry->plainkey, aesKey, 16);
 	new_entry->caid = caid;
 	new_entry->ident = ident;
 	new_entry->keyid = keyid;
-	if(memcmp(aesKey, "\xFF\xFF", 2))
-	{
+	if (memcmp(aesKey,"\xFF\xFF",2)) {
 		AES_set_decrypt_key((const unsigned char *)aesKey, 128, &(new_entry->key));
 		// cs_log("adding key : %s",cs_hexdump(1,aesKey,16, tmp, sizeof(tmp)));
 	}
-	else
-	{
+	else {
 		memset(&new_entry->key, 0, sizeof(AES_KEY));
 		// cs_log("adding fake key");
 	}
 	new_entry->next = NULL;
 
 	//if list is empty, new_entry is the new head
-	if(!*list)
-	{
+	if (!*list) {
 		*list = new_entry;
 		return;
 	}
@@ -72,8 +67,7 @@
 	//append it to the list
 	current = *list;
 	next = current->next;
-	while(next)
-	{
+	while (next) {
 		current = next;
 		next = current->next;
 	}
@@ -96,18 +90,18 @@
 
 	//if we got error caid
 	len = strlen(tmp);
-	if(len == 0 || len > 4) { return; }
+	if (len == 0 || len > 4) return;
 
 	//if there is not value after @
 	len = strlen(save);
-	if(len == 0) { return; }
+	if (len == 0) return;
 
 	caid = a2i(tmp, 2);
 	tmp = strtok_r(NULL, ":", &save);
 
 	//if we got error ident
 	len = strlen(tmp);
-	if(len == 0 || len > 6) { return; }
+	if (len == 0 || len > 6) return;
 
 	ident = a2i(tmp, 3);
 
@@ -118,28 +112,25 @@
 	{
 		dummy = 0;
 		len = strlen(tmp);
-		if(len != 32)
-		{
+		if (len != 32) {
 			dummy = a2i(tmp, 1);
 			// FF means the card will do the AES decrypt
 			// 00 means we don't have the aes.
-			if((dummy != 0xFF && dummy != 0x00) || len > 2)
-			{
+			if ((dummy != 0xFF && dummy != 0x00) || len > 2) {
 				key_id++;
-				cs_log("AES key length error .. not adding");
+//				cs_log("AES key length error .. not adding");
 				continue;
 			}
-			if(dummy == 0x00)
-			{
+			if (dummy==0x00) {
 				key_id++;
 				continue;
 			}
 		}
 		nb_keys++;
 		if(dummy)
-			{ memset(aes_key, 0xFF, 16); }
+			memset(aes_key, 0xFF, 16);
 		else
-			{ key_atob_l(tmp, aes_key, 32); }
+			key_atob_l(tmp, aes_key, 32);
 		// now add the key to the reader... TBD
 		add_aes_entry(list, caid, ident, key_id, aes_key);
 		key_id++;
@@ -154,8 +145,7 @@
 	AES_ENTRY *current, *next;
 	current = NULL;
 	next = *list;
-	while(next)
-	{
+	while (next) {
 		current = next;
 		next = current->next;
 		add_garbage(current);
@@ -171,8 +161,7 @@
 	char *save = NULL;
 	AES_ENTRY *newlist = NULL, *savelist = rdr->aes_list;
 
-	for(entry = strtok_r(value, ";", &save); entry; entry = strtok_r(NULL, ";", &save))
-	{
+	for (entry=strtok_r(value, ";",&save); entry; entry=strtok_r(NULL, ";",&save)) {
 		parse_aes_entry(&newlist, rdr->label, entry);
 	}
 	rdr->aes_list = newlist;
@@ -197,10 +186,9 @@
 static AES_ENTRY *aes_list_find(AES_ENTRY *list, uint16_t caid, uint32_t provid, int32_t keyid)
 {
 	AES_ENTRY *current = list;
-	while(current)
-	{
+	while (current) {
 		if(current->caid == caid && current->ident == provid && current->keyid == keyid)
-			{ break; }
+			break;
 		current = current->next;
 	}
 	if(!current)
@@ -215,19 +203,17 @@
 int32_t aes_decrypt_from_list(AES_ENTRY *list, uint16_t caid, uint32_t provid, int32_t keyid, uchar *buf, int32_t n)
 {
 	AES_ENTRY *current = aes_list_find(list, caid, provid, keyid);
-	if(!current)
-		{ return 0; }
+	if (!current) return 0;
 	AES_KEY dummy;
 	int32_t i;
 	// hack for card that do the AES decrypt themsleves
 	memset(&dummy, 0, sizeof(AES_KEY));
-	if(!memcmp(&current->key, &dummy, sizeof(AES_KEY)))
-	{
+	if (!memcmp(&current->key, &dummy, sizeof(AES_KEY))) {
 		return 1;
 	}
 	// decode the key
 	for(i = 0; i < n; i += 16)
-		{ AES_decrypt(buf + i, buf + i, &(current->key)); }
+		AES_decrypt(buf + i, buf + i, &(current->key));
 	return 1; // all ok, key decoded.
 }
 
Index: oscam-cache.c
===================================================================
--- oscam-cache.c	(revision 10670)
+++ oscam-cache.c	(working copy)
@@ -23,6 +23,7 @@
 
 typedef struct cw_t {
 	uchar			cw[16];
+	CWEXTENTION cwEx;	// sky(powervu)
 	uint8_t			odd_even;			//odd/even byte (0x80 0x81)
 	uint8_t			cwc_cycletime;
 	uint8_t			cwc_next_cw_cycle;
@@ -66,13 +67,15 @@
 static hash_table ht_cache;
 static list ll_cache;
 
-void init_cache(void){
+void init_cache(void)
+{
 	init_hash_table(&ht_cache, &ll_cache);
 	if (pthread_rwlock_init(&cache_lock,NULL) != 0)
 		cs_log("Error creating lock cache_lock!");
 }
 
-void free_cache(void){
+void free_cache(void)
+{
 	cleanup_cache(true);
 	deinitialize_hash_table(&ht_cache);
 	pthread_rwlock_destroy(&cache_lock);
@@ -82,12 +85,14 @@
 	return count_hash_table(&ht_cache);
 }
 
-static uint8_t count_sort(CW *a, CW *b){
+uint8_t count_sort(CW *a, CW *b)
+{
 	if (a->count == b->count) return 0;
 	return (a->count > b->count) ? -1 : 1; 	//DESC order by count
 }
 
-uint8_t check_is_pushed(void *cwp, struct s_client *cl){
+uint8_t check_is_pushed(void *cwp, struct s_client *cl)
+{
 
 	struct s_pushclient *cl_tmp;
 	CW* cw = (CW*)cwp;
@@ -115,18 +120,28 @@
 
 		pthread_rwlock_unlock(&cw->pushout_client_lock);
 		return 0;
-	}else{
+	}
+	else
+	{
 		pthread_rwlock_unlock(&cw->pushout_client_lock);
 		return 1;
 	}
 }
 
-uint8_t get_odd_even(ECM_REQUEST *er){
-	return (er->ecm[0] != 0x80 && er->ecm[0] != 0x81 ? 0 : er->ecm[0]);
+uint8_t get_odd_even(ECM_REQUEST *er)
+{
+	// sky(dvn) /* tableid:0x50 */
+	if (caid_is_dvn(er->caid)) {
+		return (er->ecm[0]);
+	}
+	else {
+		return ((er->ecm[0] != 0x80 && er->ecm[0] != 0x81) ? 0 : er->ecm[0]);
+	}
 }
 
 
-CW *get_first_cw(ECMHASH *ecmhash, ECM_REQUEST *er){
+CW *get_first_cw(ECMHASH *ecmhash, ECM_REQUEST *er)
+{
 	if(!ecmhash) return NULL;
 
 	node *j;
@@ -145,12 +160,14 @@
 	return NULL;
 }
 
-static int compare_csp_hash(const void *arg, const void *obj){
+static int compare_csp_hash(const void *arg, const void *obj)
+{
 	int32_t h = ((const ECMHASH*)obj)->csp_hash;
 	return memcmp(arg, &h, 4);
 }
 
-static int compare_cw(const void *arg, const void *obj){
+static int compare_cw(const void *arg, const void *obj)
+{
 	return memcmp(arg, ((const CW*)obj)->cw, 16);
 }
 
@@ -186,6 +203,8 @@
 struct ecm_request_t *check_cache(ECM_REQUEST *er, struct s_client *cl)
 {
 	if(!er->csp_hash) return NULL;
+	if ( er->ecm_dongles) return NULL;
+//	if (caid_is_biss(er->caid)) return NULL; /* sky(biss) */
 
 	ECM_REQUEST *ecm = NULL;
 	ECMHASH *result;
@@ -234,9 +253,11 @@
 			goto out_err;
 
 		if (cs_malloc(&ecm, sizeof(ECM_REQUEST))){
+			ecm->dmuxid = er->dmuxid; // sky(powervu)
 			ecm->rc = E_FOUND;
 			ecm->rcEx = 0;
 			memcpy(ecm->cw, cw->cw, 16);
+			memcpy(&ecm->cwEx, &cw->cwEx, sizeof(CWEXTENTION)); // sky(power)
 			ecm->grp = cw->grp;
 			ecm->selected_reader = cw->selected_reader;
 			ecm->cwc_cycletime = cw->cwc_cycletime;
@@ -345,6 +366,7 @@
 		while(1){
 			if(cs_malloc(&cw, sizeof(CW))){
 				memcpy(cw->cw, er->cw, sizeof(er->cw));
+				memcpy(&cw->cwEx, &er->cwEx, sizeof(CWEXTENTION));
 				cw->odd_even = get_odd_even(er);
 				cw->cwc_cycletime = er->cwc_cycletime;
 				cw->cwc_next_cw_cycle = er->cwc_next_cw_cycle;
@@ -402,7 +424,8 @@
 	cacheex_cache_add(er, result, cw, add_new_cw);
 }
 
-void cleanup_cache(bool force){
+void cleanup_cache(bool force)
+{
 	ECMHASH *ecmhash;
 	CW *cw;
 	struct s_pushclient *pc, *nxt;
Index: oscam-chk.c
===================================================================
--- oscam-chk.c	(revision 10670)
+++ oscam-chk.c	(working copy)
@@ -7,8 +7,9 @@
 #include "oscam-client.h"
 #include "oscam-net.h"
 #include "oscam-string.h"
-#include "module-stat.h"
 #include "oscam-reader.h"
+#include "oscam-time.h"
+#include "module-stat.h"
 
 #define CS_NANO_CLASS 0xE2
 #define OK      1
@@ -60,30 +61,30 @@
 		if(l + j > er->ecmlen) { continue; }  // skip, this is not a valid class identifier!
 		ecm_class = er->ecm[j + l];
 		cs_log_dbg(D_CLIENT, "ecm class=%02X", ecm_class);
-		for(i = 0; i < clstab->bn; i++)    // search in blocked
+		for (i=0; i<clstab->bn; i++) {  // search in blocked
 			if(ecm_class == clstab->bclass[i])
 			{
 				cs_log_dbg(D_CLIENT, "class %02X rejected by %s '%s' !%02X filter",
 							  ecm_class, type, name, ecm_class);
 				return 0;
 			}
-
+		}
 		cl_n++;
-		for(i = 0; i < clstab->an; i++)    // search in allowed
+		for (i=0; i<clstab->an; i++) { // search in allowed
 			if(ecm_class == clstab->aclass[i])
 			{
 				an++;
 				break;
 			}
+		}
 		j += l;
 	}
 
 	if(cl_n && clstab->an)
 	{
 		if(an)
-			{ cs_log_dbg(D_CLIENT, "ECM classes allowed by %s '%s' filter", type, name); }
-		else
-		{
+			cs_log_dbg(D_CLIENT, "ECM classes allowed by %s '%s' filter", type, name);
+		else {
 			cs_log_dbg(D_CLIENT, "ECM classes don't match %s '%s' filter, rejecting", type, name);
 			return 0;
 		}
@@ -97,23 +98,26 @@
 	int32_t i, rc = 0;
 
 	if(!sidtab->num_caid)
-		{ rc |= 1; }
-	else
-		for(i = 0; (i < sidtab->num_caid) && (!(rc & 1)); i++)
-			if(er->caid == sidtab->caid[i]) { rc |= 1; }
-
+		rc|=1;
+	else {
+		for (i=0; (i<sidtab->num_caid) && (!(rc&1)); i++) {
+		  	if (er->caid==sidtab->caid[i]) rc|=1;
+		}
+	}
 	if(!er->prid || !sidtab->num_provid)
-		{ rc |= 2; }
-	else
-		for(i = 0; (i < sidtab->num_provid) && (!(rc & 2)); i++)
-			if(er->prid == sidtab->provid[i]) { rc |= 2; }
-
+		rc|=2;
+	else {
+		for (i=0; (i<sidtab->num_provid) && (!(rc&2)); i++) {
+		  	if (er->prid==sidtab->provid[i]) rc|=2;
+		}
+	}
 	if(!sidtab->num_srvid)
-		{ rc |= 4; }
-	else
-		for(i = 0; (i < sidtab->num_srvid) && (!(rc & 4)); i++)
-			if(er->srvid == sidtab->srvid[i]) { rc |= 4; }
-
+		rc|=4;
+	else {
+		for (i=0; (i<sidtab->num_srvid) && (!(rc&4)); i++) {
+		  	if (er->srvid==sidtab->srvid[i]) rc|=4;
+		}
+	}
 	return (rc == 7);
 }
 
@@ -124,18 +128,19 @@
 
 	if(!cl->sidtabs.ok)
 	{
-		if(!cl->sidtabs.no) { return (1); }
+		if (!cl->sidtabs.no) return(1);
 		rc = 1;
 	}
-	for(nr = 0, sidtab = cfg.sidtab; sidtab; sidtab = sidtab->next, nr++)
+	for (nr=0, sidtab=cfg.sidtab; sidtab; sidtab=sidtab->next, nr++) {
 		if(sidtab->num_caid | sidtab->num_provid | sidtab->num_srvid)
 		{
 			if((cl->sidtabs.no & ((SIDTABBITS)1 << nr)) &&
 					(chk_srvid_match(er, sidtab)))
-				{ return (0); }
+				return(0);
 			if((cl->sidtabs.ok & ((SIDTABBITS)1 << nr)) &&
 					(chk_srvid_match(er, sidtab)))
-				{ rc = 1; }
+			rc = 1;
+		}
 		}
 	return (rc);
 }
@@ -143,17 +148,18 @@
 int32_t has_srvid(struct s_client *cl, ECM_REQUEST *er)
 {
 	if(!cl->sidtabs.ok)
-		{ return 0; }
+		return 0;
 
 	int32_t nr;
 	SIDTAB *sidtab;
 
-	for(nr = 0, sidtab = cfg.sidtab; sidtab; sidtab = sidtab->next, nr++)
+	for (nr=0, sidtab=cfg.sidtab; sidtab; sidtab=sidtab->next, nr++) {
 		if(sidtab->num_srvid)
 		{
 			if((cl->sidtabs.ok & ((SIDTABBITS)1 << nr)) &&
 					(chk_srvid_match(er, sidtab)))
-				{ return 1; }
+		    	return 1;
+		}
 		}
 	return 0;
 }
@@ -162,15 +168,19 @@
 int32_t has_lb_srvid(struct s_client *cl, ECM_REQUEST *er)
 {
 	if(!cl->lb_sidtabs.ok)
-		{ return 0; }
+		return 0;
 
 	int32_t nr;
 	SIDTAB *sidtab;
 
 	for(nr = 0, sidtab = cfg.sidtab; sidtab; sidtab = sidtab->next, nr++)
+	{
+		if (sidtab->num_srvid) {
 		if((cl->lb_sidtabs.ok & ((SIDTABBITS)1 << nr)) &&
 				(chk_srvid_match(er, sidtab)))
-			{ return 1; }
+				return 1;
+		}
+	}
 	return 0;
 }
 
@@ -180,17 +190,19 @@
 	int32_t i, rc = 0;
 
 	if(!sidtab->num_caid)
-		{ rc |= 1; }
-	else
-		for(i = 0; (i < sidtab->num_caid) && (!(rc & 1)); i++)
-			if(caid == sidtab->caid[i]) { rc |= 1; }
-
+		rc|=1;
+	else {
+		for (i=0; (i<sidtab->num_caid) && (!(rc&1)); i++) {
+			if (caid==sidtab->caid[i]) rc|=1;
+		}
+	}
 	if(!sidtab->num_provid)
-		{ rc |= 2; }
-	else
-		for(i = 0; (i < sidtab->num_provid) && (!(rc & 2)); i++)
-			if(provid == sidtab->provid[i]) { rc |= 2; }
-
+		rc|=2;
+	else {
+		for (i=0; (i<sidtab->num_provid) && (!(rc&2)); i++) {
+			if (provid==sidtab->provid[i]) rc|=2;
+		}
+	}
 	return (rc == 3);
 }
 
@@ -201,18 +213,19 @@
 
 	if(!cl->sidtabs.ok)
 	{
-		if(!cl->sidtabs.no) { return (1); }
+		if (!cl->sidtabs.no) return(1);
 		rc = 1;
 	}
-	for(nr = 0, sidtab = cfg.sidtab; sidtab; sidtab = sidtab->next, nr++)
+	for (nr=0, sidtab=cfg.sidtab; sidtab; sidtab=sidtab->next, nr++) {
 		if(sidtab->num_caid | sidtab->num_provid)
 		{
 			if((cl->sidtabs.no & ((SIDTABBITS)1 << nr)) && !sidtab->num_srvid &&
 					(chk_srvid_match_by_caid_prov(caid, provid, sidtab)))
-				{ return (0); }
+		    	return(0);
 			if((cl->sidtabs.ok & ((SIDTABBITS)1 << nr)) &&
 					(chk_srvid_match_by_caid_prov(caid, provid, sidtab)))
-				{ rc = 1; }
+		    	rc=1;
+		}
 		}
 	return (rc);
 }
@@ -224,26 +237,27 @@
 
 	if(!rdr->sidtabs.ok)
 	{
-		if(!rdr->sidtabs.no) { return (1); }
+		if (!rdr->sidtabs.no) return(1);
 		rc = 1;
 	}
-	for(nr = 0, sidtab = cfg.sidtab; sidtab; sidtab = sidtab->next, nr++)
+	for (nr=0, sidtab=cfg.sidtab; sidtab; sidtab=sidtab->next, nr++) {
 		if(sidtab->num_caid | sidtab->num_provid)
 		{
 			if((rdr->sidtabs.no & ((SIDTABBITS)1 << nr)) && !sidtab->num_srvid &&
 					(chk_srvid_match_by_caid_prov(caid, provid, sidtab)))
-				{ return (0); }
+		    	return(0);
 			if((rdr->sidtabs.ok & ((SIDTABBITS)1 << nr)) &&
 					(chk_srvid_match_by_caid_prov(caid, provid, sidtab)))
-				{ rc = 1; }
+		    rc=1;
+		}
 		}
 	return (rc);
 }
 
 int32_t chk_is_betatunnel_caid(uint16_t caid)
 {
-	if(caid == 0x1702 || caid == 0x1722) { return 1; }
-	if(caid == 0x1801 || caid == 0x1833 || caid == 0x1834 || caid == 0x1835) { return 2; }
+	if (caid == 0x1702 || caid == 0x1722) return 1;
+	if (caid == 0x1801 || caid == 0x1833 || caid == 0x1834 || caid == 0x1835) return 2;
 	return 0;
 }
 
@@ -282,7 +296,7 @@
 	uint16_t caid, scaid;
 	uint32_t  prid, sprid;
 
-	if(!ptab) { return (1); }
+	if (!ptab) return(1);
 	struct s_client *cur_cl = cur_client();
 
 	caid = er->caid;
@@ -290,7 +304,7 @@
 	pi = cur_cl->port_idx;
 
 	if(cfg.ncd_mgclient)
-		{ return 1; }
+		return 1;
 
 	if(ptab->nports && ptab->ports[pi].ncd && ptab->ports[pi].ncd->ncd_ftab.nfilts)
 	{
@@ -318,7 +332,7 @@
 			snprintf(er->msglog, MSGLOGSIZE, "no server match %04X:%06X",
 					 caid, (uint32_t) prid);
 
-			if(!er->rcEx) { er->rcEx = (E1_LSERVER << 4) | E2_IDENT; }
+			if (!er->rcEx) er->rcEx = (E1_LSERVER<<4)|E2_IDENT;
 			return (rc);
 		}
 	}
@@ -333,11 +347,10 @@
 static int32_t chk_chid(ECM_REQUEST *er, FTAB *fchid, char *type, char *name)
 {
 	int32_t rc = 1, i, j, found_caid = 0;
-	if(!fchid->nfilts) { return 1; }
+	if (!fchid->nfilts) return 1;
 
 	for(i = rc = 0; (!rc) && i < fchid->nfilts; i++)
-		if(er->caid == fchid->filts[i].caid)
-		{
+	if (er->caid == fchid->filts[i].caid) {
 			found_caid = 1;
 			for(j = 0; (!rc) && j < fchid->filts[i].nprids; j++)
 			{
@@ -358,8 +371,7 @@
 		if(found_caid)
 			cs_log_dbg(D_CLIENT, "no match, %04X:%04X rejected by %s '%s' CHID filter(s)",
 						  er->caid, er->chid, type, name);
-		else
-		{
+		else {
 			rc = 1;
 			cs_log_dbg(D_CLIENT, "%04X:%04X allowed by %s '%s' CHID filter, CAID not spezified",
 						  er->caid, er->chid, type, name);
@@ -437,14 +449,13 @@
 				}
 			}
 		}
-		if(!rc)
-		{
+		if (!rc) {
 			cs_log_dbg(D_CLIENT, "no match, %04X:%06X rejected by user '%s' filters",
 						  er->caid, er->prid, cur_cl->account->usr);
 			snprintf(er->msglog, MSGLOGSIZE, "no card support %04X:%06X",
 					 er->caid, (uint32_t) er->prid);
 
-			if(!er->rcEx) { er->rcEx = (E1_USER << 4) | E2_IDENT; }
+			if (!er->rcEx) er->rcEx = (E1_USER<<4)|E2_IDENT;
 			return (rc);
 		}
 	}
@@ -454,12 +465,101 @@
 		if(!er->rcEx) { er->rcEx = (E1_USER << 4) | E2_CLASS; }
 	}
 	else if(!(rc = chk_chid(er, &cur_cl->fchid, "user", cur_cl->account->usr)))
+	{
 		if(!er->rcEx) { er->rcEx = (E1_USER << 4) | E2_CHID; }
+	}
+	if (rc) er->rcEx = 0;
+
+	return (rc);
+}
+
+
+#if defined(MODULE_AVAMGCAMD)
+static int32_t chk_mavatarcamd_r2filter(ECM_REQUEST *er, struct s_reader *rdr)
+{
+	uint16_t rcaid = er->caid;
+	uint32_t rprid = er->exprid;
+	uint16_t caid = 0;
+	uint32_t prid = 0;
+	int32_t  i, j, rc = 0;
+
+	if (rdr->ftab.nfilts)
+	{
+		for (rc=i=0; (!rc) && (i<rdr->ftab.nfilts); i++)
+		{
+			caid = rdr->ftab.filts[i].caid;
+		//	myprintf("i=%d, caid=%x, rcaid=%x, rdr->ftab.filts[i].nprids=%d\n", i,caid, rcaid, rdr->ftab.filts[i].nprids);
+			if ((caid != 0 && caid==rcaid) || caid==0)
+			{
+				if (rcaid==0x2600 && rdr->ftab.filts[i].nprids==0) rc = 1;
+				if (IS_IRDETO(rcaid)) rc = 1;
+				for (j=0; (!rc) && (j<rdr->ftab.filts[i].nprids); j++)
+				{
+					prid = rdr->ftab.filts[i].prids[j];
+					if (IS_IRDETO(caid)) prid &= 0xff;
+					cs_log_dbg(D_CLIENT, "trying reader '%s' filter %04X:%06X",
+					        rdr->label, caid, prid);
+					if (prid==rprid)
+					{
+						rc = 1;
+						cs_log_dbg(D_CLIENT, "%04X:%06X allowed by reader '%s' filter %04X:%06X",
+					        rcaid, rprid, rdr->label, caid, prid);
+					}
+				}
+			}
+		}
+		if (!rc) {
+			cs_log_dbg(D_CLIENT, "no match, %04X:%06X rejected by reader '%s' filters",
+			    rcaid, rprid, rdr->label);
+			return 0;
+		}
+	}
 
-	if(rc) { er->rcEx = 0; }
+	return (rc);
+}
+
+static int32_t chk_mavatarcamd_rsfilter(ECM_REQUEST *er, struct s_reader *rdr)
+{
+	uint16_t rcaid = er->caid;
+	uint32_t rprid = er->exprid;
+	uint16_t caid  = 0;
+	uint32_t prid  = 0;
+	int32_t  i, j;
+	int32_t  rc = 0;
+
+	if (rdr->ftab.nfilts)
+	{
+		for (rc=i=0; (!rc) && (i<rdr->ftab.nfilts); i++)
+		{
+			caid = rdr->ftab.filts[i].caid;
+//			myprintf("i=%d, caid=%x, rcaid=%x, rdr->ftab.filts[i].nprids=%d\n", i,caid, rcaid, rdr->ftab.filts[i].nprids);
+			if ((caid != 0 && caid==rcaid) || caid==0)
+			{
+				if (rcaid==0x2600 && rdr->ftab.filts[i].nprids==0) rc = 1;
+				for (j=0; (!rc) && (j<rdr->ftab.filts[i].nprids); j++)
+				{
+					prid = rdr->ftab.filts[i].prids[j];
+					cs_log_dbg(D_CLIENT, "trying reader '%s' filter %04X:%06X",
+					        rdr->label, caid, prid);
+					if (prid==rprid)
+					{
+						rc = 1;
+						cs_log_dbg(D_CLIENT, "%04X:%06X allowed by reader '%s' filter %04X:%06X",
+					        rcaid, rprid, rdr->label, caid, prid);
+					}
+				}
+			}
+		}
+		if (!rc) {
+			cs_log_dbg(D_CLIENT, "no match, %04X:%06X rejected by reader '%s' filters",
+			    rcaid, rprid, rdr->label);
+			return 0;
+		}
+	}
 
 	return (rc);
 }
+#endif
 
 int32_t chk_rsfilter(struct s_reader *reader, ECM_REQUEST *er)
 {
@@ -467,6 +567,12 @@
 	uint16_t caid;
 	uint32_t prid;
 
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_MAVATAR_READERS(reader)) {
+		if (chk_mavatarcamd_rsfilter(er, reader)) return 1;
+		return 0;
+	}
+#endif
 	if(reader->ncd_disable_server_filt)
 	{
 		cs_log_dbg(D_CLIENT, "%04X:%06X allowed - server filters disabled",
@@ -484,26 +590,55 @@
 							  (reader->prid[i][2] << 8) |
 							  (reader->prid[i][3]));
 			cs_log_dbg(D_CLIENT, "trying server '%s' filter %04X:%06X",
-						  reader->device, caid, prid);
-			if(prid == er->prid)
+			        	reader->label, caid, prid);
+			// sky(chinese,20160429)
+			if (er->prid==0 || (reader->nprov==1 && prid==0) || prid==er->prid)
 			{
 				rc = 1;
 				cs_log_dbg(D_CLIENT, "%04X:%06X allowed by server '%s' filter %04X:%06X",
-							  er->caid, er->prid, reader->device, caid, prid);
+			     		er->caid, er->prid, reader->label, caid, prid);
 			}
 		}
 	}
-	if(!rc)
-	{
+	if (!rc) {
 		cs_log_dbg(D_CLIENT, "no match, %04X:%06X rejected by server '%s' filters",
-					  er->caid, er->prid, reader->device);
-		if(!er->rcEx) { er->rcEx = (E1_SERVER << 4) | E2_IDENT; }
+		    	er->caid, er->prid, reader->label);
+		if (!er->rcEx) er->rcEx = (E1_SERVER<<4)|E2_IDENT;
 		return 0;
 	}
 
 	return (rc);
 }
 
+// sky(n)
+int32_t chk_cafilters(struct s_reader *reader, ECM_REQUEST *er)
+{
+	uint16_t casid;
+	uint32_t prid;
+	int32_t  i, rc;
+
+	rc = prid = 0;
+	myprintf("chk_cafilters:{%4x:%6x, %4x}\n", reader->caid, reader->nprov, er->caid);
+	casid = reader->caid;
+	if (casid==er->caid)
+	{
+		// sky(2016.03.07)
+		if (!er->prid) rc = 1;
+		if (!reader->nprov) rc = 1;
+		for (i=0; (!rc) && (i<reader->nprov); i++)
+		{
+			prid = (uint32_t) ((reader->prid[i][1]<<16) |
+					             (reader->prid[i][2]<<8) |
+					             (reader->prid[i][3]));
+			myprintf("chk_cafilters:{%4x, %4x}\n", prid, er->prid);
+			// sky(chinese,20160429)
+			if ((reader->nprov==1 && prid==0) || prid==er->prid) rc = 1;
+		}
+	}
+	return (rc);
+}
+
+// sky(2016)
 int32_t chk_rfilter2(uint16_t rcaid, uint32_t rprid, struct s_reader *rdr)
 {
 	int32_t i, j, rc = 1;
@@ -515,8 +650,12 @@
 		for(rc = i = 0; (!rc) && (i < rdr->ftab.nfilts); i++)
 		{
 			caid = rdr->ftab.filts[i].caid;
+		//	myprintf("i=%d, caid=%x, rcaid=%x, rdr->ftab.filts[i].nprids=%d\n", i,caid, rcaid, rdr->ftab.filts[i].nprids);
 			if((caid != 0 && caid == rcaid) || caid == 0)
 			{
+				if (rcaid==0x2600 && rdr->ftab.filts[i].nprids==0) rc = 1;
+				if (IS_IRDETO(rcaid))  rc = 1;
+				if (IS_POWERVU(rcaid)) rc = 1;
 				for(j = 0; (!rc) && (j < rdr->ftab.filts[i].nprids); j++)
 				{
 					prid = rdr->ftab.filts[i].prids[j];
@@ -531,8 +670,7 @@
 				}
 			}
 		}
-		if(!rc)
-		{
+		if (!rc) {
 			cs_log_dbg(D_CLIENT, "no match, %04X:%06X rejected by reader '%s' filters",
 						  rcaid, rprid, rdr->label);
 			return 0;
@@ -545,6 +683,11 @@
 
 static int32_t chk_rfilter(ECM_REQUEST *er, struct s_reader *rdr)
 {
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_MAVATAR_READERS(rdr)) {
+		return (chk_mavatarcamd_r2filter(er, rdr));
+	}
+#endif
 	return chk_rfilter2(er->caid, er->prid, rdr);
 }
 
@@ -623,11 +766,11 @@
 uint8_t chk_is_fixed_fallback(struct s_reader *rdr, ECM_REQUEST *er)
 {
 
-	if(!rdr->fallback && !rdr->fallback_percaid.nfilts) { return 0; }
+	if (!rdr->fallback && !rdr->fallback_percaid.nfilts) return 0;
 
 	if(!rdr->fallback_percaid.nfilts)
 		if(rdr->fallback)
-			{ return 1; }
+			return 1;
 
 	int32_t i, k;
 	for(i = 0; i < rdr->fallback_percaid.nfilts; i++)
@@ -638,13 +781,12 @@
 
 			int32_t nprids = rdr->fallback_percaid.filts[i].nprids;
 			if(!nprids)  // No Provider ->Ok
-				{ return 1; }
+				return 1;
 
 			for(k = 0; k < nprids; k++)
 			{
 				uint32_t prid = rdr->fallback_percaid.filts[i].prids[k];
-				if(prid == er->prid)    //Provider matches
-				{
+				if (prid == er->prid) { //Provider matches
 					return 1;
 				}
 			}
@@ -663,52 +805,74 @@
 	{
 		rdr = ea->reader;
 		if(chk_is_fixed_fallback(rdr, er))
-			{ n_falb++; }
+			n_falb++;
 	}
 	return n_falb;
 }
 
-int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr)
+// sky(changed return value)
+int32_t chk_matching_reader(ECM_REQUEST *er, struct s_reader *rdr, int32_t chkMode)
 {
-
+	int32_t cAvail = 1;
 	//simple checks first:
-	if(!er || !rdr)
-		{ return (0); }
+	if (!er || !rdr) return 1;
 
 	//reader active?
 	struct s_client *cl = rdr->client;
-	if(!cl || !rdr->enable)
-		{ return (0); }
+	if (!cl || !rdr->enable) return 2;
 
 	// if physical reader a card needs to be inserted
-	if(!is_network_reader(rdr) && rdr->card_status != CARD_INSERTED)
-		{ return (0); }
+	if (!is_network_reader(rdr) && rdr->card_status != CARD_INSERTED) return 3;
+
+// sky(n)
+// check server filters
+	if (is_network_reader(rdr)) {
+		if (rdr->card_status == CARD_UNREGISTER) return 91;
+		if (rdr->card_status == CARD_FAILURE) return 92;
+	}
+	if (IS_NEWCAMD_READERS(rdr))
+	{
+		if (rdr->ncd_connect_on_init) {
+#if defined(MODULE_AVAMGCAMD)
+			if (IS_MAVATARCAMD(rdr->ncd_exprotocol)) {
+			}
+			else
+#endif
+			if (!rdr->ncd_disable_server_filt) {
+				if (!chk_cafilters(rdr, er)) return 33;
+			}
+		}
+	}
 
 	//Checking connected & group valid:
 	struct s_client *cur_cl = er->client; //cur_client();
 
+	if (!cur_cl) return 4;
 #ifdef CS_CACHEEX
 	//Cacheex=3 defines a Cacheex-only reader. never match them.
-	if(rdr->cacheex.mode == 3)
-		{ return (0); }
-	if(rdr->cacheex.mode == 2 && !rdr->cacheex.allow_request)
-		{ return (0); }
+	if (rdr->cacheex.mode == 3) return 5;
+	if (rdr->cacheex.mode == 2 && !rdr->cacheex.allow_request) return 5;
 #endif
 
 	if(!(rdr->grp & cur_cl->grp))
-		{ return (0); }
+	{
+		myprintf("mychk:non group match{%s,%llx!=%llx}\n", rdr->label, rdr->grp, cur_cl->grp);
+      return 6;
+	}
 
 	//Checking caids:
 	if((!er->ocaid || !chk_ctab(er->ocaid, &rdr->ctab)) && !chk_ctab(er->caid, &rdr->ctab))
 	{
-		cs_log_dbg(D_TRACE, "caid %04X not found in caidlist reader %s", er->caid, rdr->label);
-		return 0;
+		myprintf("mychk:--- %s.caid not found.{%04X}{%04X,%04X}\n", rdr->label, rdr->caid, er->caid, er->ocaid);
+		cs_log_dbg(D_TRACE, "caid %04X not found in caidlist reader %s\n", er->caid, rdr->label);
+		return 7;
 	}
 
-	if(!is_network_reader(rdr) && ((rdr->caid >> 8) != ((er->caid >> 8) & 0xFF) && (rdr->caid >> 8) != ((er->ocaid >> 8) & 0xFF)))
+	if (!is_network_reader(rdr))
 	{
+		if ((rdr->caid>>8) != ((er->caid>>8) & 0xFF) && (rdr->caid>>8) != ((er->ocaid>>8) & 0xFF)) {
 		if (!rdr->csystem)
-			return 0;
+				return 99;
 		int i, caid_found = 0;
 		for(i = 0; rdr->csystem->caids[i]; i++)
 		{
@@ -721,82 +885,90 @@
 				break;
 			}
 		}
-		if(!caid_found)
-			{ return 0; }
+			if (!caid_found) return 8;
+		}
+		// sky(n)
+		else if (!rdr->csystem->caidsvarious && rdr->caid != er->caid) {
+			myprintf("mychk:--- caid %04X not found in %s\n", er->caid, rdr->label);
+			cs_log_dbg(D_TRACE, "caid %04X not found in %s\n", er->caid, rdr->label);
+			return 88;
+		}
 	}
 
 	//Supports long ecms?
-	if(er->ecmlen > 255 && is_network_reader(rdr) && !rdr->ph.large_ecm_support)
-	{
-		cs_log_dbg(D_TRACE, "no large ecm support (l=%d) for reader %s", er->ecmlen, rdr->label);
-		return 0;
+	if (er->ecmlen > 255 && is_network_reader(rdr) && !rdr->ph.large_ecm_support) {
+		cs_log_dbg(D_TRACE, "non large ecm support(l=%d) for reader %s", er->ecmlen, rdr->label);
+		return 9;
 	}
 
 
 	//Checking services:
-	if(!chk_srvid(rdr->client, er))
-	{
+	if (!chk_srvid(rdr->client, er)) {
 		cs_log_dbg(D_TRACE, "service %04X not matching reader %s", er->srvid, rdr->label);
-		return (0);
+		return 10;
 	}
 
 	//Checking ident:
-	if(!chk_rfilter(er, rdr))
-	{
+	if (!chk_rfilter(er, rdr)) {
 		cs_log_dbg(D_TRACE, "r-filter reader %s", rdr->label);
-		return (0);
+		return 11;
 	}
 
 	//Check ECM nanos:
-	if(!chk_class(er, &rdr->cltab, "reader", rdr->label))
-	{
+	if (!chk_class(er, &rdr->cltab, "reader", rdr->label)) {
 		cs_log_dbg(D_TRACE, "class filter reader %s", rdr->label);
-		return (0);
+		return 12;
 	}
 
 
 	// CDS NL: check for right seca type
-	if(!is_network_reader(rdr) && er->caid == 0x100 && er->prid == 0x00006a &&
-			!(er->ecm[8] == 0x00 && er->ecm[9] == 0x00))   // no empty ecm
-	{
-		if(er->ecm[8] == 0x00 && rdr->secatype == 2)
+  	if (!(is_network_reader(rdr)) &&
+  		 (er->caid == 0x100 && er->prid == 0x00006a &&
+		  !(er->ecm[8] == 0x00 && er->ecm[9] == 0x00))) // no empty ecm
 		{
+		if (er->ecm[8] == 0x00 && rdr->secatype == 2) {
 			cs_log_dbg(D_TRACE, "Error: this is a nagra/mediaguard3 ECM and readertype is seca2!");
-			return 0;  // we dont send a nagra/mediaguard3 ecm to a seca2 reader!
+			return 13;  // we dont send a nagra/mediaguard3 ecm to a seca2 reader!
 		}
-		if((er->ecm[8] == 0x10) && (er->ecm[9] == 0x01) && rdr->secatype == 3)
-		{
+		if ((er->ecm[8] == 0x10) && (er->ecm[9] == 0x01) && rdr->secatype == 3) {
 			cs_log_dbg(D_TRACE, "Error: this is a seca2 ECM and readertype is nagra/mediaguard3!");
-			return 0;  // we dont send a seca2 ecm to a nagra/mediaguard3 reader!
+			return 14;  // we dont send a seca2 ecm to a nagra/mediaguard3 reader!
 		}
 	}
 	// CDS NL: check for right seca type by ECMPID
-	if(!is_network_reader(rdr) && er->caid == 0x100 && er->prid == 0x00006a)
-	{
-		if(rdr->secatype == 2 && er->pid >> 8 == 7)
+  	if (!(is_network_reader(rdr)) &&
+  		 (er->caid == 0x100 && er->prid == 0x00006a))
 		{
+		if (rdr->secatype == 2 && er->pid>>8 == 7) {
 			cs_log_dbg(D_TRACE, "Error: this is a nagra/mediaguard3 ECM and readertype is seca2!");
-			return 0;  // we dont send a nagra/mediaguard3 ecm to a seca2 reader!
+			return 15;  // we dont send a nagra/mediaguard3 ecm to a seca2 reader!
 		}
-		if(rdr->secatype == 3 && er->pid >> 8 == 6)
-		{
+		if (rdr->secatype == 3 && er->pid>>8 == 6) {
 			cs_log_dbg(D_TRACE, "Error: this is a seca2 ECM and readertype is nagra/mediaguard3!");
-			return 0;  // we dont send a seca2 ecm to a nagra/mediaguard3 reader!
+			return 16;  // we dont send a seca2 ecm to a nagra/mediaguard3 reader!
 		}
 	}
 
 	//Checking chid:
-	if(!chk_chid(er, &rdr->fchid, "reader", rdr->label))
-	{
+	if (!chk_chid(er, &rdr->fchid, "reader", rdr->label)) {
 		cs_log_dbg(D_TRACE, "chid filter reader %s", rdr->label);
-		return (0);
+		return 17;
 	}
 
 	//Schlocke reader-defined function, reader-self-check
-	if(rdr->ph.c_available && !rdr->ph.c_available(rdr, AVAIL_CHECK_CONNECTED, er))
+	if (rdr->ph.c_available)
 	{
-		cs_log_dbg(D_TRACE, "reader unavailable %s", rdr->label);
-		return 0;
+		int32_t checking = AVAIL_CHECK_CONNECTED;
+#if defined(MODULE_XCAMD)
+		if (IS_ICS_READERS(rdr)) {
+			checking = (chkMode==2) ? AVAIL_CHECK_ECM : AVAIL_CHECK_CHANNEL;
+		}
+#endif
+		cAvail = rdr->ph.c_available(rdr, checking, er);
+		if (!cAvail) {
+			cs_log_dbg(D_TRACE, "nonavailable reader %s", rdr->label);
+			return 18;
+		}
 	}
 
 	//Checking entitlements:
@@ -808,16 +980,14 @@
 		while((item = ll_iter_next(&itr)))
 		{
 			//if (item->caid == er->caid && (!er->prid || !item->provid || item->provid == er->prid)) {     //provid check causing problems?
-			if(item->caid == er->caid || item->caid == er->ocaid)                                           //... so check at least caid only
-			{
+			if (item->caid == er->caid || item->caid == er->ocaid) { //... so check at least caid only
 				found = 1;
 				break;
 			}
 		}
-		if(!found)
-		{
+		if (!found) {
 			cs_log_dbg(D_TRACE, "entitlements check failed on reader %s", rdr->label);
-			return 0;
+			return 19;
 		}
 	}
 
@@ -843,7 +1013,7 @@
 		{
 			cs_log_dbg(D_TRACE, "ECM is not in ecmwhitelist of reader %s.", rdr->label);
 			rdr->ecmsfilteredlen += 1;
-			return (0);
+			return 20;
 		}
 	}
 
@@ -865,68 +1035,56 @@
 			byteok = 0;
 			entryok = 0;
 			len = 0;
-			if(tmp->caid == 0 || tmp->caid == er->caid)
-			{
+			if (tmp->caid == 0 || tmp->caid == er->caid) {
 				foundcaid = 1; //-> caid was in list
 				//rdr_log_dbg(rdr, D_READER, "Headerwhitelist: found matching CAID: %04X in list", tmp->caid);
-				if(tmp->provid == 0 || tmp->provid == er->prid)
-				{
+				if (tmp->provid == 0 || tmp->provid == er->prid) {
 					foundprovid = 1; //-> provid was in list
 					//rdr_log_dbg(rdr, D_READER, "Headerwhitelist: found matching Provid: %06X in list", tmp->provid);
 					len = tmp->len;
-					for(i = 0; i < len / 2; i++)
-					{
-						if(tmp->header[i] == er->ecm[i])
-						{
+					for (i=0; i < len/2; i++) {
+						if (tmp->header[i] == er->ecm[i]) {
 							byteok = 1;
 							//rdr_log_dbg(rdr, D_READER, "ECM Byte: %i of ECMHeaderwhitelist is correct. (%02X = %02X Headerlen: %i)", i, er->ecm[i], tmp->header[i], len/2);
 						}
-						else
-						{
+						else {
 							byteok = 0;
 							//rdr_log_dbg(rdr, D_READER, "ECM Byte: %i of ECMHeaderwhitelist is not valid. (%02X != %02X Headerlen: %i)", i, er->ecm[i], tmp->header[i], len/2);
 							entryok = 0;
 							break;
 						}
-						if(i == len / 2 - 1 && byteok == 1)
-						{
+						if (i == len/2-1 && byteok == 1) {
 							entryok = 1;
 						}
 
 					}
 				}
-				else
-				{
+				else {
 					//rdr_log_dbg(rdr, D_READER, "ECMHeaderwhitelist: Provid: %06X not found in List-Entry -> skipping check", er->prid);
 					skip = 1;
 					continue;
 				}
 			}
-			else
-			{
+			else {
 				//rdr_log_dbg(rdr, D_READER, "ECMHeaderwhitelist: CAID: %04X not found in List-Entry -> skipping check", er->caid);
 				skip = 1;
 				continue;
 			}
-			if(entryok == 1)
-			{
+			if (entryok == 1) {
 				break;
 			}
 
 		}
-		if(foundcaid == 1 && foundprovid == 1 && byteok == 1 && entryok == 1)
-		{
+		if (foundcaid == 1 && foundprovid == 1 && byteok == 1 && entryok == 1) {
 			//cs_log("ECM for %04X:%06X:%04X is valid for ECMHeaderwhitelist of reader %s.", er->caid, er->prid, er->srvid, rdr->label);
 		}
-		else
-		{
-			if(skip == 0 || (foundcaid == 1 && foundprovid == 1 && entryok == 0 && skip == 1))
-			{
+		else {
+			if (skip == 0 || (foundcaid == 1 && foundprovid == 1 && entryok == 0 && skip == 1)) {
 				cs_log_dump_dbg(D_TRACE, er->ecm, er->ecmlen,
 							  "following ECM %04X:%06X:%04X was filtered by ECMHeaderwhitelist of Reader %s from User %s because of not matching Header:",
 							  er->caid, er->prid, er->srvid, rdr->label, username(er->client));
 				rdr->ecmsfilteredhead += 1;
-				return (0);
+				return 21;
 			}
 		}
 	}
@@ -940,23 +1098,42 @@
 	{
 		rdr_log_dbg(rdr, D_TRACE, "User (%s) has the same ip (%s) as the reader, blocked because block_same_ip=1!",
 					   username(cur_cl), cs_inet_ntoa(rdr->client->ip));
-		return 0;
+		return 22;
 	}
 
 	if(cfg.block_same_name && strcmp(username(cur_cl), rdr->label) == 0)
 	{
 		rdr_log_dbg(rdr, D_TRACE, "User (%s) has the same name as the reader, blocked because block_same_name=1!",
 					   username(cur_cl));
-		return 0;
+		return 23;
 	}
 
-	if(!reader_slots_available(rdr, er))  // check free slots
-	{
-		return 0;
+	if (!reader_slots_available(rdr, er)) { // check free slots
+		return 24;
 	}
 
 	//All checks done, reader is matching!
-	return (1);
+  	return 0;
+}
+
+int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr, int32_t chkMode)
+{
+	int32_t noAvailable;
+
+	if (!rdr) return 0;
+	noAvailable = chk_matching_reader(er, rdr, chkMode);
+	if (noAvailable) {
+		if (chkMode >= 0) {
+			myprintf("mychk:...............%d!{%02X,%-10s}(r%d)\n", chkMode, rdr->typ, rdr->label, noAvailable);
+		}
+	}
+	else {
+		if (chkMode >= 0) {
+			myprintf("mychk:....%d!AVAILABLE!!{%02X,%-10s}(r%d)\n", chkMode, rdr->typ, rdr->label, noAvailable);
+		}
+	}
+	if (noAvailable) return 0;
+	return 1;
 }
 
 int32_t chk_caid(uint16_t caid, CAIDTAB *ctab)
@@ -974,12 +1151,10 @@
 
 int32_t chk_caid_rdr(struct s_reader *rdr, uint16_t caid)
 {
-	if(is_network_reader(rdr))
-	{
+	if (is_network_reader(rdr)) {
 		return 1; //reader caid is not real caid
 	}
-	else if(rdr->caid == caid)
-	{
+	else if (rdr->caid==caid) {
 		return 1;
 	}
 	return 0;
@@ -989,8 +1164,7 @@
 {
 	int32_t caid;
 	caid = chk_caid(er->caid, ctab);
-	if(caid < 0)
-		{ return 0; }
+	if (caid < 0) return 0;
 	er->caid = caid;
 	return 1;
 }
@@ -1041,15 +1215,21 @@
 	 }
 
 	 //check for correct cw position
-	 if(
-	    (get_odd_even(er) == 0x80 && part1 && !part2)   //xxxxxxxx00000000
-		||
-		(get_odd_even(er) == 0x81 && !part1 && part2)   //00000000xxxxxxxx
-	 )
+		// sky(dvn) /* tableid:0x50 */
+		if (caid_is_dvn(er->caid)) {
+			if ((get_odd_even(er) &&  part1 && !part2) ||  	//xxxxxxxx00000000
+				 (get_odd_even(er) && !part1 &&  part2))  	//00000000xxxxxxxx
 	 {
 		return 1;
 	 }
-
+		}
+		else {
+			if ((get_odd_even(er) == 0x80 &&  part1 && !part2) ||	//xxxxxxxx00000000
+				 (get_odd_even(er) == 0x81 && !part1 &&  part2))   //00000000xxxxxxxx
+			{
+				return 1;
+			}
+		}
 	 return 0;  //not correct swapped cw
 
   }else
@@ -1071,12 +1251,105 @@
 	return 1;
 }
 
+// sky(n)
+int32_t set_cw_checksum(uchar *cw, int ksize)
+{
+	uint8_t i, c;
+	int r = 1;
+
+	if (chk_is_null_CW(cw)) return 0;
+	for (i = 0; i < ksize; i += 4) {
+		c = ((cw[i] + cw[i+1] + cw[i+2]) & 0xff);
+		if (cw[i+3] != c) { cw[i+3] = c;	r = -1; }
+	}
+	return r;
+}
+int32_t chk_cw_violation(uchar *cw)
+{
+	uint8_t i, c;
+	if (chk_is_null_CW(cw)) return 1;
+	for (i = 0; i < 16; i += 4) {
+		c = ((cw[i] + cw[i+1] + cw[i+2]) & 0xff);
+		if (cw[i+3] != c) return 1;
+	}
+	return 0;
+}
+
+
+/*
+ *	Firmware: Frame Output(Firmware->VDEC):
+ *  	Acquire(Try/OK):  2442/2442
+ *  	Release(Try/OK):  2439/2439
+ */
+#if defined(WITH_HISILICON)
+int32_t chk_av_descrambling(struct s_client *client)
+{
+	#if defined(SDKV500) || defined(SDKV600)
+		if (access("/proc/msp/vdec00", F_OK) != 0) return 0;
+		return 1;
+	#else
+		FILE 	*fp;
+		char 	*token;
+		char 	*tmp;
+		char 	*pszval = 0;
+		char 	*pszframe = 0;
+		uint32_t frametries = 0, okframe = 0;
+
+		fp = fopen("/proc/msp/vdec00", "r");
+		if (!fp)
+		{
+			myprintf("mychk:vdec none\n");
+			if (client) client->frameAcquire = 0;
+			return 0;
+		}
+
+		if (!cs_malloc(&token, MAX_FILELINESIZE))
+		{
+			fclose(fp);
+			return 0;
+		}
+
+		while (fgets(token, MAX_FILELINESIZE, fp))
+		{
+			tmp = trim(token);
+			if (pszframe)
+			{
+				if (!tmp) break;
+				if ((pszval = strchr(tmp, ':'))==0) break;
+				while (*(++pszval) == ' ');
+				if (!pszval) break;
+				sscanf(pszval, "%d/%d", &frametries, &okframe);
+			//	myprintf("MYCHK:FRAME ACQUIRE{%d/%d}\n", frametries, okframe);
+				break;
+			}
+			else
+			{
+				pszframe = strstr((char*)tmp, "Frame Output");
+			}
+		}
+		fclose(fp);
+
+		if (client)
+		{
+			if (client->frameAcquire == okframe)
+			{
+			//	myprintf("MYCHK:vdec same{%d/%d,%d}\n", client->frameAcquire, frametries, okframe);
+				return 0;
+			}
+			client->frameAcquire = okframe;
+			cs_sleepms(10);
+		}
+		if (okframe==0) return 0;
+		return 1;
+	#endif
+}
+#endif
+
 //check if client structure is accessible
 bool check_client(struct s_client *cl)
 {
-	if(cl && !cl->kill)
-		{ return true; }
-	return false;
+	if (cl && !cl->kill) return 1;
+	return 0;
 }
 
 uint16_t caidvaluetab_get_value(CAIDVALUETAB *cv, uint16_t caid, uint16_t default_value)
Index: oscam-chk.h
===================================================================
--- oscam-chk.h	(revision 10670)
+++ oscam-chk.h	(working copy)
@@ -5,9 +5,22 @@
 #define SRVID_ZERO  0 // srvid + 0000 (used for service-filter bypass)
 #define SRVID_MASK  1 // srvid + FFFF
 
+// sky(!)
+#define IS_IRDETO(x)			(((x)>>8)==0x06)
+#define IS_NDS(x)				(((x)>>8)==0x09)
+#define IS_VIACESS(x)		 ((x)==0x500)
+#define IS_SEKA(x)			 ((x)==0x100)
+#define IS_NAGRA(x)			(((x)>>8)==0x18)
+#define IS_CRYPTOWORKS(x)	(((x)>>8)==0x0d)
+#define IS_CONAX(x)			(((x)>>8)==0x0b)
+#define IS_BISS(x)			(((x)>>8)==0x26)
+// sky(2016)
+#define IS_POWERVU(x)		(((x)>>8)==0x0E)
+
+
 uint32_t get_fallbacktimeout(uint16_t caid);
 int32_t ecm_ratelimit_check(struct s_reader *reader, ECM_REQUEST *er, int32_t reader_mode);
-int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr);
+int32_t 	matching_reader(ECM_REQUEST *er, struct s_reader *rdr, int32_t chkex);
 
 uint8_t is_localreader(struct s_reader *rdr, ECM_REQUEST *er);
 uint8_t chk_is_fixed_fallback(struct s_reader *rdr, ECM_REQUEST *er);
@@ -35,6 +48,15 @@
 int8_t is_halfCW_er(ECM_REQUEST *er);
 int8_t chk_halfCW(ECM_REQUEST *er, uchar *cw);
 int32_t chk_is_null_nodeid(uint8_t node_id[], uint8_t len);
+// sky(n)
+#define CHK_DESCRAMBLING_COUNTER	5
+#define MAX_FILELINESIZE 		4096
+int32_t 	chk_cafilters(struct s_reader *reader, ECM_REQUEST *er);
+int32_t 	set_cw_checksum(uchar *cw, int ksize);
+int32_t  chk_cw_violation(uchar *cw);
+#if defined(WITH_HISILICON)
+int32_t 	chk_av_descrambling(struct s_client *client);
+#endif
 bool check_client(struct s_client *cl);
 uint16_t caidvaluetab_get_value(CAIDVALUETAB *cv, uint16_t caid, uint16_t default_value);
 
Index: oscam-client.c
===================================================================
--- oscam-client.c	(revision 10670)
+++ oscam-client.c	(working copy)
@@ -5,6 +5,9 @@
 #include "cscrypt/md5.h"
 #include "module-anticasc.h"
 #include "module-cccam.h"
+#if defined(MODULE_XCAMD)
+#include "module-xcamd.h"
+#endif
 #include "module-webif.h"
 #include "oscam-array.h"
 #include "oscam-conf-chk.h"
@@ -32,12 +35,11 @@
 	struct s_client *cl;
 	int32_t count = 0;
 
-	for(cl = first_client->next; cl ; cl = cl->next)
-	{
+	for (cl=first_client->next; cl ; cl=cl->next) {
 		if(cl->typ == client->typ)
-			{ count++; }
+			count++;
 		if(cl == client)
-			{ return count; }
+			return count;
 	}
 	return 0;
 }
@@ -45,10 +47,9 @@
 struct s_auth *get_account_by_name(char *name)
 {
 	struct s_auth *account;
-	for(account = cfg.account; (account); account = account->next)
-	{
+	for (account=cfg.account; (account); account=account->next) {
 		if(streq(name, account->usr))
-			{ return account; }
+			return account;
 	}
 	return NULL;
 }
@@ -57,10 +58,9 @@
 {
 	struct s_client *cl;
 	int32_t bucket = (uintptr_t)client / 16 % CS_CLIENT_HASHBUCKETS;
-	for(cl = first_client_hashed[bucket]; cl; cl = cl->nexthashed)
-	{
+	for (cl = first_client_hashed[bucket]; cl; cl = cl->nexthashed) {
 		if(cl == client)
-			{ return 1; }
+			return 1;
 	}
 	return 0;
 }
@@ -133,31 +133,26 @@
 				cs_strncpy(buf, cs_inet_ntoa(cl->ip), sizeof(buf));
 				cs_log("client(%8lX) duplicate user '%s' from %s (prev %s) set to fake (uniq=%d)",
 					   (unsigned long)cl->thread, usr, cs_inet_ntoa(ip), buf, uniq);
-				if(cl->failban & BAN_DUPLICATE)
-				{
+				if (cl->failban & BAN_DUPLICATE) {
 					cs_add_violation(cl, usr);
 				}
-				if(cfg.dropdups)
-				{
+				if (cfg.dropdups) {
 					cs_writeunlock(&fakeuser_lock);
 					cs_sleepms(120); // sleep a bit to prevent against saturation from fast reconnecting clients
 					kill_thread(cl);
 					cs_writelock(&fakeuser_lock);
 				}
 			}
-			else
-			{
+			else {
 				client->dup = 1;
 				client->aureader_list = NULL;
 				cs_strncpy(buf, cs_inet_ntoa(ip), sizeof(buf));
 				cs_log("client(%8lX) duplicate user '%s' from %s (current %s) set to fake (uniq=%d)",
 					   (unsigned long)pthread_self(), usr, cs_inet_ntoa(cl->ip), buf, uniq);
-				if(client->failban & BAN_DUPLICATE)
-				{
+				if (client->failban & BAN_DUPLICATE) {
 					cs_add_violation_by_ip(ip, get_module(client)->ptab.ports[client->port_idx].s_port, usr);
 				}
-				if(cfg.dropdups)
-				{
+				if (cfg.dropdups) {
 					cs_writeunlock(&fakeuser_lock);     // we need to unlock here as cs_disconnect_client kills the current thread!
 					cs_sleepms(120); // sleep a bit to prevent against saturation from fast reconnecting clients
 					cs_disconnect_client(client);
@@ -174,18 +169,15 @@
    If the hostname is not configured, the ip is set to 0. */
 static void cs_user_resolve(struct s_auth *account)
 {
-	if(account->dyndns)
-	{
+	if (account->dyndns) {
 		IN_ADDR_T lastip;
 		IP_ASSIGN(lastip, account->dynip);
 		cs_resolve(account->dyndns, &account->dynip, NULL, NULL);
-		if(!IP_EQUAL(lastip, account->dynip))
-		{
-			cs_log("%s: resolved ip=%s", account->dyndns, cs_inet_ntoa(account->dynip));
+		if (!IP_EQUAL(lastip, account->dynip))  {
+			cs_log("%s: resolved ip %s", account->dyndns, cs_inet_ntoa(account->dynip));
 		}
 	}
-	else
-	{
+	else {
 		set_null_ip(&account->dynip);
 	}
 }
@@ -195,33 +187,27 @@
 char *username(struct s_client *client)
 {
 	if(!check_client(client))
-		{ return "NULL"; }
+		return "NULL";
 
-	if(client->typ == 's' || client->typ == 'h' || client->typ == 'a')
-	{
+	if (client->typ == 's' || client->typ == 'h' || client->typ == 'a') {
 		return processUsername ? processUsername : "NULL";
 	}
 
-	if(client->typ == 'c' || client->typ == 'm')
-	{
+	if (client->typ == 'c' || client->typ == 'm') {
 		struct s_auth *acc = client->account;
-		if(acc)
-		{
+		if (acc) {
 			if(acc->usr[0])
-				{ return acc->usr; }
+				return (acc->usr);
 			else
-				{ return "anonymous"; }
+				return "anonymous";
 		}
-		else
-		{
+		else {
 			return "NULL";
 		}
 	}
-	else if(client->typ == 'r' || client->typ == 'p')
-	{
+	else if (client->typ == 'r' || client->typ == 'p') {
 		struct s_reader *rdr = client->reader;
-		if(rdr)
-			{ return rdr->label; }
+		if (rdr) return rdr->label;
 	}
 	return "NULL";
 }
@@ -230,8 +216,7 @@
 struct s_client *create_client(IN_ADDR_T ip)
 {
 	struct s_client *cl;
-	if(!cs_malloc(&cl, sizeof(struct s_client)))
-	{
+	if (!cs_malloc(&cl, sizeof(struct s_client))) {
 		cs_log("max connections reached (out of memory) -> reject client %s", IP_ISSET(ip) ? cs_inet_ntoa(ip) : "with null address");
 		return NULL;
 	}
@@ -245,31 +230,24 @@
 	//Now add new client to the list:
 	struct s_client *last;
 	cs_writelock(&clientlist_lock);
-	if(sizeof(uintptr_t) > 4)           // 64bit systems can have collisions because of the cast so lets check if there are some
-	{
+	if (sizeof(uintptr_t) > 4) {		// 64bit systems can have collisions because of the cast so lets check if there are some
 		int8_t found;
-		do
-		{
+		do {
 			found = 0;
-			for(last = first_client; last; last = last->next)
-			{
-				if(last->tid == cl->tid)
-				{
+			for (last=first_client; last; last=last->next) {
+				if (last->tid == cl->tid) {
 					found = 1;
 					break;
 				}
 			}
-			if(found || cl->tid == 0)
-			{
+			if (found || cl->tid == 0) {
 				cl->tid = (uint32_t)rand();
 			}
-		}
-		while(found || cl->tid == 0);
+		} while (found || cl->tid == 0);
 	}
 	for(last = first_client; last && last->next; last = last->next)
 		{ ; } //ends with cl on last client
-	if (last)
-		last->next = cl;
+	if (last) last->next = cl;
 	int32_t bucket = (uintptr_t)cl / 16 % CS_CLIENT_HASHBUCKETS;
 	cl->nexthashed = first_client_hashed[bucket];
 	first_client_hashed[bucket] = cl;
@@ -285,18 +263,16 @@
 	struct passwd *pwdbuf;
 #ifdef __ANDROID__
 	pwdbuf = getpwuid(getuid()); // This is safe
-	if(pwdbuf)
-	{
+	if (pwdbuf) {
 		memcpy(&pwd, pwdbuf, sizeof(pwd));
 		processUsername = cs_strdup(pwd.pw_name);
 	}
 #else
 	char buf[256];
 	if(getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pwdbuf) == 0)
-		{ processUsername = cs_strdup(pwd.pw_name); }
+		processUsername = cs_strdup(pwd.pw_name);
 #endif
-	if(!cs_malloc(&first_client, sizeof(struct s_client)))
-	{
+	if (!cs_malloc(&first_client, sizeof(struct s_client))) {
 		fprintf(stderr, "Could not allocate memory for master client, exiting...");
 		exit(1);
 	}
@@ -311,15 +287,13 @@
 	set_localhost_ip(&first_client->ip);
 
 	struct s_auth *null_account;
-	if(!cs_malloc(&null_account, sizeof(struct s_auth)))
-	{
+	if (!cs_malloc(&null_account, sizeof(struct s_auth))) {
 		fprintf(stderr, "Could not allocate memory for master account, exiting...");
 		exit(1);
 	}
 
 	first_client->account = null_account;
-	if(pthread_setspecific(getclient, first_client))
-	{
+	if (pthread_setspecific(getclient, first_client)) {
 		fprintf(stderr, "Could not setspecific getclient in master process, exiting...");
 		exit(1);
 	}
@@ -339,8 +313,7 @@
 
 	memset(&client->grp, 0xff, sizeof(uint64_t));
 	//client->grp=0xffffffffffffff;
-	if((intptr_t)account != 0 && (intptr_t)account != -1 && account->disabled)
-	{
+	if ((intptr_t)account != 0 && (intptr_t)account != -1 && account->disabled) {
 		cs_add_violation(client, account->usr);
 		cs_log("%s %s-client %s%s (%s%sdisabled account)",
 			   client->crypted ? t_crypt : t_plain,
@@ -368,11 +341,9 @@
 	}
 
 	client->account = first_client->account;
-	switch((intptr_t)account)
-	{
+	switch ((intptr_t)account) {
 
-	case 0:   // reject access
-	{
+		case 0: { // reject access
 		rc = 1;
 		cs_add_violation(client, NULL);
 		cs_log("%s %s-client %s%s (%s)",
@@ -384,14 +355,11 @@
 		break;
 	}
 
-	default:   // grant/check access
-	{
-		if(IP_ISSET(client->ip) && account->dyndns)
-		{
-			if(!IP_EQUAL(client->ip, account->dynip))
-				{ cs_user_resolve(account); }
+		default: { // grant/check access
+			if (IP_ISSET(client->ip) && account->dyndns) {
 			if(!IP_EQUAL(client->ip, account->dynip))
-			{
+					cs_user_resolve(account);
+				if (!IP_EQUAL(client->ip, account->dynip)) {
 				cs_add_violation(client, account->usr);
 				rc = 2;
 			}
@@ -434,30 +402,24 @@
 		}
 	}
 
-	case -1:   // anonymous grant access
-	{
-		if(rc)
-		{
+		case -1: { // anonymous grant access
+			if (rc) {
 			t_grant = t_reject;
 		}
-		else
-		{
-			if(client->typ == 'm')
-			{
+			else {
+				if (client->typ == 'm') {
 				snprintf(t_msg[0], sizeof(buf), "lvl=%d", client->monlvl);
 			}
-			else
-			{
+				else {
 				int32_t rcount = ll_count(client->aureader_list);
 				snprintf(buf, sizeof(buf), "au=");
 				if(!rcount)
-					{ snprintf(buf + 3, sizeof(buf) - 3, "off"); }
-				else
-				{
+						snprintf(buf+3, sizeof(buf)-3, "off");
+					else {
 					if(client->autoau)
-						{ snprintf(buf + 3, sizeof(buf) - 3, "auto (%d reader)", rcount); }
+							snprintf(buf+3, sizeof(buf)-3, "auto (%d reader)", rcount);
 					else
-						{ snprintf(buf + 3, sizeof(buf) - 3, "on (%d reader)", rcount); }
+							snprintf(buf+3, sizeof(buf)-3, "on (%d reader)", rcount);
 				}
 			}
 		}
@@ -476,6 +438,7 @@
 void cs_disconnect_client(struct s_client *client)
 {
 	char buf[32] = { 0 };
+	if (!client) return;
 	if(IP_ISSET(client->ip))
 		{ snprintf(buf, sizeof(buf), " from %s", cs_inet_ntoa(client->ip)); }
 	cs_log("%s disconnected%s", username(client), buf);
@@ -488,12 +451,10 @@
 void kill_all_clients(void)
 {
 	struct s_client *cl;
-	for(cl = first_client->next; cl; cl = cl->next)
-	{
-		if(cl->typ == 'c' || cl->typ == 'm')
-		{
+	for (cl = first_client->next; cl; cl=cl->next) {
+		if (cl->typ == 'c' || cl->typ == 'm') {
 			if(cl->account && cl->account->usr)
-				{ cs_log("killing client %s", cl->account->usr); }
+				cs_log("killing client %s", cl->account->usr);
 			kill_thread(cl);
 		}
 	}
@@ -506,20 +467,15 @@
 	unsigned char md5tmp[MD5_DIGEST_LENGTH];
 
 	struct s_client *cl;
-	for(cl = first_client->next; cl; cl = cl->next)
-	{
-		if((cl->typ == 'c' || cl->typ == 'm') && cl->account)
-		{
-			for(account = new_accounts; (account) ; account = account->next)
-			{
+	for (cl = first_client->next; cl; cl = cl->next) {
+		if ((cl->typ == 'c' || cl->typ == 'm') && cl->account) {
+			for (account = new_accounts; (account) ; account = account->next) {
 				if(!strcmp(cl->account->usr, account->usr))
-					{ break; }
+					break;
 			}
-			if(account && !account->disabled && cl->pcrc == crc32(0L, MD5((uchar *)ESTR(account->pwd), strlen(ESTR(account->pwd)), md5tmp), MD5_DIGEST_LENGTH))
-			{
+			if (account && !account->disabled && cl->pcrc == crc32(0L, MD5((uchar *)ESTR(account->pwd), strlen(ESTR(account->pwd)), md5tmp), MD5_DIGEST_LENGTH)) {
 				cl->account = account;
-				if(cl->typ == 'c')
-				{
+				if (cl->typ == 'c') {
 					cl->grp = account->grp;
 					cl->aureader_list   = account->aureader_list;
 					cl->autoau = account->autoau;
@@ -554,21 +510,17 @@
 					ac_init_client(cl, account);
 				}
 			}
-			else
-			{
-				if(get_module(cl)->type & MOD_CONN_NET)
-				{
+			else {
+				if (get_module(cl)->type & MOD_CONN_NET) {
 					cs_log_dbg(D_TRACE, "client '%s', thread=%8lX not found in db (or password changed)", cl->account->usr, (unsigned long)cl->thread);
 					kill_thread(cl);
 				}
-				else
-				{
+				else {
 					cl->account = first_client->account;
 				}
 			}
 		}
-		else
-		{
+		else {
 			cl->account = NULL;
 		}
 	}
@@ -576,10 +528,8 @@
 
 void client_check_status(struct s_client *cl)
 {
-	if(!cl || cl->kill || !cl->init_done)
-		{ return; }
-	switch(cl->typ)
-	{
+	if (!cl || cl->kill || !cl->init_done) return;
+	switch (cl->typ) {
 	case 'm':
 	case 'c':
 
@@ -608,16 +558,29 @@
 	case 'p':
 	{
 		struct s_reader *rdr = cl->reader;
-		if(!rdr || !rdr->enable || !rdr->active)  //reader is disabled or restarting at this moment
-			{ break; }
+			if (!rdr || !rdr->enable || !rdr->active) break; // reader is disabled or restarting at this moment
+
 		// execute reader do idle on proxy reader after a certain time (rdr->tcp_ito = inactivitytimeout)
 		// disconnect when no keepalive available
-		if((rdr->tcp_ito && is_cascading_reader(rdr)) || (rdr->typ == R_CCCAM) || (rdr->typ == R_CAMD35) || (rdr->typ == R_CS378X) || (rdr->typ == R_SCAM) || (rdr->tcp_ito != 0 && rdr->typ == R_RADEGAST))
+			if ((rdr->tcp_ito && is_cascading_reader(rdr)) ||
+				 (rdr->typ == R_CCCAM) || (rdr->typ == R_CAMD35) || (rdr->typ == R_CS378X) ||
+				 (rdr->typ == R_SCAM) ||
+				 (rdr->tcp_ito != 0 && rdr->typ == R_RADEGAST))
 		{
 			time_t now = time(NULL);
 			int32_t time_diff = llabs(now - rdr->last_check);
-			if(time_diff > 60 || (time_diff > 30 && (rdr->typ == R_CCCAM || rdr->typ == R_CAMD35 || rdr->typ == R_CS378X)) || ((time_diff > (rdr->tcp_rto?rdr->tcp_rto:60)) && rdr->typ == R_RADEGAST))     //check 1x per minute or every 30s for cccam/camd35 or reconnecttimeout radegast if 0 defaut 60s
-			{
+
+				if ((time_diff > 60) ||
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+					((time_diff >  2) &&(IS_IKS_READERS(rdr) && IS_IKS_SOUTHAMERICA(rdr->xcamd_version))) ||
+					((time_diff > 15) && IS_ICS_READERS(rdr)) ||
+#endif
+#if defined(MODULE_XCAS)  || defined(MODULE_CONSTCW)
+					((time_diff >  5) && IS_EMU_READERS(rdr)) ||
+#endif
+					((time_diff > 30) && (rdr->typ == R_CCCAM || rdr->typ == R_CAMD35 || rdr->typ == R_CS378X)) ||
+					((time_diff > (rdr->tcp_rto ? rdr->tcp_rto : 60)) && rdr->typ == R_RADEGAST))
+				{ 	// check 1x per minute or every 30s for cccam or reconnecttimeout radegast if 0 defaut 60s
 				add_job(rdr->client, ACTION_READER_IDLE, NULL, 0);
 				rdr->last_check = now;
 			}
@@ -629,19 +592,16 @@
 
 void free_client(struct s_client *cl)
 {
-	if(!cl)
-		{ return; }
+	if (!cl) return;
 	struct s_reader *rdr = cl->reader;
 
 	// Remove client from client list. kill_thread also removes this client, so here just if client exits itself...
 	struct s_client *prev, *cl2;
 	cs_writelock(&clientlist_lock);
-	if(!cl->kill_started)
-	{
+	if (!cl->kill_started) {
 		cl->kill_started = 1;
 	}
-	else
-	{
+	else {
 		cs_writeunlock(&clientlist_lock);
 		cs_log("[free_client] ERROR: free already started!");
 		return;
@@ -651,28 +611,22 @@
 			prev->next != NULL;
 			prev = prev->next, cl2 = cl2->next)
 	{
-		if(cl == cl2)
-			{ break; }
+		if (cl == cl2) break;
 	}
-	if(cl == cl2)
-		{ prev->next = cl2->next; } // Remove client from list
+	if (cl == cl2) prev->next = cl2->next; // Remove client from list
 	int32_t bucket = (uintptr_t)cl / 16 % CS_CLIENT_HASHBUCKETS;
 	// Remove client from hashed list
-	if(first_client_hashed[bucket] == cl)
-	{
+	if (first_client_hashed[bucket] == cl) {
 		first_client_hashed[bucket] = cl->nexthashed;
 	}
-	else
-	{
+	else {
 		for(prev = first_client_hashed[bucket], cl2 = first_client_hashed[bucket]->nexthashed;
 				prev->nexthashed != NULL;
 				prev = prev->nexthashed, cl2 = cl2->nexthashed)
 		{
-			if(cl == cl2)
-				{ break; }
+			if (cl == cl2) break;
 		}
-		if(cl == cl2)
-			{ prev->nexthashed = cl2->nexthashed; }
+		if (cl == cl2) prev->nexthashed = cl2->nexthashed;
 	}
 	cs_writeunlock(&clientlist_lock);
 
@@ -683,8 +637,7 @@
 	{
 		ll_destroy_data(&rdr->emmstat);
 		remove_reader_from_active(rdr);
-
-		cs_sleepms(1000); //just wait a bit that really really nobody is accessing client data
+		cs_sleepms(800); // just wait a bit that really really nobody is accessing client data
 
 		if(rdr->ph.cleanup)
 			{ rdr->ph.cleanup(cl); }
@@ -696,30 +649,28 @@
 	}
 
 	// Clean client specific data
-	if(cl->typ == 'c')
-	{
+	if (cl->typ == 'c') {
 		cs_statistics(cl);
 		cl->last_caid = NO_CAID_VALUE;
 		cl->last_srvid = NO_SRVID_VALUE;
 		cs_statistics(cl);
 
-		cs_sleepms(1000); //just wait a bit that really really nobody is accessing client data
+		cs_sleepms(800); // just wait a bit that really really nobody is accessing client data
 	}
 
 	struct s_module *module = get_module(cl);
-	if(module->cleanup)
-		{ module->cleanup(cl); }
-
+	if (module->cleanup) {
+		module->cleanup(cl);
+	}
 	// Close network socket if not already cleaned by previous cleanup functions
-	if(cl->pfd)
-		{ close(cl->pfd); }
-
+	if (cl->pfd) {
+		close(cl->pfd);
+	}
 	// Clean all remaining structures
 	free_joblist(cl);
 	NULLFREE(cl->work_mbuf);
 
-	if(cl->ecmtask)
-	{
+	if (cl->ecmtask) {
 		add_garbage(cl->ecmtask);
 		cl->ecmtask = NULL;
 	}
@@ -731,8 +682,8 @@
 	tuntab_clear(&cl->ttab);
 	caidtab_clear(&cl->ctab);
 
-	NULLFREE(cl->cw_rass);
 	ll_destroy_data(&cl->ra_buf);
+	NULLFREE(cl->cw_rass);
 	NULLFREE(cl->aes_keys);
 
 #ifdef MODULE_CCCAM
Index: oscam-client.h
===================================================================
--- oscam-client.h	(revision 10670)
+++ oscam-client.h	(working copy)
@@ -2,8 +2,7 @@
 #define OSCAM_CLIENT_H_
 
 /* Gets the client associated to the calling thread. */
-static inline struct s_client *cur_client(void)
-{
+static inline struct s_client *cur_client(void) {
 	return (struct s_client *)pthread_getspecific(getclient);
 }
 int32_t get_threadnum(struct s_client *client);
Index: oscam-conf-chk.c
===================================================================
--- oscam-conf-chk.c	(revision 10670)
+++ oscam-conf-chk.c	(working copy)
@@ -13,29 +13,24 @@
 	char *ptr1, *ptr2, *saveptr1 = NULL;
 	struct s_ip *fip, *lip, *cip;
 
-	if(!cs_malloc(&cip, sizeof(struct s_ip)))
-		{ return; }
+	if (!cs_malloc(&cip, sizeof(struct s_ip))) return;
 	fip = cip;
 
 	for(ptr1 = strtok_r(value, ",", &saveptr1); ptr1; ptr1 = strtok_r(NULL, ",", &saveptr1))
 	{
 		if(i == 0)
-			{ ++i; }
-		else
-		{
-			if(!cs_malloc(&cip, sizeof(struct s_ip)))
-				{ break; }
+			++i;
+		else {
+			if (!cs_malloc(&cip, sizeof(struct s_ip))) break;
 			lip->next = cip;
 		}
 
-		if((ptr2 = strchr(trim(ptr1), '-')))
-		{
+		if ((ptr2=strchr(trim(ptr1), '-'))) {
 			*ptr2++ = '\0';
 			cs_inet_addr(trim(ptr1), &cip->ip[0]);
 			cs_inet_addr(trim(ptr2), &cip->ip[1]);
 		}
-		else
-		{
+		else {
 			cs_inet_addr(ptr1, &cip->ip[0]);
 			IP_ASSIGN(cip->ip[1], cip->ip[0]);
 		}
@@ -118,38 +113,32 @@
 			*ptr4++ = '\0';
 			for(j = 0, ptr5 = strtok_r(ptr4, ":", &saveptr2); (j < 2) && ptr5; ptr5 = strtok_r(NULL, ":", &saveptr2), j++)
 			{
-				if(!j)
-				{
+				if (!j) {
 					dwtime = atoi(ptr5);
 				}
-				if(j)
-				{
+				if (j) {
 					awtime = dwtime;
 					dwtime = atoi(ptr5);
 				}
 			}
 		}
-		if((ptr3 = strchr(trim(ptr), '$')))
-		{
+		if ((ptr3 = strchr(trim(ptr), '$'))) {
 			*ptr3++ = '\0';
 			srvid = a2i(ptr3, 4);
 		}
-		if((ptr2 = strchr(trim(ptr), '@')))
-		{
+		if ((ptr2 = strchr(trim(ptr), '@'))) {
 			*ptr2++ = '\0';
 			provid = a2i(ptr2, 6);
 		}
-		if((ptr1 = strchr(ptr, '&')))
-		{
+		if ((ptr1 = strchr(ptr, '&'))) {
 			*ptr1++ = '\0';
 			cmask = a2i(ptr1, -2);
 		}
 		if(!ptr1 && !ptr2 && !ptr3 && !ptr4)  //only dwtime
-			{ dwtime = atoi(ptr); }
+			dwtime = atoi(ptr);
 		else
-			{ caid = a2i(ptr, 2); }
-		if((i == 0 && (caid <= 0)) || (caid > 0))
-		{
+			caid = a2i(ptr, 2);
+		if ((i==0 && (caid <= 0)) || (caid > 0)) {
 			newtab.caid[i] = caid;
 			newtab.cmask[i] = cmask;
 			newtab.prid[i] = provid;
@@ -235,24 +224,20 @@
 		int32_t provid = -1;
 		char *ptr1 = NULL, *ptr2 = NULL, *ptr3 = NULL;
 
-		if((ptr3 = strchr(trim(ptr), '$')))
-		{
+		if ((ptr3 = strchr(trim(ptr), '$'))) {
 			*ptr3++ = '\0';
 			srvid = a2i(ptr3, 4);
 		}
-		if((ptr2 = strchr(trim(ptr), '@')))
-		{
+		if ((ptr2 = strchr(trim(ptr), '@'))) {
 			*ptr2++ = '\0';
 			provid = a2i(ptr2, 6);
 		}
-		if((ptr1 = strchr(ptr, '&')))
-		{
+		if ((ptr1 = strchr(ptr, '&'))) {
 			*ptr1++ = '\0';
 			cmask = a2i(ptr1, -2);
 		}
 		caid = a2i(ptr, 2);
-		if(caid > 0)
-		{
+		if (caid > 0) {
 			newtab.caid[i] = caid;
 			newtab.cmask[i] = cmask;
 			newtab.prid[i] = provid;
@@ -331,8 +316,10 @@
 			continue;
 		}
 		ptr1 = caid_end_ptr + 1; // -> headers
-		char *ident_ptr, *saveident_ptr = NULL;
-		for(ident_ptr = strtok_r(ptr1, ",", &saveident_ptr); ident_ptr && d.nprids < ARRAY_SIZE(d.prids); ident_ptr = strtok_r(NULL, ",", &saveident_ptr))
+		char *ident_ptr = NULL, *saveident_ptr = NULL;
+		for(ident_ptr = strtok_r(ptr1, ",", &saveident_ptr);
+			 ident_ptr && d.nprids < ARRAY_SIZE(d.prids);
+			 ident_ptr = strtok_r(NULL, ",", &saveident_ptr))
 		{
 			uint32_t ident = a2i(ident_ptr, 4);
 			if (errno == EINVAL)
@@ -369,18 +356,18 @@
 {
 	int32_t i, j, nfilts, ifilt, iport;
 	PTAB *newptab;
-	char *ptr1, *ptr2, *ptr3, *saveptr1 = NULL;
+	char *ptr1 = 0, *ptr2 = 0, *ptr3 = 0, *saveptr1 = NULL;
 	char *ptr[CS_MAXPORTS] = {0};
 	int32_t port[CS_MAXPORTS] = {0};
 	if(!cs_malloc(&newptab, sizeof(PTAB)))
-		{ return; }
+		return;
 
 	for(nfilts = i = 0, ptr1 = strtok_r(portasc, ";", &saveptr1); (i < CS_MAXPORTS) && (ptr1); ptr1 = strtok_r(NULL, ";", &saveptr1), i++)
 	{
 		ptr[i] = ptr1;
 
 		if(!newptab->ports[i].ncd && !cs_malloc(&newptab->ports[i].ncd, sizeof(struct ncd_port)))
-			{ break; }
+			break;
 
 		if((ptr2 = strchr(trim(ptr1), '@')))
 		{
@@ -389,13 +376,12 @@
 
 			//checking for des key for port
 			newptab->ports[i].ncd->ncd_key_is_set = false;
-			if((ptr3 = strchr(trim(ptr1), '{')))
-			{
+			if ((ptr3=strchr(trim(ptr1), '{'))) {
 				*ptr3++ = '\0';
 				if(key_atob_l(ptr3, newptab->ports[i].ncd->ncd_key, sizeof(newptab->ports[i].ncd->ncd_key) * 2))
-					{ fprintf(stderr, "newcamd: error in DES Key for port %s -> ignored\n", ptr1); }
+					fprintf(stderr, "newcamd: error in DES Key for port %s -> ignored\n", ptr1);
 				else
-					{ newptab->ports[i].ncd->ncd_key_is_set = true; }
+					newptab->ports[i].ncd->ncd_key_is_set = true;
 			}
 
 			ptr[i] = ptr2;
@@ -405,10 +391,16 @@
 		nfilts++;
 	}
 
-	if(nfilts == 1 && strlen(portasc) < 6 && newptab->ports[0].s_port == 0)
-	{
+	if (nfilts == 1 && strlen(portasc) < 6 && newptab->ports[0].s_port == 0) {
 		newptab->ports[0].s_port = atoi(portasc);
 		newptab->nports = 1;
+		// sky(a)
+		if (newptab->ports[0].ncd) {
+			newptab->ports[0].ncd->ncd_ftab.filts[0].caid 	 = 0x0;
+			newptab->ports[0].ncd->ncd_ftab.filts[0].prids[0]= 0x0;
+			newptab->ports[0].ncd->ncd_ftab.filts[0].nprids  = 1;
+		}
+		nfilts = 0;
 	}
 
 	iport = ifilt = 0;
@@ -416,7 +408,7 @@
 	{
 		if(port[i] != 0)
 			{ iport = i; }
-		for(j = 0, ptr3 = strtok_r(ptr[i], ",", &saveptr1); (j < CS_MAXPROV) && (ptr3); ptr3 = strtok_r(NULL, ",", &saveptr1), j++)
+		for (j = 0, ptr3 = strtok_r(ptr[i], ",", &saveptr1); (j < CS_MAXPRFLT) && (ptr3); ptr3 = strtok_r(NULL, ",", &saveptr1), j++)
 		{
 			if((ptr2 = strchr(trim(ptr3), ':')))
 			{
Index: oscam-conf-mk.c
===================================================================
--- oscam-conf-mk.c	(revision 10670)
+++ oscam-conf-mk.c	(working copy)
@@ -66,31 +66,27 @@
 
 	for(i = 0; i < 64; i++)
 	{
-		if(grp & ((uint64_t)1 << i))
-		{
+		if (grp&((uint64_t)1<<i)) {
 			needed += 2;
-			if(i > 9) { needed += 1; }
+			if (i > 9) needed += 1;
 		}
 	}
 	char *value;
-	if(needed == 1 || !cs_malloc(&value, needed)) { return ""; }
+	if (needed == 1 || !cs_malloc(&value, needed)) return "";
 	char *saveptr = value;
 	for(i = 0; i < 64; i++)
 	{
-		if(grp & ((uint64_t)1 << i))
-		{
-			if(dot == 0)
-			{
+		if (grp&((uint64_t)1<<i)) {
+			if (dot == 0) {
 				snprintf(value + pos, needed - (value - saveptr), "%d", i + 1);
-				if(i > 8) { pos += 2; }
-				else { pos += 1; }
+				if (i > 8)pos += 2;
+				else pos += 1;
 				dot = 1;
 			}
-			else
-			{
+			else {
 				snprintf(value + pos, needed - (value - saveptr), ",%d", i + 1);
-				if(i > 8) { pos += 3; }
-				else { pos += 2; }
+				if (i > 8)pos += 3;
+				else pos += 2;
 			}
 		}
 	}
@@ -141,37 +137,32 @@
 	{
 		/* Port is maximally 5 chars long, plus the @caid, plus the ";" between ports */
 		needed += 11;
-		if(cfg.c35_tcp_ptab.ports[i].ncd && cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 1)
-		{
+		if (cfg.c35_tcp_ptab.ports[i].ncd && cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 1) {
 			needed += cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids * 7;
 		}
 	}
 	char *value;
-	if(needed == 1 || !cs_malloc(&value, needed)) { return ""; }
+	if (needed == 1 || !cs_malloc(&value, needed)) return "";
 	char *saveptr = value;
 	char *dot1 = "", *dot2;
 	for(i = 0; i < cfg.c35_tcp_ptab.nports; ++i)
 	{
 
-		if(cfg.c35_tcp_ptab.ports[i].ncd && cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].caid)
-		{
+		if (cfg.c35_tcp_ptab.ports[i].ncd && cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].caid) {
 			pos += snprintf(value + pos, needed - (value - saveptr), "%s%d@%04X", dot1,
 							cfg.c35_tcp_ptab.ports[i].s_port,
 							cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].caid);
 
-			if(cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 1)
-			{
+			if (cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 1) {
 				dot2 = ":";
-				for(j = 0; j < cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids; ++j)
-				{
+				for (j = 0; j < cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids; ++j) {
 					pos += snprintf(value + pos, needed - (value - saveptr), "%s%X", dot2, cfg.c35_tcp_ptab.ports[i].ncd->ncd_ftab.filts[0].prids[j]);
 					dot2 = ",";
 				}
 			}
 			dot1 = ";";
 		}
-		else
-		{
+		else {
 			pos += snprintf(value + pos, needed - (value - saveptr), "%d", cfg.c35_tcp_ptab.ports[i].s_port);
 		}
 	}
@@ -190,11 +181,10 @@
 	int32_t i, pos = 0, needed = CS_MAXPORTS * 6 + 8;
 
 	char *value;
-	if(!cs_malloc(&value, needed)) { return ""; }
+	if (!cs_malloc(&value, needed)) return "";
 	char *dot = "";
-	for(i = 0; i < CS_MAXPORTS; i++)
-	{
-		if(!cfg.cc_port[i]) { break; }
+	for (i = 0; i < CS_MAXPORTS; i++) {
+		if (!cfg.cc_port[i]) break;
 
 		pos += snprintf(value + pos, needed - pos, "%s%d", dot, cfg.cc_port[i]);
 		dot = ",";
@@ -235,12 +225,11 @@
 	uint32_t prevIdent = 0;
 
 	/* Precheck for the approximate size that we will need; it's a bit overestimated but we correct that at the end of the function */
-	while(current)
-	{
+	while (current) {
 		/* The caid, ident, "@" and the trailing ";" need to be output when they are changing */
-		if(prevCaid != current->caid || prevIdent != current->ident) { needed += 12 + (current->keyid * 2); }
+		if (prevCaid != current->caid || prevIdent != current->ident) needed += 12 + (current->keyid * 2);
 		/* "0" keys are not saved so we need to check for gaps */
-		else if(prevKeyid != current->keyid + 1) { needed += (current->keyid - prevKeyid - 1) * 2; }
+		else if (prevKeyid != current->keyid + 1) needed += (current->keyid - prevKeyid - 1) * 2;
 		/* The 32 byte key plus either the (heading) ":" or "," */
 		needed += 33;
 		prevCaid = current->caid;
@@ -256,35 +245,31 @@
 	prevKeyid = 0;
 	char tmp[needed];
 	char dot;
-	if(needed == 1) { tmp[0] = '\0'; }
+	if (needed == 1) tmp[0] = '\0';
 	char tmpkey[33];
 	while(current)
 	{
 		/* A change in the ident or caid means that we need to output caid and ident */
-		if(prevCaid != current->caid || prevIdent != current->ident)
-		{
-			if(pos > 0)
-			{
+		if (prevCaid != current->caid || prevIdent != current->ident) {
+			if (pos > 0) {
 				tmp[pos] = ';';
 				++pos;
 			}
 			pos += snprintf(tmp + pos, sizeof(tmp) - pos, "%04X@%06X", current->caid, current->ident);
 			prevKeyid = -1;
 			dot = ':';
-		}
-		else { dot = ','; }
+		} else dot = ',';
 		/* "0" keys are not saved so we need to check for gaps and output them! */
-		for(i = prevKeyid + 1; i < current->keyid; ++i)
-		{
+		for (i = prevKeyid + 1; i < current->keyid; ++i) {
 			pos += snprintf(tmp + pos, sizeof(tmp) - pos, "%c0", dot);
 			dot = ',';
 		}
 		tmp[pos] = dot;
 		++pos;
-		for(i = 0; i < 16; ++i) { snprintf(tmpkey + (i * 2), sizeof(tmpkey) - (i * 2), "%02X", current->plainkey[i]); }
+		for (i = 0; i < 16; ++i) snprintf(tmpkey + (i*2), sizeof(tmpkey) - (i*2), "%02X", current->plainkey[i]);
 		/* A key consisting of only FFs has a special meaning (just return what the card outputted) and can be specified more compact */
-		if(strcmp(tmpkey, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF") == 0) { pos += snprintf(tmp + pos, sizeof(tmp) - pos, "FF"); }
-		else { pos += snprintf(tmp + pos, sizeof(tmp) - pos, "%s", tmpkey); }
+		if (strcmp(tmpkey, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF") == 0) pos += snprintf(tmp+pos, sizeof(tmp)-pos, "FF");
+		else pos += snprintf(tmp+pos, sizeof(tmp)-pos, "%s", tmpkey);
 		prevCaid = current->caid;
 		prevIdent = current->ident;
 		prevKeyid = current->keyid;
@@ -293,7 +278,7 @@
 
 	/* copy to result array of correct size */
 	char *value;
-	if(pos == 0 || !cs_malloc(&value, pos + 1)) { return ""; }
+	if (pos == 0 || !cs_malloc(&value, pos + 1)) return "";
 	memcpy(value, tmp, pos + 1);
 	return (value);
 }
@@ -307,21 +292,18 @@
 	int32_t i, j, k, pos = 0, needed = 1;
 
 	/* Precheck to determine how long the resulting string will maximally be (might be a little bit smaller but that shouldn't hurt) */
-	for(i = 0; i < cfg.ncd_ptab.nports; ++i)
-	{
+	for (i = 0; i < cfg.ncd_ptab.nports; ++i) {
 		/* Port is maximally 5 chars long, plus the @caid, plus the ";" between ports */
 		needed += 11;
-		if(cfg.ncd_ptab.ports[i].ncd)
-		{
-			if(cfg.ncd_ptab.ports[i].ncd->ncd_key_is_set) { needed += 30; }
-			if(cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 0)
-			{
+		if (cfg.ncd_ptab.ports[i].ncd) {
+			if (cfg.ncd_ptab.ports[i].ncd->ncd_key_is_set) needed += 30;
+			if (cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 0) {
 				needed += cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids * 7;
 			}
 		}
 	}
 	char *value;
-	if(needed == 1 || !cs_malloc(&value, needed)) { return ""; }
+	if (needed == 1 || !cs_malloc(&value, needed)) return "";
 	char *dot1 = "", *dot2;
 
 	for(i = 0; i < cfg.ncd_ptab.nports; ++i)
@@ -331,21 +313,18 @@
 		// separate DES Key for this port
 		if(cfg.ncd_ptab.ports[i].ncd)
 		{
-			if(cfg.ncd_ptab.ports[i].ncd->ncd_key_is_set)
-			{
+			if (cfg.ncd_ptab.ports[i].ncd->ncd_key_is_set) {
 				pos += snprintf(value + pos, needed - pos, "{");
 				for(k = 0; k < (int32_t)sizeof(cfg.ncd_ptab.ports[i].ncd->ncd_key); k++)
-					{ pos += snprintf(value + pos, needed - pos, "%02X", cfg.ncd_ptab.ports[i].ncd->ncd_key[k]); }
+					pos += snprintf(value + pos, needed-pos, "%02X", cfg.ncd_ptab.ports[i].ncd->ncd_key[k]);
 				pos += snprintf(value + pos, needed - pos, "}");
 			}
 
 			pos += snprintf(value + pos, needed - pos, "@%04X", cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].caid);
 
-			if(cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 0)
-			{
+			if (cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids > 0) {
 				dot2 = ":";
-				for(j = 0; j < cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids; ++j)
-				{
+				for (j = 0; j < cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].nprids; ++j) {
 					pos += snprintf(value + pos, needed - pos, "%s%06X", dot2, (int)cfg.ncd_ptab.ports[i].ncd->ncd_ftab.filts[0].prids[j]);
 					dot2 = ",";
 				}
@@ -368,13 +347,12 @@
 	char *dot = "";
 
 	char *value;
-	if(ll_count(account->aureader_list) == 0 || !cs_malloc(&value, 256)) { return ""; }
+	if (ll_count(account->aureader_list) == 0 || !cs_malloc(&value, 256)) return "";
 	value[0] = '\0';
 
 	struct s_reader *rdr;
 	LL_ITER itr = ll_iter_create(account->aureader_list);
-	while((rdr = ll_iter_next(&itr)))
-	{
+	while ((rdr = ll_iter_next(&itr))) {
 		pos += snprintf(value + pos, 256 - pos, "%s%s", dot, rdr->label);
 		dot = ",";
 	}
@@ -391,22 +369,19 @@
 
 	for(i = 0; i < 16; i++)
 		if((1 << i) & nano)
-			{ needed++; }
+			needed++;
 
 	char *value;
-	if(nano == 0xFFFF)
-	{
-		if(!cs_malloc(&value, 4)) { return ""; }
+	if (nano == 0xFFFF) {
+		if (!cs_malloc(&value, 4)) return "";
 		snprintf(value, 4, "all");
 	}
-	else
-	{
-		if(needed == 0 || !cs_malloc(&value, needed * 3 + 1)) { return ""; }
+	else {
+		if (needed == 0 || !cs_malloc(&value, needed * 3 + 1)) return "";
 		value[0] = '\0';
-		for(i = 0; i < 16; i++)
-		{
+		for (i=0; i<16; i++) {
 			if((1 << i) & nano)
-				{ pos += snprintf(value + pos, (needed * 3) + 1 - pos, "%s%02x", pos ? "," : "", (i + 0x80)); }
+				pos += snprintf(value + pos, (needed*3)+1-pos, "%s%02x", pos ? "," : "", (i+0x80));
 		}
 	}
 	return value;
@@ -421,18 +396,16 @@
 	char *dot;
 	char *value;
 	struct s_sidtab *sidtab = cfg.sidtab;
-	if(!sidtab || (!sidtabs->ok && !sidtabs->no) || !cs_malloc(&value, 1024)) { return ""; }
+	if (!sidtab || (!sidtabs->ok && !sidtabs->no) || !cs_malloc(&value, 1024)) return "";
 	value[0] = '\0';
 
 	for(i = pos = 0, dot = ""; sidtab; sidtab = sidtab->next, i++)
 	{
-		if(sidtabs->ok & ((SIDTABBITS)1 << i))
-		{
+		if (sidtabs->ok&((SIDTABBITS)1<<i)) {
 			pos += snprintf(value + pos, 1024 - pos, "%s%s", dot, sidtab->label);
 			dot = ",";
 		}
-		if(sidtabs->no & ((SIDTABBITS)1 << i))
-		{
+		if (sidtabs->no&((SIDTABBITS)1<<i)) {
 			pos += snprintf(value + pos, 1024 - pos, "%s!%s", dot, sidtab->label);
 			dot = ",";
 		}
@@ -448,23 +421,20 @@
 	int32_t pos = 0, needed = 1;
 	char *value, *dot = "";
 
-	if(cfg.logtostdout == 1) { needed += 7; }
-	if(cfg.logtosyslog == 1) { needed += 7; }
-	if(cfg.logfile) { needed += strlen(cfg.logfile); }
-	if(needed == 1 || !cs_malloc(&value, needed)) { return ""; }
+	if (cfg.logtostdout == 1) needed += 7;
+	if (cfg.logtosyslog == 1) needed += 7;
+	if (cfg.logfile) needed += strlen(cfg.logfile);
+	if (needed == 1 || !cs_malloc(&value, needed)) return "";
 
-	if(cfg.logtostdout == 1)
-	{
+	if (cfg.logtostdout == 1) {
 		pos += snprintf(value + pos, needed - pos, "stdout");
 		dot = ";";
 	}
-	if(cfg.logtosyslog == 1)
-	{
+	if (cfg.logtosyslog == 1) {
 		pos += snprintf(value + pos, needed - pos, "%ssyslog", dot);
 		dot = ";";
 	}
-	if(cfg.logfile)
-	{
+	if (cfg.logfile) {
 		pos += snprintf(value + pos, needed - pos, "%s%s", dot, cfg.logfile);
 	}
 	return value;
@@ -578,23 +548,21 @@
 {
 	char *value, *dot = "";
 	int32_t i, needed = 1, pos = 0;
-	for(i = 0; i < clstab->an; ++i) { needed += 3; }
-	for(i = 0; i < clstab->bn; ++i) { needed += 4; }
+	for (i = 0; i < clstab->an; ++i) needed += 3;
+	for (i = 0; i < clstab->bn; ++i) needed += 4;
 
 	char tmp[needed];
 
-	for(i = 0; i < clstab->an; ++i)
-	{
+	for (i = 0; i < clstab->an; ++i) {
 		pos += snprintf(tmp + pos, needed - pos, "%s%02x", dot, (int32_t)clstab->aclass[i]);
 		dot = ",";
 	}
-	for(i = 0; i < clstab->bn; ++i)
-	{
+	for (i = 0; i < clstab->bn; ++i) {
 		pos += snprintf(tmp + pos, needed - pos, "%s!%02x", dot, (int32_t)clstab->bclass[i]);
 		dot = ",";
 	}
 
-	if(pos == 0 || !cs_malloc(&value, pos + 1)) { return ""; }
+	if (pos == 0 || !cs_malloc(&value, pos + 1)) return "";
 	memcpy(value, tmp, pos + 1);
 	return value;
 }
@@ -625,44 +593,43 @@
 
 char *mk_t_cacheex_valuetab(CECSPVALUETAB *tab)
 {
-	if(!tab->n) { return ""; }
+	if (!tab->n) return "";
 	int32_t i, size = 2 + tab->n * (4 + 1 + 4 + 1 + 6 + 1 + 4 + 1 + 5 + 1 + 5 + 1); //caid&mask@provid$servid:awtime:dwtime","
 	char *buf;
 	if(!cs_malloc(&buf, size))
-		{ return ""; }
+		return "";
 	char *ptr = buf;
 
 	for(i = 0; i < tab->n && tab->n <= CS_MAXCAIDTAB ; i++)
 	{
-		if(i) { ptr += snprintf(ptr, size - (ptr - buf), ","); }
+		if (i) ptr += snprintf(ptr, size-(ptr-buf), ",");
 		if(tab->caid[i] >= 0)
 		{
-			if(tab->caid[i] == 0)
-			{
+			if (tab->caid[i] == 0) {
 				if(tab->awtime[i] > 0)
-					{ ptr += snprintf(ptr, size - (ptr - buf), "%d", tab->caid[i]); }
+					ptr += snprintf(ptr, size-(ptr-buf), "%d", tab->caid[i]);
 			}
 			else if(tab->caid[i] < 256)   //Do not format 0D as 000D, its a shortcut for 0Dxx:
-				{ ptr += snprintf(ptr, size - (ptr - buf), "%02X", tab->caid[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "%02X", tab->caid[i]);
 			else
-				{ ptr += snprintf(ptr, size - (ptr - buf), "%04X", tab->caid[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "%04X", tab->caid[i]);
 		}
 		if(tab->cmask[i] >= 0)
-			{ ptr += snprintf(ptr, size - (ptr - buf), "&%04X", tab->cmask[i]); }
+			ptr += snprintf(ptr, size-(ptr-buf), "&%04X", tab->cmask[i]);
 		if(tab->prid[i] >= 0)
-			{ ptr += snprintf(ptr, size - (ptr - buf), "@%06X", tab->prid[i]); }
+			ptr += snprintf(ptr, size-(ptr-buf), "@%06X", tab->prid[i]);
 		if(tab->srvid[i] >= 0)
-			{ ptr += snprintf(ptr, size - (ptr - buf), "$%04X", tab->srvid[i]); }
+			ptr += snprintf(ptr, size-(ptr-buf), "$%04X", tab->srvid[i]);
 		if(tab->awtime[i] > 0)
-			{ ptr += snprintf(ptr, size - (ptr - buf), ":%d", tab->awtime[i]); }
+			ptr += snprintf(ptr, size-(ptr-buf), ":%d", tab->awtime[i]);
 		if(!tab->dwtime[i] > 0)
-			{ ptr += snprintf(ptr, size - (ptr - buf), ":0"); }
+				ptr += snprintf(ptr, size-(ptr-buf), ":0");
 		if(tab->dwtime[i] > 0)
 		{
 			if((tab->caid[i] <= 0) && (tab->prid[i] == -1) && (tab->srvid[i] == -1) && (tab->srvid[i] == -1) && (tab->awtime[i] <= 0))
-				{ ptr += snprintf(ptr, size - (ptr - buf), "%d", tab->dwtime[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "%d", tab->dwtime[i]);
 			else
-				{ ptr += snprintf(ptr, size - (ptr - buf), ":%d", tab->dwtime[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), ":%d", tab->dwtime[i]);
 		}
 	}
 	*ptr = 0;
@@ -708,28 +675,28 @@
 
 char *mk_t_cacheex_hitvaluetab(CECSPVALUETAB *tab)
 {
-	if(!tab->n) { return ""; }
+	if (!tab->n) return "";
 	int32_t i, size = 2 + tab->n * (4 + 1 + 4 + 1 + 6 + 1 + 4 + 1); //caid&mask@provid$servid","
 	char *buf;
 	if(!cs_malloc(&buf, size))
-		{ return ""; }
+		return "";
 	char *ptr = buf;
 
 	for(i = 0; i < tab->n; i++)
 	{
-		if(i) { ptr += snprintf(ptr, size - (ptr - buf), ","); }
+		if (i) ptr += snprintf(ptr, size-(ptr-buf), ",");
 		if(tab->caid[i] > 0)
 		{
 			if(tab->caid[i] < 256)  //Do not format 0D as 000D, its a shortcut for 0Dxx:
-				{ ptr += snprintf(ptr, size - (ptr - buf), "%02X", tab->caid[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "%02X", tab->caid[i]);
 			else
-				{ ptr += snprintf(ptr, size - (ptr - buf), "%04X", tab->caid[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "%04X", tab->caid[i]);
 			if(tab->cmask[i] >= 0)
-				{ ptr += snprintf(ptr, size - (ptr - buf), "&%04X", tab->cmask[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "&%04X", tab->cmask[i]);
 			if(tab->prid[i] >= 0)
-				{ ptr += snprintf(ptr, size - (ptr - buf), "@%06X", tab->prid[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "@%06X", tab->prid[i]);
 			if(tab->srvid[i] >= 0)
-				{ ptr += snprintf(ptr, size - (ptr - buf), "$%04X", tab->srvid[i]); }
+				ptr += snprintf(ptr, size-(ptr-buf), "$%04X", tab->srvid[i]);
 		}
 	}
 	*ptr = 0;
@@ -746,31 +713,31 @@
 	struct s_emmlen_range *blocklen;
 
 	if(!rdr->blockemmbylen)
-		{ return ""; }
+		return "";
 
 	LL_ITER it = ll_iter_create(rdr->blockemmbylen);
 	while((blocklen = ll_iter_next(&it)))
 	{
 		needed += 5 + 1; // max digits of int16 + ","
 		if(blocklen->max == 0)
-			{ needed += 1 + 1; } // "-" + ","
+			needed += 1 + 1; // "-" + ","
 		else if(blocklen->min != blocklen->max)
-			{ needed += 1 + 5 + 1; } // "-" + max digits of int16 + ","
+			needed += 1 + 5 + 1; // "-" + max digits of int16 + ","
 	}
 	// the trailing zero is already included: it's the first ","
 	if(!cs_malloc(&value, needed))
-		{ return ""; }
+		return "";
 
 	pos = value;
 	ll_iter_reset(&it);
 	while((blocklen = ll_iter_next(&it)))
 	{
 		if(blocklen->min == blocklen->max)
-			{ num = snprintf(pos, needed, "%s%d", dot, blocklen->min); }
+			num = snprintf(pos, needed, "%s%d", dot, blocklen->min);
 		else if(blocklen->max == 0)
-			{ num = snprintf(pos, needed, "%s%d-", dot, blocklen->min); }
+			num = snprintf(pos, needed, "%s%d-", dot, blocklen->min);
 		else
-			{ num = snprintf(pos, needed, "%s%d-%d", dot, blocklen->min, blocklen->max); }
+			num = snprintf(pos, needed, "%s%d-%d", dot, blocklen->min, blocklen->max);
 		pos += num;
 		needed -= num;
 		dot = ",";
@@ -785,20 +752,37 @@
 {
 
 	if(!account->allowedprotocols)
-		{ return ""; }
+		return "";
 
 	int16_t i, tmp = 1, pos = 0, needed = 255, tagcnt;
-	char *tag[] = {"camd33", "cs357x", "cs378x", "newcamd", "cccam", "gbox", "radegast", "dvbapi", "constcw", "serial"};
+	char *tag[] = {"camd33",
+						"cs357x",
+						"cs378x",
+						"newcamd",
+						"cccam",
+#if defined(MODULE_XCAMD)
+						"xcamd",
+#endif
+#if defined(MODULE_MORECAM)
+						"morecam",
+#endif
+#if defined(MODULE_XCAS)
+						"xcas",
+#endif
+						"gbox",
+						"radegast",
+						"dvbapi",
+						"constcw",
+						"serial"};
 	char *value, *dot = "";
 
 	if(!cs_malloc(&value, needed))
-		{ return ""; }
+		return "";
 
 	tagcnt = sizeof(tag) / sizeof(char *);
 	for(i = 0; i < tagcnt; i++)
 	{
-		if((account->allowedprotocols & tmp) == tmp)
-		{
+		if ((account->allowedprotocols & tmp) == tmp) {
 			pos += snprintf(value + pos, needed, "%s%s", dot, tag[i]);
 			dot = ",";
 		}
@@ -813,5 +797,5 @@
  */
 void free_mk_t(char *value)
 {
-	if(strlen(value) > 0) { NULLFREE(value); }
+	if (strlen(value) > 0) NULLFREE(value);
 }
Index: oscam-conf.c
===================================================================
--- oscam-conf.c	(revision 10670)
+++ oscam-conf.c	(working copy)
@@ -12,7 +12,7 @@
 /* Returns the default value if string length is zero, otherwise atoi is called*/
 int32_t strToIntVal(char *value, int32_t defaultvalue)
 {
-	if(strlen(value) == 0) { return defaultvalue; }
+	if (strlen(value) == 0) return defaultvalue;
 	errno = 0; // errno should be set to 0 before calling strtol
 	int32_t i = strtol(value, NULL, 10);
 	return (errno == 0) ? i : defaultvalue;
@@ -21,7 +21,7 @@
 /* Returns the default value if string length is zero, otherwise strtoul is called*/
 uint32_t strToUIntVal(char *value, uint32_t defaultvalue)
 {
-	if(strlen(value) == 0) { return defaultvalue; }
+	if (strlen(value) == 0) return defaultvalue;
 	errno = 0; // errno should be set to 0 before calling strtoul
 	uint32_t i = strtoul(value, NULL, 10);
 	return (errno == 0) ? i : defaultvalue;
@@ -47,8 +47,7 @@
 	cs_strncpy(ptr, "= ", sizeof(varnamebuf) - (ptr - varnamebuf));
 	if(fwrite(varnamebuf, sizeof(char), strlen(varnamebuf), f))
 	{
-		if(strlen(fmtstring) > 0)
-		{
+		if (strlen(fmtstring) > 0) {
 			va_start(argptr, fmtstring);
 			vfprintf(f, fmtstring, argptr);
 			va_end(argptr);
@@ -62,91 +61,93 @@
 	for(c = clist; c->opt_type != OPT_UNKNOWN; c++)
 	{
 		if(c->opt_type == OPT_SAVE_FUNC || c->opt_type == OPT_FIXUP_FUNC)
-			{ continue; }
-		if(strcasecmp(token, c->config_name) != 0)
-			{ continue; }
+			continue;
+		if (strcasecmp(token, c->config_name) != 0) continue;
+
 		void *var = config_data + c->var_offset;
-		switch(c->opt_type)
-		{
-		case OPT_INT8:
-		{
+		switch (c->opt_type) {
+			case OPT_INT8: {
 			*(int8_t *)var = (int8_t)strToIntVal(value, c->def.d_int8);
 			return 1;
 		}
-		case OPT_UINT8:
-		{
+			case OPT_UINT8: {
 			uint32_t tmp = strToUIntVal(value, c->def.d_uint8);
 			*(uint8_t *)var = (uint8_t)(tmp <= 0xff ? tmp : 0xff);
 			return 1;
 		}
-		case OPT_INT32:
-		{
+			case OPT_INT32: {
 			int32_t tmp = strToIntVal(value, c->def.d_int32);
 			memcpy(var, &tmp, sizeof(int32_t));
 			return 1;
 		}
-		case OPT_UINT32:
-		{
+			case OPT_UINT32: {
 			uint32_t tmp = strToUIntVal(value, c->def.d_uint32);
 			memcpy(var, &tmp, sizeof(uint32_t));
 			return 1;
 		}
-		case OPT_STRING:
-		{
+			case OPT_STRING: {
 			char **scfg = var;
 			if(c->def.d_char && strlen(value) == 0)  // Set default
-				{ value = c->def.d_char; }
+					value = c->def.d_char;
 			NULLFREE(*scfg);
 			if(strlen(value))
-				{ *scfg = cs_strdup(value); }
+					*scfg = cs_strdup(value);
 			return 1;
 		}
-		case OPT_SSTRING:
-		{
+			case OPT_SSTRING: {
 			char *scfg = var;
 			if(c->def.d_char && strlen(value) == 0)  // Set default
-				{ value = c->def.d_char; }
+					value = c->def.d_char;
 			scfg[0] = '\0';
 			unsigned int len = strlen(value);
-			if(len)
-			{
+				if (len) {
 				strncpy(scfg, value, c->str_size - 1);
-				if(len > c->str_size)
-				{
+					if (len > c->str_size) {
 					fprintf(stderr, "WARNING: Config value for '%s' (%s, len=%u) exceeds max length: %d (%s)\n",
 							token, value, len, c->str_size - 1, scfg);
 				}
 			}
 			return 1;
 		}
-		case OPT_HEX_ARRAY:
-		{
+
+			// sky(iks)
+			case OPT_HEX_BYTES:
+			case OPT_HEX_ARRAY: {
 			uint8_t *hex_array = var;
-			if(!strlen(value))
-				{ memset(hex_array, 0, c->def.array_size); }
-			else if(key_atob_l(value, hex_array, c->def.array_size * 2))
-			{
+				uint8_t  hexakeep[256];
+				int 		keepsize  = c->def.array_size;
+				int 		preserved = 0;
+				if (strcasecmp(token, "iksregister") == 0) {
+					memcpy(hexakeep, hex_array, keepsize);
+					preserved = 1;
+				}
+				if (!strlen(value)) {
+					if (preserved) return 1;
+					memset(hex_array, 0, c->def.array_size);
+				}
+				else if (key_atob_l(value, hex_array, c->def.array_size * 2)) {
+					if (preserved) {
+						memcpy(hex_array, hexakeep, keepsize);
+						return 1;
+					}
 				memset(hex_array, 0, c->def.array_size);
 				fprintf(stderr, "WARNING: Config value for '%s' (%s, len=%zu) requires %d chars.\n",
 						token, value, strlen(value), c->def.array_size * 2);
 			}
 			return 1;
 		}
-		case OPT_FUNC:
-		{
+			case OPT_FUNC: {
 			c->ops.process_fn(token, value, var, NULL);
 			return 1;
 		}
-		case OPT_FUNC_EXTRA:
-		{
+			case OPT_FUNC_EXTRA: {
 			c->ops.process_fn_extra(token, value, var, c->def.d_extra, NULL);
 			return 1;
 		}
 		case OPT_FIXUP_FUNC:
 		case OPT_SAVE_FUNC:
 			return 1;
-		case OPT_UNKNOWN:
-		{
+			case OPT_UNKNOWN: {
 			fprintf(stderr, "Unknown config type (%s = %s).", token, value);
 			break;
 		}
@@ -165,69 +167,56 @@
 		if(check_func && c->opt_type != OPT_UNKNOWN)
 		{
 			if(!check_func(clist, config_data, c->config_name))
-				{ continue; }
+				continue;
 		}
-		switch(c->opt_type)
-		{
-		case OPT_INT8:
-		{
+		switch (c->opt_type) {
+			case OPT_INT8: {
 			int8_t val = *(int8_t *)var;
 			if(save_all || val != c->def.d_int8)
-				{ fprintf_conf(f, c->config_name, "%d\n", val); }
+					fprintf_conf(f, c->config_name, "%d\n", val);
 			continue;
 		}
-		case OPT_UINT8:
-		{
+			case OPT_UINT8: {
 			uint8_t val = *(uint8_t *)var;
 			if(save_all || val != c->def.d_uint8)
-				{ fprintf_conf(f, c->config_name, "%u\n", val); }
+					fprintf_conf(f, c->config_name, "%u\n", val);
 			continue;
 		}
-		case OPT_INT32:
-		{
+			case OPT_INT32: {
 			int32_t val;
 			memcpy(&val, var, sizeof(int32_t));
 			if(save_all || val != c->def.d_int32)
-				{ fprintf_conf(f, c->config_name, "%d\n", val); }
+					fprintf_conf(f, c->config_name, "%d\n", val);
 			continue;
 		}
-		case OPT_UINT32:
-		{
+			case OPT_UINT32: {
 			uint32_t val;
 			memcpy(&val, var, sizeof(uint32_t));
 			if(save_all || val != c->def.d_uint32)
-				{ fprintf_conf(f, c->config_name, "%u\n", val); }
+					fprintf_conf(f, c->config_name, "%u\n", val);
 			continue;
 		}
-		case OPT_STRING:
-		{
+			case OPT_STRING: {
 			char **val = var;
-			if(save_all || !streq(*val, c->def.d_char))
-			{
+				if (save_all || !streq(*val, c->def.d_char)) {
 				fprintf_conf(f, c->config_name, "%s\n", *val ? *val : "");
 			}
 			continue;
 		}
-		case OPT_SSTRING:
-		{
+			case OPT_SSTRING: {
 			char *val = var;
-			if(save_all || !streq(val, c->def.d_char))
-			{
+				if (save_all || !streq(val, c->def.d_char)) {
 				fprintf_conf(f, c->config_name, "%s\n", val[0] ? val : "");
 			}
 			continue;
 		}
-		case OPT_HEX_ARRAY:
-		{
+			case OPT_HEX_ARRAY: {
 			uint8_t *hex_array = var;
 			uint32_t ok = check_filled(hex_array, c->def.array_size);
-			if(save_all || ok)
-			{
+				if (save_all || ok) {
 				fprintf_conf(f, c->config_name, "%s", ""); // it should not have \n at the end
-				if(ok)
-				{
-					for(ok = 0; ok < c->def.array_size; ok++)
-					{
+					if (ok) {
+						for (ok = 0; ok < c->def.array_size; ok++) {
 						fprintf(f, "%02X", hex_array[ok]);
 					}
 				}
@@ -235,13 +224,26 @@
 			}
 			continue;
 		}
-		case OPT_FUNC:
-		{
+			// sky(!)
+			case OPT_HEX_BYTES: {
+				uint8_t *hex_array = var;
+				uint32_t ok = (hex_array && c->def.array_size) ? 1 : 0;
+				if (save_all || ok) {
+					fprintf_conf(f, c->config_name, "%s", ""); // it should not have \n at the end
+					if (ok) {
+						for (ok = 0; ok < c->def.array_size; ok++) {
+							fprintf(f, "%02X", hex_array[ok]);
+						}
+					}
+					fprintf(f, "\n");
+				}
+				continue;
+			}
+			case OPT_FUNC: {
 			c->ops.process_fn((const char *)c->config_name, NULL, var, f);
 			continue;
 		}
-		case OPT_FUNC_EXTRA:
-		{
+			case OPT_FUNC_EXTRA: {
 			c->ops.process_fn_extra((const char *)c->config_name, NULL, var, c->def.d_extra, f);
 			continue;
 		}
@@ -259,8 +261,7 @@
 	const struct config_list *c;
 	for(c = clist; c->opt_type != OPT_UNKNOWN; c++)
 	{
-		if(c->opt_type == OPT_SAVE_FUNC)
-		{
+		if (c->opt_type == OPT_SAVE_FUNC) {
 			return c->ops.should_save_fn(var);
 		}
 	}
@@ -272,8 +273,7 @@
 	const struct config_list *c;
 	for(c = clist; c->opt_type != OPT_UNKNOWN; c++)
 	{
-		if(c->opt_type == OPT_FIXUP_FUNC)
-		{
+		if (c->opt_type == OPT_FIXUP_FUNC) {
 			c->ops.fixup_fn(var);
 			break;
 		}
@@ -286,57 +286,48 @@
 	for(c = clist; c->opt_type != OPT_UNKNOWN; c++)
 	{
 		void *var = config_data + c->var_offset;
-		switch(c->opt_type)
-		{
-		case OPT_INT8:
-		{
+		switch (c->opt_type) {
+			case OPT_INT8: {
 			*(int8_t *)var = c->def.d_int8;
 			break;
 		}
-		case OPT_UINT8:
-		{
+			case OPT_UINT8: {
 			*(uint8_t *)var = c->def.d_uint8;
 			break;
 		}
-		case OPT_INT32:
-		{
+			case OPT_INT32: {
 			memcpy(var, &c->def.d_int32, sizeof(int32_t));
 			break;
 		}
-		case OPT_UINT32:
-		{
+			case OPT_UINT32: {
 			memcpy(var, &c->def.d_uint32, sizeof(uint32_t));
 			break;
 		}
-		case OPT_STRING:
-		{
+			case OPT_STRING: {
 			char **scfg = var;
 			NULLFREE(*scfg);
 			if(c->def.d_char)
-				{ *scfg = cs_strdup(c->def.d_char); }
+					*scfg = cs_strdup(c->def.d_char);
 			break;
 		}
-		case OPT_SSTRING:
-		{
+			case OPT_SSTRING: {
 			char *scfg = var;
 			scfg[0] = '\0';
 			if(c->def.d_char && strlen(c->def.d_char))
-				{ cs_strncpy(scfg, c->def.d_char, c->str_size); }
+					cs_strncpy(scfg, c->def.d_char, c->str_size);
 			break;
 		}
-		case OPT_HEX_ARRAY:
-		{
+			case OPT_HEX_BYTES:
+			case OPT_HEX_ARRAY: {
 			uint8_t *hex_array = var;
 			memset(hex_array, 0, c->def.array_size);
 			break;
 		}
-		case OPT_FUNC:
-		{
+			case OPT_FUNC: {
 			c->ops.process_fn((const char *)c->config_name, "", var, NULL);
 			break;
 		}
-		case OPT_FUNC_EXTRA:
-		{
+			case OPT_FUNC_EXTRA: {
 			c->ops.process_fn_extra((const char *)c->config_name, "", var, c->def.d_extra, NULL);
 			break;
 		}
@@ -355,13 +346,11 @@
 	for(c = clist; c->opt_type != OPT_UNKNOWN; c++)
 	{
 		void *var = config_data + c->var_offset;
-		if(c->opt_type == OPT_STRING)
-		{
+		if (c->opt_type == OPT_STRING) {
 			char **scfg = var;
 			NULLFREE(*scfg);
 		}
-		if(c->free_value && (c->opt_type == OPT_FUNC || c->opt_type == OPT_FUNC_EXTRA))
-		{
+		if (c->free_value && (c->opt_type == OPT_FUNC || c->opt_type == OPT_FUNC_EXTRA)) {
 			c->free_value(var);
 		}
 	}
@@ -374,8 +363,7 @@
 	for(c = clist; c->opt_type != OPT_UNKNOWN; c++)
 	{
 		void *var = config_data + c->var_offset;
-		if(c->opt_type == OPT_STRING)
-		{
+		if (c->opt_type == OPT_STRING) {
 			char **scfg = var;
 			add_garbage(*scfg);
 		}
@@ -386,9 +374,9 @@
 int config_section_is_active(const struct config_sections *sec)
 {
 	if(!sec)
-		{ return 0; }
+		return 0;
 	if(sec->config[0].opt_type == OPT_UNKNOWN)
-		{ return 0; }
+		return 0;
 	return 1;
 }
 
@@ -397,8 +385,7 @@
 	const struct config_sections *sec;
 	for(sec = conf; sec && sec->section; sec++)
 	{
-		if(streq(section_name, sec->section))
-		{
+		if (streq(section_name, sec->section)) {
 			return sec;
 		}
 	}
@@ -426,7 +413,7 @@
 	for(sec = conf; sec && sec->section; sec++)
 	{
 		if(config_section_is_active(sec))
-			{ config_list_set_defaults(sec->config, var); }
+			config_list_set_defaults(sec->config, var);
 	}
 }
 
@@ -435,8 +422,7 @@
 	const struct config_sections *sec;
 	for(sec = conf; sec && sec->section; sec++)
 	{
-		if(config_section_is_active(sec))
-		{
+		if (config_section_is_active(sec)) {
 			config_list_free_values(sec->config, var);
 		}
 	}
@@ -445,21 +431,17 @@
 void config_set_value(const struct config_sections *conf, char *section, const char *token, char *value, void *var)
 {
 	const struct config_sections *sec = config_find_section(conf, section);
-	if(!sec)
-	{
+	if (!sec) {
 		fprintf(stderr, "WARNING: Unknown section '%s'.\n", section);
 		return;
 	}
-	if(config_section_is_active(sec))
-	{
-		if(!config_list_parse(sec->config, token, value, var))
-		{
+	if (config_section_is_active(sec)) {
+		if (!config_list_parse(sec->config, token, value, var)) {
 			fprintf(stderr, "WARNING: In section [%s] unknown setting '%s=%s' tried.\n",
 					section, token, value);
 		}
 	}
-	else
-	{
+	else {
 		fprintf(stderr, "WARNING: Section is not active '%s'.\n", section);
 	}
 }
@@ -470,14 +452,12 @@
 	FILE *f = fopen(get_config_filename(filename, sizeof(filename), conf_filename), "r");
 	if(!f)
 	{
-		if(die_on_err)
-		{
+		if (die_on_err) {
 			fprintf(stderr, "ERROR: Cannot open file \"%s\" (errno=%d %s)", filename, errno, strerror(errno));
 			fprintf(stderr, "\n");
 			exit(1);
 		}
-		else
-		{
+		else {
 			cs_log_dbg(D_TRACE, "INFO: Cannot open file \"%s\" (errno=%d %s)", filename, errno, strerror(errno));
 		}
 		return NULL;
@@ -502,8 +482,7 @@
 	get_config_filename(temp_file, sizeof(temp_file), conf_filename);
 	strncat(temp_file, ".tmp", sizeof(temp_file) - strlen(temp_file) - 1);
 	FILE *f = fopen(temp_file, "w");
-	if(!f)
-	{
+	if (!f) {
 		cs_log("ERROR: Cannot create file \"%s\" (errno=%d %s)", temp_file, errno, strerror(errno));
 		return NULL;
 	}
@@ -523,5 +502,24 @@
 	strncat(tmp_file, ".tmp", sizeof(tmp_file) - strlen(tmp_file) - 1);
 	strncat(bak_file, ".bak", sizeof(bak_file) - strlen(bak_file) - 1);
 	fclose(f);
+//	return safe_overwrite_with_bak(dst_file, tmp_file, bak_file, 0);
 	return safe_overwrite_with_bak(dst_file, tmp_file, bak_file, cfg.http_overwrite_bak_file);
 }
+
+
+// sky(n)
+FILE *create_information_file(const char *information_filename)
+{
+	char information_file[256];
+	get_config_filename(information_file, sizeof(information_file), information_filename);
+	FILE *f = fopen(information_file, "w");
+	if (!f) {
+		cs_log("ERROR: Cannot create file \"%s\" (errno=%d %s)", information_file, errno, strerror(errno));
+		return NULL;
+	}
+	fprintf(f, "# %s generated automatically by Streamboard OSCAM %s SVN r%s\n",
+			information_filename, CS_VERSION, CS_SVN_VERSION);
+	setvbuf(f, NULL, _IOFBF, 16 * 1024);
+	return (f);
+}
+
Index: oscam-conf.h
===================================================================
--- oscam-conf.h	(revision 10670)
+++ oscam-conf.h	(working copy)
@@ -12,6 +12,7 @@
 	OPT_STRING,
 	OPT_SSTRING,
 	OPT_HEX_ARRAY,
+	OPT_HEX_BYTES,	// sky(n)
 	OPT_FUNC,
 	OPT_FUNC_EXTRA,
 	OPT_SAVE_FUNC,
@@ -98,6 +99,15 @@
 		.def.array_size	= __array_size \
 	}
 
+// sky()
+#define DEF_OPT_HEXA(__name, __var_ofs, __array_size) \
+	{ \
+		.opt_type		= OPT_HEX_BYTES, \
+		.config_name	= __name, \
+		.var_offset		= __var_ofs, \
+		.def.array_size= __array_size \
+	}
+
 #define DEF_OPT_FUNC(__name, __var_ofs, __process_fn, ...) \
 	{ \
 		.opt_type		= OPT_FUNC, \
@@ -169,5 +179,7 @@
 FILE *open_config_file_or_die(const char *conf_filename);
 FILE *create_config_file(const char *conf_filename);
 bool flush_config_file(FILE *f, const char *conf_filename);
+// sky(n)
+FILE *create_information_file(const char *information_filename);
 
 #endif
Index: oscam-config-account.c
===================================================================
--- oscam-config-account.c	(revision 10670)
+++ oscam-config-account.c	(working copy)
@@ -17,13 +17,12 @@
 static void account_tosleep_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	int32_t *tosleep = setting;
-	if(value)
-	{
+	if (value) {
 		*tosleep = strToIntVal(value, cfg.tosleep);
 		return;
 	}
 	if(*tosleep != cfg.tosleep || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%d\n", *tosleep); }
+		fprintf_conf(f, token, "%d\n", *tosleep);
 }
 
 
@@ -32,25 +31,24 @@
 static void account_c35_suppresscmd08_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	int8_t *c35_suppresscmd08 = setting;
-	if(value)
-	{
+	if (value) {
 		*c35_suppresscmd08 = (int8_t)strToIntVal(value, cfg.c35_suppresscmd08);
 		return;
 	}
 	if(*c35_suppresscmd08 != cfg.c35_suppresscmd08 || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%d\n", *c35_suppresscmd08); }
+		fprintf_conf(f, token, "%d\n", *c35_suppresscmd08);
 }
 
-/*static void account_umaxidle_fn(const char *token, char *value, void *setting, FILE *f)
+/*
+static void account_umaxidle_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	int32_t *umaxidle = setting;
-	if(value)
-	{
+	if (value) {
 		*umaxidle = (int32_t)strToIntVal(value, cfg.umaxidle);
 		return;
 	}
 	if(*umaxidle != cfg.umaxidle || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%u\n", *umaxidle); }
+		fprintf_conf(f, token, "%d\n", *umaxidle);
 }
 */
 
@@ -62,47 +60,47 @@
 #ifdef MODULE_NEWCAMD
 	def_value = cfg.ncd_keepalive;
 #endif
-	if(value)
-	{
+	if (value) {
 		*ncd_keepalive = (int8_t)strToIntVal(value, def_value);
 		return;
 	}
 	if(*ncd_keepalive != def_value || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%d\n", *ncd_keepalive); }
+		fprintf_conf(f, token, "%d\n", *ncd_keepalive);
 }
 
 static void account_allowedprotocols_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_auth *account = setting;
-	if(value)
-	{
+	if (value) {
 		account->allowedprotocols = 0;
-		if(strlen(value) > 3)
-		{
+		if (strlen(value) > 3) {
 			int i;
 			char *ptr, *saveptr1 = NULL;
 			for(i = 0, ptr = strtok_r(value, ",", &saveptr1); ptr; ptr = strtok_r(NULL, ",", &saveptr1), i++)
 			{
-				if(streq(ptr, "camd33"))   { account->allowedprotocols |= LIS_CAMD33TCP; }
-				else if(streq(ptr, "camd35"))   { account->allowedprotocols |= LIS_CAMD35UDP; }
-				else if(streq(ptr, "cs357x"))   { account->allowedprotocols |= LIS_CAMD35UDP; }
-				else if(streq(ptr, "cs378x"))   { account->allowedprotocols |= LIS_CAMD35TCP; }
-				else if(streq(ptr, "newcamd"))  { account->allowedprotocols |= LIS_NEWCAMD; }
-				else if(streq(ptr, "cccam"))    { account->allowedprotocols |= LIS_CCCAM; }
-				else if(streq(ptr, "csp"))      { account->allowedprotocols |= LIS_CSPUDP; }
-				else if(streq(ptr, "gbox"))     { account->allowedprotocols |= LIS_GBOX; }
-				else if(streq(ptr, "radegast")) { account->allowedprotocols |= LIS_RADEGAST; }
+				if		  (streq(ptr, "camd33"))   account->allowedprotocols |= LIS_CAMD33TCP;
+				else if (streq(ptr, "camd35"))   account->allowedprotocols |= LIS_CAMD35UDP;
+				else if (streq(ptr, "cs357x"))   account->allowedprotocols |= LIS_CAMD35UDP;
+				else if (streq(ptr, "cs378x"))   account->allowedprotocols |= LIS_CAMD35TCP;
+				else if (streq(ptr, "newcamd"))  account->allowedprotocols |= LIS_NEWCAMD;
+				else if (streq(ptr, "cccam"))    account->allowedprotocols |= LIS_CCCAM;
+				else if (streq(ptr, "csp"))      account->allowedprotocols |= LIS_CSPUDP;
+				else if (streq(ptr, "gbox"))     account->allowedprotocols |= LIS_GBOX;
+				else if (streq(ptr, "radegast")) account->allowedprotocols |= LIS_RADEGAST;
 				else if(streq(ptr, "scam"))     { account->allowedprotocols |= LIS_SCAM; }
+				// sky(n)
+				else if (streq(ptr, "xcamd")) 	account->allowedprotocols |= LIS_XCAMD;
+				else if (streq(ptr, "morecam")) 	account->allowedprotocols |= LIS_MORECAM;
+				else if (streq(ptr, "xcas")) 		account->allowedprotocols |= LIS_XCAS;
 				// these have no listener ports so it doesn't make sense
-				else if(streq(ptr, "dvbapi"))   { account->allowedprotocols |= LIS_DVBAPI; }
-				else if(streq(ptr, "constcw"))  { account->allowedprotocols |= LIS_CONSTCW; }
-				else if(streq(ptr, "serial"))   { account->allowedprotocols |= LIS_SERIAL; }
+				else if (streq(ptr, "dvbapi"))   account->allowedprotocols |= LIS_DVBAPI;
+				else if (streq(ptr, "constcw"))  account->allowedprotocols |= LIS_CONSTCW;
+				else if (streq(ptr, "serial"))   account->allowedprotocols |= LIS_SERIAL;
 			}
 		}
 		return;
 	}
-	if(account->allowedprotocols || cfg.http_full_cfg)
-	{
+	if (account->allowedprotocols || cfg.http_full_cfg ) {
 		value = mk_t_allowedprotocols(account);
 		fprintf_conf(f, token, "%s\n", value);
 		free_mk_t(value);
@@ -117,39 +115,33 @@
 		// set default values for usage during runtime from Webif
 		account->autoau = 0;
 		if(!account->aureader_list)
-			{ account->aureader_list = ll_create("aureader_list"); }
+			account->aureader_list = ll_create("aureader_list");
 		if(streq(value, "1"))
-			{ account->autoau = 1; }
+			account->autoau = 1;
 		ll_clear(account->aureader_list);
 		LL_ITER itr = ll_iter_create(configured_readers);
 		struct s_reader *rdr;
 		char *pch, *saveptr1 = NULL;
-		for(pch = strtok_r(value, ",", &saveptr1); pch != NULL; pch = strtok_r(NULL, ",", &saveptr1))
-		{
+		for (pch = strtok_r(value, ",", &saveptr1); pch != NULL; pch = strtok_r(NULL, ",", &saveptr1)) {
 			ll_iter_reset(&itr);
-			while((rdr = ll_iter_next(&itr)))
-			{
-				if(streq(rdr->label, pch) || account->autoau)
-				{
+			while ((rdr = ll_iter_next(&itr))) {
+				if (streq(rdr->label, pch) || account->autoau) {
 					ll_append(account->aureader_list, rdr);
 				}
 			}
 		}
 		return;
 	}
-	if(account->autoau == 1)
-	{
+	if (account->autoau == 1) {
 		fprintf_conf(f, token, "%d\n", account->autoau);
 	}
-	else if(account->aureader_list)
-	{
+	else if (account->aureader_list) {
 		value = mk_t_aureader(account);
 		if(strlen(value) > 0)
-			{ fprintf_conf(f, token, "%s\n", value); }
+			fprintf_conf(f, token, "%s\n", value);
 		free_mk_t(value);
 	}
-	else if(cfg.http_full_cfg)
-	{
+	else if (cfg.http_full_cfg) {
 		fprintf_conf(f, token, "%s\n", "");
 	}
 }
@@ -159,8 +151,7 @@
 	struct s_auth *account = setting;
 	if(value)
 	{
-		if(!value[0])
-		{
+		if (!value[0]) {
 			account->expirationdate = (time_t)NULL;
 			return;
 		}
@@ -168,19 +159,11 @@
 		struct tm cstime;
 		char *ptr1, *saveptr1 = NULL;
 		memset(&cstime, 0, sizeof(cstime));
-		for(i = 0, ptr1 = strtok_r(value, "-/", &saveptr1); i < 3 && ptr1; ptr1 = strtok_r(NULL, "-/", &saveptr1), i++)
-		{
-			switch(i)
-			{
-			case 0:
-				cstime.tm_year = atoi(ptr1) - 1900;
-				break;
-			case 1:
-				cstime.tm_mon  = atoi(ptr1) - 1;
-				break;
-			case 2:
-				cstime.tm_mday = atoi(ptr1);
-				break;
+		for (i = 0, ptr1 = strtok_r(value, "-/", &saveptr1); i < 3 && ptr1; ptr1 = strtok_r(NULL, "-/", &saveptr1), i++) {
+			switch (i) {
+				case 0: cstime.tm_year = atoi(ptr1) - 1900; break;
+				case 1: cstime.tm_mon  = atoi(ptr1) - 1;    break;
+				case 2: cstime.tm_mday = atoi(ptr1);        break;
 			}
 		}
 		cstime.tm_hour  = 23;
@@ -190,8 +173,7 @@
 		account->expirationdate = mktime(&cstime);
 		return;
 	}
-	if(account->expirationdate || cfg.http_full_cfg)
-	{
+	if (account->expirationdate || cfg.http_full_cfg) {
 		char buf[16];
 		struct tm timeinfo;
 		localtime_r(&account->expirationdate, &timeinfo);
@@ -207,29 +189,23 @@
 	{
 		account->allowedtimeframe[0] = 0;
 		account->allowedtimeframe[1] = 0;
-		if(strlen(value))
-		{
+		if (strlen(value)) {
 			int32_t allowed[4];
-			if(sscanf(value, "%2d:%2d-%2d:%2d", &allowed[0], &allowed[1], &allowed[2], &allowed[3]) == 4)
-			{
+			if (sscanf(value, "%2d:%2d-%2d:%2d", &allowed[0], &allowed[1], &allowed[2], &allowed[3]) == 4) {
 				account->allowedtimeframe[0] = allowed[0] * 60 + allowed[1];
 				account->allowedtimeframe[1] = allowed[2] * 60 + allowed[3];
-			}
-			else
-			{
+			} else {
 				fprintf(stderr, "WARNING: Value '%s' is not valid for allowedtimeframe (hh:mm-hh:mm)\n", value);
 			}
 		}
 		return;
 	}
-	if(account->allowedtimeframe[0] && account->allowedtimeframe[1])
-	{
+	if (account->allowedtimeframe[0] && account->allowedtimeframe[1]) {
 		fprintf_conf(f, token, "%02d:%02d-%02d:%02d\n",
 					 account->allowedtimeframe[0] / 60, account->allowedtimeframe[0] % 60,
 					 account->allowedtimeframe[1] / 60, account->allowedtimeframe[1] % 60);
 	}
-	else if(cfg.http_full_cfg)
-	{
+	else if (cfg.http_full_cfg) {
 		fprintf_conf(f, token, "%s\n", "");
 	}
 }
@@ -260,21 +236,18 @@
 void group_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	uint64_t *grp = setting;
-	if(value)
-	{
+	if (value) {
 		char *ptr1, *saveptr1 = NULL;
 		*grp = 0;
-		for(ptr1 = strtok_r(value, ",", &saveptr1); ptr1; ptr1 = strtok_r(NULL, ",", &saveptr1))
-		{
+		for (ptr1 = strtok_r(value, ",", &saveptr1); ptr1; ptr1 = strtok_r(NULL, ",", &saveptr1)) {
 			int32_t g;
 			g = atoi(ptr1);
 			if(g > 0 && g < 65)
-				{ *grp |= (((uint64_t)1) << (g - 1)); }
+				*grp |= (((uint64_t)1) << (g-1));
 		}
 		return;
 	}
-	if(*grp || cfg.http_full_cfg)
-	{
+	if (*grp || cfg.http_full_cfg) {
 		value = mk_t_group(*grp);
 		fprintf_conf(f, token, "%s\n", value);
 		free_mk_t(value);
@@ -284,30 +257,27 @@
 void services_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	SIDTABS *sidtabs = setting;
-	if(value)
-	{
+	if (value) {
 		strtolower(value);
 		chk_services(value, sidtabs);
 		return;
 	}
 	value = mk_t_service(sidtabs);
 	if(strlen(value) > 0 || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%s\n", value); }
+		fprintf_conf(f, token, "%s\n", value);
 	free_mk_t(value);
 }
 
 void class_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	CLASSTAB *cltab = setting;
-	if(value)
-	{
+	if (value) {
 		strtolower(value);
 		chk_cltab(value, cltab);
 		return;
 	}
 	value = mk_t_cltab(cltab);
-	if(strlen(value) > 0 || cfg.http_full_cfg)
-	{
+	if (strlen(value) > 0 || cfg.http_full_cfg) {
 		fprintf_conf(f, token, "%s\n", value);
 		free_mk_t(value);
 	}
@@ -330,8 +300,7 @@
 #define OFS(X) offsetof(struct s_auth, X)
 #define SIZEOF(X) sizeof(((struct s_auth *)0)->X)
 
-static const struct config_list account_opts[] =
-{
+static const struct config_list account_opts[] = {
 #ifdef CS_ANTICASC
 	DEF_OPT_FIXUP_FUNC(account_fixups_fn),
 #endif
@@ -402,13 +371,12 @@
 void chk_account(const char *token, char *value, struct s_auth *account)
 {
 	if(config_list_parse(account_opts, token, value, account))
-		{ return; }
+		return;
 	else if(token[0] != '#')
-		{ fprintf(stderr, "Warning: keyword '%s' in account section not recognized\n", token); }
+		fprintf(stderr, "Warning: keyword '%s' in account section not recognized\n", token);
 }
 
-void account_set_defaults(struct s_auth *account)
-{
+void account_set_defaults(struct s_auth *account) {
 	config_list_set_defaults(account_opts, account);
 }
 
@@ -416,7 +384,7 @@
 {
 	FILE *fp = open_config_file(cs_user);
 	if(!fp)
-		{ return NULL; }
+		return NULL;
 
 	struct s_auth *authptr = NULL;
 	int32_t tag = 0, nr = 0, expired = 0, disabled = 0;
@@ -424,25 +392,23 @@
 	struct s_auth *account = NULL;
 	struct s_auth *probe = NULL;
 	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return NULL; }
+		return NULL;
 
-	while(fgets(token, MAXLINESIZE, fp))
-	{
+	while (fgets(token, MAXLINESIZE, fp)) {
 		int32_t l;
 		void *ptr;
 
 		if((l = strlen(trim(token))) < 3)
-			{ continue; }
-		if(token[0] == '[' && token[l - 1] == ']')
-		{
+			continue;
+		if (token[0] == '[' && token[l-1] == ']') {
 			token[l - 1] = 0;
 			tag = streq("account", strtolower(token + 1));
 			if(!cs_malloc(&ptr, sizeof(struct s_auth)))
-				{ break; }
+				break;
 			if(account)
-				{ account->next = ptr; }
+				account->next = ptr;
 			else
-				{ authptr = ptr; }
+				authptr = ptr;
 
 			account = ptr;
 			account_set_defaults(account);
@@ -452,20 +418,17 @@
 		}
 
 		if(!tag)
-			{ continue; }
+			continue;
 		char *value = strchr(token, '=');
 		if(!value)
-			{ continue; }
+			continue;
 
 		*value++ = '\0';
 
 		// check for duplicate useraccounts and make the name unique
-		if(streq(trim(strtolower(token)), "user"))
-		{
-			for(probe = authptr; probe; probe = probe->next)
-			{
-				if(!strcmp(probe->usr, trim(value)))
-				{
+		if (streq(trim(strtolower(token)), "user")) {
+			for (probe = authptr; probe; probe = probe->next) {
+				if (!strcmp(probe->usr, trim(value))) {
 					fprintf(stderr, "Warning: duplicate account '%s'\n", value);
 					strncat(value, "_x", sizeof(probe->usr) - strlen(value) - 1);
 				}
@@ -476,12 +439,11 @@
 	NULLFREE(token);
 	fclose(fp);
 
-	for(account = authptr; account; account = account->next)
-	{
+	for (account = authptr; account; account = account->next) {
 		if(account->expirationdate && account->expirationdate < time(NULL))
-			{ ++expired; }
+			++expired;
 		if(account->disabled)
-			{ ++disabled; }
+			++disabled;
 	}
 	cs_log("userdb reloaded: %d accounts loaded, %d expired, %d disabled", nr, expired, disabled);
 	return authptr;
@@ -490,8 +452,7 @@
 int32_t init_free_userdb(struct s_auth *ptr)
 {
 	int32_t nro;
-	for(nro = 0; ptr; nro++)
-	{
+	for (nro = 0; ptr; nro++) {
 		struct s_auth *ptr_next;
 		ptr_next = ptr->next;
 		ll_destroy(&ptr->aureader_list);
@@ -516,9 +477,8 @@
 	struct s_auth *account;
 	FILE *f = create_config_file(cs_user);
 	if(!f)
-		{ return 1; }
-	for(account = cfg.account; account; account = account->next)
-	{
+		return 1;
+	for (account = cfg.account; account; account = account->next) {
 		fprintf(f, "[account]\n");
 		config_list_apply_fixups(account_opts, account);
 		config_list_save(f, account_opts, account, cfg.http_full_cfg);
@@ -531,14 +491,12 @@
 {
 	struct s_auth *account1, *account2;
 	struct s_auth *new_accounts = init_userdb();
+
 	cs_writelock(&config_lock);
 	struct s_auth *old_accounts = cfg.account;
-	for(account1 = cfg.account; account1; account1 = account1->next)
-	{
-		for(account2 = new_accounts; account2; account2 = account2->next)
-		{
-			if(!strcmp(account1->usr, account2->usr))
-			{
+	for (account1 = cfg.account; account1; account1 = account1->next) {
+		for (account2 = new_accounts; account2; account2 = account2->next) {
+			if (!strcmp(account1->usr, account2->usr)) {
 				account2->cwfound    = account1->cwfound;
 				account2->cwcache    = account1->cwcache;
 				account2->cwnot      = account1->cwnot;
Index: oscam-config-global.c
===================================================================
--- oscam-config-global.c	(revision 10670)
+++ oscam-config-global.c	(working copy)
@@ -14,17 +14,16 @@
 #define cs_conf "oscam.conf"
 
 #define DEFAULT_HTTP_PORT   8888
-#define DEFAULT_HTTP_ALLOW  "127.0.0.1,192.168.0.0-192.168.255.255,10.0.0.0-10.255.255.255,::1"
+#define DEFAULT_HTTP_ALLOW	"127.0.0.1,10.0.0.0-10.255.255.255,192.168.0.0-192.168.255.255,172.16.0.0-172.31.255.255"
 
 static void disablelog_fn(const char *token, char *value, void *UNUSED(setting), FILE *f)
 {
-	if(value)
-	{
+	if (value) {
 		cs_disable_log(strToIntVal(value, 0));
 		return;
 	}
 	if(cfg.disablelog || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%d\n", cfg.disablelog); }
+		fprintf_conf(f, token, "%d\n", cfg.disablelog);
 }
 
 #if defined(WEBIF) || defined(MODULE_MONITOR)
@@ -32,17 +31,18 @@
 {
 	if(value)
 	{
-		uint32_t newsize = strToUIntVal(value, 4096);
-		if(newsize < 1024 && newsize != 0)
-		{
+		// sky()
+		uint32_t newsize = strToUIntVal(value, DEFAULT_LOGHISTORYSIZE);
+		if (newsize > DEFAULT_MAXLOGHISTORYSIZE) newsize = DEFAULT_LOGHISTORYSIZE;
+		if (newsize < DEFAULT_MINLOGHISTORYSIZE && newsize != 0) {
 			fprintf(stderr, "WARNING: loghistorysize is too small, adjusted to 1024\n");
-			newsize = 1024;
+			newsize  = DEFAULT_MINLOGHISTORYSIZE;
 		}
 		cs_reinit_loghist(newsize);
 		return;
 	}
-	if(cfg.loghistorysize != 4096 || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%u\n", cfg.loghistorysize); }
+	if (cfg.loghistorysize != DEFAULT_LOGHISTORYSIZE || cfg.http_full_cfg)
+		fprintf_conf(f, token, "%u\n", cfg.loghistorysize);
 }
 #endif
 
@@ -51,18 +51,16 @@
 	IN_ADDR_T srvip = *(IN_ADDR_T *)setting;
 	if(value)
 	{
-		if(strlen(value) == 0)
-		{
+		if (strlen(value) == 0) {
 			set_null_ip((IN_ADDR_T *)setting);
 		}
-		else
-		{
+		else {
 			cs_inet_addr(value, (IN_ADDR_T *)setting);
 		}
 		return;
 	}
 	if(IP_ISSET(srvip) || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%s\n", cs_inet_ntoa(srvip)); }
+		fprintf_conf(f, token, "%s\n", cs_inet_ntoa(srvip));
 }
 
 void iprange_fn(const char *token, char *value, void *setting, FILE *f)
@@ -70,19 +68,17 @@
 	struct s_ip **ip = setting;
 	if(value)
 	{
-		if(strlen(value) == 0)
-		{
+		if (strlen(value) == 0) {
 			clear_sip(ip);
 		}
-		else
-		{
+		else {
 			chk_iprange(value, ip);
 		}
 		return;
 	}
 	value = mk_t_iprange(*ip);
 	if(strlen(value) > 0 || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%s\n", value); }
+		fprintf_conf(f, token, "%s\n", value);
 	free_mk_t(value);
 }
 
@@ -105,25 +101,22 @@
 			for(pch = strtok_r(value, ";", &saveptr1); pch != NULL; pch = strtok_r(NULL, ";", &saveptr1))
 			{
 				pch = trim(pch);
-				if(!strcmp(pch, "stdout")) { cfg.logtostdout = 1; }
-				else if(!strcmp(pch, "syslog")) { cfg.logtosyslog = 1; }
-				else
-				{
+				if (!strcmp(pch, "stdout")) cfg.logtostdout = 1;
+				else if (!strcmp(pch, "syslog")) cfg.logtosyslog = 1;
+				else {
 					NULLFREE(cfg.logfile);
 					if(!(cfg.logfile = cs_strdup(pch)))
-						{ continue; }
+						continue;
 				}
 			}
 		}
-		else
-		{
+		else {
 			if(!(cfg.logfile = cs_strdup(CS_LOGFILE)))
-				{ cfg.logtostdout = 1; }
+				cfg.logtostdout = 1;
 		}
 		return;
 	}
-	if(cfg.logfile || cfg.logtostdout == 1 || cfg.logtosyslog == 1 || cfg.http_full_cfg)
-	{
+	if (cfg.logfile || cfg.logtostdout == 1 || cfg.logtosyslog == 1 || cfg.http_full_cfg) {
 		value = mk_t_logfile();
 		fprintf_conf(f, token, "%s\n", value);
 		free_mk_t(value);
@@ -257,7 +250,7 @@
 	if(!cfg.mailfile) { cfg.disablemail = 1; }
 	if(cfg.ctimeout < 10) { cfg.ctimeout = cfg.ctimeout * 100; } // save always in ms
 
-	if(cfg.nice < -20 || cfg.nice > 20) { cfg.nice = 99; }
+	if (cfg.nice < -20 || cfg.nice > 20) cfg.nice = 99;
 	if(cfg.nice != 99)
 	{
 #ifndef __CYGWIN__
@@ -265,37 +258,27 @@
 #else
 		HANDLE WinId;
 		uint32_t wprio;
-		switch((cfg.nice + 20) / 10)
-		{
-		case  0:
-			wprio = REALTIME_PRIORITY_CLASS;
-			break;
-		case  1:
-			wprio = HIGH_PRIORITY_CLASS;
-			break;
-		case  2:
-			wprio = NORMAL_PRIORITY_CLASS;
-			break;
-		default:
-			wprio = IDLE_PRIORITY_CLASS;
-			break;
+		switch ((cfg.nice + 20) / 10) {
+		case  0: wprio = REALTIME_PRIORITY_CLASS; break;
+		case  1: wprio = HIGH_PRIORITY_CLASS;     break;
+		case  2: wprio = NORMAL_PRIORITY_CLASS;   break;
+		default: wprio = IDLE_PRIORITY_CLASS;     break;
 		}
 		WinId = GetCurrentProcess();
 		SetPriorityClass(WinId, wprio);
 #endif
 	}
-	if(cfg.max_log_size != 0 && cfg.max_log_size <= 10) { cfg.max_log_size = 10; }
+	if (cfg.max_log_size != 0 && cfg.max_log_size <= 10) cfg.max_log_size = 10;
 #ifdef WITH_LB
-	if(cfg.lb_save > 0 && cfg.lb_save < 100) { cfg.lb_save = 100; }
-	if(cfg.lb_nbest_readers < 2) { cfg.lb_nbest_readers = DEFAULT_NBEST; }
+	if (cfg.lb_save > 0 && cfg.lb_save < 100) cfg.lb_save = 100;
+	if (cfg.lb_nbest_readers < 2) cfg.lb_nbest_readers = DEFAULT_NBEST;
 #endif
 }
 
 #define OFS(X) offsetof(struct s_config, X)
 #define SIZEOF(X) sizeof(((struct s_config *)0)->X)
 
-static const struct config_list global_opts[] =
-{
+static const struct config_list global_opts[] = {
 	DEF_OPT_FIXUP_FUNC(global_fixups_fn),
 #ifdef LEDSUPPORT
 	DEF_OPT_INT8("enableled"                , OFS(enableled),           0),
@@ -307,6 +290,9 @@
 	DEF_OPT_FUNC("serverip"                 , OFS(srvip),               serverip_fn),
 	DEF_OPT_FUNC("logfile"                  , OFS(logfile),             logfile_fn),
 	DEF_OPT_INT8("logduplicatelines"        , OFS(logduplicatelines),   0),
+#ifdef __LOG_SERVERSECRETE__
+	DEF_OPT_INT32("logsvrsecrete"			, OFS(logsvrsecrete),		1 ),	// sky(a)
+#endif
 	DEF_OPT_STR("pidfile"                   , OFS(pidfile),             NULL),
 	DEF_OPT_INT8("disableuserfile"          , OFS(disableuserfile),     1),
 	DEF_OPT_INT8("disablemail"              , OFS(disablemail),         1),
@@ -388,8 +374,7 @@
 	return cfg.ac_enabled || cfg.acosc_enabled;
 }
 
-static const struct config_list anticasc_opts[] =
-{
+static const struct config_list anticasc_opts[] = {
 	DEF_OPT_SAVE_FUNC(anticasc_should_save_fn),
 	DEF_OPT_FIXUP_FUNC(anticasc_fixups_fn),
 	DEF_OPT_INT8("enabled"			, OFS(ac_enabled),		0),
@@ -418,8 +403,7 @@
 	return cfg.mon_port;
 }
 
-static const struct config_list monitor_opts[] =
-{
+static const struct config_list monitor_opts[] = {
 	DEF_OPT_SAVE_FUNC(monitor_should_save_fn),
 	DEF_OPT_INT32("port"		, OFS(mon_port),	0),
 	DEF_OPT_FUNC("serverip"		, OFS(mon_srvip),	serverip_fn),
@@ -441,20 +425,16 @@
 		cfg.http_port = 0;
 		if(value[0])
 		{
-			if(value[0] == '+')
-			{
-				if(config_enabled(WITH_SSL))
-				{
+			if (value[0] == '+') {
+				if (config_enabled(WITH_SSL)) {
 					cfg.http_use_ssl = 1;
 				}
-				else
-				{
+				else {
 					fprintf(stderr, "Warning: OSCam compiled without SSL support.\n");
 				}
 				cfg.http_port = strtoul(value + 1, NULL, 10);
 			}
-			else
-			{
+			else {
 				cfg.http_port = strtoul(value, NULL, 10);
 			}
 		}
@@ -470,8 +450,7 @@
 	{
 		char *ptr, *saveptr1 = NULL;
 		memset(cfg.http_dyndns, 0, sizeof(cfg.http_dyndns));
-		for(i = 0, ptr = strtok_r(value, ",", &saveptr1); (i < MAX_HTTP_DYNDNS) && (ptr); ptr = strtok_r(NULL, ",", &saveptr1), i++)
-		{
+		for (i = 0, ptr = strtok_r(value, ",", &saveptr1); (i < MAX_HTTP_DYNDNS) && (ptr); ptr = strtok_r(NULL, ",", &saveptr1), i++) {
 			trim(ptr);
 			cs_strncpy((char *)cfg.http_dyndns[i], ptr, sizeof(cfg.http_dyndns[i]));
 		}
@@ -480,10 +459,8 @@
 	if(strlen((const char *)(cfg.http_dyndns[0])) > 0 || cfg.http_full_cfg)
 	{
 		fprintf_conf(f, token, "%s", ""); // it should not have \n at the end
-		for(i = 0; i < MAX_HTTP_DYNDNS; i++)
-		{
-			if(cfg.http_dyndns[i][0])
-			{
+		for (i = 0; i < MAX_HTTP_DYNDNS; i++) {
+			if (cfg.http_dyndns[i][0]) {
 				fprintf(f, "%s%s", i > 0 ? "," : "", cfg.http_dyndns[i]);
 			}
 		}
@@ -496,8 +473,7 @@
 	return cfg.http_port;
 }
 
-static const struct config_list webif_opts[] =
-{
+static const struct config_list webif_opts[] = {
 	DEF_OPT_SAVE_FUNC(webif_should_save_fn),
 	DEF_OPT_FUNC("httpport"                 , OFS(http_port),               http_port_fn),
 	DEF_OPT_FUNC("serverip"                 , OFS(http_srvip),              serverip_fn),
@@ -531,7 +507,7 @@
 	DEF_OPT_FUNC("httpdyndns"               , OFS(http_dyndns),             http_dyndns_fn),
 	DEF_OPT_INT32("aulow"                   , OFS(aulow),                   30),
 	DEF_OPT_INT32("hideclient_to"           , OFS(hideclient_to),           25),
-	DEF_OPT_STR("httposcamlabel"            , OFS(http_oscam_label),        "OSCam"),
+	DEF_OPT_STR("httposcamlabel"      	, OFS(http_oscam_label), 	"oscam.sky"),
 	DEF_OPT_INT32("httpemmuclean"           , OFS(http_emmu_clean),         256),
 	DEF_OPT_INT32("httpemmsclean"           , OFS(http_emms_clean),         -1),
 	DEF_OPT_INT32("httpemmgclean"           , OFS(http_emmg_clean),         -1),
@@ -555,8 +531,7 @@
 	return cfg.c33_port;
 }
 
-static const struct config_list camd33_opts[] =
-{
+static const struct config_list camd33_opts[] = {
 	DEF_OPT_SAVE_FUNC(camd33_should_save_fn),
 	DEF_OPT_INT32("port"	, OFS(c33_port),	0),
 	DEF_OPT_FUNC("serverip"	, OFS(c33_srvip),	serverip_fn),
@@ -572,12 +547,12 @@
 
 void cache_fixups_fn(void *UNUSED(var))
 {
-	if(cfg.max_cache_time < ((int32_t)(cfg.ctimeout + 500) / 1000 + 3)) { cfg.max_cache_time = ((cfg.ctimeout + 500) / 1000 + 3); }
+	if (cfg.max_cache_time < ((int32_t)(cfg.ctimeout+500)/1000+3)) cfg.max_cache_time = ((cfg.ctimeout+500)/1000+3);
 #ifdef CW_CYCLE_CHECK
-	if(cfg.maxcyclelist > 4000) { cfg.maxcyclelist = 4000; }
-	if(cfg.keepcycletime > 240) { cfg.keepcycletime = 240; }
-	if(cfg.cwcycle_sensitive > 4) { cfg.cwcycle_sensitive = 4; }
-	if(cfg.cwcycle_sensitive == 1) { cfg.cwcycle_sensitive = 2; }
+	if (cfg.maxcyclelist > 4000) cfg.maxcyclelist  = 4000;
+	if (cfg.keepcycletime > 240) cfg.keepcycletime = 240;
+	if (cfg.cwcycle_sensitive  > 4) cfg.cwcycle_sensitive = 4;
+	if (cfg.cwcycle_sensitive == 1) cfg.cwcycle_sensitive = 2;
 #endif
 }
 
@@ -593,8 +568,7 @@
 		   ;
 }
 
-static const struct config_list cache_opts[] =
-{
+static const struct config_list cache_opts[] = {
 	DEF_OPT_SAVE_FUNC(cache_should_save_fn),
 	DEF_OPT_FIXUP_FUNC(cache_fixups_fn),
 	DEF_OPT_UINT32("delay"			, OFS(delay),			CS_DELAY),
@@ -632,8 +606,7 @@
 	return cfg.c35_port;
 }
 
-static const struct config_list camd35_opts[] =
-{
+static const struct config_list camd35_opts[] = {
 	DEF_OPT_SAVE_FUNC(camd35_should_save_fn),
 	DEF_OPT_INT32("port"		, OFS(c35_port),		0),
 	DEF_OPT_FUNC("serverip"		, OFS(c35_srvip),		serverip_fn),
@@ -652,12 +625,10 @@
 	PTAB *ptab = setting;
 	if(value)
 	{
-		if(strlen(value) == 0)
-		{
+		if (strlen(value) == 0) {
 			clear_ptab(ptab);
 		}
-		else
-		{
+		else {
 			chk_port_tab(value, ptab);
 		}
 		return;
@@ -679,8 +650,7 @@
 	return cfg.c35_tcp_ptab.nports && cfg.c35_tcp_ptab.ports[0].s_port;
 }
 
-static const struct config_list cs378x_opts[] =
-{
+static const struct config_list cs378x_opts[] = {
 	DEF_OPT_SAVE_FUNC(cs378x_should_save_fn),
 	DEF_OPT_FUNC_X("port"		, OFS(c35_tcp_ptab),		porttab_fn, PORTTAB_CS378X, .free_value = porttab_free_fn),
 	DEF_OPT_FUNC("serverip"		, OFS(c35_tcp_srvip),		serverip_fn),
@@ -697,8 +667,7 @@
 	return cfg.ncd_ptab.nports && cfg.ncd_ptab.ports[0].s_port;
 }
 
-static const struct config_list newcamd_opts[] =
-{
+static const struct config_list newcamd_opts[] = {
 	DEF_OPT_SAVE_FUNC(newcamd_should_save_fn),
 	DEF_OPT_FUNC_X("port"		, OFS(ncd_ptab),	porttab_fn, PORTTAB_NEWCAMD, .free_value = porttab_free_fn),
 	DEF_OPT_FUNC("serverip"		, OFS(ncd_srvip),	serverip_fn),
@@ -724,7 +693,7 @@
 		{
 			cfg.cc_port[i] = strtoul(ptr, NULL, 10);
 			if(cfg.cc_port[i])
-				{ i++; }
+				i++;
 		}
 		return;
 	}
@@ -738,8 +707,7 @@
 	return cfg.cc_port[0];
 }
 
-static const struct config_list cccam_opts[] =
-{
+static const struct config_list cccam_opts[] = {
 	DEF_OPT_SAVE_FUNC(cccam_should_save_fn),
 	DEF_OPT_FUNC("port"			, OFS(cc_port),			cccam_port_fn),
 	DEF_OPT_FUNC("serverip"			, OFS(cc_srvip),		serverip_fn),
@@ -766,8 +734,7 @@
 	return cfg.pand_port;
 }
 
-static const struct config_list pandora_opts[] =
-{
+static const struct config_list pandora_opts[] = {
 	DEF_OPT_SAVE_FUNC(pandora_should_save_fn),
 	DEF_OPT_INT32("pand_port"		, OFS(pand_port),		0),
 	DEF_OPT_FUNC("pand_srvid"		, OFS(pand_srvip),		serverip_fn),
@@ -804,8 +773,7 @@
 	return cfg.rad_port;
 }
 
-static const struct config_list radegast_opts[] =
-{
+static const struct config_list radegast_opts[] = {
 	DEF_OPT_SAVE_FUNC(radegast_should_save_fn),
 	DEF_OPT_INT32("port"	, OFS(rad_port),	0),
 	DEF_OPT_FUNC("serverip"	, OFS(rad_srvip),	serverip_fn),
@@ -823,8 +791,7 @@
 	return cfg.ser_device != NULL;
 }
 
-static const struct config_list serial_opts[] =
-{
+static const struct config_list serial_opts[] = {
 	DEF_OPT_SAVE_FUNC(serial_should_save_fn),
 	DEF_OPT_STR("device"	, OFS(ser_device),	NULL),
 	DEF_LAST_OPT
@@ -906,7 +873,7 @@
 #endif
 
 #ifdef HAVE_DVBAPI
-extern const char *boxdesc[];
+extern const char *boxtype_desc[];
 
 static void dvbapi_boxtype_fn(const char *token, char *value, void *UNUSED(setting), FILE *f)
 {
@@ -916,68 +883,64 @@
 		cfg.dvbapi_boxtype = 0;
 		for(i = 1; i <= BOXTYPES; i++)
 		{
-			if(streq(value, boxdesc[i]))
-			{
+			if (streq(value, boxtype_desc[i])) {
 				cfg.dvbapi_boxtype = i;
 				break;
 			}
 		}
 		return;
 	}
-	if(cfg.dvbapi_boxtype)
-		{ fprintf_conf(f, token, "%s\n", boxdesc[cfg.dvbapi_boxtype]); }
+	if (cfg.dvbapi_boxtype) {
+		fprintf_conf(f, token, "%s\n", boxtype_desc[cfg.dvbapi_boxtype]);
+	}
 }
 
 static void dvbapi_services_fn(const char *UNUSED(token), char *value, void *UNUSED(setting), FILE *UNUSED(f))
 {
 	if(value)
-		{ chk_services(value, &cfg.dvbapi_sidtabs); }
+		chk_services(value, &cfg.dvbapi_sidtabs);
 	// THIS OPTION IS NOT SAVED
 }
 
-extern struct s_dvbapi_priority *dvbapi_priority;
+extern struct s_dvbapi_priority *dvbApi_priority;
 
 static void dvbapi_caidtab_fn(const char *UNUSED(token), char *caidasc, void *UNUSED(setting), long cmd, FILE *UNUSED(f))
 {
 	char *ptr1, *ptr3, *saveptr1 = NULL;
 	if(!caidasc)
-		{ return; }
+		return;
 	char type = (char)cmd;
 	for(ptr1 = strtok_r(caidasc, ",", &saveptr1); (ptr1); ptr1 = strtok_r(NULL, ",", &saveptr1))
 	{
 		uint32_t caid, prov;
 		if((ptr3 = strchr(trim(ptr1), ':')))
-			{ * ptr3++ = '\0'; }
+			*ptr3++ = '\0';
 		else
-			{ ptr3 = ""; }
+			ptr3 = "";
 		if(((caid = a2i(ptr1, 2)) | (prov = a2i(ptr3, 3))))
 		{
 			struct s_dvbapi_priority *entry;
 			if(!cs_malloc(&entry, sizeof(struct s_dvbapi_priority)))
-				{ return; }
+				return;
 			entry->caid = caid;
-			if(type == 'd')
-			{
+			if (type == 'd') {
 				char tmp1[5];
 				snprintf(tmp1, sizeof(tmp1), "%04X", (uint)prov);
 				int32_t cw_delay = strtol(tmp1, NULL, 10);
 				entry->delay = cw_delay;
 			}
-			else
-			{
+			else {
 				entry->provid = prov;
 			}
 			entry->type = type;
 			entry->next = NULL;
-			if(!dvbapi_priority)
-			{
-				dvbapi_priority = entry;
+			if (!dvbApi_priority) {
+				dvbApi_priority = entry;
 			}
-			else
-			{
+			else {
 				struct s_dvbapi_priority *p;
-				for(p = dvbapi_priority; p->next != NULL; p = p->next)
-					{ ; }
+				for (p = dvbApi_priority; p->next != NULL; p = p->next)
+					;
 				p->next = entry;
 			}
 		}
@@ -990,12 +953,11 @@
 	return cfg.dvbapi_enabled;
 }
 
-static const struct config_list dvbapi_opts[] =
-{
+static const struct config_list dvbapi_opts[] = {
 	DEF_OPT_SAVE_FUNC(dvbapi_should_save_fn),
-	DEF_OPT_INT8("enabled"		, OFS(dvbapi_enabled),		0),
+	DEF_OPT_INT8("enabled"					, OFS(dvbapi_enabled),		DEFAULT_DVBAPI ),
 	DEF_OPT_INT8("au"		, OFS(dvbapi_au),		0),
-	DEF_OPT_INT8("pmt_mode"		, OFS(dvbapi_pmtmode),		0),
+	DEF_OPT_INT8("pmt_mode"					, OFS(dvbapi_pmtmode),		1 ),
 	DEF_OPT_INT8("request_mode"	, OFS(dvbapi_requestmode),	0),
 	DEF_OPT_INT32("listen_port"	, OFS(dvbapi_listenport),	0),
 	DEF_OPT_INT32("delayer"		, OFS(dvbapi_delayer),		0),
@@ -1015,7 +977,7 @@
 #ifdef LCDSUPPORT
 static void lcd_fixups_fn(void *UNUSED(var))
 {
-	if(cfg.lcd_write_intervall < 5) { cfg.lcd_write_intervall = 5; }
+	if (cfg.lcd_write_intervall < 5) cfg.lcd_write_intervall = 5;
 }
 
 static bool lcd_should_save_fn(void *UNUSED(var))
@@ -1023,8 +985,7 @@
 	return cfg.enablelcd;
 }
 
-static const struct config_list lcd_opts[] =
-{
+static const struct config_list lcd_opts[] = {
 	DEF_OPT_SAVE_FUNC(lcd_should_save_fn),
 	DEF_OPT_FIXUP_FUNC(lcd_fixups_fn),
 	DEF_OPT_INT8("enablelcd"		, OFS(enablelcd),		0),
@@ -1037,8 +998,7 @@
 static const struct config_list lcd_opts[] = { DEF_LAST_OPT };
 #endif
 
-static const struct config_sections oscam_conf[] =
-{
+static const struct config_sections oscam_conf[] = {
 	{ "global",	global_opts }, // *** MUST BE FIRST ***
 	{ "anticasc",	anticasc_opts },
 	{ "cache",	cache_opts },
@@ -1086,12 +1046,10 @@
 {
 	FILE *fp;
 
-	if(config_enabled(WEBIF))
-	{
+	if (config_enabled(WEBIF)) {
 		fp = open_config_file(cs_conf);
 	}
-	else
-	{
+	else {
 		fp = open_config_file_or_die(cs_conf);
 	}
 
@@ -1117,11 +1075,17 @@
 #ifdef HAVE_DVBAPI
 		cfg.dvbapi_enabled = 1;
 #endif
+#ifdef WITH_HISILICON
+		// Always
+		cfg.dvbapi_enabled = 1;
+		cfg.dvbapi_pmtmode = 1;
+		cfg.dvbapi_boxtype = BOXTYPE_HISILICON;
+#endif
 		return 0;
 	}
 
 	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return 1; }
+		return 1;
 
 	int line = 0;
 	int valid_section = 1;
@@ -1130,50 +1094,63 @@
 		++line;
 		int len = strlen(trim(token));
 		if(len < 3)  // a=b or [a] are at least 3 chars
-			{ continue; }
+			continue;
 		if(token[0] == '#')  // Skip comments
-			{ continue; }
+			continue;
 		if(token[0] == '[' && token[len - 1] == ']')
 		{
 			token[len - 1] = '\0';
 			valid_section = 0;
 			const struct config_sections *newconf = config_find_section(oscam_conf, token + 1);
-			if(config_section_is_active(newconf) && cur_section)
-			{
+			if (config_section_is_active(newconf) && cur_section) {
 				config_list_apply_fixups(cur_section->config, &cfg);
 				cur_section = newconf;
 				valid_section = 1;
 			}
-			if(!newconf)
-			{
+			if (!newconf) {
 				fprintf(stderr, "WARNING: %s line %d unknown section [%s].\n",
 						cs_conf, line, token + 1);
 				continue;
 			}
-			if(!config_section_is_active(newconf))
-			{
+			if (!config_section_is_active(newconf)) {
 				fprintf(stderr, "WARNING: %s line %d section [%s] is ignored (support not compiled in).\n",
 						cs_conf, line, newconf->section);
 			}
 			continue;
 		}
 		if(!valid_section)
-			{ continue; }
+			continue;
 		char *value = strchr(token, '=');
 		if(!value)  // No = found, well go on
-			{ continue; }
+			continue;
 		*value++ = '\0';
 		char *tvalue = trim(value);
 		char *ttoken = trim(strtolower(token));
-		if(cur_section && !config_list_parse(cur_section->config, ttoken, tvalue, &cfg))
-		{
+		if (cur_section && !config_list_parse(cur_section->config, ttoken, tvalue, &cfg)) {
 			fprintf(stderr, "WARNING: %s line %d section [%s] contains unknown setting '%s=%s'\n",
 					cs_conf, line, cur_section->section, ttoken, tvalue);
 		}
 	}
 	NULLFREE(token);
 	fclose(fp);
-	if(cur_section) { config_list_apply_fixups(cur_section->config, &cfg); }
+// sky(a)
+#ifdef WEBIF
+	if (!cfg.http_port || !cfg.http_allowed) {
+		cfg.http_port = DEFAULT_HTTP_PORT;
+		chk_iprange(cs_strdup(DEFAULT_HTTP_ALLOW), &cfg.http_allowed);
+	}
+#endif
+
+#ifdef WITH_HISILICON
+	// Always
+	cfg.dvbapi_enabled = 1;
+	cfg.dvbapi_pmtmode = 1;
+	cfg.dvbapi_boxtype = BOXTYPE_HISILICON;
+#endif
+#if (__ADB_TRACE__)
+	cfg.logsvrsecrete  = 0;
+#endif
+	if (cur_section) config_list_apply_fixups(cur_section->config, &cfg);
 	return 0;
 }
 
@@ -1181,7 +1158,7 @@
 {
 	FILE *f = create_config_file(cs_conf);
 	if(!f)
-		{ return 1; }
+		return 1;
 	config_sections_save(oscam_conf, f, &cfg);
 	return flush_config_file(f, cs_conf);
 }
Index: oscam-config-reader.c
===================================================================
--- oscam-config-reader.c	(revision 10670)
+++ oscam-config-reader.c	(working copy)
@@ -84,29 +84,54 @@
 	struct s_reader *rdr = setting;
 	if(value)
 	{
-		if(strlen(value) == 0)
-			{ return; }
-		struct protocol_map
-		{
+		if (strlen(value) == 0) return;
+
+		struct protocol_map {
 			char *name;
 			int typ;
-		} protocols[] =
-		{
+		} protocols[] = {
+		#ifdef MODULE_SERIAL
 			{ "serial",     R_SERIAL },
+		#endif
+		#ifdef MODULE_CAMD35
 			{ "camd35",     R_CAMD35 },
-			{ "cs378x",     R_CS378X },
 			{ "cs357x",     R_CAMD35 },
+			{ "cs378x",  	R_CS378X },
+		#endif
+		#ifdef MODULE_CAMD33
 			{ "camd33",     R_CAMD33 },
+		#endif
+		#ifdef MODULE_GBOX
 			{ "gbox",       R_GBOX },
+		#endif
+		#ifdef MODULE_CCCAM
 			{ "cccam",      R_CCCAM },
 			{ "cccam_ext",  R_CCCAM },
-			{ "constcw",    R_CONSTCW },
+		#endif
+		#ifdef MODULE_RADEGAST
 			{ "radegast",   R_RADEGAST },
+		#endif
+		#ifdef MODULE_SCAM
 			{ "scam",       R_SCAM },
+		#endif
+		#ifdef MODULE_GHTTP
 			{ "ghttp",      R_GHTTP },
+		#endif
+		#ifdef MODULE_NEWCAMD
 			{ "newcamd",    R_NEWCAMD },
 			{ "newcamd525", R_NEWCAMD },
 			{ "newcamd524", R_NEWCAMD },
+			#if defined(MODULE_AVAMGCAMD)
+				{ "mgcamd",		R_NEWCAMD },
+				{ "avatarcamd",R_NEWCAMD },
+			#endif
+		#endif
+		#ifdef MODULE_CONSTCW
+			{ "constcw",	R_CONSTCW },
+		#endif
+		#ifdef MODULE_XCAS
+			{ "xcas",		R_XCAS},
+		#endif
 			{ NULL        , 0 }
 		}, *p;
 		int i;
@@ -121,19 +146,31 @@
 			}
 		}
 		// Parse protocols
-		for(i = 0, p = &protocols[0]; p->name; p = &protocols[++i])
-		{
-			if(streq(p->name, value))
-			{
+		for (i = 0, p = &protocols[0]; p->name; p = &protocols[++i]) {
+			if (streq(p->name, value)) {
 				rdr->typ = p->typ;
 				break;
 			}
 		}
-		if(rdr->typ == R_NEWCAMD)
-			{ rdr->ncd_proto = streq(value, "newcamd524") ? NCD_524 : NCD_525; }
-		if(!rdr->typ)
-			{
-				fprintf(stderr, "ERROR: '%s' is unsupported reader protocol!\n", value);
+		if (rdr->typ == R_NEWCAMD) {
+			rdr->ncd_proto = streq(value, "newcamd524") ? NCD_524 : NCD_525;
+#if defined(MODULE_AVAMGCAMD)
+			rdr->ncd_exprotocol = 0;
+			if (streq(value, "mgcamd")) {
+				rdr->ncd_exprotocol = NCD_MGCAMD;
+				rdr->ftab.nfilts    = 0;
+				rdr->ncd_proto      = NCD_525;
+			}
+			else if (streq(value, "avatarcamd")) {
+				if (!rdr->device[0]) strcpy(rdr->device, "none");
+				rdr->ncd_exprotocol = NCD_AVATARCAMD;
+				rdr->ftab.nfilts    = 0;
+				rdr->ncd_proto      = NCD_525;
+			}
+#endif
+		}
+		if (!rdr->typ) {
+			mycs_log("ERROR: '%s' is unsupported reader protocol!", value);
 				rdr->enable = 0;
 			}
 		return;
@@ -149,13 +186,19 @@
 	{
 		int32_t i;
 		char *ptr, *saveptr1 = NULL;
-		for(i = 0, ptr = strtok_r(value, ",", &saveptr1); (i < 3) && (ptr); ptr = strtok_r(NULL, ",", &saveptr1), i++)
-		{
+		for (i = 0, ptr = strtok_r(value, ",", &saveptr1); (i < 3) && (ptr); ptr = strtok_r(NULL, ",", &saveptr1), i++) {
 			trim(ptr);
-			switch(i)
-			{
+			switch (i) {
 			case 0:
+					// sky(n)
+					if (IS_SERVER_EMBEDDED(rdr)) {
+						cs_strncpy(rdr->device, T_IPEMBEDDED, sizeof(rdr->device));
+					}
+					else {
 				cs_strncpy(rdr->device, ptr, sizeof(rdr->device));
+					}
+					rdr->r_port = 0;
+					rdr->l_port = 0;
 				break;
 			case 1:
 				rdr->r_port = atoi(ptr);
@@ -167,59 +210,52 @@
 		}
 		return;
 	}
-	fprintf_conf(f, token, "%s", rdr->device); // it should not have \n at the end
+	fprintf_conf(f, token, "%s", T_READER_DEVICES(rdr)); // it should not have \n at the end
 	if((rdr->r_port || cfg.http_full_cfg) && !isphysical)
-		{ fprintf(f, ",%d", rdr->r_port); }
+		fprintf(f, ",%d", rdr->r_port);
 	if((rdr->l_port || cfg.http_full_cfg) && !isphysical && strncmp(reader_get_type_desc(rdr, 0), "cccam", 5))
-		{ fprintf(f, ",%d", rdr->l_port); }
+		fprintf(f, ",%d", rdr->l_port);
 	fprintf(f, "\n");
 }
 
 static void reader_services_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	services_fn(token, value, setting, f);
-	if(value)
-	{
+	if (value) {
 		struct s_reader *rdr = container_of(setting, struct s_reader, sidtabs);
-		if(rdr)
-			{ rdr->changes_since_shareupdate = 1; }
+		if (rdr) rdr->changes_since_shareupdate = 1;
 	}
 }
 
 static void reader_lb_services_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	services_fn(token, value, setting, f);
-	if(value)
-	{
+	if (value) {
 		struct s_reader *rdr = container_of(setting, struct s_reader, lb_sidtabs);
-		if(rdr)
-			{ rdr->changes_since_shareupdate = 1; }
+		if (rdr) rdr->changes_since_shareupdate = 1;
 	}
 }
 
 static void reader_caid_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	check_caidtab_fn(token, value, setting, f);
-	if(value)
-	{
+	if (value) {
 		struct s_reader *rdr = container_of(setting, struct s_reader, ctab);
-		if(rdr)
-			{ rdr->changes_since_shareupdate = 1; }
+		if (rdr) rdr->changes_since_shareupdate = 1;
 	}
 }
 
 static void boxid_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		rdr->boxid = strlen(value) ? a2i(value, 4) : 0;
 		return;
 	}
 	if(rdr->boxid)
-		{ fprintf_conf(f, token, "%08X\n", rdr->boxid); }
+		fprintf_conf(f, token, "%08X\n", rdr->boxid);
 	else if(cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "\n"); }
+		fprintf_conf(f, token, "\n");
 }
 
 static void rsakey_fn(const char *token, char *value, void *setting, FILE *f)
@@ -228,14 +264,11 @@
 	if(value)
 	{
 		int32_t len = strlen(value);
-		if(len != 128 && len != 240)
-		{
+		if (len != 128 && len != 240) {
 			memset(rdr->rsa_mod, 0, 120);
 		}
-		else
-		{
-			if(key_atob_l(value, rdr->rsa_mod, len))
-			{
+		else {
+			if (key_atob_l(value, rdr->rsa_mod, len)) {
 				fprintf(stderr, "reader rsakey parse error, %s=%s\n", token, value);
 				memset(rdr->rsa_mod, 0, sizeof(rdr->rsa_mod));
 			}
@@ -243,15 +276,14 @@
 		return;
 	}
 	int32_t len = check_filled(rdr->rsa_mod, 120);
-	if(len > 0)
-	{
-		if(len > 64) { len = 120; }
-		else { len = 64; }
+	if (len > 0) {
+		if (len > 64) len = 120;
+		else len = 64;
 		char tmp[len * 2 + 1];
 		fprintf_conf(f, "rsakey", "%s\n", cs_hexdump(0, rdr->rsa_mod, len, tmp, sizeof(tmp)));
 	}
 	else if(cfg.http_full_cfg)
-		{ fprintf_conf(f, "rsakey", "\n"); }
+		fprintf_conf(f, "rsakey", "\n");
 }
 
 static void boxkey_fn(const char *token, char *value, void *setting, FILE *f)
@@ -293,13 +325,13 @@
 	{
 		int i = atoi(value);
 		if(!i && (*var & flag))
-			{ *var -= flag; }
+			*var -= flag;
 		if(i)
-			{ *var |= flag; }
+			*var |= flag;
 		return;
 	}
 	if((*var & flag) || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%d\n", (*var & flag) ? 1 : 0); }
+		fprintf_conf(f, token, "%d\n", (*var & flag) ? 1 : 0);
 }
 
 static void ins7E_fn(const char *token, char *value, void *setting, long var_size, FILE *f)
@@ -309,50 +341,42 @@
 	if(value)
 	{
 		int32_t len = strlen(value);
-		if(len != var_size * 2 || key_atob_l(value, var, len))
-		{
+		if (len != var_size * 2 || key_atob_l(value, var, len)) {
 			if(len > 0)
-				{ fprintf(stderr, "reader %s parse error, %s=%s\n", token, token, value); }
+				fprintf(stderr, "reader %s parse error, %s=%s\n", token, token, value);
 			memset(var, 0, var_size + 1);
 		}
-		else
-		{
+		else {
 			var[var_size] = 1; // found and correct
 		}
 		return;
 	}
-	if(var[var_size])
-	{
+	if (var[var_size]) {
 		char tmp[var_size * 2 + 1];
 		fprintf_conf(f, token, "%s\n", cs_hexdump(0, var, var_size, tmp, sizeof(tmp)));
 	}
 	else if(cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "\n"); }
+		fprintf_conf(f, token, "\n");
 }
 
 static void atr_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		memset(rdr->atr, 0, sizeof(rdr->atr));
 		rdr->atrlen = strlen(value);
-		if(rdr->atrlen)
-		{
+		if (rdr->atrlen) {
 			if(rdr->atrlen > (int32_t)sizeof(rdr->atr) * 2)
-				{ rdr->atrlen = (int32_t)sizeof(rdr->atr) * 2; }
+				rdr->atrlen = (int32_t)sizeof(rdr->atr) * 2;
 			key_atob_l(value, rdr->atr, rdr->atrlen);
 		}
 		return;
 	}
-	if(rdr->atr[0] || cfg.http_full_cfg)
-	{
+	if (rdr->atr[0] || cfg.http_full_cfg) {
 		int j;
 		fprintf_conf(f, token, "%s", ""); // it should not have \n at the end
-		if(rdr->atr[0])
-		{
-			for(j = 0; j < rdr->atrlen / 2; j++)
-			{
+		if (rdr->atr[0]) {
+			for (j = 0; j < rdr->atrlen / 2; j++) {
 				fprintf(f, "%02X", rdr->atr[j]);
 			}
 		}
@@ -363,19 +387,15 @@
 static void detect_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		int i;
-		for(i = 0; RDR_CD_TXT[i]; i++)
-		{
-			if(!strcmp(value, RDR_CD_TXT[i]))
-			{
+		for (i = 0; RDR_CD_TXT[i]; i++) {
+			if (!strcmp(value, RDR_CD_TXT[i])) {
 				rdr->detect = i;
 			}
-			else
-			{
+			else {
 				if(value[0] == '!' && streq(value + 1, RDR_CD_TXT[i]))
-					{ rdr->detect = i | 0x80; }
+					rdr->detect = i | 0x80;
 			}
 		}
 		return;
@@ -413,22 +433,20 @@
 static void aeskeys_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		parse_aes_keys(rdr, value);
 		return;
 	}
 	value = mk_t_aeskeys(rdr);
 	if(strlen(value) > 0 || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%s\n", value); }
+		fprintf_conf(f, token, "%s\n", value);
 	free_mk_t(value);
 }
 
 static void emmcache_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		rdr->cachemm   = 0;
 		rdr->rewritemm = 0;
 		rdr->logemm    = 0;
@@ -493,49 +511,43 @@
 				ptr = strtok_r(NULL, ",", &saveptr1))
 		{
 			if(!cs_malloc(&blocklen, sizeof(*blocklen)))
-				{ return; }
+				return;
 			num = sscanf(ptr, "%hd%c%hd", &blocklen->min, &dash, &blocklen->max);
-			if(num <= 0)
-			{
+			if (num <= 0) {
 				NULLFREE(blocklen);
 				fprintf(stderr, "blockemm-bylen parse error: %s\n", value);
 				continue;
 			}
 			if(num == 1)  // single values: x1,x2,x3,...
-				{ blocklen->max = blocklen->min; }
+				blocklen->max = blocklen->min;
 			else if(num == 2)  // range values with open end: x1-
-				{ blocklen->max = 0; }
+				blocklen->max = 0;
 			ll_append(rdr->blockemmbylen, blocklen);
 		}
 		return;
 	}
 	value = mk_t_emmbylen(rdr);
 	if(strlen(value) > 0 || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%s\n", value); }
+		fprintf_conf(f, token, "%s\n", value);
 	free_mk_t(value);
 }
 
 static void nano_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	uint16_t *nano = setting;
-	if(value)
-	{
+	if (value) {
 		*nano = 0;
-		if(strlen(value) > 0)
-		{
-			if(streq(value, "all"))
-			{
+		if (strlen(value) > 0) {
+			if (streq(value, "all")) {
 				*nano = 0xFFFF;
 			}
-			else
-			{
+			else {
 				int32_t i;
 				char *ptr, *saveptr1 = NULL;
-				for(ptr = strtok_r(value, ",", &saveptr1); ptr; ptr = strtok_r(NULL, ",", &saveptr1))
-				{
+				for (ptr = strtok_r(value, ",", &saveptr1); ptr; ptr = strtok_r(NULL, ",", &saveptr1)) {
 					i = (byte_atob(ptr) % 0x80);
 					if(i >= 0 && i <= 16)
-						{ *nano |= (1 << i); }
+						*nano |= (1 << i);
 				}
 			}
 		}
@@ -543,38 +555,34 @@
 	}
 	value = mk_t_nano(*nano);
 	if(strlen(value) > 0 || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%s\n", value); }
+		fprintf_conf(f, token, "%s\n", value);
 	free_mk_t(value);
 }
 
 static void auprovid_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		rdr->auprovid = 0;
 		if(strlen(value))
-			{ rdr->auprovid = a2i(value, 3); }
+			rdr->auprovid = a2i(value, 3);
 		return;
 	}
 	if(rdr->auprovid)
-		{ fprintf_conf(f, token, "%06X\n", rdr->auprovid); }
+		fprintf_conf(f, token, "%06X\n", rdr->auprovid);
 	else if(cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "\n"); }
+		fprintf_conf(f, token, "\n");
 }
 
 static void ratelimitecm_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		rdr->ratelimitecm = 0;
-		if(strlen(value))
-		{
+		if (strlen(value)) {
 			int i;
 			rdr->ratelimitecm = atoi(value);
-			for(i = 0; i < MAXECMRATELIMIT; i++)    // reset all slots
-			{
+			for (i = 0; i < MAXECMRATELIMIT; i++) { // reset all slots
 				rdr->rlecmh[i].srvid = -1;
 				rdr->rlecmh[i].last.time = -1;
 			}
@@ -582,38 +590,34 @@
 		return;
 	}
 	if(rdr->ratelimitecm || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%d\n", rdr->ratelimitecm); }
+		fprintf_conf(f, token, "%d\n", rdr->ratelimitecm);
 }
 
 static void ratelimittime_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
-		if(strlen(value) == 0)
-		{
-			if(rdr->ratelimitecm > 0)
-			{
+	if (value) {
+		if (strlen(value) == 0) {
+			if (rdr->ratelimitecm > 0) {
 				rdr->ratelimittime = 9000; // default 9 seconds
 				rdr->srvidholdtime = 2000; // default 2 seconds hold
 			}
-			else
-			{
+			else {
 				rdr->ratelimitecm = 0; // in case someone set a negative value
 				rdr->ratelimittime = 0;
 				rdr->srvidholdtime = 0;
 			}
 		}
-		else
-		{
+		else {
 			rdr->ratelimittime = atoi(value);
 			if (rdr->ratelimittime < 60) rdr->ratelimittime *=1000;
 		}
 		return;
 	}
 	if(rdr->ratelimitecm || cfg.http_full_cfg)
-		{ fprintf_conf(f, token, "%d\n", rdr->ratelimittime); }
+		fprintf_conf(f, token, "%d\n", rdr->ratelimittime);
 }
+
 static void srvidholdtime_fn(const char *token, char *value, void *setting, FILE *f)
 {
 	struct s_reader *rdr = setting;
@@ -647,21 +651,17 @@
 	struct s_reader *rdr = setting;
 	if(value)
 	{
-		if(strlen(value) == 0)
-		{
+		if (strlen(value) == 0) {
 			rdr->cooldown[0] = 0;
 			rdr->cooldown[1] = 0;
 		}
-		else
-		{
+		else {
 			int32_t i;
 			char *ptr, *saveptr1 = NULL;
-			for(i = 0, ptr = strtok_r(value, ",", &saveptr1); (i < 2) && (ptr); ptr = strtok_r(NULL, ",", &saveptr1), i++)
-			{
+			for (i = 0, ptr = strtok_r(value, ",", &saveptr1); (i < 2) && (ptr); ptr = strtok_r(NULL, ",", &saveptr1), i++) {
 				rdr->cooldown[i] = atoi(ptr);
 			}
-			if(rdr->cooldown[0] <= 0 || rdr->cooldown[1] <= 0)
-			{
+			if (rdr->cooldown[0] <= 0 || rdr->cooldown[1] <= 0) {
 				fprintf(stderr, "cooldown must have 2 positive values (x,y) set values %d,%d ! cooldown deactivated\n",
 						rdr->cooldown[0], rdr->cooldown[1]);
 				rdr->cooldown[0] = 0;
@@ -670,8 +670,7 @@
 		}
 		return;
 	}
-	if(rdr->cooldown[0] || cfg.http_full_cfg)
-	{
+	if (rdr->cooldown[0] || cfg.http_full_cfg) {
 		fprintf_conf(f, token, "%d,%d\n", rdr->cooldown[0], rdr->cooldown[1]);
 	}
 }
@@ -679,8 +678,7 @@
 static void cooldowndelay_fn(const char *UNUSED(token), char *value, void *setting, FILE *UNUSED(f))
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
+	if (value) {
 		rdr->cooldown[0] = strlen(value) ? atoi(value) : 0;
 	}
 	// This option is *not* written in the config file.
@@ -690,15 +688,12 @@
 static void cooldowntime_fn(const char *UNUSED(token), char *value, void *setting, FILE *UNUSED(f))
 {
 	struct s_reader *rdr = setting;
-	if(value)
-	{
-		if(strlen(value) == 0)
-		{
+	if (value) {
+		if (strlen(value) == 0) {
 			rdr->cooldown[0] = 0; // no cooling down time means no cooling set
 			rdr->cooldown[1] = 0;
 		}
-		else
-		{
+		else {
 			rdr->cooldown[1] = atoi(value);
 		}
 		return;
@@ -748,6 +743,9 @@
 	DEF_OPT_SSTR("user"                 , OFS(r_usr),                   "", SIZEOF(r_usr)),
 	DEF_OPT_SSTR("password"             , OFS(r_pwd),                   "", SIZEOF(r_pwd)),
 	DEF_OPT_SSTR("pincode"              , OFS(pincode),                 "none", SIZEOF(pincode)),
+
+	DEF_OPT_INT8("confidence"			, OFS(svradr_hidden),		0 ),
+
 #ifdef MODULE_GBOX
 	DEF_OPT_UINT8("gbox_max_distance"	, OFS(gbox_maxdist),		DEFAULT_GBOX_MAX_DIST),
 	DEF_OPT_UINT8("gbox_max_ecm_send"	, OFS(gbox_maxecmsend),		DEFAULT_GBOX_MAX_ECM_SEND),
@@ -828,6 +826,12 @@
 #ifdef MODULE_PANDORA
 	DEF_OPT_UINT8("pand_send_ecm"       , OFS(pand_send_ecm),           0),
 #endif
+#ifdef MODULE_NEWCAMD
+#if defined(MODULE_AVAMGCAMD)
+	DEF_OPT_INT8("exregistration"		, OFS(ncd_exregistration),	0 ),
+	DEF_OPT_HEX("exkey"					, OFS(ncd_exkey),				SIZEOF(ncd_exkey) ),
+#endif
+#endif
 #ifdef MODULE_CCCAM
 	DEF_OPT_SSTR("cccversion"           , OFS(cc_version),              "", SIZEOF(cc_version)),
 	DEF_OPT_INT8("cccmaxhops"           , OFS(cc_maxhops),              DEFAULT_CC_MAXHOPS),
@@ -856,13 +860,46 @@
 	DEF_LAST_OPT
 };
 
+// sky(!)
+static const struct config_list reader_simples_opts[] = {
+#ifdef WITH_LB
+	DEF_OPT_FIXUP_FUNC(reader_fixups_fn),
+#endif
+	DEF_OPT_FUNC("label"					, 0,								reader_label_fn ),
+	DEF_OPT_INT8("enable"				, OFS(enable),					1 ),
+	DEF_OPT_FUNC("protocol"				, 0,								protocol_fn ),
+	DEF_OPT_FUNC("device"				, 0,								device_fn ),
+	DEF_OPT_SSTR("user"					, OFS(r_usr),					"", SIZEOF(r_usr) ),
+	DEF_OPT_SSTR("password"				, OFS(r_pwd),					"", SIZEOF(r_pwd) ),
+	DEF_OPT_FUNC("group"					, OFS(grp),						group_fn ),
+
+#ifdef MODULE_NEWCAMD
+	DEF_OPT_INT8("connectoninit"		, OFS(ncd_connect_on_init),0 ),
+	DEF_OPT_HEX("key"						, OFS(ncd_key),				SIZEOF(ncd_key) ),
+#if defined(MODULE_AVAMGCAMD)
+	DEF_OPT_INT8("exregistration"		, OFS(ncd_exregistration),	0 ),
+	DEF_OPT_HEX("exkey"					, OFS(ncd_exkey),				SIZEOF(ncd_exkey) ),
+#endif
+#endif
+#ifdef MODULE_CCCAM
+	DEF_OPT_SSTR("cccversion"			, OFS(cc_version),			"", SIZEOF(cc_version) ),
+	DEF_OPT_INT8("cccmaxhops"			, OFS(cc_maxhops),			DEFAULT_CC_MAXHOPS ),
+#endif
+
+	DEF_OPT_SSTR("pincode"				, OFS(pincode),				"none", SIZEOF(pincode) ),
+	DEF_OPT_FUNC("boxid"					, 0,								boxid_fn ),
+	DEF_OPT_HEX("boxkey"					, OFS(boxkey),					SIZEOF(boxkey) ),
+	DEF_OPT_FUNC("rsakey"				, 0,								rsakey_fn ),
+	DEF_OPT_INT8("audisabled"			, OFS(audisabled),			0 ),
+	DEF_LAST_OPT
+};
+
 static inline bool in_list(const char *token, const char *list[])
 {
 	int i;
-	for(i = 0; list[i]; i++)
-	{
+	for (i = 0; list[i]; i++) {
 		if(streq(token, list[i]))
-			{ return true; }
+			return true;
 	}
 	return false;
 }
@@ -888,50 +925,53 @@
 		"user", "inactivitytimeout", "reconnecttimeout",
 		0
 	};
-	if(is_network_reader(reader))
-	{
+	if (is_network_reader(reader)) {
 		if(in_list(setting, hw_only_settings))
-			{ return false; }
+			return false;
 	}
-	else
-	{
+	else {
 		if(in_list(setting, network_only_settings))
-			{ return false; }
+			return false;
 	}
 
 	// These are not written in the config file
-	static const char *deprecated_settings[] =
-	{
+	static const char *deprecated_settings[] = {
 		"cooldowndelay", "cooldowntime", "mg-encrypted",
 		0
 	};
 	if(in_list(setting, deprecated_settings))
-		{ return false; }
+		return false;
 
 	// Special settings for NEWCAMD
-	static const char *newcamd_settings[] =
-	{
+	static const char *newcamd_settings[] = {
 		"disableserverfilter", "connectoninit",
+#if defined(MODULE_AVAMGCAMD)
+		"exkey",
+		"exregistration",
+#endif
 		0
 	};
 	if(reader->typ != R_NEWCAMD && in_list(setting, newcamd_settings))
 		{ return false; }
+#if defined(MODULE_AVAMGCAMD)
+	if (IS_MAVATAR_READERS(reader)) {
+		if (streq(setting, "ident")) return false;
+	}
+#endif
+
 #ifdef MODULE_CCCAM
 	// These are written only when the reader is CCCAM
-	static const char *cccam_settings[] =
-	{
+	static const char *cccam_settings[] = {
 		"cccversion", "cccmaxhops", "cccmindown", "cccwantemu", "ccckeepalive",
 		"cccreconnect",
 		0
 	};
 	// Special settings for CCCAM
-	if(reader->typ != R_CCCAM)
-	{
+	if (reader->typ != R_CCCAM) {
 		if(in_list(setting, cccam_settings))
-			{ return false; }
+			return false;
 	}
-	else if(streq(setting, "ccchop"))
-	{
+	else if (streq(setting, "ccchop")) {
 		return false;
 	}
 #endif
@@ -939,7 +979,7 @@
 #ifdef MODULE_PANDORA
 	// Special settings for PANDORA
 	if(reader->typ != R_PANDORA && streq(setting, "pand_send_ecm"))
-		{ return false; }
+		return false;
 #endif
 
 	return true; // Write the setting
@@ -948,10 +988,17 @@
 
 void chk_reader(char *token, char *value, struct s_reader *rdr)
 {
-	if(config_list_parse(reader_opts, token, value, rdr))
-		{ return; }
-	else if(token[0] != '#')
-		{ fprintf(stderr, "Warning: keyword '%s' in reader section not recognized\n", token); }
+	if (config_list_parse(reader_opts, token, value, rdr)) return;
+	else if (token[0] != '#') {
+		mycs_log("Warning: keyword '%s' in reader section not recognized", token);
+	}
+}
+
+// sjy(xbmc)
+int32_t chk_reader_simples(char *token, char *value, struct s_reader *rdr)
+{
+	if (config_list_parse(reader_simples_opts, token, value, rdr)) return 1;
+	return 0;
 }
 
 void reader_set_defaults(struct s_reader *rdr)
@@ -964,19 +1011,22 @@
 	configured_readers = ll_create("configured_readers");
 
 	FILE *fp = open_config_file(cs_srvr);
-	if(!fp)
-		{ return 1; }
+	if (!fp) return 1;
 
 	int32_t tag = 0;
-	char *value, *token;
 
-	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return 1; }
 
+	int32_t counter = 0;
+	char *value, *token;
+
+	if (!cs_malloc(&token, MAXLINESIZE)) {
+		fclose(fp);
+		return 1;
+	}
 	struct s_reader *rdr;
-	if(!cs_malloc(&rdr, sizeof(struct s_reader)))
-	{
+	if (!cs_malloc(&rdr, sizeof(struct s_reader))) {
 		NULLFREE(token);
+		fclose(fp);
 		return 1;
 	}
 
@@ -984,29 +1034,25 @@
 	while(fgets(token, MAXLINESIZE, fp))
 	{
 		int32_t l;
-		if((l = strlen(trim(token))) < 3)
-			{ continue; }
+		if ((l = strlen(trim(token))) < 3) continue;
 		if((token[0] == '[') && (token[l - 1] == ']'))
 		{
 			token[l - 1] = 0;
 			tag = (!strcmp("reader", strtolower(token + 1)));
-			if(rdr->label[0] && rdr->typ)
-			{
+			if (rdr->label[0] && rdr->typ) {
 				struct s_reader *newreader;
-				if(cs_malloc(&newreader, sizeof(struct s_reader)))
-				{
+				if (cs_malloc(&newreader, sizeof(struct s_reader))) {
 					ll_append(configured_readers, newreader);
 					rdr = newreader;
 				}
 			}
 			reader_set_defaults(rdr);
+			counter++;
 			continue;
 		}
 
-		if(!tag)
-			{ continue; }
-		if(!(value = strchr(token, '=')))
-			{ continue; }
+		if (!tag) continue;
+		if (!(value=strchr(token, '='))) continue;
 		*value++ = '\0';
 		chk_reader(trim(strtolower(token)), trim(value), rdr);
 	}
@@ -1021,6 +1068,132 @@
 	return (0);
 }
 
+// sky(osd menu)
+void *init_myrdrdb_add_simples(char *labelname)
+{
+	struct s_reader *newrdr;
+	FILE *fp;
+	char *value, *tokens;
+	int32_t tag = 0;
+	int32_t rdrAdding = 0;
+
+	if (!labelname) return 0;
+	if (!labelname[0]) return 0;
+	if (!(fp = open_config_file(cs_srvr))) return 0;;
+
+	mycs_trace(D_ADB, "!!! init_myrdrdb_add_simples(%s)", labelname);
+	if (!cs_malloc(&tokens, MAXLINESIZE)) {
+		fclose(fp);
+		return 0;
+	}
+
+	if (!cs_malloc(&newrdr, sizeof(struct s_reader)))	{
+		NULLFREE(tokens);
+		fclose(fp);
+		return 0;
+	}
+
+	while (fgets(tokens, MAXLINESIZE, fp))
+	{
+		int32_t l;
+		if ((l = strlen(trim(tokens))) < 3) continue;
+		if ((tokens[0] == '[') && (tokens[l-1] == ']')) {
+			tokens[l-1] = 0;
+			if (rdrAdding) break;
+
+			tag = (!strcmp("reader", strtolower(tokens+1)));
+			if (newrdr->label[0]) {
+				memset(newrdr, 0, sizeof(struct s_reader));
+			}
+			reader_set_defaults(newrdr);
+			continue;
+		}
+		if (!tag) continue;
+		if (!(value=strchr(tokens, '=')))	continue;
+		*value++ ='\0';
+		if (chk_reader_simples(trim(strtolower(tokens)), trim(value), newrdr))
+		{
+			if (!strcmp(newrdr->label, labelname)) {
+				myprintf("!!! add(%s,%s=%s) found\n", newrdr->label, trim(strtolower(tokens)), trim(value));
+				rdrAdding = 1;
+			}
+		}
+	}
+	if (rdrAdding)
+	{
+		mycs_trace(D_ADB, "!!! append(%02X)", newrdr->typ);
+		module_reader_set(newrdr);
+		ll_append(configured_readers, newrdr);
+	}
+	else {
+		cs_free(newrdr);
+		newrdr = 0;
+	}
+	NULLFREE(tokens);
+	fclose(fp);
+	return (newrdr);
+}
+
+
+int32_t init_myrdrdb_update_simples(struct s_reader *newrdr, char *labelname)
+{
+	struct s_reader *rdrworks;
+	struct s_reader *rdr;
+	FILE *fp;
+	char *value, *tokens;
+	int32_t tag = 0;
+	int32_t rdrfound = 0;
+
+	if (!newrdr) return 0;
+	if (!labelname) return 0;
+	if (!(fp = open_config_file(cs_srvr))) return 0;;
+
+	mycs_trace(D_ADB, "!!! init_myrdrdb_update_simples(%s)", newrdr->label);
+	if (!cs_malloc(&tokens, MAXLINESIZE)) {
+		fclose(fp);
+		return 0;
+	}
+	if (!cs_malloc(&rdrworks, sizeof(struct s_reader)))	{
+		NULLFREE(tokens);
+		fclose(fp);
+		return 0;
+	}
+
+	rdr = rdrworks;
+	while (fgets(tokens, MAXLINESIZE, fp))
+	{
+		int32_t l;
+		if ((l = strlen(trim(tokens))) < 3) continue;
+		if ((tokens[0] == '[') && (tokens[l-1] == ']')) {
+			tokens[l-1] = 0;
+			if (rdrfound) break;
+
+			tag = (!strcmp("reader", strtolower(tokens+1)));
+			if (rdr->label[0]) {
+				memset(rdr, 0, sizeof(struct s_reader));
+			}
+			reader_set_defaults(rdr);
+			continue;
+		}
+		if (!tag) continue;
+		if (!(value=strchr(tokens, '=')))	continue;
+		*value++ ='\0';
+		if (chk_reader_simples(trim(strtolower(tokens)), trim(value), rdr))
+		{
+			if (!strcmp(rdr->label, newrdr->label)) {
+				myprintf("!!! update(%s,%s=%s) found\n", rdr->label, trim(strtolower(tokens)), trim(value));
+				rdrfound = 1;
+				rdr = newrdr;
+			}
+		}
+	}
+	if (!rdrfound) cs_free(rdrworks);
+	NULLFREE(tokens);
+	fclose(fp);
+	return 1;
+}
+
+
 void free_reader(struct s_reader *rdr)
 {
 	NULLFREE(rdr->emmfile);
@@ -1040,6 +1213,8 @@
 	cs_clear_entitlement(rdr);
 	ll_destroy(&rdr->ll_entitlements);
 
+	// sky(n)
+	cs_clean_cardinformation();
 	if(rdr->csystem && rdr->csystem->card_done)
 		rdr->csystem->card_done(rdr);
 	NULLFREE(rdr->csystem_data);
@@ -1059,8 +1234,7 @@
 	int count = 0;
 	struct s_reader *rdr;
 	LL_ITER itr = ll_iter_create(configured_readers);
-	while((rdr = ll_iter_next(&itr)))
-	{
+	while ((rdr = ll_iter_next(&itr))) {
 		free_reader(rdr);
 		count++;
 	}
@@ -1069,17 +1243,41 @@
 	return count;
 }
 
+// sky(sim)
+static void inactivate_reader_for_factoy(struct s_reader *rdr)
+{
+	struct s_client *cl = rdr->client;
+	if (cl)
+		{ kill_thread(cl); }
+}
+int32_t free_reader_for_factoy_products(void)
+{
+	int count = 0;
+	if (g_factoy_products) {
+		struct s_reader *rdr;
+		LL_ITER itr = ll_iter_create(configured_readers);
+		while ((rdr = ll_iter_next(&itr))) {
+			if (is_cascading_reader(rdr)) {
+				inactivate_reader_for_factoy(rdr);
+				ll_remove(configured_readers, rdr);
+				free_reader(rdr);
+				count++;
+				cs_log("factoy-made{%s}\n", rdr->label);
+			}
+		}
+	}
+	return count;
+}
+
 int32_t write_server(void)
 {
 	FILE *f = create_config_file(cs_srvr);
-	if(!f)
-		{ return 1; }
+	if (!f) return 1;
 	struct s_reader *rdr;
 	LL_ITER itr = ll_iter_create(configured_readers);
 	while((rdr = ll_iter_next(&itr)))
 	{
-		if(rdr->label[0])
-		{
+		if (rdr->label[0]) {
 			fprintf(f, "[reader]\n");
 			config_list_apply_fixups(reader_opts, rdr);
 			config_list_save_ex(f, reader_opts, rdr, cfg.http_full_cfg, reader_check_setting);
@@ -1092,6 +1290,8 @@
 void reload_readerdb(void)
 {
 	struct s_reader *rdr;
+
+	cs_log("cardreader:reload...");
 	LL_ITER itr = ll_iter_create(configured_readers);
 	while((rdr = ll_iter_next(&itr)))
 	{
Index: oscam-config.c
===================================================================
--- oscam-config.c	(revision 10670)
+++ oscam-config.c	(working copy)
@@ -12,6 +12,7 @@
 #include "oscam-lock.h"
 #include "oscam-string.h"
 #include "oscam-time.h"
+#include "oscam-reader.h"
 
 extern uint16_t len4caid[256];
 
@@ -34,6 +35,12 @@
 	return dest;
 }
 
+// sky(n)
+char *get_information_filename(char *dest, size_t destlen, const char *filename) {
+	snprintf(dest, destlen, "%s%s", CS_INFORMATIONDIR, filename);
+	return dest;
+}
+
 int32_t write_services(void)
 {
 	int32_t i;
@@ -41,36 +48,31 @@
 	char *ptr;
 	FILE *f = create_config_file(cs_sidt);
 	if(!f)
-		{ return 1; }
+		return 1;
 
-	while(sidtab != NULL)
-	{
+	while (sidtab != NULL) {
 		ptr = sidtab->label;
-		while(*ptr)
-		{
-			if(*ptr == ' ') { *ptr = '_'; }
+		while (*ptr) {
+			if (*ptr == ' ') *ptr = '_';
 			ptr++;
 		}
 		fprintf(f, "[%s]\n", sidtab->label);
 		fprintf_conf(f, "caid", "%s", ""); // it should not have \n at the end
-		for(i = 0; i < sidtab->num_caid; i++)
-		{
-			if(i == 0) { fprintf(f, "%04X", sidtab->caid[i]); }
-			else { fprintf(f, ",%04X", sidtab->caid[i]); }
+		for (i=0; i<sidtab->num_caid; i++) {
+			if (i==0) fprintf(f,"%04X", sidtab->caid[i]);
+			else fprintf(f,",%04X", sidtab->caid[i]);
 		}
 		fputc((int)'\n', f);
 		fprintf_conf(f, "provid", "%s", ""); // it should not have \n at the end
-		for(i = 0; i < sidtab->num_provid; i++)
-		{
-			if(i == 0) { fprintf(f, "%06X", sidtab->provid[i]); }
-			else { fprintf(f, ",%06X", sidtab->provid[i]); }
+		for (i=0; i<sidtab->num_provid; i++) {
+			if (i==0) fprintf(f,"%06X", sidtab->provid[i]);
+			else fprintf(f,",%06X", sidtab->provid[i]);
 		}
 		fputc((int)'\n', f);
 		fprintf_conf(f, "srvid", "%s", ""); // it should not have \n at the end
-		for(i = 0; i < sidtab->num_srvid; i++)
-		{
-			if(i == 0) { fprintf(f, "%04X", sidtab->srvid[i]); }
-			else { fprintf(f, ",%04X", sidtab->srvid[i]); }
+		for (i=0; i<sidtab->num_srvid; i++) {
+			if (i==0) fprintf(f,"%04X", sidtab->srvid[i]);
+			else fprintf(f,",%04X", sidtab->srvid[i]);
 		}
 		fprintf(f, "\n\n");
 		sidtab = sidtab->next;
@@ -81,7 +83,7 @@
 
 void free_sidtab(struct s_sidtab *ptr)
 {
-	if(!ptr) { return; }
+	if (!ptr) return;
 	add_garbage(ptr->caid); //no need to check on NULL first, freeing NULL doesnt do anything
 	add_garbage(ptr->provid);
 	add_garbage(ptr->srvid);
@@ -101,26 +103,23 @@
 	for(i = 0, ptr = strtok_r(value, ",", &saveptr1); ptr; ptr = strtok_r(NULL, ",", &saveptr1))
 	{
 		caid = a2i(ptr, b);
-		if(!errno) { i++; }
+		if (!errno) i++;
 	}
 	//if (!i) return(0);
-	if(b == sizeof(uint16_t))
-	{
-		if(!cs_malloc(&slist, i * sizeof(uint16_t))) { return; }
-	}
-	else
-	{
-		if(!cs_malloc(&llist, i * sizeof(uint32_t))) { return; }
+	if (b==sizeof(uint16_t)) {
+	if (!cs_malloc(&slist, i * sizeof(uint16_t))) return;
+	} else {
+		if (!cs_malloc(&llist, i * sizeof(uint32_t))) return;
 	}
 	cs_strncpy(value, buf, sizeof(buf));
 	for(i = 0, ptr = strtok_r(value, ",", &saveptr1); ptr; ptr = strtok_r(NULL, ",", &saveptr1))
 	{
 		caid = a2i(ptr, b);
-		if(errno) { continue; }
+		if (errno) continue;
 		if(b == sizeof(uint16_t))
-			{ slist[i++] = (uint16_t) caid; }
+		  	slist[i++]=(uint16_t) caid;
 		else
-			{ llist[i++] = caid; }
+		  	llist[i++]=caid;
 	}
 	switch(what)
 	{
@@ -165,14 +164,13 @@
 		return;
 	}
 	if(token[0] != '#')
-		{ fprintf(stderr, "Warning: keyword '%s' in sidtab section not recognized\n", token); }
+    	fprintf(stderr, "Warning: keyword '%s' in sidtab section not recognized\n",token);
 }
 
 void init_free_sidtab(void)
 {
 	struct s_sidtab *nxt, *ptr = cfg.sidtab;
-	while(ptr)
-	{
+	while (ptr) {
 		nxt = ptr->next;
 		free_sidtab(ptr);
 		ptr = nxt;
@@ -193,15 +191,15 @@
 		cs_log("label=%s", sidtab->label);
 		snprintf(buf, sizeof(buf), "caid(%d)=", sidtab->num_caid);
 		for(i = 0; i < sidtab->num_caid; i++)
-			{ snprintf(buf + strlen(buf), 1024 - (buf - saveptr), "%04X ", sidtab->caid[i]); }
+		  	snprintf(buf+strlen(buf), 1024-(buf-saveptr), "%04X ", sidtab->caid[i]);
 		cs_log("%s", buf);
 		snprintf(buf, sizeof(buf), "provider(%d)=", sidtab->num_provid);
 		for(i = 0; i < sidtab->num_provid; i++)
-			{ snprintf(buf + strlen(buf), 1024 - (buf - saveptr), "%08X ", sidtab->provid[i]); }
+		  	snprintf(buf+strlen(buf), 1024-(buf-saveptr), "%08X ", sidtab->provid[i]);
 		cs_log("%s", buf);
 		snprintf(buf, sizeof(buf), "services(%d)=", sidtab->num_srvid);
 		for(i = 0; i < sidtab->num_srvid; i++)
-			{ snprintf(buf + strlen(buf), 1024 - (buf - saveptr), "%04X ", sidtab->srvid[i]); }
+		  	snprintf(buf+strlen(buf), 1024-(buf-saveptr), "%04X ", sidtab->srvid[i]);
 		cs_log("%s", buf);
 	}
 }
@@ -213,12 +211,12 @@
 {
 	FILE *fp = open_config_file(cs_sidt);
 	if(!fp)
-		{ return 1; }
+		return 1;
 
 	int32_t nr, nro, nrr;
 	char *value, *token;
 	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return 1; }
+		return 1;
 	struct s_sidtab *ptr;
 	struct s_sidtab *sidtab = (struct s_sidtab *)0;
 
@@ -234,35 +232,32 @@
 	while(fgets(token, MAXLINESIZE, fp))
 	{
 		int32_t l;
-		if((l = strlen(trim(token))) < 3) { continue; }
+		if ((l=strlen(trim(token)))<3) continue;
 		if((token[0] == '[') && (token[l - 1] == ']'))
 		{
 			token[l - 1] = 0;
-			if(nr > MAX_SIDBITS)
-			{
+			if (nr > MAX_SIDBITS) {
 				fprintf(stderr, "Warning: Service No.%d - '%s' ignored. Max allowed Services %d\n", nr, strtolower(token + 1), MAX_SIDBITS);
 				nr++;
 				nrr++;
 			}
-			else
-			{
-				if(!cs_malloc(&ptr, sizeof(struct s_sidtab)))
-				{
+			else {
+				if (!cs_malloc(&ptr, sizeof(struct s_sidtab))) {
 					NULLFREE(token);
 					return (1);
 				}
 				if(sidtab)
-					{ sidtab->next = ptr; }
+					sidtab->next=ptr;
 				else
-					{ cfg.sidtab = ptr; }
+					cfg.sidtab=ptr;
 				sidtab = ptr;
 				nr++;
 				cs_strncpy(sidtab->label, strtolower(token + 1), sizeof(sidtab->label));
 				continue;
 			}
 		}
-		if(!sidtab) { continue; }
-		if(!(value = strchr(token, '='))) { continue; }
+		if (!sidtab) continue;
+		if (!(value=strchr(token, '='))) continue;
 		*value++ = '\0';
 		chk_sidtab(trim(strtolower(token)), trim(strtolower(value)), sidtab);
 	}
@@ -280,49 +275,45 @@
 {
 	FILE *fp = open_config_file(cs_provid);
 	if(!fp)
-		{ return 0; }
+		return 0;
 
 	int32_t nr;
 	char *payload, *saveptr1 = NULL, *token;
 	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return 0; }
+		return 0;
 	static struct s_provid *provid = (struct s_provid *)0;
 
 	nr = 0;
-	while(fgets(token, MAXLINESIZE, fp))
-	{
+	while (fgets(token, MAXLINESIZE, fp)) {
 
 		int32_t l;
 		void *ptr;
 		char *tmp, *providasc;
 		tmp = trim(token);
 
-		if(tmp[0] == '#') { continue; }
-		if((l = strlen(tmp)) < 11) { continue; }
-		if(!(payload = strchr(token, '|'))) { continue; }
-		if(!(providasc = strchr(token, ':'))) { continue; }
+		if (tmp[0] == '#') continue;
+		if ((l = strlen(tmp)) < 11) continue;
+		if (!(payload = strchr(token, '|'))) continue;
+		if (!(providasc = strchr(token, ':'))) continue;
 
 		*payload++ = '\0';
 
-		if(!cs_malloc(&ptr, sizeof(struct s_provid)))
-		{
+		if (!cs_malloc(&ptr, sizeof(struct s_provid))) {
 			NULLFREE(token);
 			fclose(fp);
 			return (1);
 		}
 		if(provid)
-			{ provid->next = ptr; }
+			provid->next = ptr;
 		else
-			{ cfg.provid = ptr; }
+			cfg.provid = ptr;
 
 		provid = ptr;
 
 		int32_t i;
 		char *ptr1;
-		for(i = 0, ptr1 = strtok_r(payload, "|", &saveptr1); ptr1; ptr1 = strtok_r(NULL, "|", &saveptr1), i++)
-		{
-			switch(i)
-			{
+		for (i = 0, ptr1 = strtok_r(payload, "|", &saveptr1); ptr1; ptr1 = strtok_r(NULL, "|", &saveptr1), i++) {
+			switch (i) {
 			case 0:
 				cs_strncpy(provid->prov, trim(ptr1), sizeof(provid->prov));
 				break;
@@ -343,7 +334,7 @@
 	NULLFREE(token);
 	fclose(fp);
 	if(nr > 0)
-		{ cs_log("%d provid's loaded", nr); }
+		cs_log("%d provid's loaded", nr);
 	return (0);
 }
 
@@ -351,12 +342,12 @@
 {
 	FILE *fp = open_config_file(cs_srid);
 	if(!fp)
-		{ return 0; }
+		return 0;
 
 	int32_t nr = 0, i;
 	char *payload, *tmp, *saveptr1 = NULL, *token;
 	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return 0; }
+		return 0;
 	struct s_srvid *srvid = NULL, *new_cfg_srvid[16], *last_srvid[16];
 	// A cache for strings within srvids. A checksum is calculated which is the start point in the array (some kind of primitive hash algo).
 	// From this point, a sequential search is done. This greatly reduces the amount of string comparisons.
@@ -369,21 +360,19 @@
 	memset(last_srvid, 0, sizeof(last_srvid));
 	memset(new_cfg_srvid, 0, sizeof(new_cfg_srvid));
 
-	while(fgets(token, MAXLINESIZE, fp))
-	{
+	while (fgets(token, MAXLINESIZE, fp)) {
 		int32_t l, j, len = 0, len2, srvidtmp;
 		uint32_t pos;
 		char *srvidasc;
 		tmp = trim(token);
 
-		if(tmp[0] == '#') { continue; }
-		if((l = strlen(tmp)) < 6) { continue; }
-		if(!(srvidasc = strchr(token, ':'))) { continue; }
-		if(!(payload = strchr(token, '|'))) { continue; }
+		if (tmp[0] == '#') continue;
+		if ((l=strlen(tmp)) < 6) continue;
+		if (!(srvidasc = strchr(token, ':'))) continue;
+		if (!(payload=strchr(token, '|'))) continue;
 		*payload++ = '\0';
 
-		if(!cs_malloc(&srvid, sizeof(struct s_srvid)))
-		{
+		if (!cs_malloc(&srvid, sizeof(struct s_srvid))) {
 			NULLFREE(token);
 			fclose(fp);
 			return (1);
@@ -400,17 +389,15 @@
 			// check if string is in cache
 			len2 = strlen(ptr1);
 			pos = 0;
-			for(j = 0; j < len2; ++j) { pos += (uint8_t)ptr1[j]; }
+			for (j = 0; j < len2; ++j) pos += (uint8_t)ptr1[j];
 			pos = pos % 1024;
-			for(j = 0; j < used[pos]; ++j)
-			{
-				if(!strcmp(stringcache[pos][j], ptr1))
-				{
+			for (j = 0; j < used[pos]; ++j) {
+				if (!strcmp(stringcache[pos][j], ptr1)) {
 					searchptr[i] = stringcache[pos][j];
 					break;
 				}
 			}
-			if(searchptr[i]) { continue; }
+			if (searchptr[i]) continue;
 
 			offset[i] = len;
 			cs_strncpy(tmptxt + len, trim(ptr1), sizeof(tmptxt) - len);
@@ -419,38 +406,33 @@
 
 		char *tmpptr = NULL;
 		if(len > 0 && !cs_malloc(&tmpptr, len))
-			{ continue; }
+			continue;
 
 		srvid->data = tmpptr;
-		if(len > 0) { memcpy(tmpptr, tmptxt, len); }
+		if (len > 0) memcpy(tmpptr, tmptxt, len);
 
 		for(i = 0; i < 4; i++)
 		{
-			if(searchptr[i])
-			{
+			if (searchptr[i]) {
 				*ptrs[i] = searchptr[i];
 				continue;
 			}
-			if(offset[i] > -1)
-			{
+			if (offset[i]>-1) {
 				*ptrs[i] = tmpptr + offset[i];
 				// store string in stringcache
 				tmp = *ptrs[i];
 				len2 = strlen(tmp);
 				pos = 0;
-				for(j = 0; j < len2; ++j) { pos += (uint8_t)tmp[j]; }
+				for (j = 0; j < len2; ++j) pos += (uint8_t)tmp[j];
 				pos = pos % 1024;
-				if(used[pos] >= allocated[pos])
-				{
-					if(allocated[pos] == 0)
-					{
+				if (used[pos] >= allocated[pos]) {
+					if (allocated[pos] == 0) {
 						if(!cs_malloc(&stringcache[pos], 16 * sizeof(char *)))
-							{ break; }
+							break;
 					}
-					else
-					{
+					else {
 						if(!cs_realloc(&stringcache[pos], (allocated[pos] + 16) * sizeof(char *)))
-							{ break; }
+							break;
 					}
 					allocated[pos] += 16;
 				}
@@ -463,17 +445,14 @@
 		srvidtmp = dyn_word_atob(srvidasc) & 0xFFFF;
 		//printf("srvid %s - %d\n",srvidasc,srvid->srvid );
 
-		if(srvidtmp < 0)
-		{
+		if (srvidtmp<0) {
 			NULLFREE(tmpptr);
 			NULLFREE(srvid);
 			continue;
-		}
-		else { srvid->srvid = srvidtmp; }
+		} else srvid->srvid = srvidtmp;
 
 		srvid->ncaid = 0;
-		for(i = 0, ptr1 = strtok_r(token, ",", &saveptr1); (ptr1) && (i < 10) ; ptr1 = strtok_r(NULL, ",", &saveptr1), i++)
-		{
+		for (i = 0, ptr1 = strtok_r(token, ",", &saveptr1); (ptr1) && (i < 10) ; ptr1 = strtok_r(NULL, ",", &saveptr1), i++) {
 			srvid->caid[i] = dyn_word_atob(ptr1);
 			srvid->ncaid = i + 1;
 			//cs_log_dbg(D_CLIENT, "ld caid: %04X srvid: %04X Prov: %s Chan: %s",srvid->caid[i],srvid->srvid,srvid->prov,srvid->name);
@@ -481,15 +460,14 @@
 		nr++;
 
 		if(new_cfg_srvid[srvid->srvid >> 12])
-			{ last_srvid[srvid->srvid >> 12]->next = srvid; }
+			last_srvid[srvid->srvid>>12]->next = srvid;
 		else
-			{ new_cfg_srvid[srvid->srvid >> 12] = srvid; }
+			new_cfg_srvid[srvid->srvid>>12] = srvid;
 
 		last_srvid[srvid->srvid >> 12] = srvid;
 	}
-	for(i = 0; i < 1024; ++i)
-	{
-		if(allocated[i] > 0) { NULLFREE(stringcache[i]); }
+	for (i = 0; i < 1024; ++i) {
+		if (allocated[i] > 0) NULLFREE(stringcache[i]);
 	}
 	NULLFREE(token);
 
@@ -516,14 +494,12 @@
 
 	struct s_client *cl;
 	for(cl = first_client->next; cl ; cl = cl->next)
-		{ cl->last_srvidptr = NULL; }
+		cl->last_srvidptr=NULL;
 
 	struct s_srvid *ptr;
-	for(i = 0; i < 16; i++)
-	{
+	for (i=0; i<16; i++) {
 		ptr = last_srvid[i];
-		while(ptr)    //cleanup old data:
-		{
+		while (ptr) { //cleanup old data:
 			add_garbage(ptr->data);
 			add_garbage(ptr);
 			ptr = ptr->next;
@@ -537,28 +513,24 @@
 {
 	FILE *fp = open_config_file(cs_ratelimit);
 	if(!fp)
-		{ return NULL; }
+		return NULL;
 	char token[1024], str1[1024];
 	int32_t i, ret, count = 0;
 	struct s_rlimit *new_rlimit = NULL, *entry, *last = NULL;
 	uint32_t line = 0;
 
-	while(fgets(token, sizeof(token), fp))
-	{
+	while (fgets(token, sizeof(token), fp)) {
 		line++;
-		if(strlen(token) <= 1) { continue; }
-		if(token[0] == '#' || token[0] == '/') { continue; }
-		if(strlen(token) > 1024) { continue; }
+		if (strlen(token) <= 1) continue;
+		if (token[0]=='#' || token[0]=='/') continue;
+		if (strlen(token)>1024) continue;
 
-		for(i = 0; i < (int)strlen(token); i++)
-		{
-			if((token[i] == ':' || token[i] == ' ') && token[i + 1] == ':')
-			{
+		for (i=0;i<(int)strlen(token);i++) {
+			if ((token[i]==':' || token[i]==' ') && token[i+1]==':') {
 				memmove(token + i + 2, token + i + 1, strlen(token) - i + 1);
 				token[i + 1] = '0';
 			}
-			if(token[i] == '#' || token[i] == '/')
-			{
+			if (token[i]=='#' || token[i]=='/') {
 				token[i] = '\0';
 				break;
 			}
@@ -568,10 +540,9 @@
 		memset(str1, 0, sizeof(str1));
 
 		ret = sscanf(token, "%4x:%6x:%4x:%4x:%d:%d:%d:%1023s", &caid, &provid, &srvid, &chid, &ratelimitecm, &ratelimittime, &srvidholdtime, str1);
-		if(ret < 1) { continue; }
+		if (ret < 1) continue;
 		strncat(str1, ",", sizeof(str1) - strlen(str1) - 1);
-		if(!cs_malloc(&entry, sizeof(struct s_rlimit)))
-		{
+		if (!cs_malloc(&entry, sizeof(struct s_rlimit))) {
 			fclose(fp);
 			return new_rlimit;
 		}
@@ -590,20 +561,18 @@
 		cs_log_dbg(D_TRACE, "ratelimit: %04X:%06X:%04X:%04X:%d:%d:%d", entry->rl.caid, entry->rl.provid, entry->rl.srvid, entry->rl.chid,
 					  entry->rl.ratelimitecm, entry->rl.ratelimittime, entry->rl.srvidholdtime);
 
-		if(!new_rlimit)
-		{
+		if (!new_rlimit) {
 			new_rlimit = entry;
 			last = new_rlimit;
 		}
-		else
-		{
+		else {
 			last->next = entry;
 			last = entry;
 		}
 	}
 
 	if(count)
-		{ cs_log("%d entries read from %s", count, cs_ratelimit); }
+	cs_log("%d entries read from %s", count, cs_ratelimit);
 
 	fclose(fp);
 
@@ -618,8 +587,7 @@
 	old_list = cfg.ratelimit_list;
 	cfg.ratelimit_list = ratelimit_read_int();
 
-	while(old_list)
-	{
+	while (old_list) {
 		entry = old_list->next;
 		NULLFREE(old_list);
 		old_list = entry;
@@ -631,18 +599,16 @@
 
 	struct ecmrl tmp;
 	memset(&tmp, 0, sizeof(tmp));
-	if(!cfg.ratelimit_list) { return tmp; }
+	if (!cfg.ratelimit_list) return tmp;
 	struct s_rlimit *entry = cfg.ratelimit_list;
-	while(entry)
-	{
-		if(entry->rl.caid == er->caid && entry->rl.provid == er->prid && entry->rl.srvid == er->srvid && (!entry->rl.chid || entry->rl.chid == er->chid))
-		{
+	while (entry) {
+		if (entry->rl.caid == er->caid && entry->rl.provid == er->prid && entry->rl.srvid == er->srvid && (!entry->rl.chid || entry->rl.chid == er->chid)) {
 			break;
 		}
 		entry = entry->next;
 	}
 
-	if(entry) { tmp = entry->rl; }
+	if (entry) tmp = entry->rl;
 
 	return (tmp);
 }
@@ -651,54 +617,51 @@
 {
 	FILE *fp = open_config_file(cs_trid);
 	if(!fp)
-		{ return 0; }
+		return 0;
 
 	int32_t nr;
 	char *payload, *saveptr1 = NULL, *token;
 	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return 0; }
+		return 0;
 	static struct s_tierid *tierid = NULL, *new_cfg_tierid = NULL;
 
 	nr = 0;
-	while(fgets(token, MAXLINESIZE, fp))
-	{
+	while (fgets(token, MAXLINESIZE, fp)) {
 
 		int32_t l;
 		void *ptr;
 		char *tmp, *tieridasc;
 		tmp = trim(token);
 
-		if(tmp[0] == '#') { continue; }
-		if((l = strlen(tmp)) < 6) { continue; }
-		if(!(payload = strchr(token, '|'))) { continue; }
-		if(!(tieridasc = strchr(token, ':'))) { continue; }
+		if (tmp[0] == '#') continue;
+		if ((l=strlen(tmp)) < 6) continue;
+		if (!(payload=strchr(token, '|'))) continue;
+		if (!(tieridasc = strchr(token, ':'))) continue;
 		*payload++ = '\0';
 
-		if(!cs_malloc(&ptr, sizeof(struct s_tierid)))
-		{
+		if (!cs_malloc(&ptr,sizeof(struct s_tierid))) {
 			NULLFREE(token);
 			fclose(fp);
 			return (1);
 		}
 		if(tierid)
-			{ tierid->next = ptr; }
+			tierid->next = ptr;
 		else
-			{ new_cfg_tierid = ptr; }
+			new_cfg_tierid = ptr;
 
 		tierid = ptr;
 
 		int32_t i;
 		char *ptr1 = strtok_r(payload, "|", &saveptr1);
 		if(ptr1)
-			{ cs_strncpy(tierid->name, trim(ptr1), sizeof(tierid->name)); }
+			cs_strncpy(tierid->name, trim(ptr1), sizeof(tierid->name));
 
 		*tieridasc++ = '\0';
 		tierid->tierid = dyn_word_atob(tieridasc);
 		//printf("tierid %s - %d\n",tieridasc,tierid->tierid );
 
 		tierid->ncaid = 0;
-		for(i = 0, ptr1 = strtok_r(token, ",", &saveptr1); (ptr1) && (i < 10) ; ptr1 = strtok_r(NULL, ",", &saveptr1), i++)
-		{
+		for (i = 0, ptr1 = strtok_r(token, ",", &saveptr1); (ptr1) && (i < 10) ; ptr1 = strtok_r(NULL, ",", &saveptr1), i++) {
 			tierid->caid[i] = dyn_word_atob(ptr1);
 			tierid->ncaid = i + 1;
 			// cs_log("ld caid: %04X tierid: %04X name: %s",tierid->caid[i],tierid->tierid,tierid->name);
@@ -708,14 +671,13 @@
 	NULLFREE(token);
 	fclose(fp);
 	if(nr > 0)
-		{ cs_log("%d tier-id's loaded", nr); }
+		cs_log("%d tier-id's loaded", nr);
 	cs_writelock(&config_lock);
 	//reload function:
 	tierid = cfg.tierid;
 	cfg.tierid = new_cfg_tierid;
 	struct s_tierid *ptr;
-	while(tierid)
-	{
+	while (tierid) {
 		ptr = tierid->next;
 		NULLFREE(tierid);
 		tierid = ptr;
@@ -739,20 +701,16 @@
 {
 	*line = -1;
 	if(!cfg.global_whitelist)
-		{ return 1; }
+		return 1;
 
 	struct s_global_whitelist *entry;
 
 	//check mapping:
-	if(cfg.global_whitelist_use_m)
-	{
+	if (cfg.global_whitelist_use_m) {
 		entry = cfg.global_whitelist;
-		while(entry)
-		{
-			if(entry->type == 'm')
-			{
-				if(match_whitelist(er, entry))
-				{
+		while (entry) {
+			if (entry->type == 'm') {
+				if (match_whitelist(er, entry)) {
 					er->caid = entry->mapcaid;
 					er->prid = entry->mapprovid;
 					cs_log_dbg(D_TRACE, "whitelist: mapped %04X:%06X to %04X:%06X", er->caid, er->prid, entry->mapcaid, entry->mapprovid);
@@ -763,16 +721,12 @@
 		}
 	}
 
-	if(cfg.global_whitelist_use_l)    //Check caid/prov/srvid etc matching, except ecm-len:
-	{
+	if (cfg.global_whitelist_use_l) { //Check caid/prov/srvid etc matching, except ecm-len:
 		entry = cfg.global_whitelist;
 		int8_t caidprov_matches = 0;
-		while(entry)
-		{
-			if(entry->type == 'l')
-			{
-				if(match_whitelist(er, entry))
-				{
+		while (entry) {
+			if (entry->type == 'l') {
+				if (match_whitelist(er, entry)) {
 					*line = entry->line;
 					return 1;
 				}
@@ -780,8 +734,7 @@
 						&& (!entry->provid || entry->provid == er->prid)
 						&& (!entry->srvid || entry->srvid == er->srvid)
 						&& (!entry->chid || entry->chid == er->chid)
-						&& (!entry->pid || entry->pid == er->pid))
-				{
+						&& (!entry->pid || entry->pid == er->pid)) {
 					caidprov_matches = 1;
 					*line = entry->line;
 				}
@@ -789,19 +742,17 @@
 			entry = entry->next;
 		}
 		if(caidprov_matches)  //...but not ecm-len!
-			{ return 0; }
+			return 0;
 	}
 
 	entry = cfg.global_whitelist;
-	while(entry)
-	{
-		if(match_whitelist(er, entry))
-		{
+	while (entry) {
+		if (match_whitelist(er, entry)) {
 			*line = entry->line;
 			if(entry->type == 'w')
-				{ return 1; }
+				return 1;
 			else if(entry->type == 'i')
-				{ return 0; }
+				return 0;
 		}
 		entry = entry->next;
 	}
@@ -823,7 +774,7 @@
 {
 	FILE *fp = open_config_file(cs_whitelist);
 	if(!fp)
-		{ return NULL; }
+		return NULL;
 
 	char token[1024], str1[1024];
 	unsigned char type;
@@ -834,22 +785,18 @@
 	cfg.global_whitelist_use_l = 0;
 	cfg.global_whitelist_use_m = 0;
 
-	while(fgets(token, sizeof(token), fp))
-	{
+	while (fgets(token, sizeof(token), fp)) {
 		line++;
-		if(strlen(token) <= 1) { continue; }
-		if(token[0] == '#' || token[0] == '/') { continue; }
-		if(strlen(token) > 1024) { continue; }
+		if (strlen(token) <= 1) continue;
+		if (token[0]=='#' || token[0]=='/') continue;
+		if (strlen(token)>1024) continue;
 
-		for(i = 0; i < (int)strlen(token); i++)
-		{
-			if((token[i] == ':' || token[i] == ' ') && token[i + 1] == ':')
-			{
+		for (i=0;i<(int)strlen(token);i++) {
+			if ((token[i]==':' || token[i]==' ') && token[i+1]==':') {
 				memmove(token + i + 2, token + i + 1, strlen(token) - i + 1);
 				token[i + 1] = '0';
 			}
-			if(token[i] == '#' || token[i] == '/')
-			{
+			if (token[i]=='#' || token[i]=='/') {
 				token[i] = '\0';
 				break;
 			}
@@ -868,13 +815,11 @@
 		//l=len-check
 		//m=map caid/prov
 		if(ret < 1 || (type != 'w' && type != 'i' && type != 'l' && type != 'm'))
-			{ continue; }
+			continue;
 
-		if(type == 'm')
-		{
+		if (type == 'm') {
 			char *p = strstr(token + 4, " ");
-			if(!p || sscanf(p + 1, "%4x:%6x", &mapcaid, &mapprovid) < 2)
-			{
+			if (!p || sscanf(p+1, "%4x:%6x", &mapcaid, &mapprovid) < 2) {
 				cs_log_dbg(D_TRACE, "whitelist: wrong mapping: %s", token);
 				continue;
 			}
@@ -885,14 +830,12 @@
 		char *p = str1, *p2 = str1;
 		while(*p)
 		{
-			if(*p == ',')
-			{
+			if (*p == ',') {
 				*p = 0;
 				ecmlen = 0;
 				sscanf(p2, "%4x", &ecmlen);
 
-				if(!cs_malloc(&entry, sizeof(struct s_global_whitelist)))
-				{
+				if (!cs_malloc(&entry, sizeof(struct s_global_whitelist))) {
 					fclose(fp);
 					return new_whitelist;
 				}
@@ -909,7 +852,7 @@
 				entry->mapcaid = mapcaid;
 				entry->mapprovid = mapprovid;
 				if(entry->type == 'l')
-					{ cfg.global_whitelist_use_l = 1; }
+					cfg.global_whitelist_use_l = 1;
 
 				if(type == 'm')
 					cs_log_dbg(D_TRACE,
@@ -918,13 +861,11 @@
 					cs_log_dbg(D_TRACE,
 								  "whitelist: %c: %04X:%06X:%04X:%04X:%04X:%02X", entry->type, entry->caid, entry->provid, entry->srvid, entry->pid, entry->chid, entry->ecmlen);
 
-				if(!new_whitelist)
-				{
+				if (!new_whitelist) {
 					new_whitelist = entry;
 					last = new_whitelist;
 				}
-				else
-				{
+				else {
 					last->next = entry;
 					last = entry;
 				}
@@ -936,7 +877,7 @@
 	}
 
 	if(count)
-		{ cs_log("%d entries read from %s", count, cs_whitelist); }
+		cs_log("%d entries read from %s", count, cs_whitelist);
 
 	fclose(fp);
 
@@ -951,8 +892,7 @@
 	old_list = cfg.global_whitelist;
 	cfg.global_whitelist = global_whitelist_read_int();
 
-	while(old_list)
-	{
+	while (old_list) {
 		entry = old_list->next;
 		NULLFREE(old_list);
 		old_list = entry;
@@ -963,13 +903,13 @@
 {
 	FILE *fp = open_config_file(cs_l4ca);
 	if(!fp)
-		{ return; }
+		return;
 
 	int32_t nr;
 	char *value, *token;
 
 	if(!cs_malloc(&token, MAXLINESIZE))
-		{ return; }
+		return;
 
 	memset(len4caid, 0, sizeof(uint16_t) << 8);
 	for(nr = 0; fgets(token, MAXLINESIZE, fp);)
@@ -977,24 +917,24 @@
 		int32_t i, c;
 		char *ptr;
 		if(!(value = strchr(token, ':')))
-			{ continue; }
+			continue;
 		*value++ = '\0';
 		if((ptr = strchr(value, '#')))
-			{ * ptr = '\0'; }
+			*ptr = '\0';
 		if(strlen(trim(token)) != 2)
-			{ continue; }
+			continue;
 		if(strlen(trim(value)) != 4)
-			{ continue; }
+			continue;
 		if((i = byte_atob(token)) < 0)
-			{ continue; }
+			continue;
 		if((c = word_atob(value)) < 0)
-			{ continue; }
+			continue;
 		len4caid[i] = c;
 		nr++;
 	}
 	NULLFREE(token);
 	fclose(fp);
 	if(nr)
-		{ cs_log("%d lengths for caid guessing loaded", nr); }
+		cs_log("%d lengths for caid guessing loaded", nr);
 	return;
 }
Index: oscam-config.h
===================================================================
--- oscam-config.h	(revision 10670)
+++ oscam-config.h	(working copy)
@@ -2,6 +2,8 @@
 #define OSCAM_CONFIG_H_
 
 char *get_config_filename(char *dest, size_t destlen, const char *filename);
+// sky(n)
+char *get_information_filename(char *dest, size_t destlen, const char *filename);
 
 int32_t init_config(void);
 void    config_set(char *section, const char *token, char *value);
@@ -18,10 +20,15 @@
 void    chk_reader(char *token, char *value, struct s_reader *rdr);
 void    reader_set_defaults(struct s_reader *rdr);
 int32_t init_readerdb(void);
+// sky(!)
+int32_t init_myrdrdb_update_simples(struct s_reader *rdr, char *labelname);
+void   *init_myrdrdb_add_simples(char *labelname);
 void    free_reader(struct s_reader *rdr);
 int32_t free_readerdb(void);
 int32_t write_server(void);
 void    reload_readerdb(void);
+// sky(sim)
+int32_t free_reader_for_factoy_products(void);
 
 void    chk_sidtab(char *token, char *value, struct s_sidtab *sidtab);
 int32_t init_sidtab(void);
Index: oscam-ecm.c
===================================================================
--- oscam-ecm.c	(revision 10670)
+++ oscam-ecm.c	(working copy)
@@ -10,6 +10,7 @@
 #include "module-ird-guess.h"
 #include "module-cw-cycle-check.h"
 #include "module-gbox.h"
+#include "module-dvbapi.h"
 #include "oscam-cache.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -24,6 +25,13 @@
 #include "oscam-work.h"
 #include "reader-common.h"
 
+#if 1
+	#define	MYECM_TRACE	myprintf
+#else
+	#define	MYECM_TRACE(...)
+#endif
+
+
 extern CS_MUTEX_LOCK ecmcache_lock;
 extern struct ecm_request_t *ecmcwcache;
 extern uint16_t len4caid[256];
@@ -67,7 +75,7 @@
 			{
 				if((ea_list->status & (REQUEST_SENT | REQUEST_ANSWERED)) == REQUEST_SENT)  //Request sent, but no answer!
 				{
-					write_ecm_answer(ea_list->reader, er, E_TIMEOUT, 0, NULL, NULL); //set timeout for readers not answered!
+				   write_ecm_answer(ea_list->reader, er, E_TIMEOUT, 0, NULL, NULL, NULL); 	//set timeout for readers not answered!
 				}
 			}
 
@@ -80,14 +88,16 @@
 	}
 }
 
-void increment_n_request(struct s_client *cl){
+void increment_n_request(struct s_client *cl)
+{
 	if(check_client(cl)){
 		cl->n_request[1]++;
 		first_client->n_request[1]++;
 	}
 }
 
-void update_n_request(void){
+void update_n_request(void)
+{
 	struct s_client *cl;
 
 	cs_readlock(&clientlist_lock);
@@ -101,7 +111,8 @@
 		{
 			cl->n_request[0]=cl->n_request[1];
 			cl->n_request[1]=0;
-		}else{
+		}
+		else {
 			cl->n_request[0]=0;
 			cl->n_request[1]=0;
 		}
@@ -149,8 +160,8 @@
 			sleepms_on_cond(&cw_process_sleep_cond_mutex, &cw_process_sleep_cond, msec_wait);
 		}
 		cw_process_wakeups = 0; // We've been woken up, reset the counter
-		if(exit_oscam)
-			{ break; }
+
+		if (exit_oscam) break;
 
 		next_check = 0;
 #ifdef CS_ANTICASC
@@ -172,8 +183,23 @@
 				||
 				!check_client(er->client)                           //ignore ecm of killed clients
 			)
-				{ continue; }
-
+			{
+				continue;
+			}
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+			if (!er->matching_rdr) {
+				MYECM_TRACE("myecm:csp.matching_rdr none{%d}\n", er->rc);
+				continue;
+			}
+			if (er->ecm_useless) {
+				MYECM_TRACE("myecm:csp.ecm_useless{%d}\n", er->rc);
+				continue;
+			}
+			if (er->ecm_bypass) {
+				MYECM_TRACE("myecm:csp.ecm_bypass{%d}\n", er->rc);
+				continue;
+			}
+#endif
 			if(er->rc >= E_UNHANDLED)
 			{
 
@@ -188,7 +214,7 @@
 					{
 						add_job(er->client, ACTION_CACHEEX_TIMEOUT, (void *)er, 0);
 						time_to_check_cacheex_wait_time = 0;
-
+						MYECM_TRACE("myecm:csp.action_cacheex_timeout{%d}\n", er->rc);
 					}else if(er->cacheex_mode1_delay && !er->stage && er->cacheex_reader_count>0){
 						//check for cacheex_mode1_delay
 						tbc = er->tps;
@@ -197,6 +223,7 @@
 						{
 							add_job(er->client, ACTION_CACHEEX1_DELAY, (void *)er, 0);
 							time_to_check_cacheex_mode1_delay = 0;
+							MYECM_TRACE("myecm:csp.action_cacheex_delay{%d}\n", er->rc);
 						}
 					}
 					if(!next_check || (time_to_check_cacheex_wait_time > 0 && time_to_check_cacheex_wait_time < next_check))
@@ -212,6 +239,10 @@
 					time_to_check_fbtimeout = add_ms_to_timeb_diff(&tbc, lb_auto_timeout(er, get_fallbacktimeout(er->caid)));
 					if(comp_timeb(&t_now, &tbc) >= 0)
 					{
+						MYECM_TRACE("myecm:csp.action_fallback_timeout{%d,%02X,%04X, %d}\n",
+									er->rc,
+									er->ecm[0], er->chid,
+									get_fallbacktimeout(er->caid));
 						add_job(er->client, ACTION_FALLBACK_TIMEOUT, (void *)er, 0);
 						time_to_check_fbtimeout = 0;
 					}
@@ -228,6 +259,7 @@
 				time_to_check_ctimeout = add_ms_to_timeb_diff(&tbc, lb_auto_timeout(er, cfg.ctimeout));
 				if(comp_timeb(&t_now, &tbc) >= 0)
 				{
+					MYECM_TRACE("myecm:csp.action_client_timeout{%d}\n", er->rc);
 					add_job(er->client, ACTION_CLIENT_TIMEOUT, (void *)er, 0);
 					time_to_check_ctimeout = 0;
 				}
@@ -260,21 +293,20 @@
 					cs_writelock(&ecmcache_lock);
 					ecmt = ecm;
 					if(prv)
-						{ prv->next = NULL; }
+						prv->next  = NULL;
 					else
-						{ ecmcwcache = NULL; }
+						ecmcwcache = NULL;
 					cs_writeunlock(&ecmcache_lock);
 					break;
 				}
 			}
 			if(!ecmt)
-				{ cs_readunlock(&ecmcache_lock); }
+				cs_readunlock(&ecmcache_lock);
 			ecmcwcache_size = count;
 
-			while(ecmt)
-			{
+			while (ecmt) {
 				ecm = ecmt->next;
-				free_ecm(ecmt);
+				ecm_free(ecmt);
 				ecmt = ecm;
 			}
 
@@ -378,15 +410,12 @@
 
 	memmove(er->ecm + 13, er->ecm + 3, er->ecmlen - 3);
 
-	if(er->ecmlen > 0x88)
-	{
+	if (er->ecmlen > 0x88) {
 		memcpy(er->ecm + 3, headerN3, 10);
-		if(er->ecm[0] == 0x81)
-			{ er->ecm[12] += 1; }
+		if (er->ecm[0] == 0x81) er->ecm[12] += 1;
 		er->ecm[1] = 0x70;
 	}
-	else
-	{
+	else {
 		memcpy(er->ecm + 3, headerN2, 10);
 	}
 
@@ -430,10 +459,10 @@
 
 void cs_betatunnel(ECM_REQUEST *er)
 {
-	int32_t i;
 	struct s_client *cl = cur_client();
 	uint32_t mask_all = 0xFFFF;
 	TUNTAB *ttab = &cl->ttab;
+	int32_t i;
 
 	for(i = 0; i < ttab->ttnum; i++)
 	{
@@ -462,18 +491,13 @@
 		{
 			//we found a outstanding reader, clean it:
 			struct s_reader *rdr = ea->reader;
-			if(rdr)
-			{
+			if (rdr) {
 				struct s_client *cl = rdr->client;
-				if(check_client(cl))
-				{
+				if (check_client(cl)) {
 					ECM_REQUEST *ecmtask = cl->ecmtask;
-					if(ecmtask)
-					{
-						for(i = 0; i < cfg.max_pending; ++i)
-						{
-							if(ecmtask[i].parent == ecm)
-							{
+					if (ecmtask) {
+						for (i = 0; i < cfg.max_pending; ++i) {
+							if (ecmtask[i].parent == ecm) {
 								ecmtask[i].client = NULL;
 								cacheex_set_csp_lastnode(&ecmtask[i]);
 							}
@@ -486,9 +510,11 @@
 	}
 }
 
-void free_ecm(ECM_REQUEST *ecm)
+void ecm_free(ECM_REQUEST *ecm)
 {
 	struct s_ecm_answer *ea, *nxt;
+
+//	MYECM_TRACE("myecm:ecm_free{%d}\n", ecm->rc);
 	cacheex_free_csp_lastnodes(ecm);
 	gbox_free_cards_pending(ecm);
 	//remove this ecm from reader queue to avoid segfault on very late answers (when ecm is already disposed)
@@ -497,8 +523,7 @@
 	//free matching_rdr list:
 	ea = ecm->matching_rdr;
 	ecm->matching_rdr = NULL;
-	while(ea)
-	{
+	while (ea) {
 		nxt = ea->next;
 		cs_lock_destroy(&ea->ecmanswer_lock);
 		add_garbage(ea);
@@ -524,21 +549,88 @@
 {
 	ECM_REQUEST *er = NULL;
 	struct s_client *cl = cur_client();
-	if(!cl)
-		{ return NULL; }
-	if(!cs_malloc(&er, sizeof(ECM_REQUEST)))
-		{ return NULL; }
+	if (!cl)	return NULL;
+	if (!cs_malloc(&er, sizeof(ECM_REQUEST))) return NULL;
 	cs_ftime(&er->tps);
 	er->rc     = E_UNHANDLED;
 	er->client = cl;
 	er->grp    = 0;  //no readers/cacheex-clients answers yet
+	er->ecm_bypass  = 0;
+	er->ecm_cssolo  = 0;
+	er->ecm_crc 	 = 0;
+	er->ecm_dongles = 0;
 	//cs_log("client %s ECMTASK %d module %s", username(cl), n, get_module(cl)->desc);
 	return er;
 }
 
+// sky(n)
+// fake ecm request.
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+ECM_REQUEST *get_ecmtask_clients(struct s_client *cl, uint16_t idx, bool initial)
+{
+	ECM_REQUEST *er = NULL;
+
+	if (!cl) return NULL;
+	if (!cl->ecmtask) return NULL;
+
+	er = &cl->ecmtask[idx];
+	if (!er) return NULL;
+	cs_ftime(&er->tps);
+
+	if (initial) {
+#ifdef MODULE_GBOX
+	   er->gbox_ecm_id = 0;
+#endif
+		er->client 		 = cl;
+		er->grp    		 = 0;  // no readers/cacheex-clients answers yet
+		er->rc 			 = E_UNHANDLED;
+	}
+//	cs_log("client %s ECMTASK %d module %s", username(cl), n, get_module(cl)->desc);
+	return er;
+}
+
+int32_t chk_ecmtask_precision_sequence(struct s_client *cl, uint16_t *psequence, uint32_t chksum)
+{
+	int32_t ecmfound = -1;
+	int32_t i;
+
+	if (!cl) return -1;
+	if (!cl->ecmtask) return -1;
+	for (i=0; i<cfg.max_pending; i++) {
+		if (cl->ecmtask[i].idx == *psequence) {
+			ecmfound = i;
+			break;
+		}
+	}
+	if (ecmfound < 0) return -1;
+	if (cl->ecmtask[ecmfound].ecm_crc==chksum) return (ecmfound);
+	for (i=0; i<cfg.max_pending; i++) {
+		if (cl->ecmtask[i].ecm_crc==chksum) {
+			MYECM_TRACE("myecm:--- precision{%d->%d}\n", *psequence, cl->ecmtask[i].idx);
+			*psequence = cl->ecmtask[i].idx;
+			ecmfound = i;
+			break;
+		}
+	}
+	return (ecmfound);
+}
+
+int32_t chk_ecmtask_precision_clients(struct s_client *cl, uint16_t sequence)
+{
+	if (cl && cl->ecmtask) {
+		int32_t i;
+		for (i=0; i<cfg.max_pending; i++) {
+			if (cl->ecmtask[i].idx == sequence) return sequence;
+		}
+	}
+	return ERE_CS_BYPASS;
+}
+#endif	// defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+
+
 void cleanup_ecmtasks(struct s_client *cl)
 {
-	if(cl && !cl->account->usr) { return; }  //not for anonymous users!
+	if (cl && cl->account && !cl->account->usr) { return; }  //not for anonymous users!
 
 	ECM_REQUEST *ecm;
 
@@ -546,8 +638,7 @@
 	cs_readlock(&ecmcache_lock);
 	for(ecm = ecmcwcache; ecm; ecm = ecm->next)
 	{
-		if(ecm->client == cl)
-		{
+		if (ecm->client == cl) {
 			ecm->client = NULL;
 		}
 	}
@@ -561,11 +652,9 @@
 		if(check_client(rdr->client) && rdr->client->ecmtask)
 		{
 			int i;
-			for(i = 0; i < cfg.max_pending; i++)
-			{
+			for (i = 0; i < cfg.max_pending; i++) {
 				ecm = &rdr->client->ecmtask[i];
-				if(ecm->client == cl)
-				{
+				if (ecm->client == cl) {
 					ecm->client = NULL;
 				}
 			}
@@ -580,7 +669,7 @@
 static void add_cascade_data(struct s_client *client, ECM_REQUEST *er)
 {
 	if(!client->cascadeusers)
-		{ client->cascadeusers = ll_create("cascade_data"); }
+		client->cascadeusers = ll_create("cascade_data");
 	LLIST *l = client->cascadeusers;
 	LL_ITER it = ll_iter_create(l);
 	time_t now = time(NULL);
@@ -591,17 +680,16 @@
 		if(er->caid == cu->caid && er->prid == cu->prid && er->srvid == cu->srvid)  //found it
 		{
 			if(cu->time < now)
-				{ cu->cwrate = now - cu->time; }
+				cu->cwrate = now-cu->time;
 			cu->time = now;
 			found = 1;
 		}
 		else if(cu->time + 60 < now)  //  old
-			{ ll_iter_remove_data(&it); }
+			ll_iter_remove_data(&it);
 	}
 	if(!found)    //add it if not found
 	{
-		if(!cs_malloc(&cu, sizeof(struct s_cascadeuser)))
-			{ return; }
+		if (!cs_malloc(&cu, sizeof(struct s_cascadeuser))) return;
 		cu->caid = er->caid;
 		cu->prid = er->prid;
 		cu->srvid = er->srvid;
@@ -631,14 +719,12 @@
 
 struct s_ecm_answer *get_ecm_answer(struct s_reader *reader, ECM_REQUEST *er)
 {
-	if(!er || !reader) { return NULL; }
+	if (!er || !reader) return NULL;
 
 	struct s_ecm_answer *ea;
 
-	for(ea = er->matching_rdr; ea; ea = ea->next)
-	{
-		if(ea->reader == reader)
-		{
+	for (ea = er->matching_rdr; ea; ea = ea->next) {
+		if (ea->reader == reader) {
 			return ea;
 		}
 	}
@@ -656,7 +742,7 @@
 		cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [distribute_ea] send ea (%s) by reader %s answering for client %s", (check_client(ea_temp->er->client) ? ea_temp->er->client->account->usr : "-"), ea_temp->er->caid, ea_temp->er->prid, ea_temp->er->srvid, ea->rc==E_FOUND?"OK":"NOK", ea_temp->reader->label, (check_client(ea->er->client) ? ea->er->client->account->usr : "-"));
 
 		//e.g. we cannot send timeout, because "ea_temp->er->client" could wait/ask other readers! Simply set not_found if different from E_FOUND!
-		write_ecm_answer(ea_temp->reader, ea_temp->er, (ea->rc==E_FOUND? E_FOUND : E_NOTFOUND), ea->rcEx, ea->cw, NULL);
+		write_ecm_answer(ea_temp->reader, ea_temp->er, (ea->rc==E_FOUND? E_FOUND : E_NOTFOUND), ea->rcEx, ea->cw, &ea->cwEx, NULL);
 	}
 }
 
@@ -660,18 +746,26 @@
 	}
 }
 
+
 int32_t send_dcw(struct s_client *client, ECM_REQUEST *er)
 {
-	if(!check_client(client) || client->typ != 'c')
-		{ return 0; }
+	if (!check_client(client)) return 0;
+	if ( client->typ != 'c')
+	{
+		MYECM_TRACE("myecm:send_dcw:client invalid{%d.%c}\n", client->kill, client->typ);
+		return 0;
+	}
 
-	cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [send_dcw] rc %d from reader %s", (check_client(er->client) ? er->client->account->usr : "-"), er->caid, er->prid, er->srvid, er->rc, er->selected_reader ? er->selected_reader->label : "-");
+	cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [send_dcw] rc %d from reader %s",
+				(check_client(er->client) ? er->client->account->usr : "-"),
+				er->caid, er->prid, er->srvid, er->rc,
+				er->selected_reader ? er->selected_reader->label : "-");
 
 	static const char stageTxt[] = {'0', 'C', 'L', 'P', 'F', 'X'};
 	static const char *stxt[] = {"found", "cache1", "cache2", "cache3",
 								 "not found", "timeout", "sleeping",
-								 "fake", "invalid", "corrupt", "no card", "expdate", "disabled", "stopped"
-								};
+											"fake", "invalid", "corrupt", "no card", "expdate", "disabled", "stopped",
+											"const",};
 	static const char *stxtEx[16] = {"", "group", "caid", "ident", "class", "chid", "queue", "peer", "sid", "", "", "", "", "", "", ""};
 	static const char *stxtWh[16] = {"", "user ", "reader ", "server ", "lserver ", "", "", "", "", "", "", "", "" , "" , "", ""};
 	char sby[100] = "", sreason[32] = "", scwcinfo[32] = "", schaninfo[32] = "", srealecmtime[50]="";
@@ -681,6 +775,7 @@
 	struct timeb tpe;
 
 	snprintf(usrname, sizeof(usrname) - 1, "%s", username(client));
+	MYECM_TRACE("myecm:send_dcw:%s,%d\n", usrname, er->rc);
 
 #ifdef WITH_DEBUG
 	if(cs_dblevel & D_CLIENTECM)
@@ -712,9 +807,7 @@
 
 	//check if answer from cacheex-1 reader
 	if(er->rc == E_FOUND && er_reader && cacheex_reader(er_reader))  //so add hit to cacheex mode 1 readers
-	{
-		er->rc = E_CACHEEX;
-	}
+		{er->rc = E_CACHEEX; }
 
 	//real ecm time
 	if(ea_orig && !ea_orig->is_pending && er->rc == E_FOUND
@@ -772,7 +865,8 @@
 
 		if(er->ocaid){
 			snprintf(sby, sizeof(sby) - 1, " by %s(btun %04X)", cex_name, er->ocaid);
-		}else{
+		}
+		else {
 			snprintf(sby, sizeof(sby) - 1, " by %s", cex_name);
 		}
 	}
@@ -786,19 +880,20 @@
 	}
 
 	if(er->rcEx)
-		{ snprintf(erEx, sizeof(erEx) - 1, "rejected %s%s", stxtWh[er->rcEx >> 4], stxtEx[er->rcEx & 0xf]); }
+		snprintf(erEx, sizeof(erEx)-1, "rejected %s%s", stxtWh[er->rcEx>>4], stxtEx[er->rcEx & 0xf]);
 
 	get_servicename_or_null(client, er->srvid, er->caid, channame);
 	if(!channame[0])
-		{ schaninfo[0] = '\0'; }
+		schaninfo[0] = '\0';
 	else
-		{ snprintf(schaninfo, sizeof(schaninfo) - 1, " - %s", channame); }
+		snprintf(schaninfo, sizeof(schaninfo)-1, " - %s", channame);
 
 	if(er->msglog[0])
-		{ snprintf(sreason, sizeof(sreason) - 1, " (%s)", er->msglog); }
+		snprintf(sreason, sizeof(sreason)-1, " (%s)", er->msglog);
+
 #ifdef CW_CYCLE_CHECK
 	if(er->cwc_msg_log[0])
-		{ snprintf(scwcinfo, sizeof(scwcinfo) - 1, " (%s)", er->cwc_msg_log); }
+		snprintf(scwcinfo, sizeof(scwcinfo)-1, " (%s)", er->cwc_msg_log);
 #endif
 
 	cs_ftime(&tpe);
@@ -821,8 +916,7 @@
 	if(er_reader)
 	{
 		struct s_client *er_cl = er_reader->client;
-		if(check_client(er_cl))
-		{
+		if (check_client(er_cl)) {
 			er_cl->cwlastresptime = client->cwlastresptime;
 			webif_client_add_lastresponsetime(er_cl, client->cwlastresptime, now, er->rc);
 			er_cl->last_srvidptr = client->last_srvidptr;
@@ -834,8 +928,7 @@
 	client->last = now;
 
 	//cs_log_dbg(D_TRACE, "CHECK rc=%d er->cacheex_src=%s", er->rc, username(er->cacheex_src));
-	switch(er->rc)
-	{
+	switch (er->rc) {
 	case E_FOUND:
 	{
 		client->cwfound++;
@@ -865,14 +958,12 @@
 	case E_CORRUPT:
 	case E_NOCARD:
 	{
-		if(er->rcEx)
-		{
+			if (er->rcEx) {
 			client->cwignored++;
 			client->account->cwignored++;
 			first_client->cwignored++;
 		}
-		else
-		{
+			else {
 			client->cwnot++;
 			client->account->cwnot++;
 			first_client->cwnot++;
@@ -886,6 +977,8 @@
 		first_client->cwtout++;
 		break;
 	}
+		// sky()
+		case E_USELESS: break;
 	default:
 	{
 		client->cwignored++;
@@ -1028,36 +1121,31 @@
 #endif
 
 	ac_chk(client, er, 1);
+
 	int32_t is_fake = 0;
-	if(er->rc == E_FAKE)
-	{
+	if (er->rc == E_FAKE) {
 		is_fake = 1;
 		er->rc = E_FOUND;
 	}
 
 	if(cfg.double_check &&  er->rc == E_FOUND && er->selected_reader && is_double_check_caid(er))
 	{
-		if(er->checked == 0)   //First CW, save it and wait for next one
-		{
+		if (er->checked == 0) {//First CW, save it and wait for next one
 			er->checked = 1;
 			er->origin_reader = er->selected_reader;
 			memcpy(er->cw_checked, er->cw, sizeof(er->cw));
 			cs_log("DOUBLE CHECK FIRST CW by %s idx %d cpti %d", er->origin_reader->label, er->idx, er->msgid);
 		}
-		else if(er->origin_reader != er->selected_reader)      //Second (or third and so on) cw. We have to compare
-		{
-			if(memcmp(er->cw_checked, er->cw, sizeof(er->cw)) == 0)
-			{
+		else if (er->origin_reader != er->selected_reader) { //Second (or third and so on) cw. We have to compare
+			if (memcmp(er->cw_checked, er->cw, sizeof(er->cw)) == 0) {
 				er->checked++;
 				cs_log("DOUBLE CHECKED! %d. CW by %s idx %d cpti %d", er->checked, er->selected_reader->label, er->idx, er->msgid);
 			}
-			else
-			{
+			else {
 				cs_log("DOUBLE CHECKED NONMATCHING! %d. CW by %s idx %d cpti %d", er->checked, er->selected_reader->label, er->idx, er->msgid);
 			}
 		}
-		if(er->checked < 2)    //less as two same cw? mark as pending!
-		{
+		if (er->checked < 2) { //less as two same cw? mark as pending!
 			er->rc = E_UNHANDLED;
 			goto ESC;
 		}
@@ -1068,7 +1156,7 @@
 	add_cascade_data(client, er);
 
 	if(is_fake)
-		{ er->rc = E_FAKE; }
+		er->rc = E_FAKE;
 
 	if(!(er->rc == E_SLEEPING && client->cwlastresptime == 0))
 	{
@@ -1091,7 +1179,10 @@
 		}
 	}
 
+	if (er->rc == E_FOUND) {
+//		myprdump("cw:", er->cw, 16);
 	cs_log_dump_dbg(D_ATR, er->cw, 16, "cw:");
+	}
 	led_status_cw_not_found(er);
 
 ESC:
@@ -1104,6 +1195,7 @@
  */
 static int32_t write_ecm_request(struct s_reader *rdr, ECM_REQUEST *er)
 {
+	if (!rdr) return 0;
 	add_job(rdr->client, ACTION_READER_ECM_REQUEST, (void *)er, 0);
 	return 1;
 }
@@ -1122,11 +1214,13 @@
 	struct s_ecm_answer *ea;
 	int8_t sent = 0;
 
-	if(er->stage >= 4) { return; }
+	if (!er) return;
+	MYECM_TRACE("myecm:request_cw_from_readers{%d,%d}\n", er->stage, er->readers);
+	if (er->stage >= 4) return;
 
 	while(1)
 	{
-		if(stop_stage && er->stage >= stop_stage) { return; }
+		if (stop_stage && er->stage >= stop_stage) return;
 
 		er->stage++;
 
@@ -1143,40 +1237,39 @@
 
 		for(ea = er->matching_rdr; ea; ea = ea->next)
 		{
-			switch(er->stage)
-			{
+			switch (er->stage) {
 #ifdef CS_CACHEEX
 			case 1:
 			{
 				// Cache-Exchange
-				if((ea->status & REQUEST_SENT) ||
-						(ea->status & (READER_CACHEEX | READER_ACTIVE)) != (READER_CACHEEX | READER_ACTIVE))
-					{ continue; }
+				  	if ((ea->status & (REQUEST_SENT)) ||
+						 (ea->status & (READER_CACHEEX|READER_ACTIVE)) != (READER_CACHEEX|READER_ACTIVE) || cfg.preferlocalcards == 2)
+					  	continue;
 				break;
 			}
 #endif
 			case 2:
 			{
 				// only local reader
-				if((ea->status & REQUEST_SENT) ||
+					if ((ea->status & (REQUEST_SENT)) ||
 						(ea->status & (READER_ACTIVE | READER_FALLBACK | READER_LOCAL)) != (READER_ACTIVE | READER_LOCAL))
-					{ continue; }
+						continue;
 				break;
 			}
 			case 3:
 			{
 				// any non fallback reader not asked yet
-				if((ea->status & REQUEST_SENT) ||
-						(ea->status & (READER_ACTIVE | READER_FALLBACK)) != READER_ACTIVE)
-					{ continue; }
+					if ((ea->status & (REQUEST_SENT)) ||
+						 (ea->status & (READER_ACTIVE|READER_FALLBACK)) != (READER_ACTIVE))
+						continue;
 				break;
 			}
 			default:
 			{
 				// only fallbacks
-				if((ea->status & REQUEST_SENT) ||
+					if ((ea->status & (REQUEST_SENT)) ||
 						(ea->status & (READER_ACTIVE | READER_FALLBACK)) != (READER_ACTIVE | READER_FALLBACK))
-					{ continue; }
+						continue;
 				break;
 			}
 			}
@@ -1184,7 +1277,7 @@
 			struct s_reader *rdr = ea->reader;
 			char ecmd5[17 * 3];
 			cs_hexdump(0, er->ecmd5, 16, ecmd5, sizeof(ecmd5));
-			cs_log_dbg(D_TRACE | D_CSP, "request_cw stage=%d to reader %s ecm hash=%s", er->stage, rdr ? rdr->label : "", ecmd5);
+			cs_log_dbg(D_TRACE | D_CSP, "request_cw stage=%d to reader %s ecm hash=%s", er->stage, (rdr) ? rdr->label : "unk", ecmd5);
 
 			ea->status |= REQUEST_SENT;
 			cs_ftime(&ea->time_request_sent);
@@ -1197,38 +1290,46 @@
 			if(!sent && rdr)
 			{
 				struct s_client *rcl = rdr->client;
-				if(check_client(rcl))
-				{
+				if (check_client(rcl)) {
 					if(rcl->typ == 'r' && rdr->card_status == CARD_INSERTED)
-						{ sent = 1; }
+						sent = 1;
 					else if(rcl->typ == 'p' && (rdr->card_status == CARD_INSERTED || rdr->tcp_connected))
-						{ sent = 1; }
+						sent = 1;
 				}
 			}
 
-			cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [write_ecm_request] reader %s --> SENT %d", (check_client(er->client) ? er->client->account->usr : "-"), er->caid, er->prid, er->srvid, rdr ? ea->reader->label : "-", sent);
+			cs_log_dbg(D_LB,"{client %s, caid %04X, prid %06X, srvid %04X} [write_ecm_request] reader %s --> SENT %d",
+					(check_client(er->client) ? er->client->account->usr:"-"),
+					er->caid, er->prid, er->srvid,
+					rdr ? ea->reader->label : "-", sent);
 		}
-		if(sent || er->stage >= 4)
-			{ break; }
+		if (sent || er->stage >= 4) break;
 	}
 }
 
 
-void add_cache_from_reader(ECM_REQUEST *er, struct s_reader *rdr, int32_t csp_hash, uchar *ecmd5, uchar *cw, int16_t caid, int32_t prid, int16_t srvid ){
+void add_cache_from_reader(ECM_REQUEST *er, struct s_reader *rdr, int32_t csp_hash, uchar *ecmd5, uchar *cw, CWEXTENTION *cwEx, int16_t caid, int32_t prid, int16_t srvid)
+{
 	ECM_REQUEST *ecm;
+
+//	if (caid_is_biss(caid)) return; /* sky(biss) */
+	if (er->ecm_dongles) return;
 	if (cs_malloc(&ecm, sizeof(ECM_REQUEST))){
 		cs_ftime(&ecm->tps);
 
 		ecm->cwc_cycletime = er->cwc_cycletime;
 		ecm->cwc_next_cw_cycle = er->cwc_next_cw_cycle;
 		memcpy(ecm->ecm, er->ecm, sizeof(ecm->ecm));  // ecm[0] is pushed to cacheexclients so we need a copy from it
+		ecm->dmuxid = er->dmuxid; // sky(powervu)
 		ecm->caid = caid;
 		ecm->prid = prid;
 		ecm->srvid = srvid;
+		ecm->exprid = prid;
 		memcpy(ecm->ecmd5, ecmd5, CS_ECMSTORESIZE);
 		ecm->csp_hash = csp_hash;
 		ecm->rc = E_FOUND;
 		memcpy(ecm->cw, cw, sizeof(ecm->cw));
+		if (cwEx) memcpy(&ecm->cwEx, cwEx, sizeof(CWEXTENTION)); // sky(powervu)
 		ecm->grp = rdr->grp;
 		ecm->selected_reader = rdr;
 #ifdef CS_CACHEEX
@@ -1252,15 +1353,22 @@
 
 void chk_dcw(struct s_ecm_answer *ea)
 {
-	if(!ea || !ea->er)
-		{ return; }
+	if (!ea || !ea->er) return;
 
 	ECM_REQUEST *ert = ea->er;
 	struct s_ecm_answer *ea_list;
 	struct s_reader *eardr = ea->reader;
-	if(!ert)
-		{ return; }
+	if (!ert) return;
 
+	MYECM_TRACE("myecm:chk_dcw(%d,%d) {%d,%d}\n", ea->rc, ert->rc, ert->ecm_bypass, ert->ecm_useless);
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (ert->ecm_bypass || ert->ecm_useless)
+	{
+		MYECM_TRACE("myecm:--- chk_dcw.ecm_skip{%d,%d}!\n", ert->ecm_bypass, ert->ecm_useless);
+	}
+	else
+#endif
+	{
 	//ecm request already answered!
 	if(ert->rc < E_99)
 	{
@@ -1272,9 +1380,9 @@
 			cs_hexdump(0, ert->cw, 16, cw2, sizeof(cw2));
 
 			char ip1[20] = "", ip2[20] = "";
-			if(ea->reader && check_client(ea->reader->client)) { cs_strncpy(ip1, cs_inet_ntoa(ea->reader->client->ip), sizeof(ip1)); }
-			if(ert->cacheex_src) { cs_strncpy(ip2, cs_inet_ntoa(ert->cacheex_src->ip), sizeof(ip2)); }
-			else if(ert->selected_reader && check_client(ert->selected_reader->client)) { cs_strncpy(ip2, cs_inet_ntoa(ert->selected_reader->client->ip), sizeof(ip2)); }
+				if (ea->reader && check_client(ea->reader->client)) cs_strncpy(ip1, cs_inet_ntoa(ea->reader->client->ip), sizeof(ip1));
+				if (ert->cacheex_src) cs_strncpy(ip2, cs_inet_ntoa(ert->cacheex_src->ip), sizeof(ip2));
+				else if (ert->selected_reader && check_client(ert->selected_reader->client)) cs_strncpy(ip2, cs_inet_ntoa(ert->selected_reader->client->ip), sizeof(ip2));
 
 			ECM_REQUEST *er = ert;
 			debug_ecm(D_TRACE, "WARNING2: Different CWs %s from %s(%s)<>%s(%s): %s<>%s", buf,
@@ -1287,7 +1395,7 @@
 		return;
 	}
 
-
+	}
 #ifdef CS_CACHEEX
 	/* if answer from cacheex-1 reader, not send answer to client! thread check_cache will check counter and send answer to client!
 	 * Anyway, we should check if we have to go to oher stage (>1)
@@ -1323,10 +1431,10 @@
 	int32_t reader_left = 0, local_left = 0, reader_not_flb_left = 0, has_not_fallback = 0, has_local = 0;
 	ert->selected_reader = eardr;
 
-	switch(ea->rc)
-	{
+	switch (ea->rc) {
 	case E_FOUND:
 		memcpy(ert->cw, ea->cw, 16);
+			memcpy(&ert->cwEx, &ea->cwEx, sizeof(CWEXTENTION)); // sky(powervu)
 		ert->rcEx = 0;
 		ert->rc = ea->rc;
 		ert->grp |= eardr->grp;
@@ -1345,18 +1453,18 @@
 			cs_readlock(&ea_list->ecmanswer_lock);
 
 			if((!(ea_list->status & READER_FALLBACK)  && ((ea_list->status & (REQUEST_SENT | REQUEST_ANSWERED | READER_LOCAL | READER_ACTIVE)) == (REQUEST_SENT | READER_LOCAL | READER_ACTIVE))) || ea_list->rc < E_NOTFOUND)
-				{ local_left++; }
+					local_left++;
 
 			if((!(ea_list->status & READER_FALLBACK)  && ((ea_list->status & (REQUEST_SENT | REQUEST_ANSWERED | READER_ACTIVE)) == (REQUEST_SENT | READER_ACTIVE))) || ea_list->rc < E_NOTFOUND)
-				{ reader_not_flb_left++; }
+					reader_not_flb_left++;
 
 			if(((ea_list->status & (REQUEST_ANSWERED | READER_ACTIVE)) == (READER_ACTIVE)) || ea_list->rc < E_NOTFOUND)
-				{ reader_left++; }
+					reader_left++;
 
 			if(((ea_list->status & (READER_FALLBACK | READER_ACTIVE))) == (READER_ACTIVE))
-				{ has_not_fallback = 1; }
+					has_not_fallback = 1;
 			if(((ea_list->status & (READER_LOCAL | READER_FALLBACK | READER_ACTIVE))) == (READER_LOCAL | READER_ACTIVE))
-				{ has_local = 1; }
+					has_local = 1;
 
 			cs_readunlock(&ea_list->ecmanswer_lock);
 		}
@@ -1397,17 +1505,19 @@
 		break;
 	}
 
+	MYECM_TRACE("myecm:--- chk_dcw.send_dcw=%d\n", ert->rc);
 	if(ert->rc < E_99)
+	{
 		send_dcw(ert->client, ert);
 }
+}
 
-uint32_t chk_provid(uint8_t *ecm, uint16_t caid)
+uint32_t chk_ecm_provid(uint8_t *ecm, uint16_t caid)
 {
 	int32_t i, len, descriptor_length = 0;
 	uint32_t provid = 0;
 
-	switch(caid >> 8)
-	{
+	switch (caid >> 8) {
 	case 0x01:
 		// seca
 		provid = b2i(2, ecm + 3);
@@ -1416,21 +1526,19 @@
 		// viaccess
 		i = (ecm[4] == 0xD2) ? ecm[5] + 2 : 0; // skip d2 nano
 		if((ecm[5 + i] == 3) && ((ecm[4 + i] == 0x90) || (ecm[4 + i] == 0x40)))
-			{ provid = (b2i(3, ecm + 6 + i) & 0xFFFFF0); }
+				provid = (b2i(3, ecm+6+i) & 0xFFFFF0);
 
 		i = (ecm[6] == 0xD2) ? ecm[7] + 2 : 0; // skip d2 nano long ecm
 		if((ecm[7 + i] == 7) && ((ecm[6 + i] == 0x90) || (ecm[6 + i] == 0x40)))
-			{ provid = (b2i(3, ecm + 8 + i) & 0xFFFFF0); }
+				provid = (b2i(3, ecm+8+i) & 0xFFFFF0);
 
 		break;
 	case 0x0D:
 		// cryptoworks
 		len = (((ecm[1] & 0xf) << 8) | ecm[2]) + 3;
-		for(i = 8; i < len; i += descriptor_length + 2)
-		{
+			for (i = 8; i < len; i += descriptor_length + 2) {
 			descriptor_length = ecm[i + 1];
-			if(ecm[i] == 0x83)
-			{
+				if (ecm[i] == 0x83) {
 				provid = (uint32_t)ecm[i + 2] & 0xFE;
 				break;
 			}
@@ -1439,8 +1547,9 @@
 		
 	case 0x18:
 		// nagra2
-		if (caid == 0x1801) // more safety
+		   if (caid == 0x1801) { // more safety
 			provid = b2i(2, ecm + 5);
+			}
 		break;
 	}
 
@@ -1449,6 +1558,8 @@
 
 void update_chid(ECM_REQUEST *er)
 {
+	if (!er) return;
+	if ( er->ecm_bypass) return;
 	er->chid = get_subid(er);
 }
 
@@ -1523,14 +1634,23 @@
 	fclose(pfCWL);
 }
 
-int32_t write_ecm_answer(struct s_reader *reader, ECM_REQUEST *er, int8_t rc, uint8_t rcEx, uint8_t *cw, char *msglog)
+int32_t write_ecm_answer(struct s_reader *reader, ECM_REQUEST *er, int8_t rc, uint8_t rcEx, uint8_t *cw, CWEXTENTION *cwEx, char *msglog)
 {
-	if(!reader || !er || !er->tps.time) { return 0; }
+	if (!er) return 0;
+	if (!er->tps.time) return 0;
+//	if (!er->parent && !er->client) return 0; // distribute also if no client is set!
+	if (!reader) return 0;
+	mycs_debug(D_ADB, "myecm:write_ecm_answer=%d,%d,%s{%c}.(%d,%d)",
+			 rc, rcEx,
+			(reader) ? reader->label : "unk",
+			(er->client) ? er->client->typ : 'x',
+			 er->ecm_bypass,
+			 er->cwdesalgo);
 
 	// drop too late answers, to avoid seg fault --> only answer until tps.time+((cfg.ctimeout+500)/1000+1) is accepted
+	int cwdesalgo = er->cwdesalgo;
 	time_t timeout = time(NULL) - ((cfg.ctimeout+500)/1000+1);
-	if(er->tps.time < timeout)   //< and NOT <=
-		{ return 0; }
+	if (er->tps.time < timeout) return 0; // < and NOT <=
 
 	int32_t i;
 	uint8_t c;
@@ -1542,21 +1662,58 @@
 		// parent is only set on reader->client->ecmtask[], but we want original er
 		ECM_REQUEST *er_reader_cp = er;
 		er = er->parent;        //Now er is "original" ecm, before it was the reader-copy
+		er->cwdesalgo = cwdesalgo;
 		er_reader_cp->rc = rc;
 		er_reader_cp->idx = 0;
-
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+//		if (!IS_ICS_READERS(reader))
+#endif
+		{
 		timeout = time(NULL) - ((cfg.ctimeout+500)/1000+1);
-		if(er->tps.time < timeout)
-			{ return 0; }
+			if (er->tps.time < timeout) {
+				mycs_trace(D_ADB, "myecm:--- ecm_answer.timeout");
+				return 0;
+			}
+		}
 	}
 
 	struct s_ecm_answer *ea = get_ecm_answer(reader, er);
-	if(!ea) { return 0; }
+	// sky(n)
+	if (!ea)
+	{
+		if (!IS_ICS_READERS(reader)) return 0;
+		mycs_trace(D_ADB, "myecm:--- ecm_answer.none");
+		if (!cs_malloc(&ea, sizeof(struct s_ecm_answer))) return 0;
+		er->matching_rdr = ea;
+		ea->reader 	= reader;
+		ea->er 		= er;
+		ea->rc 		= rc;
+		ea->rcEx 	= rcEx;
+		ea->status  = REQUEST_BYPASS;
+		ea->is_pending = 0;
+	}
 
 	cs_writelock(&ea->ecmanswer_lock);
 
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (IS_ICS_READERS(reader))
+	{
+		if (CSREADER_ChkEcmSkipto(reader, er)) {
+			cs_ftime(&er->tps);
+			ea->status  = REQUEST_BYPASS;
+			mycs_trace(D_ADB, "myecm:--- ecm_answer.useless");
+		}
+		else
 	if((ea->status & REQUEST_ANSWERED))
 	{
+			mycs_trace(D_ADB, "myecm:--- ecm_answer.answered");
+		}
+	}
+	else
+#endif
+	if ((ea->status & REQUEST_ANSWERED))
+	{
+		mycs_trace(D_ADB, "myecm:--- ecm_answer.answered");
 		cs_log_dbg(D_READER, "Reader %s already answer, skip this ecm answer!", reader ? reader->label : "-");
 		cs_writeunlock(&ea->ecmanswer_lock);
 		return 0;
@@ -1576,7 +1733,9 @@
 
 	if(reader && cw && rc < E_NOTFOUND)
 	{
-		if(reader->disablecrccws == 0)
+		mycs_trace(D_ADB, "myecm:--- ecm.dcw{%02x...%02x, %02x...%02x}(%d)", cw[0],cw[7], cw[8],cw[15], er->cwdesalgo);
+		// sky(2016,powervu)
+		if (!er->cwdesalgo && reader->disablecrccws == 0)
 		{
 			for(i = 0; i < 16; i += 4)
 			{
@@ -1628,25 +1787,33 @@
 #ifdef CW_CYCLE_CHECK
 	uint8_t cwc_ct = er->cwc_cycletime > 0 ? er->cwc_cycletime : 0;
 	uint8_t cwc_ncwc = er->cwc_next_cw_cycle < 2 ? er->cwc_next_cw_cycle : 2;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (er->ecm_bypass)
+	{
+	}
+	else
+#endif
 	if(!checkcwcycle(er->client, er, reader, cw, rc, cwc_ct, cwc_ncwc))
 	{
 		rc = E_NOTFOUND;
 		rcEx = E2_WRONG_CHKSUM;
 		cs_log_dbg(D_CACHEEX | D_CWC | D_LB, "{client %s, caid %04X, srvid %04X} [write_ecm_answer] cyclecheck failed! Reader: %s set rc: %i", (er->client ? er->client->account->usr : "-"), er->caid, er->srvid, reader ? reader->label : "-", rc);
 	}
-	else { cs_log_dbg(D_CACHEEX | D_CWC | D_LB, "{client %s, caid %04X, srvid %04X} [write_ecm_answer] cyclecheck passed! Reader: %s rc: %i", (er->client ? er->client->account->usr : "-"), er->caid, er->srvid, reader ? reader->label : "-", rc); }
+	else {
+		cs_log_dbg(D_CACHEEX | D_CWC | D_LB, "{client %s, caid %04X, srvid %04X} [write_ecm_answer] cyclecheck passed! Reader: %s rc: %i", (er->client ? er->client->account->usr : "-"), er->caid, er->srvid, reader ? reader->label : "-", rc);
+	}
 #endif
 	//END -- SPECIAL CHECKs for rc
 
 
-	ea->status |= REQUEST_ANSWERED;
 	ea->rc = rc;
+	ea->status |= REQUEST_ANSWERED;
 	ea->ecm_time = comp_timeb(&now, &ea->time_request_sent);
-	if(ea->ecm_time < 1) { ea->ecm_time = 1; }  //set ecm_time 1 if answer immediately
+	if (ea->ecm_time<1) ea->ecm_time = 1; //set ecm_time 1 if answer immediately
 	ea->rcEx = rcEx;
-	if(cw) { memcpy(ea->cw, cw, 16); }
-	if(msglog) { memcpy(ea->msglog, msglog, MSGLOGSIZE); }
-
+	if (cw) memcpy(ea->cw, cw, 16);
+	if (cwEx) memcpy(&ea->cwEx, cwEx, sizeof(CWEXTENTION)); // sky(powervu)
+	if (msglog) memcpy(ea->msglog, msglog, MSGLOGSIZE);
 	cs_writeunlock(&ea->ecmanswer_lock);
 
 	struct timeb tpe;
@@ -1658,22 +1825,21 @@
 	//send ea for ecm request
 	int32_t res = 0;
 	struct s_client *cl = er->client;
-	if(check_client(cl))
-	{
+	if (check_client(cl)) {
 		res = 1;
 		add_job(er->client, ACTION_ECM_ANSWER_READER, ea, 0); //chk_dcw
 	}
 
 	//distribute ea for pendings
-	if(ea->pending)  //has pending ea
-		{ distribute_ea(ea); }
-
+	if (ea->pending) { // has pending ea
+		distribute_ea(ea);
+	}
 
 	if(!ea->is_pending)   //not for pending ea - only once for ea
 	{
 		//cache update
 		if(ea && ea->rc < E_NOTFOUND && ea->cw)
-			add_cache_from_reader(er, reader, er->csp_hash, er->ecmd5, ea->cw, er->caid, er->prid, er->srvid );
+			add_cache_from_reader(er, reader, er->csp_hash, er->ecmd5, ea->cw, &ea->cwEx, er->caid, er->prid, er->srvid );
 
 		//readers stats for LB
 		send_reader_stat(reader, er, ea, ea->rc);
@@ -1686,36 +1852,45 @@
 		//Update reader stats:
 		if(ea->rc == E_FOUND)
 		{
-			if(cfg.cwlogdir != NULL)
-				{ logCWtoFile(er, ea->cw); } /* CWL logging only if cwlogdir is set in config */
-
+#if defined(WITH_HISILICON)
+			//
+			// UNAVIALABLE...
+			//
+#else
+			if (cfg.cwlogdir != NULL) {
+				logCWtoFile(er, ea->cw); /* CWL logging only if cwlogdir is set in config */
+			}
+#endif
 			reader->ecmsok++;
 #ifdef CS_CACHEEX
 			struct s_client *eacl = reader->client;
-			if(cacheex_reader(reader) && check_client(eacl))
-			{
+			if (cacheex_reader(reader) && check_client(eacl)) {
 				eacl->cwcacheexgot++;
 				cacheex_add_stats(eacl, ea->er->caid, ea->er->srvid, ea->er->prid, 1);
 				first_client->cwcacheexgot++;
 			}
 #endif
 		}
-		else if(ea->rc == E_NOTFOUND)
-		{
+		else if (ea->rc == E_NOTFOUND) {
 			reader->ecmsnok++;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+			if (IS_ICS_READERS(reader)) {
+			}
+			else
+#endif
 			if(reader->ecmnotfoundlimit && reader->ecmsnok >= reader->ecmnotfoundlimit)
 			{
 				rdr_log(reader, "ECM not found limit reached %u. Restarting the reader.",
 						reader->ecmsnok);
 				reader->ecmsnok = 0; // Reset the variable
 				reader->ecmshealthnok = 0; // Reset the variable
+				MYECM_TRACE("myecm:action_reader_restart.%d\n", reader->ecmnotfoundlimit);
 				add_job(reader->client, ACTION_READER_RESTART, NULL, 0);
 			}
 		}
 
 		//Reader ECMs Health Try (by Pickser)
-		if(reader->ecmsok != 0 || reader->ecmsnok != 0)
-		{
+		if (reader->ecmsok != 0 || reader->ecmsnok != 0) {
 			reader->ecmshealthok = ((double) reader->ecmsok / (reader->ecmsok + reader->ecmsnok)) * 100;
 			reader->ecmshealthnok = ((double) reader->ecmsnok / (reader->ecmsok + reader->ecmsnok)) * 100;
 		}
@@ -1723,6 +1898,11 @@
 		if(rc == E_FOUND && reader->resetcycle > 0)
 		{
 			reader->resetcounter++;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+			if (IS_ICS_READERS(reader)) {
+			}
+			else
+#endif
 			if(reader->resetcounter > reader->resetcycle)
 			{
 				reader->resetcounter = 0;
@@ -1741,18 +1921,37 @@
 	uint16_t last_hope = 0;
 
 	// viaccess - check by provid-search
-	if((er->prid = chk_provid(er->ecm, 0x500)))
-		{ er->caid = 0x500; }
-
+	if ((er->prid = chk_ecm_provid(er->ecm, 0x500))) {
+		er->caid = 0x500;
+	}
 	// nagra
 	// is ecm[1] always 0x30 ?
 	// is ecm[3] always 0x07 ?
-	if((er->ecm[6] == 1) && (er->ecm[4] == er->ecm[2] - 2))
-		{ er->caid = 0x1801; }
+	// sky(emu)
+//	if ((er->ecm[6]==1) && (er->ecm[4]==er->ecm[2]-2)) {
+//		er->caid = 0x1801;
+//	}
+	if ((er->ecm[3]==0x07) && (er->ecm[4]==er->ecm[2]-2)) {
+		if (er->ecmlen == 0x91) er->caid=0x183D;
+		else if (er->ecmlen == 0x8E) er->caid=0x1810;
+		else if (er->ecmlen == 0x92) er->caid=0x1803;
+		else er->caid=0x1801;
+	}
+	// sky(emu)
+	if ((er->ecm[1]== 0x70) && (er->ecm[3] == 0x70)) {
+		if (er->ecmlen==0x6C) er->caid = 0x0b01;
+		else er->caid = 0x0b00;
+	}
 
 	// seca2 - very poor
-	if((er->ecm[8] == 0x10) && ((er->ecm[9] & 0xF1) == 1))
-		{ last_hope = 0x100; }
+	if ((er->ecm[8]==0x10) && ((er->ecm[9]&0xF1)==1)) {
+		last_hope = 0x100;
+	}
+	// sky(emu)
+	if ((er->ecm[5] <0x02) && (er->ecmlen==0x64)) {
+		er->caid = 0x100;
+		er->prid = chk_ecm_provid(er->ecm, 0x100);
+	}
 
 	// is cryptoworks, but which caid ?
 	if((er->ecm[3] == 0x81) && (er->ecm[4] == 0xFF) &&
@@ -1762,22 +1961,42 @@
 	}
 
 	if(!er->caid && er->ecm[2] == 0x31 && er->ecm[0x0b] == 0x28)
-		{ guess_irdeto(er); }
+		guess_irdeto(er);
 
 	if(!er->caid)  // guess by len ..
-		{ er->caid = len4caid[er->ecm[2] + 3]; }
+		er->caid = len4caid[er->ecm[2] + 3];
 
 	if(!er->caid)
-		{ er->caid = last_hope; }
+		er->caid = last_hope;
 }
 
 //chid calculation from module stat to here
 //to improve the quickfix concerning ecm chid info and extend it to all client requests wereby the chid is known in module stat
+// sky()
+uint32_t get_ecm_subid(uint8_t *ecm, uint16_t caid)
+{
+	if (!ecm) return 0;
+
+	uint32_t id = 0;
+	switch (caid>>8)
+	{
+		case 0x01: id = b2i(2, ecm+ 7); break; // seca
+		case 0x05: id = b2i(2, ecm+ 8); break; // viaccess
+		case 0x06: id = b2i(2, ecm+ 6); break; // irdeto
+		case 0x09: id = b2i(2, ecm+11); break; // videoguard
+		case 0x4A: // DRE-Crypt, Bulcrypt, Tongfang and others?
+			if (!(caid == 0x4AEE)) // Bulcrypt excluded for now
+				id = b2i(2, ecm+6);
+			break;
+	}
+	return id;
+}
 
 uint32_t get_subid(ECM_REQUEST *er)
 {
-	if(!er->ecmlen)
-		{ return 0; }
+	if (!er) return 0;
+	if (!er->ecmlen) return 0;
+	if ( er->ecm_bypass) return 0x10000;
 
 	uint32_t id = 0;
 	switch(er->caid >> 8)
@@ -1798,6 +2017,10 @@
 		if(!caid_is_bulcrypt(er->caid))
 			{ id = b2i(2, er->ecm + 6); }
 		break;
+		// sky(a,vidpid)
+	   case 0x26:
+		   id = b2i(2, er->ecm + 5);
+		   break; // videoguard
 	}
 	return id;
 }
@@ -1849,14 +2072,13 @@
 	{
 #ifdef CS_CACHEEX
 		if(ecm->cacheex_src)      //from cacheex or csp
-			{
-				er->rc = E_CACHEEX;
-			}
+			{ er->rc = E_CACHEEX; }
 		else
 #endif
 			{ er->rc=E_CACHE1; }      //from normal readers
 
 		memcpy(er->cw, ecm->cw, 16);
+		memcpy(&er->cwEx, &ecm->cwEx, sizeof(CWEXTENTION));
 		er->selected_reader = ecm->selected_reader;
 		er->cw_count = ecm->cw_count;
 
@@ -1865,7 +2087,8 @@
 			er->cacheex_src = ecm->cacheex_src;
 			er->cwc_cycletime = ecm->cwc_cycletime;
 			er->cwc_next_cw_cycle = ecm->cwc_next_cw_cycle;
-		}else{
+		}
+		else {
 			er->cacheex_src = NULL;
 	    }
 
@@ -1890,15 +2113,17 @@
 
 		if(rc_orig == E_UNHANDLED)
 		{
-			cs_log_dbg(D_LB,"{client %s, caid %04X, prid %06X, srvid %04X} [write_ecm_answer_fromcache] found cw in CACHE (count %d)!", (check_client(er->client)?er->client->account->usr:"-"),er->caid, er->prid, er->srvid, er->cw_count);
+			cs_log_dbg(D_LB,"{client %s, caid %04X, prid %06X, srvid %04X} [write_ecm_answer_fromcache] found cw in CACHE (count %d)!",
+							(check_client(er->client)?er->client->account->usr:"-"), er->caid, er->prid, er->srvid, er->cw_count);
 			send_dcw(er->client, er);
 		}
 	}
 }
 
-void get_cw(struct s_client *client, ECM_REQUEST *er)
+
+bool get_cw(struct s_client *client, ECM_REQUEST *er)
 {
-	cs_log_dump_dbg(D_ATR, er->ecm, er->ecmlen, "get cw for ecm:");
+//	cs_log_dump_dbg(D_ATR, er->ecm, er->ecmlen, "get cw for ecm:");
 	cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [get_cw] NEW REQUEST!", (check_client(er->client) ? er->client->account->usr : "-"), er->caid, er->prid, er->srvid);
 	increment_n_request(client);
 
@@ -1906,10 +2131,11 @@
 	time_t now = time((time_t *)0);
 	uint32_t line = 0;
 
+	mycs_trace(D_ADB, "myecm:get_cw{%c,%d}", client->typ, er->ecm_bypass);
 	er->client = client;
 	er->rc = E_UNHANDLED; // set default rc status to unhandled
 	er->cwc_next_cw_cycle = 2; //set it to: we dont know
-	if(now - client->lastecm > cfg.hideclient_to) { client->lastswitch = 0; }       // user was on freetv or didn't request for some time so we reset lastswitch to get correct stats/webif display
+	if (now - client->lastecm > cfg.hideclient_to) client->lastswitch = 0;	// user was on freetv or didn't request for some time so we reset lastswitch to get correct stats/webif display
 	client->lastecm = now;
 
 	if(client == first_client || !client ->account || client->account == first_client->account)
@@ -1939,9 +2165,9 @@
 	}
 
 
-	if(!er->caid)
-		{ guess_cardsystem(er); }
-
+	if (!er->caid) {
+		guess_cardsystem(er);
+	}
 	/* Quickfix Area */
 
 	// add chid for all client requests as in module stat
@@ -1963,12 +2189,10 @@
 	//betacrypt ecm with nagra header
 	if(chk_is_betatunnel_caid(er->caid) == 1 && (er->ecmlen == 0x89 || er->ecmlen == 0x4A) && er->ecm[3] == 0x07 && (er->ecm[4] == 0x84 || er->ecm[4] == 0x45))
 	{
-		if(er->caid == 0x1702)
-		{
+		if (er->caid == 0x1702) {
 			er->caid = 0x1833;
 		}
-		else
-		{
+		else {
 			check_lb_auto_betatunnel_mode(er);
 		}
 		cs_log_dbg(D_TRACE, "Quickfix remap beta->nagra: 0x%X, 0x%X, 0x%X, 0x%X", er->caid, er->ecmlen, er->ecm[3], er->ecm[4]);
@@ -1977,12 +2201,10 @@
 	//nagra ecm with betacrypt header 1801, 1833, 1834, 1835
 	if(chk_is_betatunnel_caid(er->caid) == 2 && (er->ecmlen == 0x93 || er->ecmlen == 0x54) && er->ecm[13] == 0x07 && (er->ecm[14] == 0x84 || er->ecm[14] == 0x45))
 	{
-		if(er->caid == 0x1833)
-		{
+		if (er->caid == 0x1833) {
 			er->caid = 0x1702;
 		}
-		else
-		{
+		else {
 			er->caid = 0x1722;
 		}
 		cs_log_dbg(D_TRACE, "Quickfix remap nagra->beta: 0x%X, 0x%X, 0x%X, 0x%X", er->caid, er->ecmlen, er->ecm[13], er->ecm[44]);
@@ -1990,18 +2212,15 @@
 
 	//Ariva quickfix (invalid nagra provider)
 	if(((er->caid & 0xFF00) == 0x1800) && er->prid > 0x00FFFF)
-		{ er->prid = 0; }
+		er->prid = 0;
 
 	//Check for invalid provider, extract provider out of ecm:
-	uint32_t prid = chk_provid(er->ecm, er->caid);
-	if(!er->prid)
-	{
+	uint32_t prid = chk_ecm_provid(er->ecm, er->caid);
+	if (!er->prid) {
 		er->prid = prid;
 	}
-	else
-	{
-		if(prid && prid != er->prid)
-		{
+	else {
+		if (prid && prid != er->prid) {
 			cs_log_dbg(D_TRACE, "provider fixed: %04X:%06X to %04X:%06X", er->caid, er->prid, er->caid, prid);
 			er->prid = prid;
 		}
@@ -2009,17 +2228,15 @@
 
 #ifdef MODULE_NEWCAMD
 	// Set providerid for newcamd clients if none is given
-	if(!er->prid && client->ncd_server)
-	{
+	if (!er->prid && client->ncd_server) {
 		int32_t pi = client->port_idx;
 		if(pi >= 0 && cfg.ncd_ptab.nports && cfg.ncd_ptab.nports >= pi && cfg.ncd_ptab.ports[pi].ncd)
-			{ er->prid = cfg.ncd_ptab.ports[pi].ncd->ncd_ftab.filts[0].prids[0]; }
+			er->prid = cfg.ncd_ptab.ports[pi].ncd->ncd_ftab.filts[0].prids[0];
 	}
 #endif
 
 	// CAID not supported or found
-	if(!er->caid)
-	{
+	if (!er->caid) {
 		er->rc = E_INVALID;
 		er->rcEx = E2_CAID;
 		snprintf(er->msglog, MSGLOGSIZE, "CAID not supported or found");
@@ -2027,7 +2244,7 @@
 
 	// user expired
 	if(client->expirationdate && client->expirationdate < client->lastecm)
-		{ er->rc = E_EXPDATE; }
+		er->rc = E_EXPDATE;
 
 	// out of timeframe
 	if(client->allowedtimeframe[0] && client->allowedtimeframe[1])
@@ -2045,18 +2262,15 @@
 	}
 
 	// user disabled
-	if(client->disabled != 0)
-	{
-		if(client->failban & BAN_DISABLED)
-		{
+	if (client->disabled != 0) {
+		if (client->failban & BAN_DISABLED) {
 			cs_add_violation(client, client->account->usr);
 			cs_disconnect_client(client);
 		}
 		er->rc = E_DISABLED;
 	}
 
-	if(!chk_global_whitelist(er, &line))
-	{
+	if (!chk_global_whitelist(er, &line)) {
 		debug_ecm(D_TRACE, "whitelist filtered: %s (%s) line %d", username(client), buf, line);
 		er->rc = E_INVALID;
 	}
@@ -2079,24 +2293,21 @@
 		if(i != client->last_srvid || !client->lastswitch)
 		{
 			if(cfg.usrfileflag)
-				{ cs_statistics(client); }
+				cs_statistics(client);
 			client->lastswitch = now;
 		}
 
 		// user sleeping
 		if(client->tosleep && (now - client->lastswitch > client->tosleep))
 		{
-			if(client->failban & BAN_SLEEPING)
-			{
+			if (client->failban & BAN_SLEEPING) {
 				cs_add_violation(client, client->account->usr);
 				cs_disconnect_client(client);
 			}
-			if(client->c35_sleepsend != 0)
-			{
+			if (client->c35_sleepsend != 0) {
 				er->rc = E_STOPPED; // send sleep command CMD08 {00 255}
 			}
-			else
-			{
+			else {
 				er->rc = E_SLEEPING;
 			}
 		}
@@ -2108,17 +2319,15 @@
 
 		for(j = 0; (j < 6) && (er->rc >= E_UNHANDLED); j++)
 		{
-			switch(j)
-			{
+			switch (j) {
 			case 0:
 				// fake (uniq)
 				if(client->dup)
-					{ er->rc = E_FAKE; }
+					er->rc = E_FAKE;
 				break;
 			case 1:
 				// invalid (caid)
-				if(!chk_bcaid(er, &client->ctab))
-				{
+				if (!chk_bcaid(er, &client->ctab)) {
 					er->rc = E_INVALID;
 					er->rcEx = E2_CAID;
 					snprintf(er->msglog, MSGLOGSIZE, "invalid caid 0x%04X", er->caid);
@@ -2127,10 +2336,8 @@
 			case 2:
 				// invalid (srvid)
 				// matching srvids (or 0000) specified in betatunnel will bypass this filter
-				if(!chk_srvid(client, er))
-				{
-					if(!chk_on_btun(SRVID_ZERO, client, er))
-					{
+				if (!chk_srvid(client, er)) {
+					if (!chk_on_btun(SRVID_ZERO, client, er)) {
 						er->rc = E_INVALID;
 						snprintf(er->msglog, MSGLOGSIZE, "invalid SID");
 					}
@@ -2139,24 +2346,23 @@
 			case 3:
 				// invalid (ufilters)
 				if(!chk_ufilters(er))
-					{ er->rc = E_INVALID; }
+					er->rc = E_INVALID;
 				break;
 			case 4:
 				// invalid (sfilter)
 				if(!chk_sfilter(er, &get_module(client)->ptab))
-					{ er->rc = E_INVALID; }
+					er->rc = E_INVALID;
 				break;
 			case 5:
 				// corrupt
 				if((i = er->ecmlen - ecm_len))
 				{
-					if(i > 0)
-					{
+					if (i > 0) {
 						cs_log_dbg(D_TRACE, "warning: ecm size adjusted from %d to %d", er->ecmlen, ecm_len);
 						er->ecmlen = ecm_len;
 					}
 					else
-						{ er->rc = E_CORRUPT; }
+						er->rc = E_CORRUPT;
 				}
 				break;
 			}
@@ -2170,11 +2376,10 @@
 	}
 
 	//not continue, send rc to client
-	if(er->rc < E_UNHANDLED)
-	{
+	if (er->rc < E_UNHANDLED) {
 		send_dcw(client, er);
-		free_ecm(er);
-		return;
+		ecm_free(er);
+		return 1;
 	}
 
 
@@ -2223,8 +2428,8 @@
 		if(!cs_malloc(&wfc, sizeof(struct s_write_from_cache)))
 		{
 			NULLFREE(ecm);
-			free_ecm(er);
-			return;
+			ecm_free(er);
+			return 0;
 		}
 
 		wfc->er_new = er;
@@ -2232,9 +2437,9 @@
 		write_ecm_answer_fromcache(wfc);
 		NULLFREE(wfc);
 		NULLFREE(ecm);
-	  	free_ecm(er);
+	  	ecm_free(er);
 
-		return;
+		return 1;
 	}
 
 
@@ -2254,6 +2459,11 @@
 
 	struct s_ecm_answer *ea, *prv = NULL;
 	struct s_reader *rdr;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	struct s_reader *csxReader = NULL;
+	bool	 csxrequest = 0, csxskip = 0;
+	bool	 csxcascade = 0, csxonly = 0;
+#endif
 
 	cs_readlock(&readerlist_lock);
 	cs_readlock(&clientlist_lock);
@@ -2261,7 +2471,7 @@
 	for(rdr = first_active_reader; rdr; rdr = rdr->next)
 	{
 		uint8_t is_fallback = chk_is_fixed_fallback(rdr, er);
-		int8_t match = matching_reader(er, rdr);
+		int8_t match = matching_reader(er, rdr, 2);
 
 		if(!match) // if this reader does not match, check betatunnel for it
 			match = lb_check_auto_betatunnel(er, rdr);
@@ -2274,19 +2483,31 @@
 			if(cacheex == 1 && !cacheex_reader(rdr))  //ex1-cl only ask ex1-rdr
 				{ continue; }
 #endif
+			mycs_trace(D_ADB, "myecm:--- match reader{%s}", rdr->label);
+			if (!cs_malloc(&ea, sizeof(struct s_ecm_answer))) goto OUT;
 
-			if(!cs_malloc(&ea, sizeof(struct s_ecm_answer)))
-				{ goto OUT; }
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+			if (IS_ICS_READERS(rdr)) {
+				if (IS_XCAMD_READERS(rdr)) csxReader = rdr;
+				csxonly = 1;
+			}
+			else csxcascade = 1;
 
+			if (CSREADER_ChkEcmSkipto(rdr, er)) {
+				mycs_trace(D_ADB, "myecm:--- %s.ecm_skip", rdr->label);
+				csxskip = 1;
+			}
+			else csxrequest = 1;
+#endif
 			er->readers++;
 
 			ea->reader = rdr;
 			ea->er = er;
 			ea->rc = E_UNHANDLED;
 			if(prv)
-				{ prv->next = ea; }
+			   prv->next = ea;
 			else
-				{ er->matching_rdr = ea; }
+			   er->matching_rdr = ea;
 			prv = ea;
 
 			ea->status = READER_ACTIVE;
@@ -2341,15 +2562,23 @@
 			 * If readers, we have to wait cws generating by normal clients asking normal readers and answers by ex1-rdr (cannot use hitcache).
 			 * If no readers, use hitcache for calculating wait_time.
 			 */
-			(cacheex == 1 && er->reader_avail)
-		)
-			{ cacheex_wait_time = wait_time_no_hitcache; }
-		else
-			{ cacheex_wait_time = wait_time_hitcache; }
+		   (cacheex==1 && er->reader_avail))
+	   {
+		   cacheex_wait_time = wait_time_no_hitcache;
+	   }
+	   else {
+		   cacheex_wait_time = wait_time_hitcache;
+	   }
 	}
 
-	cs_log_dbg(D_TRACE | D_CACHEEX, "[GET_CW] wait_time %d caid %04X prov %06X srvid %04X rc %d cacheex cl mode %d ex1rdr %d", cacheex_wait_time, er->caid, er->prid, er->srvid, er->rc, cacheex, er->cacheex_reader_count);
-	cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [get_cw] wait_time %d - client cacheex mode %d, reader avail for ecm %d, hitcache %d, preferlocalcards %d", (check_client(er->client) ? er->client->account->usr : "-"), er->caid, er->prid, er->srvid, cacheex_wait_time, cacheex == 1 ? 1 : 0, er->reader_avail, wait_time_hitcache ? 1 : 0, er->preferlocalcards);
+	cs_log_dbg(D_TRACE | D_CACHEEX, "[GET_CW] wait_time %d caid %04X prov %06X srvid %04X rc %d cacheex cl mode %d ex1rdr %d",
+				cacheex_wait_time, er->caid, er->prid, er->srvid, er->rc, cacheex, er->cacheex_reader_count);
+	cs_log_dbg(D_LB,"{client %s, caid %04X, prid %06X, srvid %04X} [get_cw] wait_time %d - client cacheex mode %d, reader avail for ecm %d, hitcache %d",
+				(check_client(er->client) ? er->client->account->usr : "-"),
+				er->caid, er->prid, er->srvid, cacheex_wait_time,
+				cacheex==1 ? 1 : 0,
+				er->reader_avail,
+				wait_time_hitcache ? 1 : 0);
 	//END WAIT_TIME calculation
 
 	if(!cacheex_wait_time && (er->reader_count + er->fallback_reader_count) == 0)
@@ -2358,15 +2587,34 @@
 #endif
 	{
 		er->rc = E_NOTFOUND;
-		if(!er->rcEx)
-			{ er->rcEx = E2_GROUP; }
+		if (!er->rcEx) er->rcEx = E2_GROUP;
 		snprintf(er->msglog, MSGLOGSIZE, "no matching reader");
-		cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [get_cw] NO Readers and NO wait_time... not_found! ", (check_client(er->client) ? er->client->account->usr : "-"), er->caid, er->prid, er->srvid);
+		cs_log_dbg(D_LB,"{client %s, caid %04X, prid %06X, srvid %04X} [get_cw] NO Readers and NO wait_time... not_found! ",
+					(check_client(er->client) ? er->client->account->usr : "-"),
+					er->caid, er->prid, er->srvid);
 		send_dcw(client, er);
-		free_ecm(er);
-		return;
+		ecm_free(er);
+		return 1;
 	}
 
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	er->ecm_cssolo = (!csxcascade && csxonly) ? 1 : 0;
+	if (!csxrequest && csxskip)
+	{
+		int nextto = 0;
+		mycs_trace(D_ADB, "myecm:    get_cw ecm.useless{%d,%d}", er->rc, er->ecm_cssolo);
+		er->rc = E_USELESS /* E_99 */;
+		er->stage = 4;
+		er->ecm_useless = 1;
+		nextto = CSREADER_ChkEcmNextto(csxReader, er);
+		if (nextto) {
+			mycs_trace(D_ADB, "myecm:### xcamd.nextto{%d}", nextto);
+			dvbapi_try_stop_caid(er->chSets.muxid, 0);
+		}
+		ecm_free(er);
+		return 0;
+	}
+#endif
 
 	//insert it in ecmcwcache!
 	cs_writelock(&ecmcache_lock);
@@ -2397,12 +2645,12 @@
 	}
 	else
 #endif
+	{
 		request_cw_from_readers(er, 0);
-
+	}
 
 #ifdef WITH_DEBUG
-	if(D_CLIENTECM & cs_dblevel)
-	{
+	if (D_CLIENTECM & cs_dblevel) {
 		char buf[ECM_FMT_LEN];
 		format_ecm(er, buf, ECM_FMT_LEN);
 		cs_log_dump_dbg(D_CLIENTECM, er->ecm, er->ecmlen, "Client %s ECM dump %s", username(client), buf);
@@ -2410,101 +2658,57 @@
 #endif
 
 	cw_process_thread_wakeup();
+	return 1;
 }
 
 
 int32_t ecmfmt(uint16_t caid, uint16_t onid, uint32_t prid, uint16_t chid, uint16_t pid, uint16_t srvid, uint16_t l, char *ecmd5hex, char *csphash, char *cw, char *result, size_t size, uint16_t origin_peer, uint8_t distance)
 {
 	if(!cfg.ecmfmt)
-		{ return snprintf(result, size, "%04X&%06X/%04X/%04X/%02X:%s", caid, prid, chid, srvid, l, ecmd5hex); }
+		return snprintf(result, size, "%04X&%06X/%04X/%04X/%02X:%s", caid, prid, chid, srvid, l, ecmd5hex);
 
 	uint32_t s = 0, zero = 0, flen = 0, value = 0;
 	char *c = cfg.ecmfmt, fmt[5] = "%04X";
-	while(*c)
-	{
-		switch(*c)
-		{
-		case '0':
-			zero = 1;
-			value = 0;
-			break;
-		case 'c':
-			flen = 4;
-			value = caid;
-			break;
-		case 'o':
-			flen = 4;
-			value = onid;
-			break;
-		case 'p':
-			flen = 6;
-			value = prid;
-			break;
-		case 'i':
-			flen = 4;
-			value = chid;
-			break;
-		case 'd':
-			flen = 4;
-			value = pid;
-			break;
-		case 's':
-			flen = 4;
-			value = srvid;
-			break;
-		case 'l':
-			flen = 2;
-			value = l;
-			break;
-		case 'h':
-			flen = CS_ECMSTORESIZE;
-			break;
-		case 'e':
-			flen = 5;
-			break;
-		case 'w':
-			flen = 17;
-			break;
-		case 'j':
-			flen = 2;
-			value = distance;
-			break;
-		case 'g':
-			flen = 4;
-			value = origin_peer;
-			break;
+	while (*c) {
+		switch (*c) {
+			case '0': zero = 1; value = 0; 	 break;
+			case 'c': flen = 4; value = caid; break;
+			case 'o': flen = 4; value = onid; break;
+			case 'p': flen = 6; value = prid; break;
+			case 'i': flen = 4; value = chid; break;
+			case 'd': flen = 4; value = pid;  break;
+			case 's': flen = 4; value = srvid;break;
+			case 'l': flen = 2; value = l; 	 break;
+			case 'h': flen = CS_ECMSTORESIZE; break;
+			case 'e': flen = 5;  break;
+			case 'w': flen =17; break;
+			case 'j': flen = 2; value = distance; break;
+			case 'g': flen = 4; value = origin_peer; break;
 		case '\\':
 			c++;
 			flen = 0;
 			value = *c;
 			break;
-		default:
-			flen = 0;
-			value = *c;
-			break;
+			default:  flen = 0; value = *c; break;
 		}
-		if(value)
-			{ zero = 0; }
+		if (value) zero = 0;
 
-		if(!zero)
-		{
+		if (!zero) {
 			//fmt[0] = '%';
-			if(flen)    //Build %04X / %06X / %02X
-			{
+			if (flen) { //Build %04X / %06X / %02X
 				fmt[1] = '0';
 				fmt[2] = flen + '0';
 				fmt[3] = 'X';
 				fmt[4] = 0;
 			}
-			else
-			{
+			else {
 				fmt[1] = 'c';
 				fmt[2] = 0;
 			}
-			if(flen == CS_ECMSTORESIZE) { s += snprintf(result + s, size - s , "%s", ecmd5hex); }
-			else if(flen == 5)          { s += snprintf(result + s, size - s , "%s", csphash); }
-			else if(flen == 17)         { s += snprintf(result + s, size - s , "%s", cw); }
-			else                         { s += snprintf(result + s, size - s, fmt, value); }
+			if (flen == CS_ECMSTORESIZE) s += snprintf(result+s, size-s,"%s", ecmd5hex);
+			else if (flen == 5)          s += snprintf(result+s, size-s,"%s", csphash);
+			else if (flen == 17)         s += snprintf(result+s, size-s,"%s", cw);
+			else                         s += snprintf(result+s, size-s, fmt, value);
 		}
 		c++;
 	}
Index: oscam-ecm.h
===================================================================
--- oscam-ecm.h	(revision 10670)
+++ oscam-ecm.h	(working copy)
@@ -6,24 +6,33 @@
 
 void convert_to_beta(struct s_client *cl, ECM_REQUEST *er, uint16_t caidto);
 void convert_to_nagra(struct s_client *cl, ECM_REQUEST *er, uint16_t caidto);
+// sky(quad)
+int32_t write_ecm_answer(struct s_reader * reader, ECM_REQUEST *er, int8_t rc, uint8_t rcEx, uint8_t *cw, CWEXTENTION *cwEx, char *msglog);
 
-int32_t write_ecm_answer(struct s_reader *reader, ECM_REQUEST *er, int8_t rc, uint8_t rcEx, uint8_t *cw, char *msglog);
-
-void get_cw(struct s_client *, ECM_REQUEST *);
+bool get_cw(struct s_client *, ECM_REQUEST *);
 
 void update_chid(ECM_REQUEST *ecm);
 uint32_t get_subid(ECM_REQUEST *er);
-uint32_t chk_provid(uint8_t *ecm, uint16_t caid);
+// sky()
+uint32_t get_ecm_subid (uint8_t *ecm, uint16_t caid);
+uint32_t chk_ecm_provid(uint8_t *ecm, uint16_t caid);
 
 int32_t send_dcw(struct s_client *client, ECM_REQUEST *er);
-void free_ecm(ECM_REQUEST *ecm);
+void ecm_free(ECM_REQUEST *ecm);
 void free_push_in_ecm(ECM_REQUEST *ecm);
 void write_ecm_answer_fromcache(struct s_write_from_cache *wfc);
 void fallback_timeout(ECM_REQUEST *er);
 void ecm_timeout(ECM_REQUEST *er);
 void reader_get_ecm(struct s_reader *reader, ECM_REQUEST *er);
-ECM_REQUEST *get_ecmtask(void);
 struct s_ecm_answer *get_ecm_answer(struct s_reader *reader, ECM_REQUEST *er);
+ECM_REQUEST *get_ecmtask(void);
+// sky(n)
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+ECM_REQUEST *get_ecmtask_clients(struct s_client *cl, uint16_t idx, bool initial);
+int32_t chk_ecmtask_precision_sequence(struct s_client *cl, uint16_t *psequence, uint32_t chksum);
+int32_t chk_ecmtask_precision_clients (struct s_client *cl, uint16_t sequence);
+#endif
+
 void cleanup_ecmtasks(struct s_client *cl);
 void remove_reader_from_ecm(struct s_reader *rdr);
 
Index: oscam-emm.c
===================================================================
--- oscam-emm.c	(revision 10670)
+++ oscam-emm.c	(working copy)
@@ -10,23 +10,27 @@
 #include "oscam-string.h"
 #include "oscam-time.h"
 #include "oscam-work.h"
-#include "reader-common.h"
 #include "oscam-chk.h"
 #include "oscam-emm-cache.h"
+#include "reader-common.h"
+#if defined(MODULE_XCAS)
+#include "module-xcas.h"
+#endif
 
 const char *entitlement_type[] = { "", "package", "PPV-Event", "chid", "tier", "class", "PBM", "admin" };
 
 static int8_t cs_emmlen_is_blocked(struct s_reader *rdr, int16_t len)
 {
 	struct s_emmlen_range *blocklen;
-	if(!rdr->blockemmbylen)
-		{ return 0; }
+	if (!rdr->blockemmbylen) return 0;
 	LL_ITER it = ll_iter_create(rdr->blockemmbylen);
 	while((blocklen = ll_iter_next(&it)))
 	{
 		if(blocklen->min <= len
 				&& (len <= blocklen->max || blocklen->max == 0))
-			{ return 1; }
+		{
+			return 1;
+		}
 	}
 	return 0;
 }
@@ -39,14 +43,14 @@
  */
 static int8_t do_simple_emm_filter(struct s_reader *rdr, const struct s_cardsystem *csystem, EMM_PACKET *ep, int8_t cl_dvbapi)
 {
-	if(is_network_reader(rdr)) { return 1; }  // dont evaluate on network readers, server with local reader will check it
+	if (is_network_reader(rdr)) return 1; // dont evaluate on network readers, server with local reader will check it
 
 	//copied and enhanced from module-dvbapi.c
 	//dvbapi_start_emm_filter()
-	int32_t i, k, match;
-	uint8_t flt, mask;
 	struct s_csystem_emm_filter *dmx_filter = NULL;
 	unsigned int j, filter_count = 0;
+	int32_t i, k, match;
+	uint8_t flt, mask;
 
 	// Call cardsystems emm filter
 	csystem->get_emm_filter(rdr, &dmx_filter, &filter_count);
@@ -63,30 +67,25 @@
 
 	for(j = 0; j < filter_count; j++)
 	{
-		if(dmx_filter[j].enabled == 0)
-			{ continue; }
+		if (dmx_filter[j].enabled == 0) continue;
 
 		uint8_t emmtype = dmx_filter[j].type;
-		if(emmtype != org_emmtype)
-			{ continue; }
+		if (emmtype != org_emmtype) continue;
 
 		match = 1;
 		for(i = 0, k = 0; i < 16 && k < ep->emmlen && match; i++, k++)
 		{
 			mask = dmx_filter[j].mask[i];
 			if(k == 1 && cl_dvbapi)  // fixup for emms send by dvbapi
-				{ k += 2; } //skip emm len bytes
-			if(!mask)
-				{ continue; }
+				k += 2; // skip emm len bytes
+			if (!mask) continue;
 			//cs_log("**** filter %d [%d] = %02X, filter mask[%d] = %02X, flt&mask = %02X , ep->emm[%d] = %02X, ep->emm[%d] & mask = %02X ****", j, i,
 			//  dmx_filter[j].filter[i], i, dmx_filter[j].mask[i], flt&mask, k, ep->emm[k], k, ep->emm[k] & mask);
 			flt = (dmx_filter[j].filter[i] & mask);
 			match = (flt == (ep->emm[k] & mask));
-			if(!match)
-				{ break; }
+			if (!match) break;
 		}
-		if(match)
-		{
+		if (match) {
 			NULLFREE(dmx_filter);
 			return 1; //valid emm
 		}
@@ -99,13 +98,14 @@
 
 static void reader_log_emm(struct s_reader *reader, EMM_PACKET *ep, int32_t count, int32_t rc, struct timeb *tps)
 {
-	char *rtxt[] =
-	{
+	if (!ep) return;
+	if (!reader) return;
+	if (!reader->client) return;
+	char  *rtxt[] = {
 		"error",
-		is_network_reader(reader) ? "sent" : "written",
+				   (is_network_reader(reader)) ? "sent" : "written",
 		"skipped",
-		"blocked"
-	};
+				   "blocked" };
 	char *typedesc[] = { "unknown", "unique", "shared", "global" };
 	struct s_client *cl = reader->client;
 	struct timeb tpe;
@@ -113,35 +113,24 @@
 	if(reader->logemm & (1 << rc))
 	{
 		cs_ftime(&tpe);
-		if(!tps)
-			{ tps = &tpe; }
+		if (!tps) tps = &tpe;
 
 		rdr_log(reader, "%s emmtype=%s, len=%d, cnt=%d: %s (%"PRId64" ms)",
 				username(ep->client), typedesc[ep->type], ep->emm[2], count, rtxt[rc], comp_timeb(&tpe, tps));
 	}
 
-	if(rc)
-	{
+	if (rc) {
 		cl->lastemm = time(NULL);
 		led_status_emm_ok();
 	}
 
 #if defined(WEBIF) || defined(LCDSUPPORT)
 	//counting results
-	switch(rc)
-	{
-	case 0:
-		reader->emmerror[ep->type]++;
-		break;
-	case 1:
-		reader->emmwritten[ep->type]++;
-		break;
-	case 2:
-		reader->emmskipped[ep->type]++;
-		break;
-	case 3:
-		reader->emmblocked[ep->type]++;
-		break;
+	switch (rc) {
+		case 0: reader->emmerror  [ep->type]++; break;
+		case 1: reader->emmwritten[ep->type]++; break;
+		case 2: reader->emmskipped[ep->type]++; break;
+		case 3: reader->emmblocked[ep->type]++; break;
 	}
 #endif
 }
@@ -150,12 +139,20 @@
 {
 	int32_t i;
 
+	if (!reader) return 0;
+	// sky(powervu)
 	// if physical reader a card needs to be inserted
-	if(!is_network_reader(reader) && reader->card_status != CARD_INSERTED)
-		{ return 0; }
-
-	if(reader->audisabled)
-		{ return 0; }
+	if (!is_network_reader(reader) && reader->card_status != CARD_INSERTED) return 0;
+	if (IS_CONSTCW_READERS(reader)) return 0;
+// sky(powervu)
+#if defined(MODULE_XCAS)
+	if (IS_XCAS_READERS(reader)) {
+		if (!xcas_IsAuAvailable(reader, caid, provid)) return 0;
+		return 1;
+	}
+	else
+#endif
+	if (reader->audisabled) return 0;
 
 	if(reader->caid != caid)
 	{
@@ -309,11 +306,13 @@
 	}
 }
 
-void do_emm(struct s_client *client, EMM_PACKET *ep)
+// sky(!)
+bool do_emm(struct s_client *client, EMM_PACKET *ep)
 {
 	char *typtext[] = {"unknown", "unique", "shared", "global"};
 	char tmp[17];
 	int32_t emmnok = 0;
+	int32_t emmsento = 0;
 	bool lastseendone = false;
 
 	struct s_reader *aureader = NULL;
@@ -327,9 +326,6 @@
 	LL_ITER itr = ll_iter_create(client->aureader_list);
 	while((aureader = ll_iter_next(&itr)))
 	{
-		if(!aureader->enable)
-			{ continue; }
-
 		uint16_t caid = b2i(2, ep->caid);
 		uint32_t provid = b2i(4, ep->provid);
 		
@@ -338,6 +334,19 @@
 			 provid &= 0xFFFFF0;
 		}
 		
+
+		if (!aureader->enable) continue;
+		// sky(powervu)
+		if (IS_XCAMD_READERS(aureader)) continue;
+		if (IS_MORECAM_READERS(aureader)) continue;
+		if (IS_CONSTCW_READERS(aureader)) continue;
+// sky(powervu)
+#if defined(MODULE_XCAS)
+		if (IS_XCAS_READERS(aureader)) {
+			if (!xcas_IsAuAvailable(aureader, caid, provid)) continue;
+		}
+		else
+#endif
 		if(aureader->audisabled)
 		{
 			rdr_log_dbg(aureader, D_EMM, "AU is disabled");
@@ -354,34 +363,41 @@
 			continue;
 		}
 
-		if(!(aureader->grp & client->grp))
-		{
+		if (!(aureader->grp & client->grp)) {
+			mycs_trace(D_TRACE, "myemm:skip emm, group mismatch{%lld,%lld}", aureader->grp, client->grp);
 			rdr_log_dbg(aureader, D_EMM, "skip emm, group mismatch");
 			continue;
 		}
 
 		//TODO: provider possibly not set yet, this is done in get_emm_type()
-		if(!emm_reader_match(aureader, caid, provid))
-			{ continue; }
+		if (!emm_reader_match(aureader, caid, provid)) {
+			mycs_trace(D_TRACE, "myemm:skip emm.%s{%04X,%06X}", aureader->label, caid, provid);
+			continue;
+		}
+		emmsento = 1;
 
+		// sky(powervu)
+		int32_t writeemm = 1; // 0= dont write emm, 1=write emm, default = write
 		const struct s_cardsystem *csystem = NULL;
-
-		if(is_network_reader(aureader))    // network reader (R_CAMD35 R_NEWCAMD R_CS378X R_CCCAM)
-		{
-			if(!aureader->ph.c_send_emm)  // no emm support
-				{ continue; }
+// sky(powervu)
+#if defined(MODULE_XCAS)
+		if (IS_XCAS_READERS(aureader)) {
+			if (!xcas_IsEmmAvailable(aureader, ep)) continue;
+			writeemm = -1;
+		}
+		else
+#endif
+		if (is_network_reader(aureader)) { // network reader (R_CAMD35 R_NEWCAMD R_CS378X R_CCCAM)
+			if (!aureader->ph.c_send_emm) continue; // no emm support
 
 			csystem = get_cardsystem_by_caid(caid);
-			if(!csystem)
-			{
+			if (!csystem) {
 				rdr_log_dbg(aureader, D_EMM, "unable to find cardsystem for caid %04X", caid);
 				continue;
 			}
 		}
-		else     // local reader
-		{
-			if(aureader->csystem_active)
-				{ csystem = aureader->csystem; }
+		else { // local reader
+			if (aureader->csystem_active) csystem = aureader->csystem;
 		}
 
 		if(csystem && csystem->get_emm_type)
@@ -389,6 +405,7 @@
 			if(!csystem->get_emm_type(ep, aureader))
 			{
 				rdr_log_dbg(aureader, D_EMM, "emm skipped, get_emm_type() returns error");
+				myprintf("myemm:emm skipped, get_emm_type() returns error\n");
 				emmnok++;
 				continue;
 			}
@@ -396,11 +413,10 @@
 
 		if(!ep->skip_filter_check && csystem && csystem->get_emm_filter)
 		{
-			if(!do_simple_emm_filter(aureader, csystem, ep, 1)) // do check with dvbapi fixup enabled
-			{
-				if(!do_simple_emm_filter(aureader, csystem, ep, 0)) // do check with dvbapi fixup disabled
-				{
+			if (!do_simple_emm_filter(aureader, csystem, ep, 1)) { // do check with dvbapi fixup enabled
+				if (!do_simple_emm_filter(aureader, csystem, ep, 0)) { // do check with dvbapi fixup disabled
 					rdr_log_dbg(aureader, D_EMM, "emm skipped, do_simple_emm_filter() returns invalid");
+					myprintf("myemm:emm skipped, do_simple_emm_filter() returns invalid\n");
 					emmnok++;
 					continue;
 				}
@@ -409,13 +425,10 @@
 
 		if(csystem && csystem->do_emm_reassembly)
 		{
-			if(assemble)
-			{
-				if(!csystem->do_emm_reassembly(aureader, client, ep))
-					{ continue; } // skip this reader
+			if (assemble) {
+				if (!csystem->do_emm_reassembly(aureader, client, ep)) continue; // skip this reader
 			}
-			else
-			{
+			else {
 				rdr_log_dbg(aureader, D_EMM, "processing raw emm");
 			}
 		}
@@ -456,24 +469,15 @@
 			}
 		}
 
-		switch(ep->type)
-		{
-		case UNKNOWN:
-			is_blocked = (aureader->blockemm & EMM_UNKNOWN) == EMM_UNKNOWN;
-			break;
-		case UNIQUE :
-			is_blocked = (aureader->blockemm & EMM_UNIQUE) == EMM_UNIQUE;
-			break;
-		case SHARED :
-			is_blocked = (aureader->blockemm & EMM_SHARED) == EMM_SHARED;
-			break;
-		case GLOBAL :
-			is_blocked = (aureader->blockemm & EMM_GLOBAL) == EMM_GLOBAL;
-			break;
+		switch (ep->type) {
+			case UNKNOWN: is_blocked = (aureader->blockemm & EMM_UNKNOWN) == EMM_UNKNOWN; break;
+			case UNIQUE : is_blocked = (aureader->blockemm & EMM_UNIQUE ) == EMM_UNIQUE;  break;
+			case SHARED : is_blocked = (aureader->blockemm & EMM_SHARED ) == EMM_SHARED;  break;
+			case GLOBAL : is_blocked = (aureader->blockemm & EMM_GLOBAL ) == EMM_GLOBAL;  break;
 		}
 		
 		// if not already blocked we check for block by len
-		if(!is_blocked) { is_blocked = cs_emmlen_is_blocked(aureader, ep->emm[2]) ; }
+		if (!is_blocked) is_blocked = cs_emmlen_is_blocked(aureader, ep->emm[2]);
 
 		if(is_blocked != 0)
 		{
@@ -481,32 +485,30 @@
 			aureader->emmblocked[ep->type]++;
 			is_blocked = aureader->emmblocked[ep->type];
 #endif
+			myprintf("myemm:emm blocked\n");
 			/* we have to write the log for blocked EMM here because
 			 this EMM never reach the reader module where the rest
 			 of EMM log is done. */
-			if(aureader->logemm & 0x08)
-			{
+			if (aureader->logemm & 0x08)  {
 				rdr_log(aureader, "%s emmtype=%s, len=%d, idx=0, cnt=%d: blocked (0 ms)",
 						client->account->usr,
 						typtext[ep->type],
 						ep->emm[2],
 						is_blocked);
 			}
-			saveemm(aureader, ep, "blocked");
+			// sky(powervu)
+			if (writeemm > 0) saveemm(aureader, ep, "blocked");
 			continue;
 		}
 
 		client->lastemm = time((time_t *)0);
 
 		client->emmok++;
-		if(client->account)
-			{ client->account->emmok++; }
+		if (client->account) client->account->emmok++;
 		first_client->emmok++;
 
 		ep->client = client;
 
-		int32_t writeemm = 1; // 0= dont write emm, 1=write emm, default = write
-
 		if(aureader->cachemm) //Check emmcache early:
 		{
 			unsigned char md5tmp[MD5_DIGEST_LENGTH];
@@ -529,7 +531,8 @@
 			{
 				reader_log_emm(aureader, ep, emmstat->count, 2, NULL);
 				writeemm = 0; // dont write emm!
-				saveemm(aureader, ep, "emmcache");
+				// sky(powervu)
+				if (writeemm > 0) saveemm(aureader, ep, "emmcache");
 				continue; // found emm match needs no further handling, proceed with next reader!
 			}
 		}
@@ -542,7 +545,8 @@
 				rdr_log_dbg(aureader, D_EMM, "emm is being sent to reader");
 				memcpy(emm_pack, ep, sizeof(EMM_PACKET));
 				add_job(aureader->client, ACTION_READER_EMM, emm_pack, sizeof(EMM_PACKET));
-				saveemm(aureader, ep, "written");
+				// sky(powervu)
+				if (writeemm > 0) saveemm(aureader, ep, "written");
 			}
 		}
 
@@ -551,10 +555,10 @@
 	if(emmnok > 0 && emmnok == ll_count(client->aureader_list))
 	{
 		client->emmnok++;
-		if(client->account)
-			{ client->account->emmnok++; }
+		if (client->account) client->account->emmnok++;
 		first_client->emmnok++;
 	}
+	return (emmsento);
 }
 
 
@@ -643,33 +647,30 @@
 
 void do_emm_from_file(struct s_reader *reader)
 {
-	if(!reader->emmfile)
-		{ return; }
+	if (!reader) return;
+	if (!reader->emmfile) return;
 
 	char token[256];
 	FILE *fp;
 
 	if(reader->emmfile[0] == '/')
-		{ snprintf(token, sizeof(token), "%s", reader->emmfile); } //pathname included
+		snprintf(token, sizeof(token), "%s", reader->emmfile); //pathname included
 	else
-		{ get_config_filename(token, sizeof(token), reader->emmfile); } //only file specified, look in confdir for this file
+		get_config_filename(token, sizeof(token), reader->emmfile); //only file specified, look in confdir for this file
 
-	if(!(fp = fopen(token, "rb")))
-	{
+	if (!(fp = fopen (token, "rb"))) {
 		rdr_log(reader, "ERROR: Cannot open EMM file '%s' (errno=%d %s)\n", token, errno, strerror(errno));
 		return;
 	}
 
 	EMM_PACKET *eptmp;
-	if(!cs_malloc(&eptmp, sizeof(EMM_PACKET)))
-	{
+	if (!cs_malloc(&eptmp, sizeof(EMM_PACKET))) {
 		fclose(fp);
 		return;
 	}
 
 	size_t ret = fread(eptmp, sizeof(EMM_PACKET), 1, fp);
-	if(ret < 1 && ferror(fp))
-	{
+	if (ret < 1 && ferror(fp)) {
 		rdr_log(reader, "ERROR: Can't read EMM from file '%s' (errno=%d %s)", token, errno, strerror(errno));
 		NULLFREE(eptmp);
 		fclose(fp);
@@ -725,10 +726,8 @@
 		for(j = 0; j < len;)
 		{
 			int32_t l = src[j + 1] + 2;
-			if(src[j] == c)
-			{
-				if(w + l > len)
-				{
+			if (src[j] == c) {
+				if (w + l > len) {
 					cs_log_dbg(D_EMM, "sortnanos: sanity check failed. Exceeding memory area. Probably corrupted nanos!");
 					memset(dest, 0, len); // zero out everything
 					return;
@@ -736,14 +735,12 @@
 				memcpy(&dest[w], &src[j], l);
 				w += l;
 			}
-			else if(src[j] > c && src[j] < n)
-			{
+			else if (src[j] > c && src[j] < n) {
 				n = src[j];
 			}
 			j += l;
 		}
-		if(n >= 256)
-			{ break; }
+		if (n >= 256) break;
 		c = n;
 	}
 }
Index: oscam-emm.h
===================================================================
--- oscam-emm.h	(revision 10670)
+++ oscam-emm.h	(working copy)
@@ -2,7 +2,7 @@
 #define OSCAM_EMM_H_
 
 int32_t emm_reader_match(struct s_reader *reader, uint16_t caid, uint32_t provid);
-void do_emm(struct s_client *client, EMM_PACKET *ep);
+bool 	  do_emm(struct s_client *client, EMM_PACKET *ep);
 int32_t reader_do_emm(struct s_reader *reader, EMM_PACKET *ep);
 void do_emm_from_file(struct s_reader *reader);
 void emm_sort_nanos(unsigned char *dest, const unsigned char *src, int32_t len);
Index: oscam-files.c
===================================================================
--- oscam-files.c	(revision 10670)
+++ oscam-files.c	(working copy)
@@ -13,26 +13,30 @@
 char *get_tmp_dir(void)
 {
 	if(cs_tmpdir[0])
-		{ return cs_tmpdir; }
+		return cs_tmpdir;
 #if defined(__CYGWIN__)
 	char *d = getenv("TMPDIR");
 	if(!d || !d[0])
-		{ d = getenv("TMP"); }
+		d = getenv("TMP");
 	if(!d || !d[0])
-		{ d = getenv("TEMP"); }
+		d = getenv("TEMP");
 	if(!d || !d[0])
-		{ getcwd(cs_tmpdir, sizeof(cs_tmpdir) - 1); }
+		getcwd(cs_tmpdir, sizeof(cs_tmpdir)-1);
 
 	cs_strncpy(cs_tmpdir, d, sizeof(cs_tmpdir));
 	char *p = cs_tmpdir;
-	while(*p) { p++; }
+	while (*p) p++;
 	p--;
 	if(*p != '/' && *p != '\\')
-		{ strcat(cs_tmpdir, "/"); }
+		strcat(cs_tmpdir, "/");
 	strcat(cs_tmpdir, "_oscam");
 #else
+#if defined(WITH_HISILICON)
+	cs_strncpy(cs_tmpdir, "/var", sizeof(cs_tmpdir));
+#else
 	cs_strncpy(cs_tmpdir, "/tmp/.oscam", sizeof(cs_tmpdir));
 #endif
+#endif
 	mkdir(cs_tmpdir, S_IRWXU);
 	return cs_tmpdir;
 }
@@ -41,7 +45,7 @@
 {
 	char *tmp_dir = get_tmp_dir();
 	const char *slash = "/";
-	if(tmp_dir[strlen(tmp_dir) - 1] == '/') { slash = ""; }
+	if (tmp_dir[strlen(tmp_dir) - 1] == '/') slash = "";
 	snprintf(dest, destlen, "%s%s%s", tmp_dir, slash, filename);
 	return dest;
 }
@@ -58,8 +62,7 @@
 	errno = 0;
 	*result = readdir(dirp);
 	rc = errno;
-	if(errno == 0 && *result != NULL)
-	{
+	if (errno == 0 && *result != NULL) {
 		memcpy(entry, *result, sizeof(struct dirent));
 		*result = entry;
 	}
@@ -79,30 +82,24 @@
 	FILE *src, *dest;
 	int32_t ch;
 	src = fopen(srcfile, "r");
-	if(!src)
-	{
+	if (!src) {
 		cs_log("Error opening file %s for reading (errno=%d %s)!", srcfile, errno, strerror(errno));
 		return -1;
 	}
 	dest = fopen(destfile, "w");
-	if(!dest)
-	{
+	if (!dest) {
 		cs_log("Error opening file %s for writing (errno=%d %s)!", destfile, errno, strerror(errno));
 		fclose(src);
 		return -1;
 	}
-	while(1)
-	{
+	while (1) {
 		ch = fgetc(src);
-		if(ch == EOF)
-		{
+		if (ch==EOF) {
 			break;
 		}
-		else
-		{
+		else {
 			fputc(ch, dest);
-			if(ferror(dest))
-			{
+			if (ferror(dest)) {
 				cs_log("Error while writing to file %s (errno=%d %s)!", destfile, errno, strerror(errno));
 				fclose(src);
 				fclose(dest);
@@ -119,30 +116,26 @@
 int32_t safe_overwrite_with_bak(char *destfile, char *temp_file, char *bakfile, int32_t forceBakOverWrite)
 {
 	int32_t rc;
-	if(file_exists(destfile))
-	{
-		if(forceBakOverWrite != 0 || !file_exists(bakfile))
-		{
-			if(file_copy(destfile, bakfile) < 0)
-			{
+	if (file_exists(destfile)) {
+		if (forceBakOverWrite != 0 || !file_exists(bakfile)) {
+			if (file_copy(destfile, bakfile) < 0) {
 				cs_log("Error copying original config file %s to %s. The original config will be left untouched!", destfile, bakfile);
 				if(unlink(temp_file) < 0)
-					{ cs_log("Error removing temp config file %s (errno=%d %s)!", temp_file, errno, strerror(errno)); }
+					cs_log("Error removing temp config file %s (errno=%d %s)!", temp_file, errno, strerror(errno));
 				return 1;
 			}
 		}
 	}
 	rc = file_copy(temp_file, destfile);
-	if(rc < 0)
-	{
+	if (rc < 0) {
 		cs_log("An error occured while writing the new config file %s.", destfile);
 		if(rc == -2)
-			{ cs_log("The config will be missing or only partly filled upon next startup as this is a non-recoverable error! Please restore from backup or try again."); }
+			cs_log("The config will be missing or only partly filled upon next startup as this is a non-recoverable error! Please restore from backup or try again.");
 		if(unlink(temp_file) < 0)
-			{ cs_log("Error removing temp config file %s (errno=%d %s)!", temp_file, errno, strerror(errno)); }
+			cs_log("Error removing temp config file %s (errno=%d %s)!", temp_file, errno, strerror(errno));
 		return 1;
 	}
 	if(unlink(temp_file) < 0)
-		{ cs_log("Error removing temp config file %s (errno=%d %s)!", temp_file, errno, strerror(errno)); }
+		cs_log("Error removing temp config file %s (errno=%d %s)!", temp_file, errno, strerror(errno));
 	return 0;
 }
Index: oscam-hashtable.c
===================================================================
--- oscam-hashtable.c	(revision 10670)
+++ oscam-hashtable.c	(working copy)
@@ -7,29 +7,35 @@
 #include "tommyDS_hashlin/tommyhashlin.c"
 #include "tommyDS_hashlin/tommylist.c"
 
-void init_hash_table(void *ht, void *ll){
+void init_hash_table(void *ht, void *ll)
+{
 	tommy_hashlin_init(ht);
 	tommy_list_init(ll);
 }
 
-void add_hash_table(void *ht, void *ht_node, void *ll, void *ll_node, void *obj, void *key, int key_len){
+void add_hash_table(void *ht, void *ht_node, void *ll, void *ll_node, void *obj, void *key, int key_len)
+{
 	tommy_hashlin_insert(ht, ht_node, obj, tommy_hash_u32(0,key,key_len));
 	tommy_list_insert_tail(ll, ll_node, obj);
 }
 
-void *find_hash_table(void *ht, void *key, int key_len, void *compare){
+void *find_hash_table(void *ht, void *key, int key_len, void *compare)
+{
 	return tommy_hashlin_search(ht, compare, key, tommy_hash_u32(0,key,key_len));
 }
 
-void *search_remove_elem_hash_table(void *ht, void *key, int key_len, void *compare){
+void *search_remove_elem_hash_table(void *ht, void *key, int key_len, void *compare)
+{
 	return tommy_hashlin_remove	(ht,compare,key,tommy_hash_u32(0,key,key_len));
 }
 
-void *remove_elem_hash_table(void *ht, void *ht_node){
+void *remove_elem_hash_table(void *ht, void *ht_node)
+{
 	return tommy_hashlin_remove_existing(ht,ht_node);
 }
 
-int count_hash_table(void *ht){
+int count_hash_table(void *ht)
+{
 	return tommy_hashlin_count(ht);
 }
 
@@ -37,25 +43,30 @@
 	tommy_hashlin_done(ht);
 }
 
-void sort_list(void *ll, void *cmp){
+void sort_list(void *ll, void *cmp)
+{
 	tommy_list_sort (ll, cmp);
 }
 
-void *remove_elem_list(void *ll, void *ll_node){
+void *remove_elem_list(void *ll, void *ll_node)
+{
 	return tommy_list_remove_existing(ll,ll_node);
 }
 
-void *get_first_node_list(void *ll){
+void *get_first_node_list(void *ll)
+{
 	return tommy_list_head(ll);
 }
 
-void *get_first_elem_list(void *ll){
+void *get_first_elem_list(void *ll)
+{
 	if (tommy_list_head(ll))
 		return tommy_list_head(ll)->data;
 	else return NULL;
 }
 
-void *get_data_from_node(void *node){
+void *get_data_from_node(void *node)
+{
 	if (node)
 		return ((tommy_node *)node)->data;
 	else return NULL;
Index: oscam-lock.c
===================================================================
--- oscam-lock.c	(revision 10670)
+++ oscam-lock.c	(working copy)
@@ -24,7 +24,7 @@
 
 void cs_lock_destroy(CS_MUTEX_LOCK *l)
 {
-	if(!l || !l->name || l->flag) { return; }
+	if (!l || !l->name || l->flag) return;
 
 	cs_rwlock_int(l, WRITELOCK);
 #ifdef WITH_DEBUG
@@ -60,7 +60,7 @@
 	int8_t ret = 0;
 
 	if(!l || !l->name || l->flag)
-		{ return; }
+		return;
 
 	pthread_mutex_lock(&l->lock);
 
@@ -71,18 +71,16 @@
 		l->writelock++;
 		// if read- or writelock is busy, wait for unlock
 		if(l->writelock > 1 || l->readlock > 0)
-			{ ret = pthread_cond_timedwait(&l->writecond, &l->lock, &ts); }
+			ret = pthread_cond_timedwait(&l->writecond, &l->lock, &ts);
 	}
-	else
-	{
+	else {
 		l->readlock++;
 		// if writelock is busy, wait for unlock
 		if(l->writelock > 0)
-			{ ret = pthread_cond_timedwait(&l->readcond, &l->lock, &ts); }
+			ret = pthread_cond_timedwait(&l->readcond, &l->lock, &ts);
 	}
 
-	if(ret > 0)
-	{
+	if (ret > 0) {
 		// lock wasn't returned within time, assume locking thread to
 		// be stuck or finished, so enforce lock.
 		l->writelock = (type == WRITELOCK) ? 1 : 0;
@@ -103,31 +101,30 @@
 void cs_rwunlock_int(CS_MUTEX_LOCK *l, int8_t type)
 {
 
-	if(!l || l->flag) { return; }
+	if (!l || l->flag) return;
 
 	pthread_mutex_lock(&l->lock);
 
 	if(type == WRITELOCK)
-		{ l->writelock--; }
+		l->writelock--;
 	else
-		{ l->readlock--; }
+		l->readlock--;
 
-	if(l->writelock < 0) { l->writelock = 0; }
-	if(l->readlock < 0) { l->readlock = 0; }
+	if (l->writelock < 0) l->writelock = 0;
+	if (l->readlock < 0) l->readlock = 0;
 
 	// waiting writelocks always have priority. If one is waiting, signal it
 	if(l->writelock)
-		{ pthread_cond_signal(&l->writecond); }
+		pthread_cond_signal(&l->writecond);
 	// Otherwise signal a waiting readlock (if any)
 	else if(l->readlock && type != READLOCK)
-		{ pthread_cond_broadcast(&l->readcond); }
+		pthread_cond_broadcast(&l->readcond);
 
 	pthread_mutex_unlock(&l->lock);
 
 #ifdef WITH_MUTEXDEBUG
 #ifdef WITH_DEBUG
-	if(l->name != LOG_LIST)
-	{
+	if (l->name != LOG_LIST)  {
 		const char *typetxt[] = { "", "write", "read" };
 		cs_log_dbg(D_TRACE, "%slock %s: released", typetxt[type], l->name);
 	}
@@ -138,33 +135,30 @@
 int8_t cs_try_rwlock_int(CS_MUTEX_LOCK *l, int8_t type)
 {
 	if(!l || !l->name || l->flag)
-		{ return 0; }
+		return 0;
 
 	int8_t status = 0;
 
 	pthread_mutex_lock(&l->lock);
 
-	if(type == WRITELOCK)
-	{
+	if (type==WRITELOCK) {
 		if(l->writelock || l->readlock)
-			{ status = 1; }
+			status = 1;
 		else
-			{ l->writelock++; }
+			l->writelock++;
 	}
-	else
-	{
+	else {
 		if(l->writelock)
-			{ status = 1; }
+			status = 1;
 		else
-			{ l->readlock++; }
+			l->readlock++;
 	}
 
 	pthread_mutex_unlock(&l->lock);
 
 #ifdef WITH_MUTEXDEBUG
 #ifdef WITH_DEBUG
-	if(l->name != LOG_LIST)
-	{
+	if (l->name != LOG_LIST) {
 		const char *typetxt[] = { "", "write", "read" };
 		cs_log_dbg(D_TRACE, "try_%slock %s: status=%d", typetxt[type], l->name, status);
 	}
Index: oscam-log-reader.c
===================================================================
--- oscam-log-reader.c	(revision 10670)
+++ oscam-log-reader.c	(working copy)
@@ -77,7 +77,9 @@
 	va_start(args, fmt);
 	vsnprintf(txt, sizeof(txt), fmt, args);
 	va_end(args);
-	cs_log("%s [%s] %s", reader->label, reader_desc_txt(reader), txt);
+// sky(!)
+//	cs_log("%s [%s] %s", reader->label, reader_desc_txt(reader), txt);
+	cs_log("%s: %s", reader->label, txt);
 }
 
 void rdr_log_sensitive(struct s_reader *reader, char *fmt, ...)
@@ -100,7 +102,9 @@
 		va_start(args, fmt);
 		vsnprintf(txt, sizeof(txt), fmt, args);
 		va_end(args);
-		cs_log_dbg(mask, "%s [%s] %s%s", reader->label, reader_desc_txt(reader), debug_mask_txt(mask), txt);
+// sky(!)
+//		cs_log_dbg(mask, "%s [%s] %s%s", reader->label, reader_desc_txt(reader), debug_mask_txt(mask), txt);
+		cs_log_dbg(mask, "%s: %s%s", reader->label, debug_mask_txt(mask), txt);
 	}
 }
 
@@ -125,7 +129,9 @@
 	va_start(args, fmt);
 	vsnprintf(txt, sizeof(txt), fmt, args);
 	va_end(args);
-	cs_log_dump(buf, n, "%s [%s] %s", reader->label, reader_desc_txt(reader), txt);
+// sky(!)
+//	cs_log_dump(buf, n, "%s [%s] %s", reader->label, reader_desc_txt(reader), txt);
+	cs_log_dump(buf, n, "%s: %s", reader->label, txt);
 }
 
 void rdr_log_dump_dbg(struct s_reader *reader, uint16_t mask, const uint8_t *buf, int n, char *fmt, ...)
@@ -137,6 +143,50 @@
 		va_start(args, fmt);
 		vsnprintf(txt, sizeof(txt), fmt, args);
 		va_end(args);
-		cs_log_dump_dbg(mask, buf, n, "%s [%s] %s%s", reader->label, reader_desc_txt(reader), debug_mask_txt(mask), txt);
+// sky(!)
+//		cs_log_dump_dbg(mask, buf, n, "%s [%s] %s%s", reader->label, reader_desc_txt(reader), debug_mask_txt(mask), txt);
+		cs_log_dump_dbg(mask, buf, n, "%s: %s%s", reader->label, debug_mask_txt(mask), txt);
 	}
 }
+// sky(a)
+static char *format_tilde_sensitive(char *result, int setsensitive)
+{
+	// Filter sensitive information
+	int i, n = strlen(result), p = 0;
+
+	if (setsensitive)
+	{
+		int in_sens = 0;
+		for (i = 0; i < n; i++)
+		{
+			switch (result[i]) {
+				case '{': in_sens = 1; continue;
+				case '}': in_sens = 0; break;
+			}
+			if (in_sens) {
+			//	int ch = result[i];
+			//	if (isalpha(ch) || isdigit(ch)) result[i] = '*';
+				result[i] = '~';
+			}
+		}
+	}
+	// Filter sensitive markers
+	for (i = 0; i < n; i++)
+	{
+		if (result[i] == '{' || result[i] == '}') continue;
+		result[p++] = result[i];
+	}
+	result[p] = '\0';
+	return result;
+}
+void rdr_log_tildes(struct s_reader *reader, char *fmt, ...)
+{
+	char txt[256];
+	va_list args;
+	va_start(args, fmt);
+	vsnprintf(txt, sizeof(txt), fmt, args);
+	va_end(args);
+	format_tilde_sensitive(txt, 1);
+	rdr_log(reader, "%s", txt);
+}
+
Index: oscam-log-reader.h
===================================================================
--- oscam-log-reader.h	(revision 10670)
+++ oscam-log-reader.h	(working copy)
@@ -3,6 +3,8 @@
 
 void rdr_log(struct s_reader *reader, char *, ...) __attribute__((format(printf, 2, 3)));
 void rdr_log_sensitive(struct s_reader *reader, char *, ...) __attribute__((format(printf, 2, 3)));
+// sky(a)
+void rdr_log_tildes(struct s_reader *reader, char *,...) __attribute__ ((format (printf, 2, 3)));
 
 void rdr_log_dbg(struct s_reader *reader, uint16_t mask, char *fmt, ...) __attribute__((format(printf, 3, 4)));
 void rdr_log_dbg_sensitive(struct s_reader *reader, uint16_t mask, char *fmt, ...) __attribute__((format(printf, 3, 4)));
Index: oscam-log.c
===================================================================
--- oscam-log.c	(revision 10670)
+++ oscam-log.c	(working copy)
@@ -55,12 +55,10 @@
 			fclose(*f);
 			*f = (FILE *)0;
 			rc = rename(file, prev_log);
-			if(rc != 0)
-			{
+			if (rc!=0) {
 				fprintf(stderr, "rename(%s, %s) failed (errno=%d %s)\n", file, prev_log, errno, strerror(errno));
 			}
-			else if(pfinit())
-			{
+			else if ( pfinit()) {
 				fprintf(stderr, "Initialisation of log file failed, continuing without logging thread %8lX. Log will be output to stdout!", (unsigned long)pthread_self());
 				cfg.logtostdout = 1;
 			}
@@ -70,32 +68,26 @@
 
 void cs_reopen_log(void)
 {
-	if(cfg.logfile)
-	{
-		if(fp)
-		{
+	if (cfg.logfile) {
+		if (fp) {
 			fprintf(fp, "flush and re-open log file\n");
 			fflush(fp);
 			fclose(fp);
 			fp = NULL;
 		}
-		if(cs_open_logfiles())
-		{
+		if (cs_open_logfiles()) {
 			fprintf(stderr, "Initialisation of log file failed, continuing without logging thread %8luX. Log will be output to stdout!", (unsigned long)pthread_self());
 			cfg.logtostdout = 1;
 		}
 	}
-	if(cfg.usrfile)
-	{
-		if(fps)
-		{
+	if (cfg.usrfile) {
+		if (fps) {
 			fprintf(fps, "flush and re-open user log file\n");
 			fflush(fps);
 			fclose(fps);
 			fps = NULL;
 		}
-		if(cs_init_statistics())
-		{
+		if (cs_init_statistics()) {
 			fprintf(stderr, "Initialisation of user log file failed, continuing without logging thread %8luX.", (unsigned long)pthread_self());
 		}
 	}
@@ -104,35 +96,27 @@
 static void cs_write_log(char *txt, int8_t do_flush)
 {
 	// filter out entries with leading 's' and forward to statistics
-	if(txt[0] == 's')
-	{
-		if(fps)
-		{
+	if (txt[0] == 's') {
+		if (fps) {
 			switch_log(cfg.usrfile, &fps, cs_init_statistics);
-			if(fps)
-			{
+			if (fps) {
 				fputs(txt + 1, fps); // remove the leading 's' and write to file
-				if(do_flush) { fflush(fps); }
+					if (do_flush) fflush(fps);
 			}
 		}
 	}
-	else
-	{
-		if(!cfg.disablelog)
-		{
-			if(fp)
-			{
+	else {
+		if (!cfg.disablelog) {
+			if (fp) {
 				switch_log(cfg.logfile, &fp, cs_open_logfiles);     // only call the switch code if lock = 1 is specified as otherwise we are calling it internally
-				if(fp)
-				{
+				if (fp) {
 					fputs(txt, fp);
-					if(do_flush) { fflush(fp); }
+					if (do_flush) fflush(fp);
 				}
 			}
-			if(cfg.logtostdout)
-			{
+			if (cfg.logtostdout) {
 				fputs(txt + 11, stdout);
-				if(do_flush) { fflush(stdout); }
+				if (do_flush) fflush(stdout);
 			}
 		}
 	}
@@ -142,8 +126,7 @@
 {
 	pthread_cond_signal(&log_thread_sleep_cond);
 	int32_t i = 0;
-	while(ll_count(log_list) > 0 && i < 200)
-	{
+	while (ll_count(log_list) > 0 && i < 200) {
 		cs_sleepms(5);
 		++i;
 	}
@@ -153,12 +136,10 @@
 {
 	int32_t count = ll_count(log_list);
 	log_list_queued++;
-	if(count < MAX_LOG_LIST_BACKLOG)
-	{
+	if (count < MAX_LOG_LIST_BACKLOG) {
 		ll_append(log_list, log);
 	}
-	else     // We have too much backlog
-	{
+	else { // We have too much backlog
 		NULLFREE(log->txt);
 		NULLFREE(log);
 		cs_write_log("-------------> Too much data in log_list, dropping log message.\n", 1);
@@ -168,18 +149,15 @@
 
 static void cs_write_log_int(char *txt)
 {
-	if(exit_oscam == 1)
-	{
+	if (exit_oscam == 1) {
 		cs_write_log(txt, 1);
 	}
 	else
 	{
 		char *newtxt = cs_strdup(txt);
-		if(!newtxt)
-			{ return; }
+		if (!newtxt) return;
 		struct s_log *log;
-		if(!cs_malloc(&log, sizeof(struct s_log)))
-		{
+		if (!cs_malloc(&log, sizeof(struct s_log))) {
 			NULLFREE(newtxt);
 			return;
 		}
@@ -193,8 +171,10 @@
 int32_t cs_open_logfiles(void)
 {
 	char *starttext;
-	if(logStarted) { starttext = "log switched"; }
-	else { starttext = "started"; }
+
+	if (logStarted) starttext = "log switched";
+	else starttext = "started";
+
 	if(!fp && cfg.logfile)      //log to file
 	{
 		if((fp = fopen(cfg.logfile, "a+")) <= (FILE *)0)
@@ -229,7 +209,7 @@
 static CS_MUTEX_LOCK loghistory_lock;
 // These are accessed in module-monitor and module-webif
 char *loghist = NULL;     // ptr of log-history
-char *loghistid = NULL;
+uint64_t *loghistid 	= NULL;
 char *loghistptr = NULL;
 
 /*
@@ -237,10 +217,11 @@
 */
 void cs_reinit_loghist(uint32_t size)
 {
-	char *tmp = NULL, *tmp2, *tmp3 = NULL, *tmp4;
+	char *tmp = NULL, *tmp2, *tmp3 = NULL;
+	uint64_t *tmp4;
 	if(size != cfg.loghistorysize)
 	{
-		if(cs_malloc(&tmp, size) && cs_malloc(&tmp3, size/3+8))
+		if (cs_malloc(&tmp, size) && cs_malloc(&tmp3, size+8))
 		{
 			cs_writelock(&loghistory_lock);
 			tmp2 = loghist;
@@ -252,7 +233,7 @@
 				cs_sleepms(20); // Monitor or webif may be currently outputting the loghistory but don't use locking so we sleep a bit...
 				loghistptr = tmp;
 				loghist = tmp;
-				loghistid = tmp3;
+				loghistid  = (uint64_t *)tmp3;
 			}
 			else
 			{
@@ -260,12 +241,12 @@
 				{
 					memcpy(tmp, loghist, cfg.loghistorysize);
 					loghistptr = tmp + (loghistptr - loghist);
-					memcpy(tmp3, loghistid, cfg.loghistorysize/3);
+					memcpy(tmp3, loghistid, cfg.loghistorysize/8);
 				} else { 
 					loghistptr = tmp;
 				}
 				loghist = tmp;
-				loghistid = tmp3;
+				loghistid = (uint64_t *)tmp3;
 				cs_sleepms(20); // Monitor or webif may be currently outputting the loghistory but don't use locking so we sleep a bit...
 				cfg.loghistorysize = size;
 			}
@@ -322,23 +303,20 @@
 
 		cs_writelock(&loghistory_lock);
 		char *lastpos = loghist + (cfg.loghistorysize) - 1;
-		if(loghist + target_len + 1 >= lastpos)
-		{
+		if (loghist + target_len + 1 >= lastpos) {
 			strncpy(txt + 39, "Log entry too long!", strlen(txt) - 39); // we can assume that the min loghistorysize is always 1024 so we don't need to check if this new string fits into it!
 			target_len = strlen(usrtxt) + (strlen(txt) - 8) + 1;
 		}
 		if(!loghistptr)
 			{ loghistptr = loghist;	}
 
-		if(loghistptr + target_len + 1 > lastpos)
-		{
+		if (loghistptr + target_len + 1 > lastpos) {
 			*loghistptr = '\0';
 			loghistptr = loghist + target_len + 1;
 			*loghistptr = '\0';
 			target_ptr = loghist;
 		}
-		else
-		{
+		else {
 			target_ptr = loghistptr;
 			loghistptr = loghistptr + target_len + 1;
 			*loghistptr = '\0';
@@ -346,7 +324,11 @@
 		++counter;
 		cs_writeunlock(&loghistory_lock);
 		snprintf(target_ptr, target_len + 1, "%s\t%s", usrtxt, txt + 8);
-		ull2b_buf(counter, (uchar *)(loghistid + ((target_ptr-loghist)/3)));
+
+		uint64_t *puid;
+		puid  = (uint64_t *)(loghistid + (target_ptr-loghist)/8);
+		*puid = counter;
+//		ull2b_buf(counter, (uchar *)(loghistid + ((target_ptr-loghist)/3)));
 	}
 #endif
 
@@ -357,12 +339,11 @@
 	{
 		if((cl->typ == 'm') && (cl->monlvl > 0) && cl->log)  //this variable is only initialized for cl->typ = 'm'
 		{
-			if(cl->monlvl < 2)
-			{
+			if (cl->monlvl<2) {
 				if(log->cl_typ != 'c' && log->cl_typ != 'm')
-					{ continue; }
+					continue;
 				if(log->cl_usr && cl->account && strcmp(log->cl_usr, cl->account->usr))
-					{ continue; }
+					continue;
 			}
 			snprintf(sbuf, sizeof(sbuf), "%03d", cl->logcounter);
 			cl->logcounter = (cl->logcounter + 1) % 1000;
@@ -376,14 +357,12 @@
 static void write_to_log_int(char *txt, int8_t header_len)
 {
 #if !defined(WEBIF) && !defined(MODULE_MONITOR)
-	if(cfg.disablelog) { return; }
+	if (cfg.disablelog) return;
 #endif
 	char *newtxt = cs_strdup(txt);
-	if(!newtxt)
-		{ return; }
+	if (!newtxt) return;
 	struct s_log *log;
-	if(!cs_malloc(&log, sizeof(struct s_log)))
-	{
+	if (!cs_malloc(&log, sizeof(struct s_log))) {
 		NULLFREE(newtxt);
 		return;
 	}
@@ -399,16 +378,13 @@
 	}
 	else
 	{
-		switch(cl->typ)
-		{
+		switch (cl->typ) {
 		case 'c':
 		case 'm':
-			if(cl->account)
-			{
+				if (cl->account) {
 				log->cl_text = cl->account->usr;
 				log->cl_usr = cl->account->usr;
-			}
-			else { log->cl_text = ""; }
+				} else log->cl_text = "";
 			break;
 		case 'p':
 		case 'r':
@@ -522,8 +498,7 @@
 static void cs_close_log(void)
 {
 	log_list_flush();
-	if(fp)
-	{
+	if (fp) {
 		fclose(fp);
 		fp = (FILE *)0;
 	}
@@ -559,28 +534,25 @@
 			cwps /= client->cwfound + client->cwnot;
 		}
 		else
-			{ cwps = 0; }
+			cwps=0;
 
 		char channame[32];
 		get_servicename(client, client->last_srvid, client->last_caid, channame);
 
 		int32_t lsec;
 		if((client->last_caid == NO_CAID_VALUE) && (client->last_srvid == NO_SRVID_VALUE))
-			{ lsec = client->last - client->login; } //client leave calc total duration
+			lsec = client->last - client->login; //client leave calc total duration
 		else
-			{ lsec = client->last - client->lastswitch; }
+			lsec = client->last - client->lastswitch;
 
 		int32_t secs = 0, fullmins = 0, mins = 0, fullhours = 0;
 
-		if((lsec > 0) && (lsec < 1000000))
-		{
+		if ((lsec > 0) && (lsec < 1000000)) {
 			secs = lsec % 60;
-			if(lsec > 60)
-			{
+			if (lsec > 60) {
 				fullmins = lsec / 60;
 				mins = fullmins % 60;
-				if(fullmins > 60)
-				{
+				if (fullmins > 60) {
 					fullhours = fullmins / 60;
 				}
 			}
@@ -612,6 +584,62 @@
 		cs_write_log_int(buf);
 	}
 }
+// sky(A)
+static char *cs_format_sensitive(char *result, int setsensitive)
+{
+	// Filter sensitive information
+	int i, n = strlen(result), p = 0;
+
+	if (setsensitive)
+	{
+		int in_sens = 0;
+		for (i = 0; i < n; i++)
+		{
+			switch (result[i]) {
+				case '{': in_sens = 1; continue;
+				case '}': in_sens = 0; break;
+			}
+			if (in_sens) {
+			//	int ch = result[i];
+			//	if (isalpha(ch) || isdigit(ch)) result[i] = '*';
+				result[i] = '~';
+			}
+		}
+	}
+	// Filter sensitive markers
+	for (i = 0; i < n; i++)
+	{
+		if (result[i] == '{' || result[i] == '}') continue;
+		result[p++] = result[i];
+	}
+	result[p] = '\0';
+	return result;
+}
+
+void cs_debug_mask_sensitive(uint16_t mask, char *fmt, ...)
+{
+	if (config_enabled(WITH_DEBUG))
+	{
+		char stxt[2048];
+		va_list args;
+		va_start(args, fmt);
+		vsnprintf(stxt, sizeof(stxt), fmt, args);
+		va_end(args);
+		cs_format_sensitive(stxt, 1);
+		cs_log_dbg(mask, "%s", stxt);
+	}
+}
+
+void cs_log_sensitive(char *fmt, ...)
+{
+	char stxt[2048];
+	va_list args;
+	va_start(args, fmt);
+	vsnprintf(stxt, sizeof(stxt), fmt, args);
+	va_end(args);
+	cs_format_sensitive(stxt, 1);
+	cs_log("%s", stxt);
+}
 
 void log_list_thread(void)
 {
@@ -659,8 +687,7 @@
 		pthread_attr_init(&attr);
 		pthread_attr_setstacksize(&attr, PTHREAD_STACK_SIZE);
 		int32_t ret = pthread_create(&log_thread, &attr, (void *)&log_list_thread, NULL);
-		if(ret)
-		{
+		if (ret) {
 			fprintf(stderr, "ERROR: Can't create logging thread (errno=%d %s)", ret, strerror(ret));
 			pthread_attr_destroy(&attr);
 			cs_exit(1);
@@ -668,7 +695,7 @@
 		pthread_attr_destroy(&attr);
 	}
 	int32_t rc = 0;
-	if(!cfg.disablelog) { rc = cs_open_logfiles(); }
+	if (!cfg.disablelog) rc = cs_open_logfiles();
 	logStarted = 1;
 	return rc;
 }
@@ -677,22 +704,18 @@
 {
 	if(cfg.disablelog != disabled)
 	{
-		if(disabled && logStarted)
-		{
+		if (disabled && logStarted) {
 			cs_log("Stopping log...");
 			log_list_flush();
 		}
 		cfg.disablelog = disabled;
-		if(disabled)
-		{
-			if(logStarted)
-			{
+		if (disabled) {
+			if (logStarted) {
 				cs_sleepms(20);
 				cs_close_log();
 			}
 		}
-		else
-		{
+		else {
 			cs_open_logfiles();
 		}
 	}
@@ -707,6 +730,7 @@
 #if defined(WEBIF) || defined(MODULE_MONITOR)
 	NULLFREE(loghist);
 	NULLFREE(loghistid);
-	loghist = loghistptr = loghistid = NULL;
+	loghist = loghistptr = NULL;
+	loghistid = NULL;
 #endif
 }
Index: oscam-log.h
===================================================================
--- oscam-log.h	(revision 10670)
+++ oscam-log.h	(working copy)
@@ -14,24 +14,26 @@
 void cs_log_txt(const char *log_prefix, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
 void cs_log_hex(const char *log_prefix, const uint8_t *buf, int32_t n, const char *fmt, ...) __attribute__((format(printf, 4, 5)));
 
+#if defined(__HISILICON_MANUFACTORY__)
+#define cs_log(fmt, params...)          do { if (0) cs_log_txt(MODULE_LOG_PREFIX, fmt, ##params); } while (0)
+#define cs_log_dump(buf, n, fmt, params...) do { if (0) cs_log_hex(MODULE_LOG_PREFIX, buf,  n, fmt, ##params); } while (0)
+
+#define cs_log_dbg(mask, fmt, params...)        	do { if (0) cs_log_txt(MODULE_LOG_PREFIX, fmt, ##params); } while (0)
+#define cs_log_dump_dbg(mask, buf, n, fmt, params...) 	do { if (0) cs_log_hex(MODULE_LOG_PREFIX, buf , n, fmt, ##params); } while (0)
+#else
 #define cs_log(fmt, params...)              cs_log_txt(MODULE_LOG_PREFIX, fmt, ##params)
 #define cs_log_dump(buf, n, fmt, params...) cs_log_hex(MODULE_LOG_PREFIX, buf,  n, fmt, ##params)
 
 #define cs_log_dbg(mask, fmt, params...)         do { if (config_enabled(WITH_DEBUG) && ((mask) & cs_dblevel)) cs_log_txt(MODULE_LOG_PREFIX, fmt, ##params); } while(0)
 #define cs_log_dump_dbg(mask, buf, n, fmt, params...) do { if (config_enabled(WITH_DEBUG) && ((mask) & cs_dblevel)) cs_log_hex(MODULE_LOG_PREFIX, buf , n, fmt, ##params); } while(0)
+#endif // defined(__HISILICON_MANUFACTORY__)
+
+void cs_log_sensitive(char *fmt, ...);
+void cs_debug_mask_sensitive(uint16_t mask, char *fmt, ...);
 
 int32_t cs_init_statistics(void);
 void cs_statistics(struct s_client *client);
 
 void log_free(void);
 
-// Compatability with older function names. If your code uses these
-// it must migrate to the new names using find + replace
-// *** DO NOT USE OLD NAMES NEW CODE! ***
-#define cs_debug_mask             cs_log_dbg
-#define rdr_debug_mask            rdr_log_dbg
-#define rdr_debug_mask_sensitive  rdr_log_dbg_sensitive
-#define cs_ddump_mask             cs_log_dump_dbg
-#define rdr_ddump_mask            rdr_log_dump_dbg
-
 #endif
Index: oscam-net.c
===================================================================
--- oscam-net.c	(revision 10670)
+++ oscam-net.c	(working copy)
@@ -18,11 +18,9 @@
 static in_addr_t cs_inet_order(in_addr_t n)
 {
 	if(!inet_byteorder)
-		{ inet_byteorder = (inet_addr("1.2.3.4") + 1 == inet_addr("1.2.3.5")) ? 1 : 2; }
-	switch(inet_byteorder)
-	{
-	case 1:
-		break;
+		inet_byteorder= (inet_addr("1.2.3.4") + 1 == inet_addr("1.2.3.5")) ? 1 : 2;
+	switch (inet_byteorder) {
+	   case 1: break;
 	case 2:
 		n = ((n & 0xff000000) >> 24) |
 			((n & 0x00ff0000) >>  8) |
@@ -38,13 +36,11 @@
 {
 #ifdef IPV6SUPPORT
 	static char buff[INET6_ADDRSTRLEN];
-	if(IN6_IS_ADDR_V4MAPPED(&addr) || IN6_IS_ADDR_V4COMPAT(&addr))
-	{
+	if (IN6_IS_ADDR_V4MAPPED(&addr) || IN6_IS_ADDR_V4COMPAT(&addr)) {
 		snprintf(buff, sizeof(buff), "%d.%d.%d.%d",
 				 addr.s6_addr[12], addr.s6_addr[13], addr.s6_addr[14], addr.s6_addr[15]);
 	}
-	else
-	{
+	else {
 		inet_ntop(AF_INET6, &(addr.s6_addr), buff, INET6_ADDRSTRLEN);
 	}
 	return buff;
@@ -60,8 +56,7 @@
 #ifdef IPV6SUPPORT
 	char buff[INET6_ADDRSTRLEN];
 	//trying as IPv6 address
-	if(inet_pton(AF_INET6, txt, out->s6_addr) == 0)
-	{
+	if (inet_pton(AF_INET6, txt, out->s6_addr) == 0) {
 		//now trying as mapped IPv4
 		snprintf(buff, sizeof(buff), "::ffff:%s", txt);
 		inet_pton(AF_INET6, buff, out->s6_addr);
@@ -78,7 +73,7 @@
 #else
 	*ip = cs_getIPfromHost(hostname);
 	if(sa_len)
-		{ *sa_len = sizeof(*sock); }
+		*sa_len = sizeof(*sock);
 #endif
 }
 
@@ -95,10 +90,10 @@
 	{
 		if((i == 2) && ((IN6_IS_ADDR_V4COMPAT(a) && IN6_IS_ADDR_V4MAPPED(b)) ||
 						(IN6_IS_ADDR_V4COMPAT(b) && IN6_IS_ADDR_V4MAPPED(a))))
-			{ continue; }   //skip comparing this part
+			continue;	//skip comparing this part
 
 		if(a->s6_addr32[i] != b->s6_addr32[i])
-			{ return ntohl(a->s6_addr32[i]) < ntohl(b->s6_addr32[i]); }
+			return ntohl(a->s6_addr32[i]) < ntohl(b->s6_addr32[i]);
 	}
 
 	return 0;
@@ -109,7 +104,7 @@
 	int i;
 	for(i = 0; i < 16; i++)
 		if(addr->s6_addr[i])
-			{ return 0; }
+			return 0;
 	return 1;
 }
 
@@ -156,20 +151,32 @@
 #endif
 }
 
+
+// sky(n)
+int32_t check_LOCALHOST_ip(IN_ADDR_T ip)
+{
+	IN_ADDR_T loip;
+
+	set_localhost_ip(&loip);
+	if (IP_EQUAL(loip, ip)) return 1;
+	return 0;
+}
+
+
 int32_t check_ip(struct s_ip *ip, IN_ADDR_T n)
 {
 	struct s_ip *p_ip;
 	int32_t ok = 0;
 #ifdef IPV6SUPPORT
-	for(p_ip = ip; (p_ip) && (!ok); p_ip = p_ip->next)
-	{
+	for (p_ip=ip; (p_ip) && (!ok); p_ip=p_ip->next) {
 		ok  = cs_in6addr_lt(&n, &p_ip->ip[0]);
 		ok |= cs_in6addr_lt(&p_ip->ip[1], &n);
 		ok = !ok;
 	}
 #else
-	for(p_ip = ip; (p_ip) && (!ok); p_ip = p_ip->next)
-		{ ok = ((cs_inet_order(n) >= cs_inet_order(p_ip->ip[0])) && (cs_inet_order(n) <= cs_inet_order(p_ip->ip[1]))); }
+	for (p_ip=ip; (p_ip) && (!ok); p_ip=p_ip->next) {
+		ok = ((cs_inet_order(n) >= cs_inet_order(p_ip->ip[0])) && (cs_inet_order(n) <= cs_inet_order(p_ip->ip[1])));
+	}
 #endif
 	return ok;
 }
@@ -180,18 +187,19 @@
 {
 	uint32_t result = 0;
 	//Resolve with gethostbyname:
-	if(cfg.resolve_gethostbyname)
-	{
+#if defined(WITH_HISILICON)
+	cfg.resolve_gethostbyname = 1;
+#endif
+	if (cfg.resolve_gethostbyname) {
 		cs_writelock(&gethostbyname_lock);
 		struct hostent *rht = gethostbyname(hostname);
 		if(!rht)
-			{ cs_log("can't resolve %s", hostname); }
+			cs_log("can't resolve %s", hostname);
 		else
-			{ result = ((struct in_addr *)rht->h_addr)->s_addr; }
+			result = ((struct in_addr *)rht->h_addr)->s_addr;
 		cs_writeunlock(&gethostbyname_lock);
 	}
-	else     //Resolve with getaddrinfo:
-	{
+	else { //Resolve with getaddrinfo:
 		struct addrinfo hints, *res = NULL;
 		memset(&hints, 0, sizeof(hints));
 		hints.ai_socktype = SOCK_STREAM;
@@ -199,15 +207,12 @@
 		hints.ai_protocol = IPPROTO_TCP;
 
 		int32_t err = getaddrinfo(hostname, NULL, &hints, &res);
-		if(err != 0 || !res || !res->ai_addr)
-		{
+		if (err != 0 || !res || !res->ai_addr) {
 			cs_log("can't resolve %s, error: %s", hostname, err ? gai_strerror(err) : "unknown");
-		}
-		else
-		{
+		} else {
 			result = ((struct sockaddr_in *)(res->ai_addr))->sin_addr.s_addr;
 		}
-		if(res) { freeaddrinfo(res); }
+		if (res) freeaddrinfo(res);
 	}
 	return result;
 }
@@ -222,24 +227,22 @@
 	hints.ai_family = AF_UNSPEC;
 	hints.ai_protocol = IPPROTO_TCP;
 	int32_t err = getaddrinfo(hostname, NULL, &hints, &res);
-	if(err != 0 || !res || !res->ai_addr)
-	{
+	if (err != 0 || !res || !res->ai_addr) {
 		cs_log("can't resolve %s, error: %s", hostname, err ? gai_strerror(err) : "unknown");
 	}
-	else
-	{
+	else {
 		ipv4addr = ((struct sockaddr_in *)(res->ai_addr))->sin_addr.s_addr;
 		if(res->ai_family == AF_INET)
-			{ cs_in6addr_ipv4map(addr, ipv4addr); }
+			cs_in6addr_ipv4map(addr, ipv4addr);
 		else
-			{ IP_ASSIGN(*addr, SIN_GET_ADDR(*res->ai_addr)); }
+			IP_ASSIGN(*addr, SIN_GET_ADDR(*res->ai_addr));
 		if(sa)
-			{ memcpy(sa, res->ai_addr, res->ai_addrlen); }
+			memcpy(sa, res->ai_addr, res->ai_addrlen);
 		if(sa_len)
-			{ *sa_len = res->ai_addrlen; }
+			*sa_len = res->ai_addrlen;
 	}
 	if(res)
-		{ freeaddrinfo(res); }
+		freeaddrinfo(res);
 }
 #endif
 
@@ -258,41 +261,33 @@
 {
 	int32_t flag = 1;
 	// this is not only for a real keepalive but also to detect closed connections so it should not be configurable
-	if(setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &flag, sizeof(flag)) && errno != EBADF)
-	{
+	if (setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &flag, sizeof(flag)) && errno != EBADF) {
 		cs_log("Setting SO_KEEPALIVE failed, errno=%d, %s", errno, strerror(errno));
 	}
 #if defined(TCP_KEEPIDLE) && defined(TCP_KEEPCNT) && defined(TCP_KEEPINTVL)
 	flag = 10;
-	if(setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, &flag, sizeof(flag)) && errno != EBADF)  //send first keepalive packet after 10 seconds of last package received (keepalive packets included)
-	{
+	if (setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, &flag, sizeof(flag)) && errno != EBADF) {	//send first keepalive packet after 10 seconds of last package received (keepalive packets included)
 		cs_log("Setting TCP_KEEPIDLE failed, errno=%d, %s", errno, strerror(errno));
 	}
 	flag = 3;
-	if(setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, &flag, sizeof(flag)) && errno != EBADF)       //send up to 3 keepalive packets out (in interval TCP_KEEPINTVL), then disconnect if no response
-	{
+	if (setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, &flag, sizeof(flag)) && errno != EBADF) {		//send up to 3 keepalive packets out (in interval TCP_KEEPINTVL), then disconnect if no response
 		cs_log("Setting TCP_KEEPCNT failed, errno=%d, %s", errno, strerror(errno));
 	}
 	flag = 1;
-	if(setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, &flag, sizeof(flag)) && errno != EBADF)
-	{
-		;       //send a keepalive packet out every second (until answer has been received or TCP_KEEPCNT has been reached)
+	if (setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, &flag, sizeof(flag)) && errno != EBADF) {
+		// send a keepalive packet out every second (until answer has been received or TCP_KEEPCNT has been reached)
 		cs_log("Setting TCP_KEEPINTVL failed, errno=%d, %s", errno, strerror(errno));
 	}
 #endif
 	struct timeval tv;
 	tv.tv_sec = 60;
 	tv.tv_usec = 0;
-	if(setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(struct timeval)) && errno != EBADF)
-	{
-		;
+	if (setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(struct timeval)) && errno != EBADF) {;
 		cs_log("Setting SO_SNDTIMEO failed, errno=%d, %s", errno, strerror(errno));
 	}
 	tv.tv_sec = 600;
 	tv.tv_usec = 0;
-	if(setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval)) && errno != EBADF)
-	{
-		;
+	if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval)) && errno != EBADF) {;
 		cs_log("Setting SO_RCVTIMEO failed, errno=%d, %s", errno, strerror(errno));
 	}
 #if defined(TCP_USER_TIMEOUT)
@@ -304,8 +299,7 @@
 int set_nonblock(int32_t fd, bool nonblock)
 {
 	int32_t flags = fcntl(fd, F_GETFL);
-	if (flags == -1)
-		return -1;
+	if (flags == -1) return -1;
 	if (nonblock)
 		flags |= O_NONBLOCK;
 	else
@@ -318,18 +312,19 @@
 	int32_t rc;
 	struct pollfd pfd[1];
 
+	if (!fd) return 0; // sky(a)
 	pfd[0].fd = fd;
 	pfd[0].events = (POLLIN | POLLPRI);
 	rc = poll(pfd, 1, 0);
 
 	if(rc == -1)
-		{ cs_log("check_fd_for_data(fd=%d) failed: (errno=%d %s)", fd, errno, strerror(errno)); }
+		cs_log("check_fd_for_data(fd=%d) failed: (errno=%d %s)", fd, errno, strerror(errno));
 
 	if(rc == -1 || rc == 0)
-		{ return rc; }
+		return rc;
 
 	if(pfd[0].revents & (POLLHUP | POLLNVAL | POLLERR))
-		{ return -2; }
+		return -2;
 
 	return 1;
 }
@@ -337,8 +332,7 @@
 int32_t recv_from_udpipe(uint8_t *buf)
 {
 	uint16_t n;
-	if(buf[0] != 'U')
-	{
+	if (buf[0]!='U') {
 		cs_log("INTERNAL PIPE-ERROR");
 		cs_exit(1);
 	}
@@ -362,8 +356,7 @@
 	while(1)
 	{
 		pfdcount = 0;
-		if(cl->pfd)
-		{
+		if (cl->pfd) {
 			pfd[pfdcount].fd = cl->pfd;
 			pfd[pfdcount++].events = POLLIN | POLLPRI;
 		}
@@ -379,9 +372,9 @@
 		if(p_rc < 0)
 		{
 			if(errno == EINTR)
-				{ continue; }
+				continue;
 			else
-				{ return 0; }
+				return 0;
 		}
 		
 		if((p_rc == 0) && (timeout != 0) && (gone >= timeoutms))  // client maxidle reached? timeout = 0, idle disconnect disabled
@@ -397,10 +390,10 @@
 				return 0;
 			}
 			if(!(pfd[i].revents & (POLLIN | POLLPRI)))
-				{ continue; }
+				continue;
 
 			if(pfd[i].fd == cl->pfd)
-				{ return get_module(cl)->recv(cl, buf, buflen); }
+				return get_module(cl)->recv(cl, buf, buflen);
 		}
 	}
 	return rc;
@@ -421,8 +414,7 @@
 	return NULL;
 }
 
-int32_t accept_connection(struct s_module *module, int8_t module_idx, int8_t port_idx)
-{
+int32_t accept_connection(struct s_module *module, int8_t module_idx, int8_t port_idx) {
 	struct SOCKADDR cad;
 	int32_t scad = sizeof(cad), n;
 	struct s_client *cl;
@@ -432,8 +424,9 @@
 	if(module->type == MOD_CONN_UDP)
 	{
 		uchar *buf;
-		if(!cs_malloc(&buf, 1024))
-			{ return -1; }
+		if (!cs_malloc(&buf, 1024)) return -1;
+
+		mycs_trace(D_ADB, "mynet:accept_connection{%s}", module->desc);
 		if((n = recvfrom(port->fd, buf + 3, 1024 - 3, 0, (struct sockaddr *)&cad, (socklen_t *)&scad)) > 0)
 		{
 			uint16_t rl;
@@ -442,8 +435,7 @@
 			buf[0] = 'U';
 			memcpy(buf + 1, &rl, 2);
 
-			if(cs_check_violation(SIN_GET_ADDR(cad), port->s_port))
-			{
+			if (cs_check_violation(SIN_GET_ADDR(cad), port->s_port)) {
 				NULLFREE(buf);
 				return 0;
 			}
@@ -453,10 +445,9 @@
 						  cs_inet_ntoa(SIN_GET_ADDR(cad)), SIN_GET_PORT(cad),
 						  username(cl));
 
-			if(!cl)
-			{
+			if (!cl) {
 				cl = create_client(SIN_GET_ADDR(cad));
-				if(!cl) { return 0; }
+				if (!cl) return 0;
 
 				cl->module_idx = module_idx;
 				cl->port_idx = port_idx;
@@ -472,23 +463,20 @@
 			add_job(cl, ACTION_CLIENT_UDP, buf, n + 3);
 		}
 		else
-			{ NULLFREE(buf); }
+			NULLFREE(buf);
 	}
 	else     //TCP
 	{
 		int32_t pfd3;
-		if((pfd3 = accept(port->fd, (struct sockaddr *)&cad, (socklen_t *)&scad)) > 0)
-		{
+		if ((pfd3=accept(port->fd, (struct sockaddr *)&cad, (socklen_t *)&scad))>0) {
 
-			if(cs_check_violation(SIN_GET_ADDR(cad), port->s_port))
-			{
+			if (cs_check_violation(SIN_GET_ADDR(cad), port->s_port)) {
 				close(pfd3);
 				return 0;
 			}
 
 			cl = create_client(SIN_GET_ADDR(cad));
-			if(cl == NULL)
-			{
+			if (cl == NULL) {
 				close(pfd3);
 				return 0;
 			}
@@ -511,7 +499,8 @@
 	return 0;
 }
 
-void set_so_reuseport(int fd) {
+void set_so_reuseport(int fd)
+{
 #ifdef SO_REUSEPORT
 	// See: http://stackoverflow.com/questions/3261965/so-reuseport-on-linux
 	int32_t on = 1;
@@ -544,27 +533,24 @@
 #else
 	sad.sin_family = AF_INET;
 	sad_len = sizeof(struct sockaddr);
-	if(!module->s_ip)
-		{ module->s_ip = cfg.srvip; }
-	if(module->s_ip)
-	{
+	if (!module->s_ip) module->s_ip = cfg.srvip;
+	if ( module->s_ip) {
 		sad.sin_addr.s_addr = module->s_ip;
 		snprintf(ptxt[0], sizeof(ptxt[0]), ", ip=%s", inet_ntoa(sad.sin_addr));
+		myprintf("start_listener: %s{%s, %d}{%d}\n", module->desc, inet_ntoa(sad.sin_addr), port->s_port, is_udp);
 	}
-	else
-	{
+	else {
 		sad.sin_addr.s_addr = INADDR_ANY;
+		myprintf("start_listener: %s{Any,%d}{%d}\n", module->desc, port->s_port, is_udp);
 	}
 #endif
 	timeout = cfg.bindwait;
 	port->fd = 0;
 
-	if(port->s_port > 0)    // test for illegal value
-	{
+	if (port->s_port > 0) { // test for illegal value
 		SIN_GET_PORT(sad) = htons((uint16_t)port->s_port);
 	}
-	else
-	{
+	else {
 		cs_log("%s: Bad port %d", module->desc, port->s_port);
 		return 0;
 	}
@@ -594,15 +580,13 @@
 #endif
 	// set the server socket option to listen on IPv4 and IPv6 simultaneously
 	int val = 0;
-	if(setsockopt(port->fd, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&val, sizeof(val)) < 0)
-	{
+	if (setsockopt(port->fd, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&val, sizeof(val)) < 0) {
 		cs_log("%s: setsockopt(IPV6_V6ONLY) failed (errno=%d: %s)", module->desc, errno, strerror(errno));
 	}
 #endif
 
 	ov = 1;
-	if(setsockopt(port->fd, SOL_SOCKET, SO_REUSEADDR, (void *)&ov, sizeof(ov)) < 0)
-	{
+	if (setsockopt(port->fd, SOL_SOCKET, SO_REUSEADDR, (void *)&ov, sizeof(ov)) < 0) {
 		cs_log("%s: setsockopt failed (errno=%d: %s)", module->desc, errno, strerror(errno));
 		close(port->fd);
 		port->fd = 0;
@@ -612,42 +596,36 @@
 	set_so_reuseport(port->fd);
 
 	if(set_socket_priority(port->fd, cfg.netprio) > -1)
-		{ snprintf(ptxt[1], sizeof(ptxt[1]), ", prio=%d", cfg.netprio); }
+		snprintf(ptxt[1], sizeof(ptxt[1]), ", prio=%d", cfg.netprio);
 
-	if(!is_udp)
-	{
+	if (!is_udp) {
 		int32_t keep_alive = 1;
 		setsockopt(port->fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&keep_alive, sizeof(keep_alive));
 	}
 
 	while(timeout-- && !exit_oscam)
 	{
-		if(bind(port->fd, (struct sockaddr *)&sad, sad_len) < 0)
-		{
-			if(timeout)
-			{
+		if (bind(port->fd, (struct sockaddr *)&sad, sad_len) < 0) {
+			if (timeout) {
 				cs_log("%s: Bind request failed (%s), waiting another %d seconds",
 					   module->desc, strerror(errno), timeout);
+				myprintf("%s:bind waiting(%3d)\n", module->desc, timeout);
 				cs_sleepms(1000);
 			}
-			else
-			{
+			else {
 				cs_log("%s: Bind request failed (%s), giving up", module->desc, strerror(errno));
 				close(port->fd);
 				port->fd = 0;
 				return 0;
 			}
 		}
-		else
-		{
+		else {
 			timeout = 0;
 		}
 	}
 
-	if(!is_udp)
-	{
-		if(listen(port->fd, CS_QLEN) < 0)
-		{
+	if (!is_udp) {
+		if (listen(port->fd, CS_QLEN) < 0) {
 			cs_log("%s: Cannot start listen mode (errno=%d: %s)", module->desc, errno, strerror(errno));
 			close(port->fd);
 			port->fd = 0;
@@ -667,10 +645,10 @@
 		pos += snprintf(buf, sizeof(buf), "-> CAID: %04X PROVID: ", port->ncd->ncd_ftab.filts[i].caid);
 
 		for(j = 0; j < port->ncd->ncd_ftab.filts[i].nprids; j++)
-			{ pos += snprintf(buf + pos, sizeof(buf) - pos, "%06X, ", port->ncd->ncd_ftab.filts[i].prids[j]); }
+			pos += snprintf(buf+pos, sizeof(buf)-pos, "%06X, ", port->ncd->ncd_ftab.filts[i].prids[j]);
 
 		if(pos > 2 && j > 0)
-			{ buf[pos - 2] = '\0'; }
+			buf[pos-2] = '\0';
 
 		cs_log("%s", buf);
 	}
Index: oscam-net.h
===================================================================
--- oscam-net.h	(revision 10670)
+++ oscam-net.h	(working copy)
@@ -32,6 +32,8 @@
 void set_null_ip(IN_ADDR_T *ip);
 void set_localhost_ip(IN_ADDR_T *ip);
 int32_t check_ip(struct s_ip *ip, IN_ADDR_T n);
+// sky(n)
+int32_t check_LOCALHOST_ip(IN_ADDR_T n);
 uint32_t cs_getIPfromHost(const char *hostname);
 int set_socket_priority(int fd, int priority);
 void setTCPTimeouts(int32_t sock);
Index: oscam-reader.c
===================================================================
--- oscam-reader.c	(revision 10670)
+++ oscam-reader.c	(working copy)
@@ -1,10 +1,19 @@
 #define MODULE_LOG_PREFIX "reader"
 
 #include "globals.h"
+#include <sys/system_properties.h>
+#include <net/if.h>
+#include "cscrypt/md5.h"
 #include "module-cccam.h"
 #include "module-led.h"
 #include "module-stat.h"
 #include "module-dvbapi.h"
+#if defined(MODULE_CONSTCW)
+#include "module-constcw.h"
+#endif
+#include "oscam-config.h"
+#include "oscam-conf.h"
+#include "oscam-files.h"
 #include "oscam-cache.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -17,15 +26,27 @@
 #include "oscam-time.h"
 #include "oscam-work.h"
 #include "reader-common.h"
-#include "oscam-config.h"
+
+#if 1
+	#define	MYREADER_TRACE			myprintf
+#else
+	#define	MYREADER_TRACE(...)
+#endif
+/*
+ caid	= 0624
+ rsakey= 79EA25A763DA2C3E02B456A13962E60BCE63E628A2C177BE951CED96A9C6131A146F98D5867B7AE6682324FD6481913C0241F065C8D3457E54BB59B7B5DE0362
+ boxkey= A1C6F3D8B5E1F2C1
+ */
 
 extern CS_MUTEX_LOCK system_lock;
 extern CS_MUTEX_LOCK ecmcache_lock;
 extern struct ecm_request_t *ecmcwcache;
 extern const struct s_cardsystem *cardsystems[];
+// sky(n)
+extern char  *entitlement_type[];
+extern struct s_client	*dvbApi_client;
 
-const char *RDR_CD_TXT[] =
-{
+const char *RDR_CD_TXT[] = {
 	"cd", "dsr", "cts", "ring", "none",
 	"gpio1", "gpio2", "gpio3", "gpio4", "gpio5", "gpio6", "gpio7",
 	NULL
@@ -127,9 +148,9 @@
 							ecm = check_cache(erold, erold->client); //CHECK IF FOUND ECM IN CACHE
 							NULLFREE(erold);
 							if(ecm)   //found in cache
-								{ write_ecm_answer(reader, er, ecm->rc, ecm->rcEx, ecm->cw, NULL); }
+								{ write_ecm_answer(reader, er, ecm->rc, ecm->rcEx, ecm->cw, &ecm->cwEx, NULL); }
 							else
-								{ write_ecm_answer(reader, er, E_NOTFOUND, E2_RATELIMIT, NULL, "Ratelimiter: no slots free!"); }
+								{ write_ecm_answer(reader, er, E_NOTFOUND, E2_RATELIMIT, NULL, NULL, "Ratelimiter: no slots free!"); }
 
 							NULLFREE(ecm);
 							return -2;
@@ -212,7 +233,8 @@
 		else { 
 			int64_t gone = comp_timeb(&actualtime, &reader->rlecmh[h].last);
 		cs_log_dbg(D_CLIENT, "ratelimiter srvid %04X for %"PRId64" ms present in slot %d/%d of reader %s", reader->rlecmh[h].srvid, gone , h + 1,
-			maxecms, reader->label); }  //occupied slots
+					maxecms, reader->label);
+		}  //occupied slots
 	}
 
 	foundspace = dvbapi_override_prio(reader, er, maxecms, &actualtime);
@@ -265,6 +287,9 @@
 // Else just report if a free slot is available.
 {
 	// No rate limit set
+	if (!er) return OK;
+	// sky(a)
+	if ( er->ecm_bypass) return OK;
 	if(!reader->ratelimitecm)
 	{
 		return OK;
@@ -305,7 +330,7 @@
 				if(foundspace != -2)
 				{
 					cs_log_dbg(D_CLIENT, "ratelimiter no free slot for srvid %04X on reader %s -> dropping!", er->srvid, reader->label);
-					write_ecm_answer(reader, er, E_NOTFOUND, E2_RATELIMIT, NULL, "Ratelimiter: no slots free!");
+					write_ecm_answer(reader, er, E_NOTFOUND, E2_RATELIMIT, NULL, NULL, "Ratelimiter: no slots free!");
 				}
 			}
 
@@ -403,7 +429,7 @@
 			{
 				cs_log_dbg(D_CLIENT, "ratelimiter cooldownphase %d no free slot for srvid %04X on reader %s -> dropping!",
 							  reader->cooldownstate, er->srvid, reader->label);
-				write_ecm_answer(reader, er, E_NOTFOUND, E2_RATELIMIT, NULL, "Ratelimiter: cooldown no slots free!");
+				write_ecm_answer(reader, er, E_NOTFOUND, E2_RATELIMIT, NULL, NULL, "Ratelimiter: cooldown no slots free!");
 			}
 		}
 
@@ -470,19 +496,74 @@
 
 struct s_reader *get_reader_by_label(char *lbl)
 {
-	struct s_reader *rdr;
+	struct s_reader *rdr = 0;
+
+	if (!lbl) return 0;
 	LL_ITER itr = ll_iter_create(configured_readers);
-	while((rdr = ll_iter_next(&itr)))
-	{
+	while ((rdr = ll_iter_next(&itr))) {
 		if(streq(lbl, rdr->label))
-			{ break; }
+			break;
 	}
 	return rdr;
 }
+// sky(n)
+void chk_group_violation(struct s_reader *rdr)
+{
+	struct s_reader *rdr2 = 0;
+	uint64_t	lgrps = 0;
+	int i;
+
+	if (!rdr) return;
+	if ( rdr->grp) return;
+
+	LL_ITER itr  = ll_iter_create(configured_readers);
+	while ((rdr2 = ll_iter_next(&itr))) {
+		if (rdr2->grp) lgrps |= rdr2->grp;
+	}
+
+	for (i=1; i<64; i++) {
+		if ((lgrps>>i) & 1) continue;
+		rdr->grp = 1<<i;
+		mycs_trace(D_ADB, "myrdr:violation group=%llx", rdr->grp);
+		break;
+	}
+}
+
+struct s_reader *chk_sole_reader_protocols(char *protocols)
+{
+	if (!protocols) return NULL;
+	struct protocol_map {
+		char *name;
+		int  typ;
+	} sole_protocols[] = {
+		{ "constcw",R_CONSTCW },
+		{ "xcamd",	R_XCAMD},
+		{ "morecam",R_MORECAM},
+		{ "xcas",	R_XCAS},
+		{ NULL, 		0 }
+	}, *p;
+	int32_t	i, typ = 0;
+
+	// Parse protocols
+	for (i = 0, p = &sole_protocols[0]; p->name; p = &sole_protocols[++i]) {
+		if (streq(p->name, protocols)) {
+			typ = p->typ;
+			break;
+		}
+	}
+	if (!typ) return NULL;
+	struct s_reader *rdr = 0;
+	LL_ITER itr = ll_iter_create(configured_readers);
+	while ((rdr = ll_iter_next(&itr))) {
+		if (rdr->typ == typ) return (rdr);
+	}
+	return NULL;
+}
 
 const char *reader_get_type_desc(struct s_reader *rdr, int32_t extended)
 {
 	const char *desc = "unknown";
+	if (!rdr) return desc;
 	if(rdr->crdr && rdr->crdr->desc)
 		{ return rdr->crdr->desc; }
 	if(is_network_reader(rdr) || rdr->typ == R_SERIAL)
@@ -490,8 +571,11 @@
 		if(rdr->ph.desc)
 			{ desc = rdr->ph.desc; }
 	}
-	if(rdr->typ == R_NEWCAMD && rdr->ncd_proto == NCD_524)
-		{ desc = "newcamd524"; }
+	if (rdr->typ == R_NEWCAMD && rdr->ncd_proto == NCD_524) desc = "newcamd524";
+#if defined(MODULE_AVAMGCAMD)
+	else if (rdr->typ == R_NEWCAMD && rdr->ncd_exprotocol == NCD_MGCAMD) desc = "mgcamd";
+	else if (rdr->typ == R_NEWCAMD && rdr->ncd_exprotocol == NCD_AVATARCAMD) desc = "avatarcamd";
+#endif
 	else if(extended && rdr->typ == R_CCCAM && cccam_client_extended_mode(rdr->client))
 	{
 		desc = "cccam_ext";
@@ -499,17 +583,24 @@
 	return desc;
 }
 
+bool chk_reader_devices(struct s_reader *rdr)
+{
+	if (!strlen(rdr->device)) return 0;
+	if (rdr->device[0] == 0)  return 0;
+	if (rdr->r_pwd [0] == 0)  return 0;
+	if (rdr->r_usr [0] == 0)  return 0;
+	if (rdr->r_port    == 0)  return 0;
+	return 1;
+}
+
 bool hexserialset(struct s_reader *rdr)
 {
 	int i;
-	if(!rdr)
-		{ return false; }
-	for(i = 0; i < 8; i++)
-	{
-		if(rdr->hexserial[i])
-			{ return true; }
+	if (!rdr) return 0;
+	for (i = 0; i < 8; i++) {
+		if (rdr->hexserial[i]) return 1;
 	}
-	return false;
+	return 0;
 }
 
 void hexserial_to_newcamd(uchar *source, uchar *dest, uint16_t caid)
@@ -574,7 +665,8 @@
  * add or find one entitlement item to entitlements of reader
  * use add = 0 for find only, or add > 0 to find and add if not found 
  **/
-S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, uint8_t add)
+// sky(Add comments)
+S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, char *comments, uint8_t add)
 {
 	if(!rdr->ll_entitlements)
 	{ 
@@ -613,7 +705,8 @@
 			item->start = start;
 			item->end = end;
 			item->type = type;
-
+		   item->comments[0] = 0;
+		   if (comments) strcpy(item->comments, comments);
 			//add item
 			ll_append(rdr->ll_entitlements, item);
 			// cs_log_dbg(D_TRACE, "entitlement: Add caid %4X id %4X %s - %s ", item->caid, item->id, item->start, item->end);
@@ -627,56 +720,277 @@
 	
 	return item;
 }
+//
+//
+// sky(oscam.smartcard)
+// sky(sim)
+extern int __system_property_set(const char *key, char *value);
+void cs_clean_cardinformation(void)
+{
+	char viewfile[256] = { 0 };
+
+	__system_property_set("service.sci.state", "");
+	get_information_filename(viewfile, sizeof(viewfile), cs_SMCINFORMATION);
+	if (file_exists(viewfile))	{
+		cs_log("removing scinformation %s", viewfile);
+		if (unlink(viewfile) < 0) {
+			cs_log("Error removing scinformation file %s (errno=%d %s)!", viewfile, errno, strerror(errno));
+		}
+	}
+}
+
+int cs_save_cardinformation(struct s_reader *rdr)
+{
+	char viewfile[256] = { 0 };
+	FILE *fp;
+	char tbuffer1[64], tbuffer2[64], buf[256] = { 0 }, tmpbuf[256] = { 0 }, valid_to[32] = { 0 };
+	char tmp[512];
+	uint16_t casysid;
+	int32_t  i;
+
+	get_information_filename(viewfile, sizeof(viewfile), cs_SMCINFORMATION);
+	fp = fopen(viewfile, "w");
+	if (!fp) {
+		cs_log("ERROR: Cannot create file \"%s\" (errno=%d %s)", viewfile, errno, strerror(errno));
+		return 0;
+	}
+	setvbuf(fp, NULL, _IOFBF, 4 * 1024);
+	fprintf(fp, "# smc information generated automatically by sky.\n");
+	fprintf(fp, "\n");
+	if (!rdr) {
+		fprintf(fp, "%s\n", "; Reader do not exist or it is not started.");
+		fclose (fp);
+		return 0;
+	}
+
+	casysid = rdr->caid & 0xff00;
+	fprintf(fp, "[INFORMATIONS]\n");
+	if (!rdr->enable) {
+		__system_property_set("service.sci.state", "disable");
+		fprintf(fp, "  status     : disabled\n");
+		fclose (fp);
+		return 0;
+	}
+	if (rdr->card_status == NO_CARD)
+	{
+		__system_property_set("service.sci.state", "nocard");
+		fprintf(fp, "  status     : no card\n");
+		fclose(fp);
+		return 0;
+	}
+
+	fprintf(fp, "  Reader     : %s\n",   rdr->label);
+	fprintf(fp, "  Cardsystem : %s\n",  (rdr->csystem && rdr->csystem->desc) ? rdr->csystem->desc : "unknown");
+	fprintf(fp, "  Casysid    : %04X\n", rdr->caid);
+	fprintf(fp, "  Serial     : %s\n",   rdr->ascserial);
+	if (casysid == 0x0600)
+	{
+		fprintf(fp, "  Acs        : %04X\n",   rdr->acs);
+		fprintf(fp, "  Nationality: %c%c%c\n", rdr->country_code[0],rdr->country_code[1],rdr->country_code[2]);
+	}
+	else
+	if (casysid == 0x0B00)
+	{
+		fprintf(fp, "  Ver.       : %02X\n", rdr->cardver);
+		fprintf(fp, "  Maturity   : %d\n",   rdr->maturity);
+	}
+	else
+	if (casysid == 0x0500)
+	{
+		fprintf(fp, "  Maturity   : %d\n",   rdr->maturity);
+	}
+	else
+	if (casysid == 0x0D00)
+	{
+		fprintf(fp, "  Maturity   : %d\n",   rdr->maturity);
+	}
+//	fprintf(fp, "  HexSerial  : %s\n", cs_hexdump(1, rdr->hexserial, 8, tbuffer2, sizeof(tbuffer2)));
+	fprintf(fp, "  ATR        : %s\n", (rdr->card_atr_length) ? cs_hexdump(1, rdr->card_atr, rdr->card_atr_length, buf, sizeof(buf)) : "?");
+	fprintf(fp, "\n");
+	//
+	//
+	//
+	if (casysid == 0x0100 || casysid == 0x0500 || casysid == 0x0b00 || casysid == 0x0d00)
+	{
+		fprintf(fp, "  Pincode    : %s\n", rdr->pincode);
+	}
+	if (casysid == 0x0900)
+	{
+		fprintf(fp, "  Boxid      : %08X\n", rdr->boxid);
+	}
+	if (casysid == 0x0600 || casysid == 0x1800)
+	{
+		fprintf(fp, "  Boxkey     : %s\n", cs_hexdump(0, rdr->boxkey, sizeof(rdr->boxkey), tmp, sizeof(tmp)));
+	}
+	if (casysid == 0x0600 || casysid == 0x1800 || casysid == 0xB00)
+	{
+		int32_t len = check_filled(rdr->rsa_mod, 120);
+		if (len > 0) {
+			len = (len > 64) ? 120 : 64;
+			fprintf(fp, "  Rsakey     : %s\n", cs_hexdump(0, rdr->rsa_mod, len, tmp, sizeof(tmp)));
+		} else
+			fprintf(fp, "  Rsakey     : none\n");
+	}
+	fprintf(fp, "  Autoroll   : %s\n", (rdr->audisabled) ? "disable" : "enable" );
+	//
+	//
+	//
+	//
+	if (rdr->card_valid_to) {
+		struct tm vto_t;
+		localtime_r(&rdr->card_valid_to, &vto_t);
+		strftime(valid_to, sizeof(valid_to) - 1, "%Y-%m-%d", &vto_t);
+		fprintf(fp, "  ValidTo    : %s\n", valid_to);
+	}
+	if (rdr->card_status == CARD_FAILURE)
+	{
+		if (rdr->card_atr_length) {
+			__system_property_set("service.sci.state", "atr");
+		}
+		else {
+		   __system_property_set("service.sci.state", "ng");
+		}
+		fprintf(fp, "  status     : failure\n");
+		fprintf(fp, "\n");
+		fclose (fp);
+		return 0;
+	}
+	__system_property_set("service.sci.state", "ok");
+	if (casysid == 0x1800) {
+		fprintf(fp, "  status     : %s\n", rdr->nagra_negotiate ? "success" : "unsettled");
+	}
+	else {
+		fprintf(fp, "  status     : success\n");
+	}
+	fprintf(fp, "\n");
+
+	fprintf(fp, "[ENTITLEMENTS]\n");
+	if (rdr->ll_entitlements)
+	{
+		S_ENTITLEMENT *item;
+		LL_ITER itr = ll_iter_create(rdr->ll_entitlements);
+		time_t now = (time(NULL) / 84600) * 84600;
+
+		while ((item = ll_iter_next(&itr))) {
+			struct tm start_t, end_t;
+
+			localtime_r(&item->start, &start_t);
+			localtime_r(&item->end  , &end_t);
+			strftime(tbuffer1, sizeof(tbuffer1) - 1, "%d-%m-%Y", &start_t);
+			strftime(tbuffer2, sizeof(tbuffer2) - 1, "%d-%m-%Y", &end_t);
+
+			snprintf(tmpbuf, sizeof(tmpbuf) - 1, "%s:: %-9s: provid.%06X (%s ~ %s) ",
+					item->end > now ? "Active " : "Expired",
+					entitlement_type[item->type],
+					item->provid,
+					tbuffer1,
+					tbuffer2);
+			if (item->comments[0])
+			{
+				strcat(tmpbuf, item->comments);
+			}
+			else
+			{
+				char *entresname = get_tiername(item->id & 0xFFFF, item->caid, buf);
+				if (!entresname[0]) entresname = get_provider_existnace(item->caid, item->provid, buf, sizeof(buf));
+				if ( entresname[0]) {
+					strcat(tmpbuf, "Name: ");
+					strcat(tmpbuf, entresname);
+				}
+			}
+			fprintf(fp, "  %s\n", tmpbuf);
+		}
+	}
+	else
+	{
+		fprintf(fp, "; No entitlements.\n");
+	}
+
+	fprintf(fp, "\n");
+	fprintf(fp, "[PROVIDERS]\n");
+	if (rdr->nprov)
+	{
+		for (i= 0; i<rdr->nprov; i++)
+		{
+			fprintf(fp, "  %2d. %04X:%06X\n", i, rdr->caid, b2i(4, rdr->prid[i]));
+		}
+	}
+	else
+	{
+		fprintf(fp, "; No providers.\n");
+	}
+	fprintf(fp, "\n");
+	fclose(fp);
+	return 1;
+}
 
 /**
  * clears entitlements of reader.
  **/
 void cs_clear_entitlement(struct s_reader *rdr)
 {
-	if(!rdr->ll_entitlements)
-		{ return; }
+	if (!rdr) return;
+	if (!rdr->ll_entitlements) return;
 
 	ll_clear_data(rdr->ll_entitlements);
 }
 
 
-void casc_check_dcw(struct s_reader *reader, int32_t idx, int32_t rc, uchar *cw)
+void casc_check_dcw(struct s_reader *reader, int32_t idx, int32_t cwfound, uchar *cw, CWEXTENTION *cwEx)
 {
+	struct s_client *cl = reader->client;
+	ECM_REQUEST *ere;
+	ECM_REQUEST *chkere;
 	int32_t i, pending = 0;
 	time_t t = time(NULL);
-	ECM_REQUEST *ecm;
-	struct s_client *cl = reader->client;
 
-	if(!check_client(cl)) { return; }
+	if (!check_client(cl)) return;
+	chkere = &(cl->ecmtask[idx]);
+	MYREADER_TRACE("myrdr:casc_check_dcw=%d,%d, %04x{%d,%s}\n", idx, cwfound, chkere->caid, cfg.max_pending, reader->label);
+	// sky(a)
+	if (chkere->ecm_bypass)
+	{
+		if (!cwfound) return;
+		mycs_trace(D_ADB, "myrdr:casc_check_dcw.ecm_skip{%d,%d, %04X:%06X.%5d}",
+					idx,
+					chkere->rc,
+					chkere->caid, chkere->prid, chkere->srvid);
+		cs_ftime(&chkere->tps);
+		write_ecm_answer(reader, chkere, E_FOUND, 0, cw, NULL, NULL);
+		cl->last_srvid = chkere->srvid;
+		cl->last_caid  = chkere->caid;
+	 	cl->last 		= t;
+		cl->pending 	= pending;
+		reader->last_g = t;
+		chkere->rc  	= E_FOUND;
+		return;
+	}
 
 	for(i = 0; i < cfg.max_pending; i++)
 	{
-		ecm = &cl->ecmtask[i];
-		if((ecm->rc >= E_NOCARD) && ecm->caid == cl->ecmtask[idx].caid && (!memcmp(ecm->ecmd5, cl->ecmtask[idx].ecmd5, CS_ECMSTORESIZE)))
+		ere = &(cl->ecmtask[i]);
+
+		if ((ere->rc >= E_NOCARD) && ere->caid == chkere->caid && (!memcmp(ere->ecmd5, chkere->ecmd5, CS_ECMSTORESIZE)))
 		{
-			if(rc==2)  //E_INVALID from camd35 CMD08
+			if (cwfound==2)  //E_INVALID from camd35 CMD08
 			{
-				write_ecm_answer(reader, ecm, E_INVALID, 0, cw, NULL);
+				write_ecm_answer(reader, ere, E_INVALID, 0, cw, cwEx, NULL);
 			}
-			else if(rc)
-			{
-				write_ecm_answer(reader, ecm, E_FOUND, 0, cw, NULL);
+			else if (cwfound) {
+				write_ecm_answer(reader, ere, E_FOUND,   0, cw, cwEx, NULL);
 			}
-			else
-			{
-				write_ecm_answer(reader, ecm, E_NOTFOUND, 0 , NULL, NULL);
+			else {
+				write_ecm_answer(reader, ere, E_NOTFOUND,0, NULL, NULL, NULL);
 			}
-			ecm->idx = 0;
-			ecm->rc = E_FOUND;
+			ere->idx= 0;
+			ere->rc = E_FOUND;
 		}
 
-		if(ecm->rc >= E_NOCARD && (t - (uint32_t)ecm->tps.time > ((cfg.ctimeout + 500) / 1000) + 1))  // drop timeouts
-		{
-			ecm->rc = E_FOUND;
+		if ((ere->rc >= E_NOCARD) && (t-(uint32_t)ere->tps.time > ((cfg.ctimeout + 500) / 1000) + 1)) { // drop timeouts
+			ere->rc = E_FOUND;
 		}
 
-		if(ecm->rc >= E_NOCARD)
-			{ pending++; }
+		if (ere->rc >= E_NOCARD) pending++;
 	}
 	cl->pending = pending;
 }
@@ -685,7 +999,7 @@
 {
 	struct s_client *cl = rdr->client;
 
-	if(!cl) { return 0; }
+   if (!cl) return 0;
 
 	IN_ADDR_T last_ip;
 	IP_ASSIGN(last_ip, cl->ip);
@@ -694,7 +1008,16 @@
 
 	if(!IP_EQUAL(cl->ip, last_ip))
 	{
-		cs_log("%s: resolved ip=%s", rdr->device, cs_inet_ntoa(cl->ip));
+   	if (IS_SERVER_EMBEDDED(rdr)) {
+   	}
+   	else {
+			if (cfg.logsvrsecrete) {
+		  		rdr_log_tildes(rdr, "resolve ip {%s}", cs_inet_ntoa(cl->ip));
+			}
+			else {
+		  		rdr_log(rdr, "resolved ip %s", cs_inet_ntoa(cl->ip));
+			}
+	   }
 	}
 
 	return IP_ISSET(cl->ip);
@@ -702,6 +1025,7 @@
 
 void clear_block_delay(struct s_reader *rdr)
 {
+	if (!rdr) return;
 	rdr->tcp_block_delay = 0;
 	cs_ftime(&rdr->tcp_block_connect_till);
 }
@@ -723,46 +1047,277 @@
 	struct timeb cur_time;
 	cs_ftime(&cur_time);
 	int32_t diff = comp_timeb(&cur_time, &rdr->tcp_block_connect_till);
+	// sky(a)
+	// wrong time,86400(1970-01-01~)
+	if (rdr->tcp_block_connect_till.time < 40000000) {
+		rdr_log_dbg(rdr, D_TRACE, "connection time wrong(%d)", (int)rdr->tcp_block_connect_till.time);
+		return 0;
+	}
 	int32_t blocked = rdr->tcp_block_delay && diff < 0;
-	if(blocked)
+	if (blocked) {
 		rdr_log_dbg(rdr, D_TRACE, "connection blocked, retrying in %d ms", -diff);
+	}
 	return blocked;
 }
 
-int32_t network_tcp_connection_open(struct s_reader *rdr)
+// sky(Add)
+int32_t
+network_chk_intefaces(uint32_t *ip, uint8_t *mac)
+{
+	struct SOCKADDR *s_in;
+	struct ifreq ifr;
+	int sockfd;
+
+	// no mac address specified so use mac of eth0 on local box
+	sockfd = socket(PF_INET, SOCK_STREAM, 0);
+	if (sockfd < 1) return 0;
+
+	memset(&ifr, 0, sizeof(struct ifreq));
+	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "eth0");
+	if (ioctl(sockfd, SIOCGIFHWADDR, &ifr) < 0)
 {
-	if(!rdr) { return -1; }
-	struct s_client *client = rdr->client;
-	struct SOCKADDR loc_sa;
+		mycs_trace(D_ADB, "camd:!!! siocgifhwaddr(eth0) fail");
+		close(sockfd);
+	 	return 0;
+	}
 
-	memset((char *)&client->udp_sa, 0, sizeof(client->udp_sa));
+	if (mac) memcpy(mac, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);
+	if (ioctl(sockfd, SIOCGIFADDR, &ifr) < 0)
+	{
+		mycs_trace(D_ADB, "camd:!!! siocgifaddr(eth0) fail");
+		// for wifi
+		#if 0
+				memset(&ifr, 0, sizeof(struct ifreq));
+				snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "wlan0");
+				if (ioctl(sockfd, SIOCGIFHWADDR, &ifr) < 0)
+				{
+					mycs_trace(D_ADB, "camd:!!! siocgifhwaddr(wlan0) fail");
+					close(sockfd);
+					return;
+				}
+				memcpy(mac, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);
+				if (ioctl(sockfd, SIOCGIFADDR, &ifr) < 0)
+				{
+					mycs_trace(D_ADB, "camd:!!! siocgifaddr(wlan0) fail");
+					close(sockfd);
+					return;
+				}
+		#endif
+	}
+	if (ip) {
+		s_in = (struct sockaddr_in *)(&ifr.ifr_addr);
+		*ip = s_in->sin_addr.s_addr;
+	}
+	close(sockfd);
+	if (mac) {
+		MYREADER_TRACE("camd:MAC:%x.%x.%x.%x.%x.%x\n",
+			mac[0], mac[1], mac[2],
+			mac[3], mac[4], mac[5]);
+	}
+	return 1;
+}
 
+int32_t
+network_tcp_socket_open(struct s_reader *rdr, char *devices, int32_t rport)
+{
+	if (!rdr) return -1;
+	struct SOCKADDR loc_sa;
+	struct SOCKADDR tcp_sa;
+	IN_ADDR_T ip;
 	IN_ADDR_T last_ip;
-	IP_ASSIGN(last_ip, client->ip);
-	if(!hostResolve(rdr))
-		{ return -1; }
+	socklen_t sa_len;
+	int32_t	 sockfd;
+
+	MYREADER_TRACE("mysocket:connect to %s,%d\n", devices, rport);
+
+	memset((char *)&tcp_sa, 0, sizeof(tcp_sa));
+	IP_ASSIGN(last_ip, ip);
+
+   cs_resolve(devices, &ip, &tcp_sa, &sa_len);
+   IP_ASSIGN(SIN_GET_ADDR(tcp_sa), ip);
+ 	if (!IP_ISSET(ip)) {
+		MYREADER_TRACE("mysocket:hostResolve(%s) failure\n", devices);
+		return -1;
+	}
+  if (!IP_EQUAL(ip, last_ip)) {
+		clear_block_delay(rdr);
+  		MYREADER_TRACE("mysocket:resolved ip %s\n", cs_inet_ntoa(ip));
+   }
+	if (is_connect_blocked(rdr)) { // inside of blocking delay, do not connect!
+		return -1;
+	}
+	if (rport <= 0) {
+		MYREADER_TRACE("mysocket:invalid port %d for server %s\n", rport, devices);
+		return -1;
+	}
 
-	if(!IP_EQUAL(last_ip, client->ip))  //clean blocking delay on ip change:
-		{ clear_block_delay(rdr); }
+	int s_domain = PF_INET;
+	int s_family = AF_INET;
+#ifdef IPV6SUPPORT
+	if (!IN6_IS_ADDR_V4MAPPED(&ip) && !IN6_IS_ADDR_V4COMPAT(&ip))
+	{
+		s_domain  = PF_INET6;
+		s_family  = AF_INET6;
+	}
+#endif
+	int s_type   = SOCK_STREAM;
+	int s_proto  = IPPROTO_TCP;
 
-	if(is_connect_blocked(rdr))    //inside of blocking delay, do not connect!
+	if ((sockfd = socket(s_domain, s_type, s_proto)) < 0)
 	{
+		MYREADER_TRACE("mysocket:Socket creation failed (errno=%d,%s)\n", errno, strerror(errno));
+		block_connect(rdr);
+		return -1;
+	}
+
+	set_socket_priority(sockfd, cfg.netprio);
+
+	int32_t keep_alive = 1;
+	setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&keep_alive, sizeof(keep_alive));
+
+	int32_t flag = 1;
+	setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flag, sizeof(flag));
+
+	if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)
+	{
+		MYREADER_TRACE("mysocket:setsockopt failed (errno=%d,%s)\n", errno, strerror(errno));
+		block_connect(rdr);
+		sockfd = 0;
+		return -1;
+	}
+
+#ifdef SO_REUSEPORT
+	setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, (void *)&flag, sizeof(flag));
+#endif
+
+	memset((char *)&loc_sa,0,sizeof(loc_sa));
+	SIN_GET_FAMILY(loc_sa) = s_family;
+	SIN_GET_ADDR(loc_sa) = ADDR_ANY;
+
+	if (bind(sockfd, (struct sockaddr *)&loc_sa, sizeof (loc_sa)) < 0) {
+		MYREADER_TRACE("mysocket:bind failed (errno=%d,%s)\n", errno, strerror(errno));
+		block_connect(rdr);
+		close(sockfd);
+		sockfd = 0;
 		return -1;
 	}
 
-	if(client->reader->r_port <= 0)
+#ifdef IPV6SUPPORT
+	if (IN6_IS_ADDR_V4MAPPED(&ip) || IN6_IS_ADDR_V4COMPAT(&ip)) {
+		((struct sockaddr_in  *)(&tcp_sa))->sin_family  = AF_INET;
+		((struct sockaddr_in  *)(&tcp_sa))->sin_port    = htons((uint16_t)rport);
+	}
+	else {
+		((struct sockaddr_in6 *)(&tcp_sa))->sin6_family = AF_INET6;
+		((struct sockaddr_in6 *)(&tcp_sa))->sin6_port   = htons((uint16_t)rport);
+	}
+#else
+	tcp_sa.sin_family = AF_INET;
+	tcp_sa.sin_port   = htons((uint16_t)rport);
+#endif
+
+	MYREADER_TRACE("mysocket:socket open for fd=%d\n", sockfd);
+	set_nonblock(sockfd, true);
+
+	int32_t res = connect(sockfd, (struct sockaddr *)&tcp_sa, sa_len);
+	if (res == -1)
+	{
+		int32_t r = -1;
+		int32_t waitMs = 8000; // sky(cccam:tv2020),3000
+		if (errno == EINPROGRESS || errno == EALREADY)
+		{
+			MYREADER_TRACE("mysocket:connect(%d) waiting...\n", errno);
+			struct pollfd pfd;
+			pfd.fd = sockfd;
+			pfd.events = POLLOUT;
+			int32_t rc = poll(&pfd, 1, waitMs);
+			if (rc > 0)
+			{
+				uint32_t l = sizeof(r);
+				if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &r, (socklen_t *)&l) != 0)
+					{ r = -1; }
+				else
+					{ errno = r; }
+			}
+			else
 	{
-		rdr_log(client->reader, "invalid port %d for server %s", client->reader->r_port, client->reader->device);
+				errno = ETIMEDOUT;
+			}
+		}
+		if (r != 0) {
+			MYREADER_TRACE("mysocket:connect(%d) failure.%s\n", errno, strerror(errno));
+			block_connect(rdr);
+			close(sockfd);
+			sockfd = 0;
 		return -1;
 	}
+	}
+
+	set_nonblock(sockfd, false); //restore blocking mode
+	setTCPTimeouts(sockfd);
+	clear_block_delay(rdr);
+	MYREADER_TRACE("mysocket:connect successful fd=%d\n", sockfd);
+	return (sockfd);
+}
+
+void
+network_tcp_socket_close(struct s_reader *reader, int32_t sockfd)
+{
+	if (!reader) return;
+	MYREADER_TRACE("mysocket:disconnect to %d\n", sockfd);
+	if (sockfd)
+	{
+		shutdown(sockfd, SHUT_RDWR);	// Send a FIN here
+		close(sockfd);
+	}
+}
+
+
+int32_t network_tcp_connection_open(struct s_reader *rdr)
+{
+	if (!rdr) return -1;
+	if (!rdr->client) return -1;
+	struct s_client *client = rdr->client;
+	struct SOCKADDR loc_sa;
+
+	MYREADER_TRACE("myrdr:connect to %s,%d(%s)\n", rdr->device, rdr->r_port, rdr->label);
+	if (cfg.logsvrsecrete) {
+		rdr_log_tildes(rdr, "connect to {%s},{%d}\n", T_READER_DEVICES(rdr), T_READER_RPORTS(rdr));
+	}
+	else {
+		rdr_log(rdr, "connect to %s,%d\n", T_READER_DEVICES(rdr), T_READER_RPORTS(rdr));
+	}
+	memset((char *)&client->udp_sa, 0, sizeof(client->udp_sa));
 
-	client->is_udp = (rdr->typ == R_CAMD35);
+	IN_ADDR_T last_ip;
+	IP_ASSIGN(last_ip, client->ip);
+	if (!hostResolve(rdr)) {
+		MYREADER_TRACE("hostResolve(%s) failure\n", client->reader->device);
+		return -1;
+	}
+	if (!IP_EQUAL(last_ip, client->ip)) { // clean blocking delay on ip change:
+		clear_block_delay(rdr);
+	}
+	if (is_connect_blocked(rdr)) { // inside of blocking delay, do not connect!
+		return -1;
+	}
 
-	rdr_log(rdr, "connecting to %s:%d", rdr->device, rdr->r_port);
+	if (client->reader->r_port <= 0) {
+		if (cfg.logsvrsecrete) {
+			rdr_log_tildes(client->reader, "invalid port {%d} for server {%s}", T_READER_RPORTS(client->reader), T_READER_DEVICES(client->reader));
+		}
+		else {
+			rdr_log(client->reader, "invalid port %d for server %s", T_READER_RPORTS(client->reader), T_READER_DEVICES(client->reader));
+		}
+		return -1;
+	}
 
-	if(client->udp_fd)
-		{ rdr_log(rdr, "WARNING: client->udp_fd was not 0"); }
+	int bindCounter = 1;
+	client->is_udp = (rdr->typ==R_CAMD35) ? 1 : 0;
 
+	if (client->udp_fd) {
+		rdr_log(rdr, "WARNING: client->udp_fd was not 0");
+	}
 	int s_domain = PF_INET;
 	int s_family = AF_INET;
 #ifdef IPV6SUPPORT
@@ -777,7 +1332,7 @@
 
 	if((client->udp_fd = socket(s_domain, s_type, s_proto)) < 0)
 	{
-		rdr_log(rdr, "Socket creation failed (errno=%d %s)", errno, strerror(errno));
+		rdr_log(rdr, "Socket creation failed (errno=%d,%s)", errno, strerror(errno));
 		client->udp_fd = 0;
 		block_connect(rdr);
 		return -1;
@@ -793,7 +1348,7 @@
 
 	if(setsockopt(client->udp_fd, SOL_SOCKET, SO_REUSEADDR, (void *)&flag, sizeof(flag)) < 0)
 	{
-		rdr_log(rdr, "setsockopt failed (errno=%d: %s)", errno, strerror(errno));
+		rdr_log(rdr, "setsockopt failed (errno=%d,%s)", errno, strerror(errno));
 		client->udp_fd = 0;
 		block_connect(rdr);
 		return -1;
@@ -809,24 +1364,41 @@
 		{ SIN_GET_ADDR(loc_sa) = ADDR_ANY; }
 
 	if(client->reader->l_port)
-		{ SIN_GET_PORT(loc_sa) = htons(client->reader->l_port); }
+	{
+		do
+		{
+			SIN_GET_PORT(loc_sa) = htons(client->reader->l_port);
+			if (bind(client->udp_fd, (struct sockaddr *)&loc_sa, sizeof (loc_sa)) >= 0) break;
+			client->reader->l_port++;
+		} while (--bindCounter);
+		if (bindCounter==0) {
+			MYREADER_TRACE("myrdr:bind failed (errno=%d,%s)", errno, strerror(errno));
+			rdr_log(rdr, "bind failed (errno=%d,%s)", errno, strerror(errno));
+			close(client->udp_fd);
+			client->udp_fd = 0;
+			block_connect(rdr);
+			return -1;
+		}
+	}
+	else
+	{
+	//	if (bind(client->udp_fd, (struct sockaddr *)&loc_sa, sizeof (loc_sa)) < 0) {
 	if(client->is_udp && bind(client->udp_fd, (struct sockaddr *)&loc_sa, sizeof(loc_sa)) < 0)
 	{
-		rdr_log(rdr, "bind failed (errno=%d %s)", errno, strerror(errno));
+			rdr_log(rdr, "bind failed (errno=%d,%s)", errno, strerror(errno));
 		close(client->udp_fd);
 		client->udp_fd = 0;
 		block_connect(rdr);
 		return -1;
 	}
+	}
 
 #ifdef IPV6SUPPORT
-	if(IN6_IS_ADDR_V4MAPPED(&rdr->client->ip) || IN6_IS_ADDR_V4COMPAT(&rdr->client->ip))
-	{
+	if (IN6_IS_ADDR_V4MAPPED(&rdr->client->ip) || IN6_IS_ADDR_V4COMPAT(&rdr->client->ip)) {
 		((struct sockaddr_in *)(&client->udp_sa))->sin_family = AF_INET;
 		((struct sockaddr_in *)(&client->udp_sa))->sin_port = htons((uint16_t)client->reader->r_port);
 	}
-	else
-	{
+	else {
 		((struct sockaddr_in6 *)(&client->udp_sa))->sin6_family = AF_INET6;
 		((struct sockaddr_in6 *)(&client->udp_sa))->sin6_port = htons((uint16_t)client->reader->r_port);
 	}
@@ -837,10 +1409,9 @@
 
 	rdr_log_dbg(rdr, D_TRACE, "socket open fd=%d", client->udp_fd);
 
-	if(client->is_udp)
-	{
+	if (client->is_udp) {
 		rdr->tcp_connected = 1;
-		return client->udp_fd;
+		return (client->udp_fd);
 	}
 
 	set_nonblock(client->udp_fd, true);
@@ -849,12 +1420,14 @@
 	if(res == -1)
 	{
 		int32_t r = -1;
+		int32_t waitMs = 8000; // sky(cccam:tv2020),3000
 		if(errno == EINPROGRESS || errno == EALREADY)
 		{
+			rdr_log(rdr, "connect(%d) waiting...", errno);
 			struct pollfd pfd;
 			pfd.fd = client->udp_fd;
 			pfd.events = POLLOUT;
-			int32_t rc = poll(&pfd, 1, 3000);
+			int32_t rc = poll(&pfd, 1, waitMs);
 			if(rc > 0)
 			{
 				uint32_t l = sizeof(r);
@@ -868,9 +1441,8 @@
 				errno = ETIMEDOUT;
 			}
 		}
-		if(r != 0)
-		{
-			rdr_log(rdr, "connect failed: %s", strerror(errno));
+		if (r != 0) {
+			rdr_log(rdr, "connect(%d) failure.%s", errno, strerror(errno));
 			block_connect(rdr); //connect has failed. Block connect for a while
 			close(client->udp_fd);
 			client->udp_fd = 0;
@@ -882,19 +1454,18 @@
 
 	setTCPTimeouts(client->udp_fd);
 	clear_block_delay(rdr);
+	client->pfd  = client->udp_fd;
 	client->last = client->login = time((time_t *)0);
 	client->last_caid = NO_CAID_VALUE;
 	client->last_srvid = NO_SRVID_VALUE;
-	client->pfd = client->udp_fd;
 	rdr->tcp_connected = 1;
 	rdr_log_dbg(rdr, D_TRACE, "connect successful fd=%d", client->udp_fd);
-	return client->udp_fd;
+	return (client->udp_fd);
 }
 
 void network_tcp_connection_close(struct s_reader *reader, char *reason)
 {
-	if(!reader)
-	{
+	if (!reader) {
 		//only proxy reader should call this, client connections are closed on thread cleanup
 		cs_log("WARNING: invalid client");
 		cs_disconnect_client(cur_client());
@@ -902,14 +1473,26 @@
 	}
 
 	struct s_client *cl = reader->client;
-	if(!cl) { return; }
-	int32_t fd = cl->udp_fd;
+	if (!cl) return;
 
+	int32_t fd = cl->udp_fd;
 	int32_t i;
 
 	if(fd)
 	{
-		rdr_log(reader, "disconnected: reason %s", reason ? reason : "undef");
+		rdr_log(reader, "disconnected(%s)", reason ? reason : "undef");
+//		MYREADER_TRACE("myrdr:disconnected %s(%s):%s\n", reader->device, reader->label, (reason) ? reason : "undef");
+
+		#if 1
+		// sky(!)
+		// for remove TIME_WAIT status
+		// Linger Options
+		//	struct linger lng;
+		//	lng.l_onoff  = 1;
+		//	lng.l_linger = 0;
+		//	setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&lng, sizeof(lng));
+			shutdown(fd, SHUT_RDWR);	// Send a FIN here
+		#endif
 		close(fd);
 
 		cl->udp_fd = 0;
@@ -922,8 +1505,7 @@
 
 	if(cl->ecmtask)
 	{
-		for(i = 0; i < cfg.max_pending; i++)
-		{
+		for (i = 0; i < cfg.max_pending; i++) {
 			cl->ecmtask[i].idx = 0;
 			cl->ecmtask[i].rc = E_FOUND;
 		}
@@ -931,52 +1513,56 @@
 	// newcamd message ids are stored as a reference in ecmtask[].idx
 	// so we need to reset them aswell
 	if(reader->typ == R_NEWCAMD)
-		{ cl->ncd_msgid = 0; }
+		cl->ncd_msgid = 0;
 }
 
 int32_t casc_process_ecm(struct s_reader *reader, ECM_REQUEST *er)
 {
-	int32_t rc, n, i, sflag, pending = 0;
-	time_t t;//, tls;
 	struct s_client *cl = reader->client;
+	int32_t rc, n, i, sending, pending=0;
+	// sky(n)
+	int32_t nfirst = 0, niniz = -1;
+	time_t  t;//, tls;
 
-	if(!cl || !cl->ecmtask)
-	{
+	mycs_trace(D_ADB, "myrdr:casc_process_ecm{%s}", reader->label);
+	if (!cl || !cl->ecmtask) {
 		rdr_log(reader, "WARNING: ecmtask not a available");
 		return -1;
 	}
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (IS_ICS_READERS(reader)) {
+		if (er->ecm_bypass || er->ecm_useless) return -1;
+		niniz = 0; nfirst = 1;
+	}
+#endif
 
 	uchar buf[512];
 
 	t = time((time_t *)0);
-	ECM_REQUEST *ecm;
-	for(i = 0; i < cfg.max_pending; i++)
-	{
-		ecm = &cl->ecmtask[i];
-		if((ecm->rc >= E_NOCARD) && (t - (uint32_t)ecm->tps.time > ((cfg.ctimeout + 500) / 1000) + 1))  // drop timeouts
+	ECM_REQUEST *ere;
+	for (i = nfirst; i < cfg.max_pending; i++)
 		{
-			ecm->rc = E_FOUND;
+		ere = &cl->ecmtask[i];
+		if (((ere->rc >= E_NOCARD) && (t-(uint32_t)ere->tps.time > ((cfg.ctimeout + 500) / 1000) + 1))) { // drop timeouts
+			ere->rc = E_FOUND;
 		}
 	}
-
-	for(n = -1, i = 0, sflag = 1; i < cfg.max_pending; i++)
+	for (n = niniz, i = nfirst, sending = 1; i < cfg.max_pending; i++)
 	{
-		ecm = &cl->ecmtask[i];
-		if(n < 0 && (ecm->rc < E_NOCARD))  // free slot found
-			{ n = i; }
+		ere = &cl->ecmtask[i];
+		if (n<nfirst && (ere->rc < E_NOCARD))	// free slot found
+			n = i;
 
 		// ecm already pending
 		// ... this level at least
-		if((ecm->rc >= E_NOCARD) &&  er->caid == ecm->caid && (!memcmp(er->ecmd5, ecm->ecmd5, CS_ECMSTORESIZE)))
-			{ sflag = 0; }
+		if ((ere->rc >= E_NOCARD) && er->caid == ere->caid && (!memcmp(er->ecmd5, ere->ecmd5, CS_ECMSTORESIZE)))
+			sending = 0;
 
-		if(ecm->rc >= E_NOCARD)
-			{ pending++; }
+		if (ere->rc >= E_NOCARD) pending++;
 	}
 	cl->pending = pending;
 
-	if(n < 0)
-	{
+	if (n<0) {
 		rdr_log(reader, "WARNING: reader ecm pending table overflow !!");
 		return (-2);
 	}
@@ -980,39 +1566,53 @@
 		rdr_log(reader, "WARNING: reader ecm pending table overflow !!");
 		return (-2);
 	}
-
 	memcpy(&cl->ecmtask[n], er, sizeof(ECM_REQUEST));
+
+	cl->ecmtask[n].parent = er;
 	cl->ecmtask[n].matching_rdr = NULL; //This avoids double free of matching_rdr!
 #ifdef CS_CACHEEX
 	cl->ecmtask[n].csp_lastnodes = NULL; //This avoids double free of csp_lastnodes!
 #endif
-	cl->ecmtask[n].parent = er;
 
-	if(reader->typ == R_NEWCAMD)
-		{ cl->ecmtask[n].idx = (cl->ncd_msgid == 0) ? 2 : cl->ncd_msgid + 1; }
+// sky(n)
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (IS_ICS_READERS(reader))
+	{
+		// sky(uk)
+		if (XCAMDIKS_Isv2()) {
+			cl->ch_ecmsequece++;
+	      if (cl->ch_ecmsequece < ERE_CS_FIRST) cl->ch_ecmsequece = ERE_CS_FIRST;
+	      if (cl->ch_ecmsequece > ERE_CS_FINAL) cl->ch_ecmsequece = ERE_CS_FIRST;
+		   mycs_trace(D_ADB, "myrdr:ecm.sequence{%d}{%04X}{s.%d}",
+				   n, cl->ecmtask[n].caid, cl->ch_ecmsequece);
+			cl->ecmtask[n].idx = cl->ch_ecmsequece;
+		}
+	}
 	else
-	{
-		if(!cl->idx)
-			{ cl->idx = 1; }
+#endif
+	if (reader->typ == R_NEWCAMD)
+		cl->ecmtask[n].idx = (cl->ncd_msgid==0) ? 2 : cl->ncd_msgid+1;
+	else {
+		if (!cl->idx) cl->idx = 1;
 		cl->ecmtask[n].idx = cl->idx++;
 	}
 
 	cl->ecmtask[n].rc = E_NOCARD;
-	cs_log_dbg(D_TRACE, "---- ecm_task %d, idx %d, sflag=%d", n, cl->ecmtask[n].idx, sflag);
-
-	cs_log_dump_dbg(D_ATR, er->ecm, er->ecmlen, "casc ecm (%s):", (reader) ? reader->label : "n/a");
+	cs_log_dbg(D_TRACE, "---- ecm_task %d, idx %d, sending=%d", n, cl->ecmtask[n].idx, sending);
+	cs_log_dump_dbg(D_TRACE, er->ecm, er->ecmlen, "casc ecm (%s):", (reader) ? reader->label : "n/a");
 	rc = 0;
-	if(sflag)
+	if (sending)
 	{
-		if((rc = reader->ph.c_send_ecm(cl, &cl->ecmtask[n], buf)))
-			{ casc_check_dcw(reader, n, 0, cl->ecmtask[n].cw); }  // simulate "not found"
+		rc = reader->ph.c_send_ecm(cl, &cl->ecmtask[n], buf);
+		MYREADER_TRACE("myrdr:c_send_ecm{%s.%d}\n", reader->label, rc);
+		if (rc)
+			casc_check_dcw(reader, n, 0, cl->ecmtask[n].cw, &cl->ecmtask[n].cwEx);  // simulate "not found"
 		else
-			{ cl->last_idx = cl->ecmtask[n].idx; }
+			cl->last_idx = cl->ecmtask[n].idx;
 		reader->last_s = t;   // used for inactive_timeout and reconnect_timeout in TCP reader
 	}
 
-	if(cl->idx > 0x1ffe) { cl->idx = 1; }
-
+	if (cl->idx > 0x1ffe) cl->idx = 1;
 	return (rc);
 }
 
@@ -1016,22 +1616,46 @@
 	return (rc);
 }
 
+
 void reader_get_ecm(struct s_reader *reader, ECM_REQUEST *er)
 {
-	if(!reader) { return; }
+	if (!er) return;
+	if (!reader) return;
 	struct s_client *cl = reader->client;
-	if(!check_client(cl)) { return; }
+	if (!check_client(cl)) return;
 
-	if(!chk_bcaid(er, &reader->ctab))
-	{
+	mycs_trace(D_ADB, "myrdr:reader_get_ecm(%s.%d)", reader->label, er->rc);
+
+	if (!chk_bcaid(er, &reader->ctab)) {
 		rdr_log_dbg(reader, D_READER, "caid %04X filtered", er->caid);
-		write_ecm_answer(reader, er, E_NOTFOUND, E2_CAID, NULL, NULL);
+		mycs_trace(D_READER, "caid %04X filtered", er->caid);
+		write_ecm_answer(reader, er, E_NOTFOUND, E2_CAID, NULL, NULL, NULL);
 		return;
 	}
 
+#if defined(MODULE_XCAS)
+	if (IS_CONSTCW_READERS(reader))
+	{
+		if (er->constAfterwards > 1) {
+			mycs_trace(D_ADB, "myrdr:constAfterwards.%s", reader->label);
+			return;
+		}
+	}
+#endif
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (CSREADER_ChkEcmSkipto(reader, er))
+	{
+		mycs_trace(D_ADB, "myrdr:ecm_useless.%s", reader->label);
+		return;
+	}
+#endif
+
 	//CHECK if ecm already sent to reader
 	struct s_ecm_answer *ea_er = get_ecm_answer(reader, er);
-	if(!ea_er) { return; }
+	if (!ea_er) {
+		mycs_trace(D_ADB, "myrdr:ecm_sent.");
+		return;
+	}
 
 	struct s_ecm_answer *ea = NULL, *ea_prev = NULL;
 	struct ecm_request_t *ecm;
@@ -1041,10 +1665,16 @@
 	for(ecm = ecmcwcache; ecm; ecm = ecm->next)
 	{
 		timeout = time(NULL) - ((cfg.ctimeout+500)/1000+1);
-		if(ecm->tps.time <= timeout)
-			{ break; }
+		if (ecm->tps.time <= timeout) break;
+#if defined(MODULE_XCAS)
+		if (er->constAfterwards)
+		{
+			mycs_trace(D_ADB, "myrdr:constAfterwards.");
+			break;
+		}
+#endif
 
-		if(!ecm->matching_rdr || ecm == er || ecm->rc == E_99) { continue; }
+		if (!ecm->matching_rdr || ecm == er || ecm->rc == E_99) continue;
 
 		//match same ecm
 		if(er->caid == ecm->caid && !memcmp(er->ecmd5, ecm->ecmd5, CS_ECMSTORESIZE))
@@ -1067,7 +1697,7 @@
 			cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [reader_get_ecm] ecm already sent to reader %s (%s)", (check_client(er->client) ? er->client->account->usr : "-"), er->caid, er->prid, er->srvid, reader ? reader->label : "-", ea->rc==E_FOUND?"OK":"NOK");
 
 			//e.g. we cannot send timeout, because "ea_temp->er->client" could wait/ask other readers! Simply set not_found if different from E_FOUND!
-			write_ecm_answer(reader, er, (ea->rc==E_FOUND? E_FOUND : E_NOTFOUND), ea->rcEx, ea->cw, NULL);
+			write_ecm_answer(reader, er, (ea->rc==E_FOUND ? E_FOUND : E_NOTFOUND), ea->rcEx, ea->cw, &ea->cwEx, NULL);
 			return;
 		}
 		else
@@ -1083,14 +1713,12 @@
 
 	lb_update_last(ea_er, reader);
 
-	if(ecm_ratelimit_check(reader, er, 1) != OK)
-	{
+	if (ecm_ratelimit_check(reader, er, 1) != OK) {
 		rdr_log_dbg(reader, D_READER, "ratelimiter has no space left -> skip!");
 		return;
 	}
 
-	if(is_cascading_reader(reader))     // forward request to proxy reader
-	{
+	if (is_cascading_reader(reader)) { // forward request to proxy reader
 		cl->last_srvid = er->srvid;
 		cl->last_caid = er->caid;
 		casc_process_ecm(reader, er);
@@ -1103,37 +1731,41 @@
 
 void reader_do_card_info(struct s_reader *reader)
 {
+	if (!reader) return;
 	cardreader_get_card_info(reader);
-	if(reader->ph.c_card_info)
-		{ reader->ph.c_card_info(); }
+
+	if (reader->ph.c_card_info) {
+		 reader->ph.c_card_info();
+	}
 }
 
 void reader_do_idle(struct s_reader *reader)
 {
-	if(reader->ph.c_idle)
-		{ reader->ph.c_idle(); }
+	if (reader->ph.c_idle) { reader->ph.c_idle(); }
 	else if (reader->tcp_ito > 0)
 	{
 		time_t now;
 		int32_t time_diff;
 		time(&now);
 		time_diff = llabs(now - reader->last_s);
-		if(time_diff > reader->tcp_ito)
-		{
+		if (time_diff > reader->tcp_ito) {
 			struct s_client *cl = reader->client;
 			if(check_client(cl) && reader->tcp_connected && reader->ph.type == MOD_CONN_TCP)
 			{
 				rdr_log_dbg(reader, D_READER, "inactive_timeout, close connection (fd=%d)", cl->pfd);
 				network_tcp_connection_close(reader, "inactivity");
 			}
-			else
-				{ reader->last_s = now; }
+			else {
+				reader->last_s = now;
+			}
 		}
 	}
 }
 
 int32_t reader_init(struct s_reader *reader)
 {
+	if (!reader) return 0;
+	if (!reader->client) return 0;
 	struct s_client *client = reader->client;
 
 	if(is_cascading_reader(reader))
@@ -1148,9 +1780,9 @@
 			return 0;
 		}
 
-		if(reader->ph.c_init(client))
-		{
+		if (reader->ph.c_init(client)) {
 			//proxy reader start failed
+			rdr_log(reader, "myrdr:init error{%s}", reader->label);
 			return 0;
 		}
 
@@ -1161,14 +1793,13 @@
 		}
 
 		if(!cs_malloc(&client->ecmtask, cfg.max_pending * sizeof(ECM_REQUEST)))
-			{ return 0; }
+			return 0;
 
-		rdr_log(reader, "proxy initialized, server %s:%d", reader->device, reader->r_port);
+		MYREADER_TRACE("myrdr:initialized(%s,%d)\n", reader->device, reader->r_port);
 	}
-	else
-	{
-		if(!cardreader_init(reader))
-			{ return 0; }
+	else {
+		if (!reader->typ) return 0;
+		if (!cardreader_init(reader)) return 0;
 	}
 
 	ll_destroy_data(&reader->emmstat);
@@ -1196,7 +1827,7 @@
 	for(cl = first_client->next; cl ; cl = cl->next)
 	{
 		if(cl->typ == 'r' && cl->reader)
-			{ add_job(cl, ACTION_READER_CARDINFO, NULL, 0); }
+			add_job(cl, ACTION_READER_CARDINFO, NULL, 0);
 	}
 }
 
@@ -1207,20 +1838,18 @@
 	struct s_reader *rdr2, *rdr_prv = NULL, *rdr_tmp = NULL;
 	int8_t at_first = 1;
 
-	if(rdr->next)
-		{ remove_reader_from_active(rdr); }
-
+	if (rdr->next) {
+		remove_reader_from_active(rdr);
+	}
 	cs_writelock(&readerlist_lock);
 	cs_writelock(&clientlist_lock);
 
 	// search configured position:
-	LL_ITER it = ll_iter_create(configured_readers);
-	while((rdr2 = ll_iter_next(&it)))
-	{
-		if(rdr2 == rdr)
-			{ break; }
-		if(rdr2->client && rdr2->enable)
+	LL_ITER itr  = ll_iter_create(configured_readers);
+	while ((rdr2 = ll_iter_next(&itr)))
 		{
+		if (rdr2 == rdr) break;
+		if (rdr2->client && rdr2->enable) {
 			rdr_prv = rdr2;
 			at_first = 0;
 		}
@@ -1229,8 +1858,7 @@
 	// insert at configured position:
 	if(first_active_reader)
 	{
-		if(at_first)
-		{
+		if (at_first) {
 			rdr->next = first_active_reader;
 			first_active_reader = rdr;
 			//resort client list:
@@ -1239,18 +1867,16 @@
 					prev->next != NULL; prev = prev->next, cl = cl->next)
 			{
 				if(rdr->client == cl)
-					{ break; }
+					break;
 			}
-			if(cl && rdr->client == cl)
-			{
+			if (cl && rdr->client == cl) {
 				prev->next = cl->next; //remove client from list
 				cl->next = first_client->next;
 				first_client->next = cl;
 			}
 		}
-		else
-		{
-			for(rdr2 = first_active_reader; rdr2->next && rdr2 != rdr_prv ; rdr2 = rdr2->next) { ; }  //search last element
+		else {
+			for (rdr2=first_active_reader; rdr2->next && rdr2 != rdr_prv ; rdr2=rdr2->next) ; //search last element
 			rdr_prv = rdr2;
 			rdr_tmp = rdr2->next;
 			rdr2->next = rdr;
@@ -1261,18 +1887,16 @@
 					prev->next != NULL; prev = prev->next, cl = cl->next)
 			{
 				if(rdr->client == cl)
-					{ break; }
+					break;
 			}
-			if(cl && rdr->client == cl)
-			{
+			if (cl && rdr->client == cl) {
 				prev->next = cl->next; //remove client from list
 				cl->next = rdr_prv->client->next;
 				rdr_prv->client->next = cl;
 			}
 		}
 	}
-	else
-	{
+	else {
 		first_active_reader = rdr;
 	}
 	rdr->active = 1;
@@ -1284,14 +1908,15 @@
 void remove_reader_from_active(struct s_reader *rdr)
 {
 	struct s_reader *rdr2, *prv = NULL;
-	//rdr_log(rdr, "CHECK: REMOVE READER FROM ACTIVE");
+
+	mycs_trace(D_ADB, "myrdr:REMOVE READER(%s) FROM ACTIVE", rdr->label);
 	cs_writelock(&readerlist_lock);
 	for(rdr2 = first_active_reader; rdr2 ; prv = rdr2, rdr2 = rdr2->next)
 	{
 		if(rdr2 == rdr)
 		{
-			if(prv) { prv->next = rdr2->next; }
-			else { first_active_reader = rdr2->next; }
+			if (prv) prv->next = rdr2->next;
+			else first_active_reader = rdr2->next;
 			break;
 		}
 	}
@@ -1304,51 +1929,80 @@
    if restart=0 the cardreader is only started. */
 static int32_t restart_cardreader_int(struct s_reader *rdr, int32_t restart)
 {
+	if (!rdr) return 0;
 	struct s_client *cl = rdr->client;
-	if(restart)
-	{
+
+	if (restart) {
 		remove_reader_from_active(rdr); // remove from list
 		kill_thread(cl); // kill old thread
 		cs_sleepms(1500);  //we have to wait a bit so free_client is ended and socket closed too!
 	}
 
-	while(restart && is_valid_client(cl))
-	{
+	int timeouts = 0;
+	while (restart && is_valid_client(cl)) {
 		// If we quick disable+enable a reader (webif), remove_reader_from_active is called from
 		// cleanup. this could happen AFTER reader is restarted, so oscam crashes or reader is hidden
-		// rdr_log(rdr, "CHECK: WAITING FOR CLEANUP");
+		mycs_trace(D_ADB, "myrdr:WAITING FOR CLEANUP(%d)", timeouts);
 		cs_sleepms(500);
+		if (++timeouts>10) break;
+	}
+
+#if defined(WITH_HISILICON)
+	// sky(sim)
+	if (IS_CARD_READER(rdr)) {
+		if (!chker_smartcard_enable()) {
+			rdr_log(rdr, "smartcard nosupport\n");
+			rdr->card_status = UNKNOWN;
+			rdr->client = NULL;
+			rdr->enable = 0;
+			return 0;
+		}
 	}
 
+	if (is_cascading_reader(rdr)) {
+		if ( chker_factoy_products()) {
+			rdr_log(rdr, "factoy products nosupport\n");
+			rdr->card_status = UNKNOWN;
+			rdr->client = NULL;
+			rdr->enable = 0;
+			return 0;
+		}
+	}
+#endif
+
+	mycs_trace(D_ADB, "myrdr:restart_cardreader{%02X}(%s,%d,%d) {%d}",
+			rdr->typ, rdr->device, rdr->r_port, rdr->l_port, restart);
 	rdr->client = NULL;
 	rdr->tcp_connected = 0;
 	rdr->card_status = UNKNOWN;
 	rdr->tcp_block_delay = 100;
+	// sky(n)
+	rdr->restarting 		= restart;
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	rdr->iks_ecmRequired	= 0;
+	rdr->iks_ecmSento		= 0;
+	rdr->ics_chMonitor	= 0;
+#endif
 	cs_ftime(&rdr->tcp_block_connect_till);
 
-	if(rdr->device[0] && is_cascading_reader(rdr))
-	{
-		if(!rdr->ph.num)
-		{
+	if (rdr->device[0] && is_cascading_reader(rdr)) {
+		if (!rdr->ph.num) {
+			rdr->enable = 0;
 			rdr_log(rdr, "Protocol Support missing. (typ=%d)", rdr->typ);
 			return 0;
 		}
 	}
 
-	if(!rdr->enable)
-		{ return 0; }
-
+	if (!rdr->enable) return 0;
 	if(rdr->device[0])
 	{
-		if(restart)
-		{
+		if (restart) {
 			rdr_log(rdr, "Restarting reader");
 		}
 		cl = create_client(first_client->ip);
-		if(cl == NULL)
-			{ return 0; }
+		if (cl == NULL) return 0;
 		cl->reader  = rdr;
-		rdr_log(rdr, "creating thread for device %s", rdr->device);
+		rdr_log(rdr, "creating thread for device %s", rdr->label);
 
 		cl->sidtabs.ok = rdr->sidtabs.ok;
 		cl->sidtabs.no = rdr->sidtabs.no;
@@ -1375,7 +2029,7 @@
 	cs_writelock(&system_lock);
 	int32_t result = restart_cardreader_int(rdr, restart);
 	cs_writeunlock(&system_lock);
-	return result;
+	return (result);
 }
 
 void init_cardreader(void)
@@ -1388,8 +2042,8 @@
 	LL_ITER itr = ll_iter_create(configured_readers);
 	while((rdr = ll_iter_next(&itr)))
 	{
-		if(rdr->enable)
-		{
+		cs_log_dbg(D_TRACE, "cardreader: %s(%d)", rdr->label, rdr->enable);
+		if (rdr->enable) {
 			restart_cardreader_int(rdr, 0);
 		}
 	}
@@ -1404,8 +2058,8 @@
 	for(rdr = first_active_reader; rdr; rdr = rdr->next)
 	{
 		struct s_client *cl = rdr->client;
-		if(!cl)
-			{ continue; }
+
+		if (!cl) continue;
 		rdr_log(rdr, "Killing reader");
 		kill_thread(cl);
 	}
@@ -1414,12 +2068,140 @@
 
 int32_t reader_slots_available(struct s_reader *reader, ECM_REQUEST *er)
 {
-	if(ecm_ratelimit_check(reader, er, 0) != OK)   //check ratelimiter & cooldown -> in check mode: dont register srvid!!!
-	{
+	if (ecm_ratelimit_check(reader, er, 0) != OK) { // check ratelimiter & cooldown -> in check mode: dont register srvid!!!
 		return 0; // no slot free
 	}
-	else
-	{
+	else {
 		return 1; // slots available!
 	}
 }
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+uint16_t
+CSREADER_Chkstatus(struct s_reader *rdr)
+{
+	uint16_t	rdrstatus;
+
+	if (!rdr) return (READERSTATUS_UNKNOWN);
+	if (!rdr->enable) return (READERSTATUS_DISABLED);
+	switch (rdr->card_status) {
+		case NO_CARD: 			rdrstatus = READERSTATUS_DISCONNECT; break;
+		case CARD_NEED_INIT:	rdrstatus = READERSTATUS_DISCONNECT; break;
+		case CARD_FAILURE:  	rdrstatus = READERSTATUS_FAILURE; 	 break;
+		case CARD_INSERTED:	rdrstatus = READERSTATUS_OK;			 break;
+		case CARD_UNREGISTER:rdrstatus = READERSTATUS_NOTSUPPORT; break;
+		case UNKNOWN:
+		default:					rdrstatus = READERSTATUS_UNKNOWN; 	 break;
+	}
+	return (rdrstatus);
+}
+
+struct s_reader *
+CSREADER_GetReaders(int32_t typ)
+{
+	struct s_reader *rdr;
+	for (rdr = first_active_reader; rdr; rdr = rdr->next)
+	{
+		if (rdr->typ == typ) return (rdr);
+	}
+	return (NULL);
+}
+
+void
+CSREADER_Restart(int32_t typ)
+{
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	struct s_reader *rdr;
+
+	rdr = CSREADER_ChkActive(typ);
+	if (!rdr) return;
+	if (!rdr->client) return;
+	mycs_trace(D_ADB, "myrdr:reader restart{%x}", typ);
+	add_job(rdr->client, ACTION_READER_RESTART, NULL, 0);
+#endif
+}
+
+bool
+CSREADER_IsFTAbiss(uint16_t degree, uint32_t frequency, uint16_t srvid, uint16_t vidpid)
+{
+#if defined(MODULE_CONSTCW)
+	struct s_reader *rdr;
+	uint32_t pfid;
+	uint16_t edegree;
+
+	pfid = cs_i2BCD(frequency);
+	edegree = cs_i2BCD(degree);
+
+	rdr = CSREADER_GetReaders(R_CONSTCW);
+	if (!rdr) return 0;
+	if (CONSTCW_IsFtaBisses(rdr,
+				0x2600,
+				pfid,
+				srvid,
+				vidpid,
+				edegree)) return 1;
+#endif
+	return 0;
+}
+
+#if defined(MODULE_CONSTCW) || defined(MODULE_XCAS) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+struct s_reader *
+CSREADER_ChkActive(int32_t typ)
+{
+	struct s_reader *rdr;
+
+	rdr = CSREADER_GetReaders(typ);
+	if (!rdr) return 0;
+	if (!rdr->enable) return 0;
+	if ( rdr->card_status != CARD_INSERTED) return 0;
+	if (!check_client(rdr->client)) return 0;
+	return (rdr);
+}
+
+
+void
+CSREADER_ChCloser(int dmuxid, struct demux_s *demuxp, int32_t typ)
+{
+	struct s_reader *rdr;
+
+	rdr = CSREADER_ChkActive(typ);
+	if (!rdr) return;
+	if (!rdr->client) return;
+	struct s_client *cl = rdr->client;
+	mycs_trace(D_ADB, "myrdr:ch.stop{%02X,%p}{%d}", typ, cl, dmuxid);
+	if (rdr->ph.c_ChCloser) {
+		 rdr->ph.c_ChCloser(cl, dmuxid);
+	}
+}
+
+
+bool
+CSREADER_ChRetuning(int dmuxid, struct demux_s *demuxp, int32_t typ)
+{
+	struct s_reader *rdr;
+
+	rdr = CSREADER_ChkActive(typ);
+	if (!rdr) return 0;
+	if (!rdr->ics_chRetune) return 0;
+	mycs_trace(D_ADB, "myrdr:ch.Retunes");
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+	if (!CSREADER_ChSetting(dmuxid, demuxp, typ, CHCS_CASRETUNE)) return 0;
+#endif
+	return 1;
+}
+
+void
+CSREADER_ChDescrambled(int32_t typ, int descramble)
+{
+	struct s_reader *rdr;
+
+	rdr = CSREADER_ChkActive(typ);
+	if (!rdr) return;
+	rdr->ch_descramble = descramble;
+}
+
+#endif	// defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//--------------------------------------------------------------------
Index: oscam-reader.h
===================================================================
--- oscam-reader.h	(revision 10670)
+++ oscam-reader.h	(working copy)
@@ -1,25 +1,64 @@
 #ifndef _OSCAM_READER_H_
 #define _OSCAM_READER_H_
-
+//
+//
+//
+// sky(n)
+#if defined(WITH_HISILICON)
+#define CS_INFORMATIONDIR		"/var/"
+#else
+#define CS_INFORMATIONDIR		"/tmp/"
+#endif
+#define cs_SMCINFORMATION		"oscam.smartcard"
+#define cs_XCAMDSERVICES		"oscam.ibservices"
+#define cs_MORECAMSERVICES		"oscam.imservices"
+#define cs_CASERVICES			"oscam.caservices"
+#define cs_OSCAMSERVER 			"oscam.server"
+
+
+#define IS_SOCKET_OK(s)			((s)> 0)
+#define IS_SOCKET_FAIL(s)		((s)<=0)
+#define IS_SOCKET_ERRORNO(e)	((errno)==(e))
+
+#define INET_TIMEOUT 			-1
+#define INET_DISCONNECTED 		-2
+#define IS_INET_OK(nstatus)	((nstatus)> 0)
+//
+//
+//
 const struct s_cardsystem *get_cardsystem_by_caid(uint16_t caid);
 struct s_reader *get_reader_by_label(char *lbl);
 const char *reader_get_type_desc(struct s_reader *rdr, int32_t extended);
+// sky(n)
+bool 		chk_reader_devices(struct s_reader *rdr);
+void 		chk_group_violation(struct s_reader *rdr);
+struct s_reader *chk_sole_reader_protocols(char *protocols);
 
 bool hexserialset(struct s_reader *rdr);
 void hexserial_to_newcamd(uchar *source, uchar *dest, uint16_t caid);
 void newcamd_to_hexserial(uchar *source, uchar *dest, uint16_t caid);
 
-S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, uint8_t add);
+S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, char *comments, uint8_t add);
 void cs_clear_entitlement(struct s_reader *rdr);
+// sky(oscam.smartcard)
+void 		cs_clean_cardinformation(void);
+int  		cs_save_cardinformation (struct s_reader *rdr);
 
 int32_t hostResolve(struct s_reader *reader);
 int32_t network_tcp_connection_open(struct s_reader *);
 void    network_tcp_connection_close(struct s_reader *, char *);
+// sky(Add)
+int32_t	network_chk_intefaces(uint32_t *ip, uint8_t *mac);
+int32_t 	network_tcp_socket_open(struct s_reader *rdr, char *devices, int32_t rport);
+void 		network_tcp_socket_close(struct s_reader *rdr, int32_t sockfd);
+
+void 		clear_block_delay(struct s_reader *rdr);
 void    block_connect(struct s_reader *rdr);
 int32_t is_connect_blocked(struct s_reader *rdr);
 
 void reader_do_idle(struct s_reader *reader);
-void casc_check_dcw(struct s_reader *reader, int32_t idx, int32_t rc, uchar *cw);
+void 		casc_check_dcw(struct s_reader *reader, int32_t idx, int32_t cwfound, uchar *cw, CWEXTENTION *cwEx);
+int32_t 	casc_process_ecm(struct s_reader *reader, ECM_REQUEST *er);
 void reader_do_card_info(struct s_reader *reader);
 int32_t reader_slots_available(struct s_reader *reader, ECM_REQUEST *er);
 
@@ -29,5 +68,35 @@
 int32_t restart_cardreader(struct s_reader *rdr, int32_t restart);
 void init_cardreader(void);
 void kill_all_readers(void);
+//
+// sky(n)
+uint16_t	CSREADER_Chkstatus(struct s_reader *rdr);
+void		CSREADER_Restart(int32_t typ);
+struct s_reader *CSREADER_GetReaders(int32_t typ);
+bool		CSREADER_IsFTAbiss(uint16_t degree, uint32_t frequency, uint16_t srvid, uint16_t vidpid);
+
+#if defined(MODULE_CONSTCW) || defined(MODULE_XCAS) || defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+#define ERE_CS_BYPASS	1
+#define ERE_CS_FIRST		2
+#define ERE_CS_FINAL		254
+
+enum
+{
+	CHCS_CASIDLE		= 0,
+	CHCS_CASFIRST		= 0x1,
+	CHCS_CASFOWARD		= 0x2,
+	CHCS_CAS2FAKE		= 0x4,
+	CHCS_CASRETUNE		= 0x8
+};
+
+struct s_reader *CSREADER_ChkActive(int32_t typ);
+int32_t	CSREADER_ChkEcmSkipto(struct s_reader *rdr, ECM_REQUEST *er);
+int32_t	CSREADER_ChkEcmNextto(struct s_reader *rdr, ECM_REQUEST *er);
+int32_t	CSREADER_ChSetting (int dmuxid, struct demux_s *demux, int32_t typ, int chstages);
+void		CSREADER_ChCloser	 (int dmuxid, struct demux_s *demux, int32_t typ);
+bool		CSREADER_ChRetuning(int dmuxid, struct demux_s *demux, int32_t typ);
+void		CSREADER_ChDescrambled(int32_t typ, int descramble);
+#endif // defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
 
 #endif
+
Index: oscam-simples.c
===================================================================
--- oscam-simples.c	(revision 10670)
+++ oscam-simples.c	(working copy)
@@ -9,12 +9,11 @@
 	buf[0] = '\0';
 
 	if(!srvid || (srvid >> 12) >= 16)  //cfg.srvid[16]
-		{ return (buf); }
+		return(buf);
 
 	if(cl && cl->last_srvidptr && cl->last_srvidptr->srvid == srvid)
 		for(i = 0; i < cl->last_srvidptr->ncaid; i++)
-			if(cl->last_srvidptr->caid[i] == caid && cl->last_srvidptr->name)
-			{
+			if (cl->last_srvidptr->caid[i] == caid && cl->last_srvidptr->name) {
 				cs_strncpy(buf, cl->last_srvidptr->name, 32);
 				return (buf);
 			}
@@ -22,18 +21,18 @@
 	for(this = cfg.srvid[srvid >> 12]; this; this = this->next)
 		if(this->srvid == srvid)
 			for(i = 0; i < this->ncaid; i++)
-				if(this->caid[i] == caid && this->name && cl)
-				{
+				if (this->caid[i] == caid && this->name && cl) {
 					cs_strncpy(buf, this->name, 32);
 					cl->last_srvidptr = this;
 					return (buf);
 				}
 
-	if(!buf[0])
-	{
-		if(return_unknown)
-			{ snprintf(buf, 32, "%04X:%04X unknown", caid, srvid); }
-		if(cl) { cl->last_srvidptr = NULL; }
+	if (!buf[0]) {
+		if (return_unknown) {
+//			snprintf(buf, 32, "%04X:%04X unknown", caid, srvid);
+			snprintf(buf, 32, "%04X:%04X", caid, srvid);
+		}
+		if (cl) cl->last_srvidptr = NULL;
 	}
 	return (buf);
 }
@@ -50,8 +49,7 @@
 
 
 /* Gets the tier name. Make sure that buf is at least 83 bytes long. */
-char *get_tiername(uint16_t tierid, uint16_t caid, char *buf)
-{
+char *get_tiername(uint16_t tierid, uint16_t caid, char *buf) {
 	int32_t i;
 	struct s_tierid *this = cfg.tierid;
 
@@ -59,9 +57,9 @@
 		if(this->tierid == tierid)
 			for(i = 0; i < this->ncaid; i++)
 				if(this->caid[i] == caid)
-					{ cs_strncpy(buf, this->name, 32); }
+					cs_strncpy(buf, this->name, 32);
 
-	if(!tierid) { buf[0] = '\0'; }
+	if (!tierid) buf[0] = '\0';
 	return (buf);
 }
 
@@ -70,18 +68,31 @@
 {
 	struct s_provid *this = cfg.provid;
 
-	for(buf[0] = 0; this && (!buf[0]); this = this->next)
-	{
-		if(this->caid == caid && this->provid == provid)
-		{
+	for (buf[0] = 0; this && (!buf[0]); this = this->next) {
+		if (this->caid == caid && this->provid == provid) {
 			snprintf(buf, buflen, "%s%s%s%s%s", this->prov,
 					 this->sat[0] ? " / " : "", this->sat,
 					 this->lang[0] ? " / " : "", this->lang);
 		}
 	}
 
-	if(!buf[0]) { snprintf(buf, buflen, "%04X:%06X unknown", caid, provid); }
-	if(!caid) { buf[0] = '\0'; }
+	if (!buf[0]) snprintf(buf, buflen, "%04X:%06X unknown", caid, provid);
+	if (!caid) buf[0] = '\0';
+	return(buf);
+}
+// sky(oscam.smartcard)
+char *get_provider_existnace(uint16_t caid, uint32_t provid, char *buf, uint32_t buflen)
+{
+	struct s_provid *this = cfg.provid;
+
+	for (buf[0] = 0; this && (!buf[0]); this = this->next) {
+		if (this->caid == caid && this->provid == provid) {
+			snprintf(buf, buflen, "%s%s%s%s%s", this->prov,
+					this->sat[0]  ? " / " : "", this->sat,
+					this->lang[0] ? " / " : "", this->lang);
+		}
+	}
+	if (!caid) buf[0] = '\0';
 	return (buf);
 }
 
@@ -89,15 +100,14 @@
 void add_provider(uint16_t caid, uint32_t provid, const char *name, const char *sat, const char *lang)
 {
 	struct s_provid **ptr;
-	for(ptr = &cfg.provid; *ptr; ptr = &(*ptr)->next)
-	{
+	for (ptr = &cfg.provid; *ptr; ptr = &(*ptr)->next) {
 		if((*ptr)->caid == caid && (*ptr)->provid == provid)
-			{ return; }
+			return;
 	}
 
 	struct s_provid *prov;
 	if(!cs_malloc(&prov, sizeof(struct s_provid)))
-		{ return; }
+		return;
 
 	prov->provid = provid;
 	prov->caid = caid;
Index: oscam-string.c
===================================================================
--- oscam-string.c	(revision 10670)
+++ oscam-string.c	(working copy)
@@ -1,6 +1,45 @@
 #include "globals.h"
+#include "oscam-time.h"
 #include "oscam-string.h"
 
+
+// sky(n)
+bool cs_Iszero(uchar *data, int size)
+{
+	int	i;
+
+	if (!data) return 1;
+	for (i = 0; i < size; i++)
+		if (data[i]) return 0;
+	return 1;
+}
+bool cs_Isczero(uchar *data, int size)
+{
+	int	i;
+
+	if (!data) return 1;
+	for (i = 0; i < size; i++)
+		if (data[i] != '0') return 0;
+	return 1;
+}
+
+bool cs_Isff(uchar *data, int size)
+{
+	int	i;
+
+	if (!data) return 0;
+	for (i = 0; i < size; i++)
+		if (data[i] != 0xff) return 0;
+	return 1;
+}
+
+
+bool cs_Isxx(uchar *data, int size)
+{
+	if (cs_Iszero(data, size)) return 0;
+	if (cs_Isff(data, size)) return 0;
+	return 1;
+}
 /* This function encapsulates malloc. It automatically adds an error message
    to the log if it failed and calls cs_exit(quiterror) if quiterror > -1.
    result will be automatically filled with the new memory position or NULL
@@ -8,18 +47,23 @@
 bool cs_malloc(void *result, size_t size)
 {
 	void **tmp = result;
+	if (!size) return 0;
 	*tmp = malloc(size);
-	if(*tmp == NULL)
-	{
+	if (*tmp == NULL) {
 		fprintf(stderr, "%s: ERROR: Can't allocate %zu bytes!", __func__, size);
 	}
-	else
-	{
+	else {
 		memset(*tmp, 0, size);
 	}
 	return !!*tmp;
 }
-
+// sky(n)
+bool cs_free(void *result)
+{
+	if (!result) return 0;
+	NULLFREE(result);
+	return 1;
+}
 /* This function encapsulates realloc. It automatically adds an error message
    to the log if it failed and calls cs_exit(quiterror) if quiterror > -1.
    result will be automatically filled with the new memory position or NULL
@@ -42,7 +86,7 @@
 {
 	char *newstr;
 	if(!str)
-		{ return NULL; }
+		return NULL;
 	if(cs_malloc(&newstr, strlen(str) + 1))
 	{
 		strncpy(newstr, str, strlen(str));
@@ -57,16 +101,15 @@
    num should be the real size of char array (do not subtract -1). */
 void cs_strncpy(char *destination, const char *source, size_t num)
 {
-	if(!source)
-	{
+	if (!source) {
 		destination[0] = '\0';
 		return;
 	}
 	uint32_t l, size = strlen(source);
 	if(size > num - 1)
-		{ l = num - 1; }
+		l = num - 1;
 	else
-		{ l = size; }
+		l = size;
 	memcpy(destination, source, l);
 	destination[l] = '\0';
 }
@@ -78,7 +121,7 @@
 	for(p = txt; *p; p++)
 	{
 		if(isupper((uchar)*p))
-			{ *p = tolower((uchar) * p); }
+			*p = tolower((uchar)*p);
 	}
 	return txt;
 }
@@ -90,7 +133,7 @@
 	for(p = txt; *p; p++)
 	{
 		if(islower((uchar)*p))
-			{ *p = toupper((uchar) * p); }
+		  	*p = toupper((uchar)*p);
 	}
 	return txt;
 }
@@ -102,16 +145,15 @@
 	if(*txt == ' ')
 	{
 		for(p1 = p2 = txt; (*p1 == ' ') || (*p1 == '\t') || (*p1 == '\n') || (*p1 == '\r'); p1++)
-			{ ; }
+			;
 		while(*p1)
-			{ *p2++ = *p1++; }
+			*p2++ = *p1++;
 		*p2 = '\0';
 	}
 	l = strlen(txt);
-	if(l > 0)
-	{
+	if (l > 0) {
 		for(p1 = txt + l - 1; l > 0 && ((*p1 == ' ') || (*p1 == '\t') || (*p1 == '\n') || (*p1 == '\r')); *p1-- = '\0', l--)
-			{ ; }
+			;
 	}
 	return txt;
 }
@@ -139,10 +181,10 @@
 
 bool streq(const char *s1, const char *s2)
 {
-	if(!s1 && s2) { return 0; }
-	if(s1 && !s2) { return 0; }
-	if(!s1 && !s2) { return 1; }
-	return strcmp(s1, s2) == 0;
+	if (!s1 &&  s2) return 0;
+	if ( s1 && !s2) return 0;
+	if (!s1 && !s2) return 1;
+	return (strcmp(s1, s2) == 0);
 }
 
 char *cs_hexdump(int32_t m, const uchar *buf, int32_t n, char *target, int32_t len)
@@ -151,7 +193,7 @@
 	target[0] = '\0';
 	m = m ? 3 : 2;
 	if(m * n >= len)
-		{ n = (len / m) - 1; }
+		n = (len / m) - 1;
 	while(i < n)
 	{
 		snprintf(target + (m * i), len - (m * i), "%02X%s", *buf++, m > 2 ? " " : "");
@@ -160,11 +202,77 @@
 	return target;
 }
 
+// sky(a)
+void
+cs_prdump(const char *title, void *data, uint16_t size)
+{
+	#if (__ADB_TRACE__==1)
+	uint8_t *pbuf = (uint8_t *)data;
+	int k;
+
+	myprintf("~~~%24s[%2d] = {", (title) ? title : "myhexa", size);
+	if (size>16) { myprintf("\n\t"); }
+
+	for (k=0; k<size; k++)
+	{
+		myprintf("0x%02X,", pbuf[k]);
+		if ((k%16)==7) { myprintf(" "); }
+		if ((k%16)==15 && k!=size-1) { myprintf("\n\t"); }
+	}
+	myprintf("};\n");
+	#endif
+}
+
+void
+cs_ascdump(char *title, void *data, uint16_t size)
+{
+	#if (__ADB_TRACE__==1)
+	static char strAsctexts[256];
+	uint8_t *pbuf = (uint8_t *)data;
+	int i, k, p;
+
+	myprintf("~~~%s.%d", (title) ? title : "mytext", size);
+	for (i=0; i<size; i+=16)
+	{
+		myprintf("\n   ");
+		p = 0;
+		for (k=0; k<16; k++)
+		{
+			if ((i+k) < size)  { sprintf(&strAsctexts[p], "%02X ", pbuf[i+k]); p+=3; }
+			else               { strcpy (&strAsctexts[p], "   "); p+=3; }
+			if (k==7 || k==15) { strcpy (&strAsctexts[p], " "); p+=1; }
+		}
+
+		for (k=0; k<16; k++)
+		{
+			if ((i+k) >= size) break;
+			sprintf(&strAsctexts[p], "%c", (pbuf[i+k] >= 0x20 && pbuf[i+k] < 0x7f) ?  pbuf[i+k] : '.');
+			p += 1;
+ 		}
+ 		strAsctexts[p] = 0;
+	 	myprintf("%s", strAsctexts);
+	}
+	myprintf("\n");
+	#endif
+}
+
+void cs_prtimes(uint32_t ultime, char *messages)
+{
+	#if (__ADB_TRACE__==1)
+	struct tm local_times;
+	cs_gmtime_r((time_t *)&ultime, &local_times);
+	myprintf("cstime:%16s  %04d/%02d/%02d  %02d:%02d:%02d\n",
+				messages,
+				local_times.tm_mon+1,local_times.tm_mday ,local_times.tm_year+1900,
+				local_times.tm_hour, local_times.tm_min,local_times.tm_sec);
+	#endif
+}
+
 int32_t gethexval(char c)
 {
-	if(c >= '0' && c <= '9') { return c - '0'; }
-	if(c >= 'A' && c <= 'F') { return c - 'A' + 10; }
-	if(c >= 'a' && c <= 'f') { return c - 'a' + 10; }
+	if (c >= '0' && c <= '9') return c - '0';
+	if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+	if (c >= 'a' && c <= 'f') return c - 'a' + 10;
 	return -1;
 }
 
@@ -174,8 +282,7 @@
 	for(i = 0; i < n; i++)
 	{
 		rc = (gethexval(asc[i << 1]) << 4) | gethexval(asc[(i << 1) + 1]);
-		if(rc & 0x100)
-			{ return -1; }
+		if (rc & 0x100) return -1;
 		buf[i] = rc;
 	}
 	return n;
@@ -188,8 +295,7 @@
 	for(i = ((l - 1) << 1), errno = 0; i >= 0 && n < 4; i -= 2)
 	{
 		int32_t b = (gethexval(asc[i]) << 4) | gethexval(asc[i + 1]);
-		if(b < 0)
-		{
+		if (b < 0) {
 			errno = EINVAL;
 			rc = val_on_err ? 0xFFFFFFFF : 0;
 			break;
@@ -203,15 +309,13 @@
 int32_t byte_atob(char *asc)
 {
 	int32_t rc;
-	if(strlen(trim(asc)) != 2)
-	{
+	if (strlen(trim(asc)) != 2) {
 		rc = -1;
 	}
-	else
-	{
+	else {
 		rc = (gethexval(asc[0]) << 4) | gethexval(asc[1]);
 		if(rc & 0x100)
-			{ rc = -1; }
+			rc = -1;
 	}
 	return rc;
 }
@@ -219,16 +323,14 @@
 int32_t word_atob(char *asc)
 {
 	int32_t rc;
-	if(strlen(trim(asc)) != 4)
-	{
+	if (strlen(trim(asc)) != 4) {
 		rc = -1;
 	}
-	else
-	{
+	else {
 		rc = gethexval(asc[0]) << 12 | gethexval(asc[1]) << 8 |
 			 gethexval(asc[2]) << 4  | gethexval(asc[3]);
 		if(rc & 0x10000)
-			{ rc = -1; }
+			rc = -1;
 	}
 	return rc;
 }
@@ -243,12 +345,11 @@
 	int32_t i, len = strlen(trim(asc));
 	if(len <= 4 && len > 0)
 	{
-		for(i = 0, rc = 0; i < len; i++)
-		{
+		for (i = 0, rc = 0; i < len; i++) {
 			rc = rc << 4 | gethexval(asc[i]);
 		}
 		if(rc & 0x10000)
-			{ rc = -1; }
+			rc = -1;
 	}
 	return rc;
 }
@@ -258,8 +359,8 @@
 	int32_t i, n1, n2, rc;
 	for(i = rc = 0; i < l; i += 2)
 	{
-		if((n1 = gethexval(asc[i  ])) < 0) { rc = -1; }
-		if((n2 = gethexval(asc[i + 1])) < 0) { rc = -1; }
+		if ((n1 = gethexval(asc[i  ])) < 0) rc = -1;
+		if ((n2 = gethexval(asc[i+1])) < 0) rc = -1;
 		bin[i >> 1] = (n1 << 4) + (n2 & 0xff);
 	}
 	return rc;
@@ -267,16 +368,29 @@
 
 uint32_t b2i(int32_t n, const uchar *b)
 {
-	switch(n)
+	switch (n) {
+		case 1: return  (b[0]);
+		case 2: return  (b[0] <<  8) |  b[1];
+		case 3: return  (b[0] << 16) | (b[1] <<  8) |  b[2];
+		case 4: return ((b[0] << 24) | (b[1] << 16) | (b[2] <<8 ) | b[3]) & 0xffffffffL;
+		default: cs_log("Error in b2i, n=%i",n);
+	}
+	return 0;
+}
+// sky(n)
+uint32_t b2be(int32_t n, const uchar *b)
+{
+	return (b2i(n,b));
+}
+
+uint32_t b2le(int32_t n, const uchar *b)
 	{
-	case 2:
-		return (b[0] <<  8) |  b[1];
-	case 3:
-		return (b[0] << 16) | (b[1] <<  8) |  b[2];
-	case 4:
-		return ((b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3]) & 0xffffffffL;
-	default:
-		cs_log("Error in b2i, n=%i", n);
+	switch (n) {
+		case 1: return  (b[0]);
+		case 2: return  (b[1] <<  8) |  b[0];
+		case 3: return  (b[2] << 16) | (b[1] <<  8) |  b[0];
+		case 4: return ((b[3] << 24) | (b[2] << 16) | (b[1] <<8 ) | b[0]) & 0xffffffffL;
+		default: cs_log("Error in b2le, n=%i",n);
 	}
 	return 0;
 }
@@ -286,30 +401,133 @@
 	int32_t i;
 	uint64_t k = 0;
 	for(i = 0; i < n; k += b[i++])
-		{ k <<= 8; }
+		k <<= 8;
 	return k;
 }
 
-uchar *i2b_buf(int32_t n, uint32_t i, uchar *b)
+uchar *i2b_buf(int32_t n, uint32_t i, uchar *buf)
 {
-	switch(n)
+	if (!buf) return 0;
+	switch (n) {
+		case 1:
+			buf[0] = (i    ) & 0xff;
+			break;
+		case 2:
+			buf[0] = (i>> 8) & 0xff;
+			buf[1] = (i    ) & 0xff;
+			break;
+		case 3:
+			buf[0] = (i>>16) & 0xff;
+			buf[1] = (i>> 8) & 0xff;
+			buf[2] = (i    ) & 0xff;
+		case 4:
+			buf[0] = (i>>24) & 0xff;
+			buf[1] = (i>>16) & 0xff;
+			buf[2] = (i>> 8) & 0xff;
+			buf[3] = (i    ) & 0xff;
+			break;
+	}
+	return (buf);
+}
+
+// sky(n)
+uchar *i2be(uint32_t i, uchar *be, int32_t n)
+{
+	if (!be) return 0;
+	return (i2b_buf(n,i,be));
+}
+
+uchar *i2le(uint32_t i, uchar *le, int32_t n)
 	{
+	if (!le) return 0;
+	switch (n) {
+		case 1:
+			le[0] = (i    ) & 0xff;
+			break;
 	case 2:
-		b[0] = (i >> 8) & 0xff;
-		b[1] = (i) & 0xff;
+			le[0] = (i    ) & 0xff;
+			le[1] = (i>> 8) & 0xff;
 		break;
 	case 3:
-		b[0] = (i >> 16) & 0xff;
-		b[1] = (i >> 8) & 0xff;
-		b[2] = (i) & 0xff;
+			le[0] = (i    ) & 0xff;
+			le[1] = (i>> 8) & 0xff;
+			le[2] = (i>>16) & 0xff;
 	case 4:
-		b[0] = (i >> 24) & 0xff;
-		b[1] = (i >> 16) & 0xff;
-		b[2] = (i >> 8) & 0xff;
-		b[3] = (i) & 0xff;
+			le[0] = (i    ) & 0xff;
+			le[1] = (i>> 8) & 0xff;
+			le[2] = (i>>16) & 0xff;
+			le[3] = (i>>24) & 0xff;
+			break;
+	}
+	return (le);
+}
+
+// sky(n)
+int
+cs_a2i(char *buffer, int lsize)
+{
+	char *pdata = NULL;
+	int valid = 0;;
+	int k;
+
+	k = 0;
+	while (k < lsize) {
+		if (isdigit(buffer[k])) {
+			valid = 1;
 		break;
 	}
-	return b;
+		k++;
+	}
+
+	if (valid) {
+		pdata = &buffer[k];
+		return (atoi(pdata));
+	}
+	return -1;
+}
+
+uint32_t
+cs_BCD2i(uint32_t bcd)
+{
+	uint32_t result;
+
+	result  =  ((bcd >> 28) & 0xf) * 10000000;
+	result +=  ((bcd >> 24) & 0xf) * 1000000;
+	result +=  ((bcd >> 20) & 0xf) * 100000;
+	result += (((bcd >> 16) & 0xf) * 10000);
+	result += (((bcd >> 12) & 0xf) * 1000);
+	result += (((bcd >>  8) & 0xf) * 100);
+	result += (((bcd >>  4) & 0xf) * 10);
+	result +=	(bcd & 0xf);
+	return (result);
+}
+
+uint32_t
+cs_i2BCD(uint32_t val)
+{
+	uint32_t result;
+	char asc2h[32];
+
+	sprintf(asc2h, "%08d", val);
+	result = cs_atoi(asc2h, 4, 1);
+	return (result);
+}
+
+
+uchar *b2Ro(uchar *ro, int32_t n)
+{
+	uchar *s = ro;
+	uchar *e = ro + n - 1;
+	uchar t;
+
+	if (ro && n>1) {
+		do	{
+			t = *s;
+			*s++ = *e;
+			*e-- = t;
+		} while(s < e);
+	}
+	return (ro);
 }
 
 void ull2b_buf(uint64_t i, uchar *b)
@@ -330,20 +548,17 @@
 	uint32_t rc;
 	for(rc = i = 0, n = strlen(trim(asc)) - 1; i < abs(bytes) << 1; n--, i++)
 	{
-		if(n >= 0)
-		{
+		if (n >= 0) {
 			int32_t rcl;
-			if((rcl = gethexval(asc[n])) < 0)
-			{
+			if ((rcl = gethexval(asc[n])) < 0) {
 				errno = EINVAL;
 				return 0x1f1f1f;
 			}
 			rc |= rcl << (i << 2);
 		}
-		else
-		{
+		else {
 			if(bytes < 0)
-				{ rc |= 0xf << (i << 2); }
+				rc |= 0xf << (i << 2);
 		}
 	}
 	errno = 0;
@@ -359,13 +574,10 @@
    length specifies the maximum length to check for. */
 int32_t check_filled(uchar *value, int32_t length)
 {
-	if(!value)
-		{ return 0; }
+	if (!value) return 0;
 	int32_t i, j = 0;
-	for(i = 0; i < length; ++i)
-	{
-		if(value[i] > 0)
-			{ j++; }
+	for (i = 0; i < length; ++i) {
+		if (value[i] > 0) j++;
 	}
 	return j;
 }
@@ -379,11 +591,9 @@
 {
 	srand(time(NULL));
 	int fd = open("/dev/urandom", O_RDONLY);
-	if(fd < 0)
-	{
+	if (fd < 0) {
 		fd = open("/dev/random", O_RDONLY);
-		if(fd < 0)
-			{ return; }
+		 if (fd < 0) return;
 	}
 	if(read(fd, rand_pool, RAND_POOL_SIZE + sizeof(uint32_t)) > -1)
 	{
@@ -397,15 +607,76 @@
 {
 	static uint32_t rand_pool_pos; // *MUST* be static
 	uint32_t i;
-	for(i = 0; i < dst_len; i++)
-	{
+	for (i = 0; i < dst_len; i++) {
 		rand_pool_pos++; // Races are welcome...
 		dst[i] = rand() ^ rand_pool[rand_pool_pos % RAND_POOL_SIZE];
 	}
 }
+//
+// sky(n)
+// crc32table_be
+static const unsigned int dvb_crc_table[256] = {
+    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+    0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+    0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
+    0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
+    0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+    0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
+    0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
+    0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+    0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+    0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
+    0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+    0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
+    0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
+    0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+    0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
+    0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+    0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+    0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
+    0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
+    0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+    0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
+    0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
+    0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+    0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+    0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
+    0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+    0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
+    0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
+    0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+    0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
+    0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+    0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+    0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+
+uint32_t dvb_crc32(uint8_t *data, uint32_t lsize)
+{
+	uint32_t i;
+	uint32_t	crc = 0xffffffff;
+	uint8_t  *ptr = data;
 
-static unsigned long crc_table[256] =
+	for (i = 0; i < lsize; ++i)
 {
+		crc = (crc << 8) ^ dvb_crc_table[((crc >> 24) ^ *ptr++) & 0xff];
+	}
+	return crc;
+}
+//
+//
+// crc32table_le
+static unsigned long crc_table[256] = {
 	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
 	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
 	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
@@ -472,8 +743,8 @@
 
 unsigned long crc32(unsigned long crc, const unsigned char *buf, unsigned int len)
 {
-	if(!buf)
-		{ return 0L; }
+	if (!buf) return 0L;
+	if (!len) return 0L;
 	crc = crc ^ 0xffffffffL;
 	while(len >= 8)
 	{
@@ -482,11 +753,9 @@
 	}
 	if(len)
 	{
-		do
-		{
+		do {
 			DO1(buf);
-		}
-		while(--len);
+		} while (--len);
 	}
 	return crc ^ 0xffffffffL;
 }
@@ -601,29 +870,28 @@
 	while(inlen && outlen)
 	{
 		*out++ = b64str[(to_uchar(in[0]) >> 2) & 0x3f];
-		if(!--outlen) { break; }
+		if (!--outlen) break;
 		*out++ = b64str[((to_uchar(in[0]) << 4) + (--inlen ? to_uchar(in[1]) >> 4 : 0)) & 0x3f];
-		if(!--outlen) { break; }
+		if (!--outlen) break;
 *out++ = (inlen ? b64str[((to_uchar(in[1]) << 2) + (--inlen ? to_uchar(in[2]) >> 6 : 0)) & 0x3f] : '=');
-		if(!--outlen) { break; }
+		if (!--outlen) break;
 		*out++ = inlen ? b64str[to_uchar(in[2]) & 0x3f] : '=';
-		if(!--outlen) { break; }
-		if(inlen) { inlen--; }
-		if(inlen) { in += 3; }
-		if(outlen) { *out = '\0'; }
+		if (!--outlen) break;
+		if (inlen)  inlen--;
+		if (inlen)  in += 3;
+		if (outlen) *out = '\0';
 	}
 }
 
 size_t b64encode(const char *in, size_t inlen, char **out)
 {
 	size_t outlen = 1 + BASE64_LENGTH(inlen);
-	if(inlen > outlen)
-	{
+	if (inlen > outlen) {
 		*out = NULL;
 		return 0;
 	}
 	if(!cs_malloc(out, outlen))
-		{ return -1; }
+		return -1;
 	base64_encode(in, inlen, *out, outlen);
 	return outlen - 1;
 }
@@ -635,13 +903,11 @@
 {
 	const unsigned char alphabet[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 	int32_t i;
-	for(i = sizeof(b64decoder) - 1; i >= 0; --i)
-	{
+	for (i = sizeof(b64decoder) - 1; i >= 0; --i) {
 		b64decoder[i] = -1;
 	}
 
-	for(i = sizeof(alphabet) - 1; i >= 0; --i)
-	{
+	for (i = sizeof(alphabet) - 1; i >= 0; --i) {
 		b64decoder[alphabet[i]] = i;
 	}
 }
@@ -651,40 +917,34 @@
 {
 	int32_t i, len = strlen((char *)result), j = 0, bits = 0, char_count = 0;
 
-	if(!b64decoder[0]) { b64prepare(); }
+	if (!b64decoder[0]) b64prepare();
 
 	for(i = 0; i < len; ++i)
 	{
-		if(result[i] == '=') { break; }
+		if (result[i] == '=') break;
 		int8_t tmp = b64decoder[result[i]];
-		if(tmp == -1) { continue; }
+		if (tmp == -1) continue;
 		bits += tmp;
 		++char_count;
-		if(char_count == 4)
-		{
+		if (char_count == 4) {
 			result[j++] = bits >> 16;
 			result[j++] = (bits >> 8) & 0xff;
 			result[j++] = bits & 0xff;
 			bits = 0;
 			char_count = 0;
 		}
-		else
-		{
+		else {
 			bits <<= 6;
 		}
 	}
-	if(i == len)
-	{
-		if(char_count)
-		{
+	if (i == len) {
+		if (char_count) {
 			result[j] = '\0';
 			return 0;
 		}
 	}
-	else
-	{
-		switch(char_count)
-		{
+	else {
+		switch (char_count) {
 		case 1:
 			result[j] = '\0';
 			return 0;
Index: oscam-string.h
===================================================================
--- oscam-string.h	(revision 10670)
+++ oscam-string.h	(working copy)
@@ -1,8 +1,14 @@
 #ifndef OSCAM_STRING_H_
 #define OSCAM_STRING_H_
+// sky(n)
+bool cs_Iszero (uchar *data, int size);
+bool cs_Isczero(uchar *data, int size);
+bool cs_Isff(uchar *data, int size);
+bool cs_Isxx(uchar *data, int size);
 
 bool cs_malloc(void *result, size_t size) MUST_CHECK_RESULT;
 bool cs_realloc(void *result, size_t size) MUST_CHECK_RESULT;
+bool cs_free(void *result);
 char *cs_strdup(const char *str);
 
 void cs_strncpy(char *destination, const char *source, size_t num);
@@ -13,6 +19,9 @@
 bool streq(const char *s1, const char *s2);
 
 char *cs_hexdump(int32_t m, const uchar *buf, int32_t n, char *target, int32_t len);
+void  cs_prdump (const char *title, void *data, uint16_t size);
+void	cs_ascdump(char *title, void *data, uint16_t size);
+void  cs_prtimes(uint32_t ultime, char *messages);
 
 int32_t gethexval(char c);
 
@@ -23,6 +32,9 @@
 int32_t dyn_word_atob(char *asc);
 int32_t key_atob_l(char *asc, uchar *bin, int32_t l);
 uint32_t b2i(int32_t n, const uchar *b);
+// sky(!)
+uint32_t b2le(int32_t n, const uchar *b);
+uint32_t b2be(int32_t n, const uchar *b);
 uint64_t b2ll(int32_t n, uchar *b);
 uchar *i2b_buf(int32_t n, uint32_t i, uchar *b);
 void ull2b_buf(uint64_t i, uchar *b);
@@ -38,6 +50,15 @@
 unsigned long crc32(unsigned long crc, const unsigned char *buf, unsigned int len);
 uint16_t ccitt_crc(uint8_t *data, size_t length, uint16_t seed, uint16_t final);
 uint32_t jhash(const char *key, size_t len);
+// sky(n)
+uint32_t	dvb_crc32(uint8_t *data, uint32_t lsize);
+uchar 	*i2be(uint32_t i, uchar *be, int32_t n);
+uchar 	*i2le(uint32_t i, uchar *le, int32_t n);
+uchar 	*b2Ro(uchar *ro, int32_t n);
+// sky(n)
+uint32_t	cs_BCD2i(uint32_t bcd);
+uint32_t cs_i2BCD(uint32_t val);
+int32_t 	cs_a2i(char *buffer, int lsize);
 
 char to_hex(char code);
 void char_to_hex(const unsigned char *p_array, uint32_t p_array_len, unsigned char *result);
Index: oscam-time.c
===================================================================
--- oscam-time.c	(revision 10670)
+++ oscam-time.c	(working copy)
@@ -144,6 +144,11 @@
 	tp->time    = tv.tv_sec;
 	tp->millitm = tv.tv_usec;
 }
+// sky(a)
+void cs_sleep(uint32_t msec)
+{
+	usleep(msec * 1000);
+}
 
 void cs_sleepms(uint32_t msec)
 {
@@ -167,6 +172,12 @@
 	errno = olderrno;
 }
 
+uint32_t cs_random(void)
+{
+//	srand((uint32_t)time((time_t *)0));
+	return ((uint32_t)rand());
+}
+
 void cs_sleepus(uint32_t usec)
 {
 	//does not interfere with signals like sleep and usleep do
@@ -292,7 +303,8 @@
 	__cs_pthread_cond_init(cond);
 }
 
-enum clock_type cs_getclocktype(void) {
+enum clock_type cs_getclocktype(void)
+{
 	if (clock_type == CLOCK_TYPE_UNKNOWN) {
 		struct timespec ts;
 		cs_gettime(&ts); // init clock type
Index: oscam-time.h
===================================================================
--- oscam-time.h	(revision 10670)
+++ oscam-time.h	(working copy)
@@ -14,6 +14,7 @@
 char *cs_ctime_r(const time_t *timep, char *buf);
 void cs_ftime(struct timeb *tp);
 void cs_ftimeus(struct timeb *tp);
+void 		  cs_sleep(uint32_t msec); // sky(a)
 void cs_sleepms(uint32_t msec);
 void cs_sleepus(uint32_t usec);
 
@@ -34,5 +35,6 @@
 
 void __cs_pthread_cond_init(pthread_cond_t *cond);
 void cs_pthread_cond_init(pthread_mutex_t *mutex, pthread_cond_t *cond);
+uint32_t   cs_random(void);
 
 #endif
Index: oscam-work.c
===================================================================
--- oscam-work.c	(revision 10670)
+++ oscam-work.c	(working copy)
@@ -15,11 +15,17 @@
 #include "module-cccshare.h"
 #include "oscam-time.h"
 
+#if 1
+	#define	MYWROKS_TRACE	myprintf
+#else
+	#define	MYWROKS_TRACE(...)
+#endif
+
+
 extern CS_MUTEX_LOCK system_lock;
 extern int32_t thread_pipe[2];
 
-struct job_data
-{
+struct job_data {
 	enum actions action;
 	struct s_reader *rdr;
 	struct s_client *cl;
@@ -30,8 +36,7 @@
 
 static void free_job_data(struct job_data *data)
 {
-	if(!data)
-		{ return; }
+	if (!data) return;
 	if(data->len && data->ptr)
 	{
 		//special free checks
@@ -50,8 +55,7 @@
 	pthread_mutex_trylock(&cl->thread_lock);
 	LL_ITER it = ll_iter_create(cl->joblist);
 	struct job_data *data;
-	while((data = ll_iter_next(&it)))
-	{
+	while ((data = ll_iter_next(&it))) {
 		free_job_data(data);
 	}
 	ll_destroy(&cl->joblist);
@@ -110,12 +115,10 @@
 
 	struct s_module *module = get_module(cl);
 	uint16_t bufsize = module->bufsize; //CCCam needs more than 1024bytes!
-	if(!bufsize)
-		{ bufsize = 1024; }
+	if (!bufsize) bufsize = 1288;  /* sky(1024) */
 
 	uint8_t *mbuf;
-	if(!cs_malloc(&mbuf, bufsize))
-		{ return NULL; }
+	if (!cs_malloc(&mbuf, bufsize)) return NULL;
 	cl->work_mbuf = mbuf; // Track locally allocated data, because some callback may call cs_exit/cs_disconect_client/pthread_exit and then mbuf would be leaked
 	int32_t n = 0, rc = 0, i, idx, s;
 	uint8_t dcw[16];
@@ -134,27 +137,30 @@
 				__free_job_data(cl, data);
 				cl->work_mbuf = NULL; // Prevent free_client from freeing mbuf (->work_mbuf)
 				free_client(cl);
-				if(restart_reader)
-					{ restart_cardreader(reader, 0); }
-				NULLFREE(mbuf);
+				if (restart_reader) {
+					restart_cardreader(reader, 1); // sky(0->1)
+				}
+				cs_free(mbuf);
 				pthread_exit(NULL);
 				return NULL;
 			}
 
-			if(data && data->action != ACTION_READER_CHECK_HEALTH)
-				{ cs_log_dbg(D_TRACE, "data from add_job action=%d client %c %s", data->action, cl->typ, username(cl)); }
-
+			if (data &&
+				(data->action != ACTION_READER_CHECK_HEALTH && data->action != ACTION_READER_POLL_STATUS && data->action != ACTION_CLIENT_TIMEOUT)) {
+				cs_log_dbg(D_TRACE, "data from add_job action=%d client %c %s", data->action, cl->typ, username(cl));
+			}
 			if(!data)
 			{
-				if(!cl->kill && cl->typ != 'r')
-					{ client_check_status(cl); } // do not call for physical readers as this might cause an endless job loop
+				if (!cl->kill && cl->typ != 'r') {
+					client_check_status(cl); // do not call for physical readers as this might cause an endless job loop
+				}
 				pthread_mutex_lock(&cl->thread_lock);
-				if(cl->joblist && ll_count(cl->joblist) > 0)
-				{
+				if (cl->joblist && ll_count(cl->joblist)>0) {
 					LL_ITER itr = ll_iter_create(cl->joblist);
 					data = ll_iter_next_remove(&itr);
-					if(data)
-						{ set_work_thread_name(data); }
+					if (data) {
+						set_work_thread_name(data);
+					}
 					//cs_log_dbg(D_TRACE, "start next job from list action=%d", data->action);
 				}
 				pthread_mutex_unlock(&cl->thread_lock);
@@ -164,8 +170,7 @@
 			{
 				/* for serial client cl->pfd is file descriptor for serial port not socket
 				   for example: pfd=open("/dev/ttyUSB0"); */
-				if(!cl->pfd || module->listenertype == LIS_SERIAL)
-					{ break; }
+				if (!cl->pfd || module->listenertype == LIS_SERIAL) break;
 				pfd[0].fd = cl->pfd;
 				pfd[0].events = POLLIN | POLLPRI;
 
@@ -179,41 +184,40 @@
 				if(rc > 0)
 				{
 					cs_ftime(&end); // register end time
-					cs_log_dbg(D_TRACE, "[OSCAM-WORK] new event %d occurred on fd %d after %"PRId64" ms inactivity", pfd[0].revents,
-								  pfd[0].fd, comp_timeb(&end, &start));
+				//	cs_log_dbg(D_TRACE, "[OSCAM-WORK] new event %d occurred on fd %d after %"PRId64" ms inactivity", pfd[0].revents,
+				//				  pfd[0].fd, comp_timeb(&end, &start));
 					data = &tmp_data;
 					data->ptr = NULL;
 					cs_ftime(&start); // register start time for new poll next run
 
-					if(reader)
-						{ data->action = ACTION_READER_REMOTE; }
+					if (reader) {
+						data->action = ACTION_READER_REMOTE;
+					}
 					else
 					{
-						if(cl->is_udp)
-						{
+						if (cl->is_udp) {
 							data->action = ACTION_CLIENT_UDP;
 							data->ptr = mbuf;
 							data->len = bufsize;
 						}
-						else
-							{ data->action = ACTION_CLIENT_TCP; }
-						if(pfd[0].revents & (POLLHUP | POLLNVAL | POLLERR))
-							{ cl->kill = 1; }
+						else {
+							data->action = ACTION_CLIENT_TCP;
+						}
+						if (pfd[0].revents & (POLLHUP | POLLNVAL | POLLERR)) {
+							cl->kill = 1;
+						}
 					}
 				}
 			}
 
-			if(!data)
-				{ continue; }
+			if (!data) continue;
 
-			if(!reader && data->action < ACTION_CLIENT_FIRST)
-			{
+			if (!reader && data->action < ACTION_CLIENT_FIRST) {
 				__free_job_data(cl, data);
 				break;
 			}
 
-			if(!data->action)
-				{ break; }
+			if (!data->action) break;
 
 			struct timeb actualtime;
 			cs_ftime(&actualtime);
@@ -226,40 +230,63 @@
 			}
 
 			if(data != &tmp_data)
-				{ cl->work_job_data = data; } // Track the current job_data
-			switch(data->action)
+				cl->work_job_data = data; // Track the current job_data
+			// sky(TEST)
+			if (data->action != ACTION_READER_IDLE &&
+				 data->action != ACTION_READER_REMOTE &&
+				 data->action != ACTION_READER_EMM &&
+				 data->action != ACTION_READER_POLL_STATUS &&
+				 data->action != ACTION_READER_CHECK_HEALTH)
 			{
+				MYWROKS_TRACE("ACTION=%d\n", data->action);
+			}
+
+			switch (data->action) {
 			case ACTION_READER_IDLE:
 				reader_do_idle(reader);
 				break;
 			case ACTION_READER_REMOTE:
 				s = check_fd_for_data(cl->pfd);
-				if(s == 0)  // no data, another thread already read from fd?
-					{ break; }
+					if (s == 0) break; // no data, another thread already read from fd?
 				if(s < 0)
 				{
-					if(reader->ph.type == MOD_CONN_TCP)
-						{ network_tcp_connection_close(reader, "disconnect"); }
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+						if (IS_ICS_READERS(reader)) {
+						//	if (!(reader->ics_failure % 5000)) {
+						//		MYWROKS_TRACE("myworks:%s server strange !!!\n", reader->label);
+						//	}
+							reader->ics_failure++;
+							reader->tcp_ito = 10;
+							break;
+						}
+#endif
+						if (reader->ph.type==MOD_CONN_TCP) {
+							network_tcp_connection_close(reader, "disconnect");
+						}
 					break;
 				}
 				rc = reader->ph.recv(cl, mbuf, bufsize);
 				if(rc < 0)
 				{
-					if(reader->ph.type == MOD_CONN_TCP)
-						{ network_tcp_connection_close(reader, "disconnect on receive"); }
+#if defined(MODULE_XCAMD) || defined(MODULE_MORECAM)
+						if (IS_ICS_READERS(reader)) break;
+#endif
+						if (reader->ph.type==MOD_CONN_TCP) {
+							network_tcp_connection_close(reader, "disconnect on receive");
+						}
 					break;
 				}
 				cl->last = time(NULL); // *********************************** TO BE REPLACE BY CS_FTIME() LATER ****************
 				idx = reader->ph.c_recv_chk(cl, dcw, &rc, mbuf, rc);
-				if(idx < 0) { break; }  // no dcw received
-				if(!idx) { idx = cl->last_idx; }
+					if ( idx < 0) break;  	// no dcw received
+					if (!idx) idx = cl->last_idx;
 				reader->last_g = time(NULL); // *********************************** TO BE REPLACE BY CS_FTIME() LATER **************** // for reconnect timeout
 				for(i = 0, n = 0; i < cfg.max_pending && n == 0; i++)
 				{
-					if(cl->ecmtask[i].idx == idx)
-					{
+						MYWROKS_TRACE("myworks:cl->ecmtask{%3d,%3d}\n", cl->ecmtask[i].idx, idx);
+						if (cl->ecmtask[i].idx==idx) {
 						cl->pending--;
-						casc_check_dcw(reader, i, rc, dcw);
+							casc_check_dcw(reader, i, rc, dcw, NULL);
 						n++;
 					}
 				}
@@ -295,25 +322,23 @@
 				cardreader_do_checkhealth(reader);
 				break;
 			case ACTION_READER_CAPMT_NOTIFY:
-				if(reader->ph.c_capmt) { reader->ph.c_capmt(cl, data->ptr); }
+					if (reader->ph.c_capmt) reader->ph.c_capmt(cl, data->ptr);
 				break;
 			case ACTION_CLIENT_UDP:
 				n = module->recv(cl, data->ptr, data->len);
-				if(n < 0) { break; }
+					if (n < 0) break;
 				module->s_handler(cl, data->ptr, n);
 				break;
 			case ACTION_CLIENT_TCP:
 				s = check_fd_for_data(cl->pfd);
 				if(s == 0)  // no data, another thread already read from fd?
-					{ break; }
-				if(s < 0)    // system error or fd wants to be closed
-				{
+						break;
+					if (s < 0) { 		// system error or fd wants to be closed
 					cl->kill = 1; // kill client on next run
 					continue;
 				}
 				n = module->recv(cl, mbuf, bufsize);
-				if(n < 0)
-				{
+					if (n < 0) {
 					cl->kill = 1; // kill client on next run
 					continue;
 				}
@@ -339,8 +364,8 @@
 				break;
 			case ACTION_CLIENT_INIT:
 				if(module->s_init)
-					{ module->s_init(cl); }
-				cl->is_udp = module->type == MOD_CONN_UDP;
+						module->s_init(cl);
+					cl->is_udp = (module->type == MOD_CONN_UDP) ? 1 : 0;
 				cl->init_done = 1;
 				break;
 			case ACTION_CLIENT_IDLE:
@@ -450,9 +475,12 @@
 		if(cl->thread_active == 2)
 			{ pthread_kill(cl->thread, OSCAM_SIGNAL_WAKEUP); }
 		pthread_mutex_unlock(&cl->thread_lock);
+		// sky(log)
+		if (action != ACTION_READER_POLL_STATUS /* && action!=ACTION_READER_IDLE */) {
 		cs_log_dbg(D_TRACE, "add %s job action %d queue length %d %s",
 					  action > ACTION_CLIENT_FIRST ? "client" : "reader", action,
 					  ll_count(cl->joblist), username(cl));
+		}
 		return 1;
 	}
 
@@ -463,7 +491,7 @@
 	if(cl->typ != 'r' || !rdr || rdr->typ != R_PCSC)
 		{ pthread_attr_setstacksize(&attr, PTHREAD_STACK_SIZE); }
 
-	if(action != ACTION_READER_CHECK_HEALTH)
+	if (action != ACTION_READER_CHECK_HEALTH && action != ACTION_READER_POLL_STATUS && data->action != ACTION_CLIENT_TIMEOUT)
 	{
 		cs_log_dbg(D_TRACE, "start %s thread action %d",
 					  action > ACTION_CLIENT_FIRST ? "client" : "reader", action);
Index: oscam.c
===================================================================
--- oscam.c	(revision 10670)
+++ oscam.c	(working copy)
@@ -2,6 +2,7 @@
 
 #include "globals.h"
 #include <getopt.h>
+#include <sys/system_properties.h>
 
 #include "csctapi/cardreaders.h"
 #include "modules.h"
@@ -15,6 +16,9 @@
 #include "module-dvbapi-azbox.h"
 #include "module-dvbapi-mca.h"
 #include "module-dvbapi-chancache.h"
+#if defined(WITH_HISILICON)
+#include "module-dvbapi-his.h"
+#endif
 #include "module-ird-guess.h"
 #include "module-lcd.h"
 #include "module-led.h"
@@ -22,6 +26,12 @@
 #include "module-webif.h"
 #include "module-webif-tpl.h"
 #include "module-cw-cycle-check.h"
+#if defined(MODULE_MORECAM)
+#include "module-morecam.h"
+#endif
+#if defined(MODULE_XCAS)
+#include "module-xcas.h"
+#endif
 #include "oscam-chk.h"
 #include "oscam-cache.h"
 #include "oscam-client.h"
@@ -85,13 +95,16 @@
 uint16_t  len4caid[256];    // table for guessing caid (by len)
 char  cs_confdir[128] = CS_CONFDIR;
 uint16_t cs_dblevel = 0; // Debug Level
-int32_t thread_pipe[2] = {0, 0};
 static int8_t cs_restart_mode = 1; //Restartmode: 0=off, no restart fork, 1=(default)restart fork, restart by webif, 2=like=1, but also restart on segfaults
 uint8_t cs_http_use_utf8 = 0;
-static int8_t cs_capture_SEGV;
-static int8_t cs_dump_stack;
-static uint16_t cs_waittime = 60;
+static int8_t 		cs_capture_SEGV	= 0;
+static int8_t 		cs_dump_stack		= 0;
+
+int32_t 				cs_timefaults		= 0;	// sky(A)
+static uint16_t 	cs_waittime 		= 1;	// sky(60)
+
 char  cs_tmpdir[200] = {0x00};
+int32_t 				thread_pipe[2]   	= {0, 0};
 CS_MUTEX_LOCK system_lock;
 CS_MUTEX_LOCK config_lock;
 CS_MUTEX_LOCK gethostbyname_lock;
@@ -120,12 +133,42 @@
 int log_remove_sensitive = 1;
 
 static char *prog_name;
-static char *stb_boxtype;
-static char *stb_boxname;
-
+static char 		*stb_boxtype = NULL;
+static char 		*stb_boxname = NULL;
+// sky(sim) for tvheadend
+extern int property_get(const char *key, char *value, const char *default_value);
+extern int property_set(const char *key, const char *value);
+bool       g_smartcard_supported = true;
+bool       g_factoy_products = false;
 /*****************************************************************************
         Statics
 *****************************************************************************/
+// sky(sim)
+bool chker_smartcard_enable(void)
+{
+	bool enabled = true;
+	char smcprop[PROP_VALUE_MAX] = {0};
+	if (__system_property_get("ro.buyer.sim",smcprop) > 0) {
+		if (!strcmp("irum", smcprop)) enabled = false;
+	}
+	if (__system_property_get("persist.sci.slot",smcprop) > 0) {
+		if (!strcmp("irum", smcprop)) enabled = false;
+		if (!strcmp("none", smcprop)) enabled = false;
+	}
+	g_smartcard_supported = enabled;
+	return enabled;
+}
+
+bool chker_factoy_products(void)
+{
+	char fabprop[PROP_VALUE_MAX] = {0};
+	g_factoy_products = false;
+	if (__system_property_get("persist.sys.product.mode",fabprop) > 0) {
+		if (!strcmp("true", fabprop)) g_factoy_products = true;
+	}
+	return g_factoy_products;
+}
+
 /* Prints usage information and information about the built-in modules. */
 static void show_usage(void)
 {
@@ -140,8 +183,8 @@
 	printf("This program is distributed under GPLv3.\n");
 	printf("OSCam is based on Streamboard mp-cardserver v0.9d written by dukat\n");
 	printf("Visit http://www.streamboard.tv/oscam/ for more details.\n\n");
-
-	printf(" ConfigDir  : %s\n", CS_CONFDIR);
+	// sky(cs_confdir)
+	printf(" ConfigDir  : %s\n", cs_confdir);
 	printf("\n");
 	printf(" Usage: oscam [parameters]\n");
 	printf("\n Directories:\n");
@@ -151,13 +194,16 @@
 #if defined(__CYGWIN__)
 	printf("                         . Default: (OS-TMP)\n");
 #else
+	#if defined(WITH_HISILICON)
+	printf("                         . Default: /var/.oscam\n");
+	#else
 	printf("                         . Default: /tmp/.oscam\n");
 #endif
+#endif
 	printf("\n Startup:\n");
 	printf(" -b, --daemon            | Start in the background as daemon.\n");
 	printf(" -B, --pidfile <pidfile> | Create pidfile when starting.\n");
-	if(config_enabled(WEBIF))
-	{
+	if (config_enabled(WEBIF)) {
 		printf(" -r, --restart <level>   | Set restart level:\n");
 		printf("                         .   0 - Restart disabled (exit on restart request).\n");
 		printf("                         .   1 - WebIf restart is active (default).\n");
@@ -188,8 +234,7 @@
 	printf("\n Settings:\n");
 	printf(" -p, --pending-ecm <num> | Set the maximum number of pending ECM packets.\n");
 	printf("                         . Default: 32 Max: 4096\n");
-	if(config_enabled(WEBIF))
-	{
+	if (config_enabled(WEBIF)) {
 		printf(" -u, --utf8              | Enable WebIf support for UTF-8 charset.\n");
 	}
 	printf("\n Debug parameters:\n");
@@ -209,8 +254,7 @@
 static const char short_options[] = "aB:bc:d:g:hI:p:r:Sst:uVw:";
 
 /* Keep the options sorted by short option */
-static const struct option long_options[] =
-{
+static const struct option long_options [] = {
 	{ "crash-dump",         no_argument,       NULL, 'a' },
 	{ "pidfile",            required_argument, NULL, 'B' },
 	{ "daemon",             no_argument,       NULL, 'b' },
@@ -238,7 +282,7 @@
 	while((i = getopt_long(argc, argv, short_options, long_options, NULL)) != EOF)
 	{
 		if(i == '?')
-			{ fprintf(stderr, "ERROR: Unknown command line parameter: %s\n", argv[optind - 1]); }
+			fprintf(stderr, "ERROR: Unknown command line parameter: %s\n", argv[optind - 1]);
 		switch(i)
 		{
 		case 'a': // --crash-dump
@@ -270,8 +314,7 @@
 			max_pending = atoi(optarg) <= 0 ? 32 : MIN(atoi(optarg), 4096);
 			break;
 		case 'r': // --restart
-			if(config_enabled(WEBIF))
-			{
+			   if (config_enabled(WEBIF)) {
 				cs_restart_mode = atoi(optarg);
 			}
 			break;
@@ -281,24 +324,20 @@
 		case 's': // --capture-segfaults
 			cs_capture_SEGV = 1;
 			break;
-		case 't':   // --temp-dir
-		{
+		   case 't': { // --temp-dir
 			mkdir(optarg, S_IRWXU);
 			int j = open(optarg, O_RDONLY);
-			if(j >= 0)
-			{
+			   if (j >= 0) {
 				close(j);
 				cs_strncpy(cs_tmpdir, optarg, sizeof(cs_tmpdir));
 			}
-			else
-			{
+				else {
 				printf("WARNING: Temp dir does not exist. Using default value.\n");
 			}
 			break;
 		}
 		case 'u': // --utf8
-			if(config_enabled(WEBIF))
-			{
+			   if (config_enabled(WEBIF)) {
 				cs_http_use_utf8 = 1;
 				printf("WARNING: Web interface UTF-8 mode enabled. Carefully read documentation as bugs may arise.\n");
 			}
@@ -330,8 +369,7 @@
 	{
 		char targetfile[256];
 		fp = fopen(get_tmp_dir_filename(targetfile, sizeof(targetfile), "oscam.version"), "w");
-		if(!fp)
-		{
+		if (!fp) {
 			cs_log("Cannot open %s (errno=%d %s)", targetfile, errno, strerror(errno));
 			return;
 		}
@@ -344,14 +382,28 @@
 				st.tm_hour, st.tm_min, st.tm_sec);
 	}
 
+	// sky(a)
+	// sky(sim)
+#if defined(__HISILICON_MANUFACTORY__)
+	fprintf(fp, "Version:        oscam-%s.%s(f)\n", CS_VERSION, CS_SVN_VERSION);
+	fprintf(fp, "ConfigDir:      %s\n", cs_confdir);
+#else
 	fprintf(fp, "Version:        oscam-%s-r%s\n", CS_VERSION, CS_SVN_VERSION);
-	fprintf(fp, "Compiler:       %s\n", CS_TARGET);
+//	fprintf(fp, "Compiler:       %s\n", CS_TARGET);
 	fprintf(fp, "Box type:       %s (%s)\n", boxtype_get(), boxname_get());
 	fprintf(fp, "ConfigDir:      %s\n", cs_confdir);
 #ifdef WEBIF
 	fprintf(fp, "WebifPort:      %d\n", cfg.http_port);
 #endif
 	fprintf(fp, "\n");
+	// sky(sim)
+	if (g_factoy_products) {
+		fprintf(fp, "Factory products\n");
+		if (!use_stdout) fclose(fp);
+		return;
+	}
+	// sky(sim)
+	fprintf(fp, "%-40s %s\n", "Smartcard support:", g_smartcard_supported ? "yes" : "no");
 	write_conf(WEBIF, "Web interface support");
 	write_conf(WEBIF_LIVELOG, "LiveLog support");
 	write_conf(WEBIF_JQUERY, "jQuery support intern");
@@ -360,10 +412,11 @@
 	write_conf(HAVE_DVBAPI, "DVB API support");
 	if(config_enabled(HAVE_DVBAPI))
 	{
-		write_conf(WITH_AZBOX, "DVB API with AZBOX support");
-		write_conf(WITH_MCA, "DVB API with MCA support");
-		write_conf(WITH_COOLAPI, "DVB API with COOLAPI support");
-		write_conf(WITH_STAPI, "DVB API with STAPI support");
+		write_conf(WITH_HISILICON, "DVB API with HISKY support");
+	//	write_conf(WITH_AZBOX, "DVB API with AZBOX support");
+	//	write_conf(WITH_MCA, "DVB API with MCA support");
+	//	write_conf(WITH_COOLAPI, "DVB API with COOLAPI support");
+	//	write_conf(WITH_STAPI, "DVB API with STAPI support");
 	}
 	write_conf(IRDETO_GUESSING, "Irdeto guessing");
 	write_conf(CS_ANTICASC, "Anti-cascading support");
@@ -386,6 +439,9 @@
 	write_conf(MODULE_CAMD35, "camd 3.5 UDP");
 	write_conf(MODULE_CAMD35_TCP, "camd 3.5 TCP");
 	write_conf(MODULE_NEWCAMD, "newcamd");
+	#if defined(MODULE_XCAS)
+		write_conf(MODULE_XCAS, "xcas");
+	#endif
 	write_conf(MODULE_CCCAM, "CCcam");
 	write_conf(MODULE_CCCSHARE, "CCcam share");
 	write_conf(MODULE_GBOX, "gbox");
@@ -414,10 +470,11 @@
 		write_readerconf(READER_GRIFFIN, "Griffin");
 		write_readerconf(READER_DGCRYPT, "DGCrypt");
 		fprintf(fp, "\n");
-		write_cardreaderconf(CARDREADER_PHOENIX, "phoenix");
-		write_cardreaderconf(CARDREADER_INTERNAL_AZBOX, "internal_azbox");
-		write_cardreaderconf(CARDREADER_INTERNAL_COOLAPI, "internal_coolapi");
+		write_cardreaderconf(CARDREADER_INTERNAL_HISKY, "internal_hisky");
+//		write_cardreaderconf(CARDREADER_INTERNAL_AZBOX, "internal_azbox");
+//		write_cardreaderconf(CARDREADER_INTERNAL_COOLAPI, "internal_coolapi");
 		write_cardreaderconf(CARDREADER_INTERNAL_SCI, "internal_sci");
+		write_cardreaderconf(CARDREADER_PHOENIX, "phoenix");
 		write_cardreaderconf(CARDREADER_SC8IN1, "sc8in1");
 		write_cardreaderconf(CARDREADER_MP35, "mp35");
 		write_cardreaderconf(CARDREADER_SMARGO, "smargo");
@@ -427,12 +484,11 @@
 		write_cardreaderconf(CARDREADER_STAPI, "stapi");
 		write_cardreaderconf(CARDREADER_STINGER, "stinger");
 	}
-	else
-	{
+	else {
 		write_readerconf(WITH_CARDREADER, "Reader Support");
 	}
-	if(!use_stdout)
-		{ fclose(fp); }
+#endif // defined(__HISILICON_MANUFACTORY__)
+	if (!use_stdout) fclose(fp);
 }
 #undef write_conf
 #undef write_readerconf
@@ -452,6 +508,8 @@
 
 static void do_report_emm_support(void)
 {
+#if defined(__HISILICON_MANUFACTORY__)
+#else
 	if(!config_enabled(WITH_CARDREADER))
 	{
 		cs_log("Binary without Cardreader Support! No EMM processing possible!");
@@ -471,6 +529,7 @@
 		report_emm_support(READER_GRIFFIN, "Griffin");
 		report_emm_support(READER_DGCRYPT, "DGCrypt");
 	}
+#endif // defined(__HISILICON_MANUFACTORY__)
 }
 #undef report_emm_support
 
@@ -482,27 +541,23 @@
 
 	switch(fork())
 	{
-	case -1:
-		return (-1);
-	case 0:
-		break;
-	default:
-		_exit(0);
+		case -1: return (-1);
+		case  0: break;
+		default: _exit(0);
 	}
 
 	if(setsid() == (-1))
-		{ return (-1); }
+		return(-1);
 
 	if(!nochdir)
-		{ (void)chdir("/"); }
+		(void)chdir("/");
 
 	if(!noclose && (fd = open("/dev/null", O_RDWR, 0)) != -1)
 	{
 		(void)dup2(fd, STDIN_FILENO);
 		(void)dup2(fd, STDOUT_FILENO);
 		(void)dup2(fd, STDERR_FILENO);
-		if(fd > 2)
-			{ (void)close(fd); }
+		if (fd>2) (void)close(fd);
 	}
 	return (0);
 }
@@ -535,8 +590,9 @@
 
 static void cs_sigpipe(void)
 {
-	if(cs_dblevel & D_ALL_DUMP)
-		{ cs_log("Got sigpipe signal -> captured"); }
+	if (cs_dblevel & D_ALL_DUMP) {
+		cs_log("Got sigpipe signal -> captured");
+	}
 }
 
 static void cs_dummy(void)
@@ -547,19 +603,11 @@
 /* Switch debuglevel forward one step (called when receiving SIGUSR1). */
 static void cs_debug_level(void)
 {
-	switch(cs_dblevel)
-	{
-	case 0:
-		cs_dblevel = 1;
-		break;
-	case 128:
-		cs_dblevel = 255;
-		break;
-	case 255:
-		cs_dblevel = 0;
-		break;
-	default:
-		cs_dblevel <<= 1;
+	switch (cs_dblevel) {
+		case   0: cs_dblevel =   1; break;
+		case 128: cs_dblevel = 255; break;
+		case 255: cs_dblevel =   0; break;
+		default:	 cs_dblevel <<= 1; break;
 	}
 
 	cs_log("debug_level=%d", cs_dblevel);
@@ -588,6 +636,17 @@
 	fprintf(fp, "FATAL: Signal %d: %s Fault. Logged StackTrace:\n\n", sig, (sig == SIGSEGV) ? "Segmentation" : ((sig == SIGBUS) ? "Bus" : "Unknown"));
 	fclose(fp);
 
+#if defined(WITH_HISILICON)
+	FILE *cmd = fopen("/var/gdbcmd", "w");
+	fputs ("bt\n", cmd);
+	fputs ("thread apply all bt\n", cmd);
+	fclose(cmd);
+
+	snprintf(buf, sizeof(buf)-1, "gdb %s %d -batch -x /var/gdbcmd >> oscam.crash", prog_name, getpid());
+	if (system(buf) == -1)
+		fprintf(stderr, "Fatal error on trying to start gdb process.");
+	exit(-1);
+#else
 	FILE *cmd = fopen("/tmp/gdbcmd", "w");
 	fputs("bt\n", cmd);
 	fputs("thread apply all bt\n", cmd);
@@ -595,9 +654,9 @@
 
 	snprintf(buf, sizeof(buf) - 1, "gdb %s %d -batch -x /tmp/gdbcmd >> oscam.crash", prog_name, getpid());
 	if(system(buf) == -1)
-		{ fprintf(stderr, "Fatal error on trying to start gdb process."); }
-
+		fprintf(stderr, "Fatal error on trying to start gdb process.");
 	exit(-1);
+#endif
 }
 
 
@@ -648,13 +707,11 @@
 	set_signal_handler(SIGUSR2, 1, cs_card_info);
 	set_signal_handler(OSCAM_SIGNAL_WAKEUP, 0, cs_dummy);
 
-	if(cs_capture_SEGV)
-	{
+	if (cs_capture_SEGV) {
 		set_signal_handler(SIGSEGV, 1, cs_exit);
 		set_signal_handler(SIGBUS, 1, cs_exit);
 	}
-	else if(cs_dump_stack)
-	{
+	else if (cs_dump_stack) {
 		set_signal_handler(SIGSEGV, 1, cs_dumpstack);
 		set_signal_handler(SIGBUS, 1, cs_dumpstack);
 	}
@@ -666,14 +723,13 @@
 void cs_exit(int32_t sig)
 {
 	if(cs_dump_stack && (sig == SIGSEGV || sig == SIGBUS || sig == SIGQUIT))
-		{ cs_dumpstack(sig); }
+		cs_dumpstack(sig);
 
 	set_signal_handler(SIGHUP , 1, SIG_IGN);
 	set_signal_handler(SIGPIPE, 1, SIG_IGN);
 
 	struct s_client *cl = cur_client();
-	if(!cl)
-		{ return; }
+  	if (!cl) return;
 
 	// this is very important - do not remove
 	if(cl->typ != 's')
@@ -712,6 +769,18 @@
 
 static void init_machine_info(void)
 {
+	#if defined(WITH_HISILICON)
+		#if defined(SDKV600)
+			stb_boxtype = cs_strdup("hisilicon");
+			stb_boxname = cs_strdup("quads");
+		#elif defined(SDKV500)
+			stb_boxtype = cs_strdup("hisilicon");
+			stb_boxname = cs_strdup("u4plus");
+		#else
+			stb_boxtype = cs_strdup("hisilicon");
+			stb_boxname = cs_strdup("u4");
+		#endif
+	#else
 	struct utsname buffer;
 	if (uname(&buffer) == 0)
 	{
@@ -816,6 +885,7 @@
 		stb_boxtype = cs_strdup(boxtype);
 	else if (model[0])
 		stb_boxtype = cs_strdup(model);
+	#endif
 }
 
 const char *boxtype_get(void)
@@ -839,38 +909,52 @@
 }
 
 /* Checks if the date of the system is correct and waits if necessary. */
-static void init_check(void)
+static void cs_time_check(void)
 {
 	char *ptr = __DATE__;
+
 	int32_t month, year = atoi(ptr + strlen(ptr) - 4), day = atoi(ptr + 4);
-	if(day > 0 && day < 32 && year > 2010 && year < 9999)
-	{
-		struct tm timeinfo;
 		char months[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 		for(month = 0; month < 12; ++month)
 		{
-			if(!strncmp(ptr, months[month], 3)) { break; }
+		if (!strncmp(ptr, months[month], 3)) break;
 		}
-		if(month > 11) { month = 0; }
+	if (month > 11) month = 0;
+	if (day > 0 && day < 32 && year > 2010 && year < 9999)
+	{
+		struct tm timeinfo;
 		memset(&timeinfo, 0, sizeof(timeinfo));
 		timeinfo.tm_mday = day;
 		timeinfo.tm_mon = month;
 		timeinfo.tm_year = year - 1900;
 		time_t builddate = mktime(&timeinfo) - 86400;
+
+#if defined(SDKV500) || defined(SDKV600)
+		if (time((time_t *)0) < builddate) {
+			cs_log("The current system time is smaller than the build date (%s).", ptr);
+			cs_timefaults = 1;
+		}
+		first_client->login = time((time_t *)0);
+#else
 		int32_t i = 0;
 		while(time((time_t *)0) < builddate)
 		{
-			if(i == 0) { cs_log("The current system time is smaller than the build date (%s). Waiting up to %d seconds for time to correct", ptr, cs_waittime); }
-			cs_sleepms(1000);
+			if (i == 0) {
+				cs_log("The current system time is smaller than the build date (%s).", ptr);
+				cs_log("Waiting up to %d seconds for time to correct", cs_waittime);
+			}
 			++i;
-			if(i > cs_waittime)
-			{
-				cs_log("Waiting was not successful. OSCam will be started but is UNSUPPORTED this way. Do not report any errors with this version.");
+			if (i > cs_waittime) {
+				cs_log("Waiting was not successful. OSCam will be started but is UNSUPPORTED this way.");
+			//	cs_log("Do not report any errors with this version.");
+				cs_timefaults = 1;
 				break;
 			}
+			cs_sleepms(1000);
 		}
 		// adjust login time of first client
-		if(i > 0) { first_client->login = time((time_t *)0); }
+		if (i > 0) first_client->login = time((time_t *)0);
+#endif
 	}
 }
 
@@ -901,9 +985,8 @@
 	cs_writelock(&system_lock);
 	int32_t ret = pthread_create(&temp, &attr, startroutine, NULL);
 	if(ret)
-		{ cs_log("ERROR: can't create %s thread (errno=%d %s)", nameroutine, ret, strerror(ret)); }
-	else
-	{
+		cs_log("ERROR: can't create %s thread (errno=%d %s)", nameroutine, ret, strerror(ret));
+	else {
 		cs_log_dbg(D_TRACE, "%s thread started", nameroutine);
 		pthread_detach(temp);
 	}
@@ -915,7 +998,7 @@
   If the own thread has to be cancelled, cs_exit or cs_disconnect_client has to be used. */
 void kill_thread(struct s_client *cl)
 {
-	if(!cl || cl->kill) { return; }
+	if (!cl || cl->kill) return;
 	if(cl == cur_client())
 	{
 		cs_log("Trying to kill myself, exiting.");
@@ -933,24 +1016,24 @@
 void module_reader_set(struct s_reader *rdr)
 {
 	int i;
-	if(!is_cascading_reader(rdr))
-		{ return; }
+	if (!is_cascading_reader(rdr)) return;
 	for(i = 0; i < CS_MAX_MOD; i++)
 	{
 		struct s_module *module = &modules[i];
 		if(module->num && module->num == rdr->typ)
+		{
 			rdr->ph = *module;
 	}
 }
+}
 
 static void cs_waitforcardinit(void)
 {
 	if(cfg.waitforcards)
 	{
 		cs_log("waiting for local card init");
-		int32_t card_init_done;
-		do
-		{
+		int32_t card_init_done = 1;
+		do {
 			card_init_done = 1;
 			struct s_reader *rdr;
 			LL_ITER itr = ll_iter_create(configured_readers);
@@ -964,12 +1047,11 @@
 			}
 
 			if(!card_init_done)
-				{ cs_sleepms(300); } // wait a little bit
+				cs_sleepms(300); // wait a little bit
 			//alarm(cfg.cmaxidle + cfg.ctimeout / 1000 + 1);
-		}
-		while(!card_init_done && !exit_oscam);
+		} while (!card_init_done && !exit_oscam);
 		if(cfg.waitforcards_extra_delay > 0 && !exit_oscam)
-			{ cs_sleepms(cfg.waitforcards_extra_delay); }
+			cs_sleepms(cfg.waitforcards_extra_delay);
 		cs_log("init for all local cards done");
 	}
 }
@@ -979,18 +1061,15 @@
 	if(old_size != new_size)
 	{
 		struct pollfd *pfd_new;
-		if(!cs_malloc(&pfd_new, new_size * sizeof(struct pollfd)))
-		{
+		if (!cs_malloc(&pfd_new, new_size * sizeof(struct pollfd))) {
 			return old_size;
 		}
 		struct s_client **cl_list_new;
-		if(!cs_malloc(&cl_list_new, new_size * sizeof(cl_list)))
-		{
+		if (!cs_malloc(&cl_list_new, new_size * sizeof(cl_list))) {
 			NULLFREE(pfd_new);
 			return old_size;
 		}
-		if(old_size > 0)
-		{
+		if (old_size > 0) {
 			memcpy(pfd_new, *pfd, old_size * sizeof(struct pollfd));
 			memcpy(cl_list_new, *cl_list, old_size * sizeof(cl_list));
 			NULLFREE(*pfd);
@@ -1025,8 +1104,7 @@
 
 	uchar buf[10];
 
-	if(pipe(thread_pipe) == -1)
-	{
+	if (pipe(thread_pipe) == -1) {
 		printf("cannot create pipe, errno=%d\n", errno);
 		exit(1);
 	}
@@ -1037,6 +1115,8 @@
 	pfd[pfdcount].events = POLLIN | POLLPRI;
 	cl_list[pfdcount] = NULL;
 
+	// main loop function
+	mycs_log("main process_clients...");
 	while(!exit_oscam)
 	{
 		pfdcount = 1;
@@ -1046,8 +1126,7 @@
 		{
 			if(cl->init_done && !cl->kill && cl->pfd && cl->typ == 'c' && !cl->is_udp)
 			{
-				if(cl->pfd && !cl->thread_active)
-				{
+				if (cl->pfd && !cl->thread_active) {
 					cl_size = chk_resize_cllist(&pfd, &cl_list, cl_size, pfdcount);
 					cl_list[pfdcount] = cl;
 					pfd[pfdcount].fd = cl->pfd;
@@ -1093,30 +1172,31 @@
 			}
 		}
 
-		if(pfdcount >= 1024)
-			{ cs_log("WARNING: too many users!"); }
+		if (pfdcount >= 1024) {
+			cs_log("WARNING: too many users!");
+		}
 		cs_ftime(&start); // register start time
 		rc = poll(pfd, pfdcount, 5000);
-		if(rc < 1) { continue; }
+		if (rc<1) continue;
 		cs_ftime(&end); // register end time
 
 		for(i = 0; i < pfdcount && rc > 0; i++)
 		{
-			if(pfd[i].revents == 0) { continue; }  // skip sockets with no changes
+			if (pfd[i].revents == 0) continue; // skip sockets with no changes
 			rc--; //event handled!
-			cs_log_dbg(D_TRACE, "[OSCAM] new event %d occurred on fd %d after %"PRId64" ms inactivity", pfd[i].revents,
+			cs_log_dbg(D_TRACE, "[OSCAM] new event %d occurred on fd %d after %"PRId64" ms inactivity",
+						pfd[i].revents,
 						  pfd[i].fd, comp_timeb(&end, &start));
 			//clients
 			cl = cl_list[i];
 			if(cl && !is_valid_client(cl))
-				{ continue; }
+				continue;
 
 			if(pfd[i].fd == thread_pipe[0] && (pfd[i].revents & (POLLIN | POLLPRI)))
 			{
 				// a thread ended and cl->pfd should be added to pollfd list again (thread_active==0)
 				int32_t len = read(thread_pipe[0], buf, sizeof(buf));
-				if(len == -1)
-				{
+				if (len == -1) {
 					cs_log_dbg(D_TRACE, "[OSCAM] Reading from pipe failed (errno=%d %s)", errno, strerror(errno));
 				}
 				cs_log_dump_dbg(D_TRACE, buf, len, "[OSCAM] Readed:");
@@ -1148,8 +1228,7 @@
 			if(cl && cl->typ == 'p')
 			{
 				rdr = cl->reader;
-				if(rdr)
-					{ cl2 = rdr->client; }
+				if (rdr) cl2 = rdr->client;
 			}
 
 			if(rdr && cl2 && cl2->init_done)
@@ -1158,7 +1237,7 @@
 				{
 					//connection to remote proxy was closed
 					//oscam should check for rdr->tcp_connected and reconnect on next ecm request sent to the proxy
-					network_tcp_connection_close(rdr, "closed");
+					network_tcp_connection_close(rdr, "clients closed");
 					rdr_log_dbg(rdr, D_READER, "connection closed");
 				}
 				if(cl2->pfd && pfd[i].fd == cl2->pfd && (pfd[i].revents & (POLLIN | POLLPRI)))
@@ -1210,7 +1289,7 @@
 		for(cl = first_client->next; cl ; cl = cl->next)
 		{
 			if(!cl->thread_active)
-				{ client_check_status(cl); }
+				client_check_status(cl);
 		}
 		cs_readlock(&readerlist_lock);
 		for(rdr = first_active_reader; rdr; rdr = rdr->next)
@@ -1219,9 +1298,9 @@
 			{
 				cl = rdr->client;
 				if(!cl || cl->kill)
-					{ restart_cardreader(rdr, 0); }
+					restart_cardreader(rdr, 0);
 				else if(!cl->thread_active)
-					{ client_check_status(cl); }
+					client_check_status(cl);
 			}
 		}
 		cs_readunlock(&readerlist_lock);
@@ -1279,9 +1358,9 @@
 		//start client process:
 		pid = fork();
 		if(!pid)
-			{ return; } //client process=oscam process
+		  	return; //client process=oscam process
 		if(pid < 0)
-			{ exit(1); }
+		  	exit(1);
 
 		//set signal handler for the restart daemon:
 		set_signal_handler(SIGINT, 3, fwd_sig);
@@ -1301,25 +1380,21 @@
 		//restart control process:
 		int32_t res = 0;
 		int32_t status = 0;
-		do
-		{
+		do {
 			res = waitpid(pid, &status, 0);
-			if(res == -1)
-			{
+			if (res==-1) {
 				if(errno != EINTR)
-					{ exit(1); }
-			}
+			  	exit(1);
 		}
-		while(res != pid);
+		} while (res!=pid);
 
 		if(cs_restart_mode == 2 && WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV)
-			{ status = 99; } //restart on segfault!
+			status = 99; //restart on segfault!
 		else
-			{ status = WEXITSTATUS(status); }
+			status = WEXITSTATUS(status);
 
 		//status=99 restart oscam, all other->terminate
-		if(status != 99)
-		{
+		if (status != 99) {
 			exit(status);
 		}
 	}
@@ -1376,15 +1451,38 @@
 #endif
 }
 
-#ifdef BUILD_TESTS
-extern void run_all_tests(void);
-__attribute__ ((noreturn)) static void run_tests(void)
+#if defined(WITH_HISILICON)
+static void cs_confs_existance(void)
 {
-	run_all_tests();
-	exit(0);
+	struct stat sb;
+	char srvfiles[256] = { 0 };
+	char commands[256] = { 0 };
+
+	if (!stat(cs_confdir, &sb)) {
+		snprintf(srvfiles, sizeof(srvfiles), "%s%s", cs_confdir, cs_OSCAMSERVER);
+		if (access(srvfiles, 0) == 0) {
+			myprintf("oscam:%s existance.\n", cs_OSCAMSERVER);
+			return;
 }
+	}
+	else {
+		myprintf("oscam:mkdir %s\n", cs_confdir);
+		snprintf(commands, sizeof(commands), "mkdir -p %s", cs_confdir);
+		system(commands);
+	}
+	myprintf("oscam:confs copy...\n");
+	#if defined(SDKV600)
+		snprintf(commands, sizeof(commands), "cp -f %s/* %s", CS_OSCAMDIR, cs_confdir);
 #else
-static void run_tests(void) { }
+		if (access(CS_XBMCUSERDIR, F_OK)==0) {
+			snprintf(commands, sizeof(commands), "cp -f %s/* %s", CS_XBMCUSERDIR, cs_confdir);
+		}
+		else {
+			snprintf(commands, sizeof(commands), "cp -f %s/* %s", CS_OSCAMDIR, cs_confdir);
+		}
+		system(commands);
+	#endif
+}
 #endif
 
 const struct s_cardsystem *cardsystems[] =
@@ -1435,7 +1533,9 @@
 #ifdef CARDREADER_DB2COM
 	&cardreader_db2com,
 #endif
-#if defined(CARDREADER_INTERNAL_AZBOX)
+	#if defined(CARDREADER_INTERNAL_HISKY)
+		&cardreader_internal_hisky,
+   #elif defined(CARDREADER_INTERNAL_AZBOX)
 	&cardreader_internal_azbox,
 #elif defined(CARDREADER_INTERNAL_COOLAPI)
 	&cardreader_internal_cool,
@@ -1471,7 +1571,6 @@
 
 int32_t main(int32_t argc, char *argv[])
 {
-	run_tests();
 	int32_t i, j;
 	prog_name = argv[0];
 	struct timespec start_ts;
@@ -1485,6 +1584,9 @@
 
 	void (*mod_def[])(struct s_module *) =
 	{
+		#ifdef HAVE_DVBAPI
+		   	 module_dvbapi,	// sky(move)
+		#endif
 #ifdef MODULE_MONITOR
 		module_monitor,
 #endif
@@ -1500,6 +1602,9 @@
 #ifdef MODULE_NEWCAMD
 		module_newcamd,
 #endif
+		#if defined(MODULE_XCAS)
+		       MODULE_xcas,
+		#endif
 #ifdef MODULE_CCCAM
 		module_cccam,
 #endif
@@ -1527,9 +1632,6 @@
 #ifdef MODULE_SERIAL
 		module_serial,
 #endif
-#ifdef HAVE_DVBAPI
-		module_dvbapi,
-#endif
 		0
 	};
 
@@ -1544,14 +1646,15 @@
 	get_random_bytes_init();
 
 #ifdef WEBIF
-	if(cs_restart_mode)
-		{ restart_daemon(); }
+	if (cs_restart_mode) {
+		restart_daemon();
+	}
 #endif
 
 	memset(&cfg, 0, sizeof(struct s_config));
 	cfg.max_pending = max_pending;
 
-	if(cs_confdir[strlen(cs_confdir) - 1] != '/') { strcat(cs_confdir, "/"); }
+	if (cs_confdir[strlen(cs_confdir) - 1] != '/') strcat(cs_confdir, "/");
 	init_signal_pre(); // because log could cause SIGPIPE errors, init a signal handler first
 	init_first_client();
 	cs_lock_create(&system_lock, "system_lock", 5000);
@@ -1565,18 +1668,27 @@
 	cs_lock_create(&cwcycle_lock, "cwcycle_lock", 5000);
 	init_cache();
 	cacheex_init_hitcache();
+#if defined(WITH_HISILICON)
+	cs_confs_existance();
+#endif
+	init_machine_info();
 	init_config();
 	cs_init_log();
-	init_machine_info();
-	init_check();
-	if(!oscam_pidfile && cfg.pidfile)
-		{ oscam_pidfile = cfg.pidfile; }
-	if(!oscam_pidfile)
-	{
+	cs_time_check();
+	// sky(sim)
+	chker_factoy_products();
+	chker_smartcard_enable();
+	cs_clean_cardinformation(); // sky(n)
+
+	if (!oscam_pidfile && cfg.pidfile) {
+		 oscam_pidfile = cfg.pidfile;
+	}
+	if (!oscam_pidfile) {
 		oscam_pidfile = get_tmp_dir_filename(default_pidfile, sizeof(default_pidfile), "oscam.pid");
 	}
-	if(oscam_pidfile)
-		{ pidfile_create(oscam_pidfile); }
+	if ( oscam_pidfile) {
+		pidfile_create(oscam_pidfile);
+	}
 	cs_init_statistics();
 	coolapi_open_all();
 	init_stat();
@@ -1584,8 +1696,7 @@
 
 	// These initializations *MUST* be called after init_config()
 	// because modules depend on config values.
-	for(i = 0; mod_def[i]; i++)
-	{
+	for (i=0; mod_def[i]; i++) {
 		struct s_module *module = &modules[i];
 		mod_def[i](module);
 	}
@@ -1610,6 +1721,11 @@
 	led_init();
 	led_status_default();
 
+//	#if defined(WITH_HISILICON)
+//	for cur_client() != dvbApi_client
+//		hidemuxapi_Init();
+//	#endif
+
 	azbox_init();
 
 	mca_init();
@@ -1624,7 +1740,10 @@
 		{
 			for(j = 0; j < module->ptab.nports; j++)
 			{
-				start_listener(module, &module->ptab.ports[j]);
+				if (!start_listener(module, &module->ptab.ports[j]))
+				{
+					myprintf("start_listener: %s fail...\n", module->desc);
+				}
 			}
 		}
 	}
@@ -1636,7 +1755,9 @@
 
 	start_thread((void *) &reader_check, "reader check");
 	cw_process_thread_start();
+#ifdef CS_CACHEEX
 	checkcache_process_thread_start();
+#endif
 
 	lcd_thread_start();
 
@@ -1659,9 +1780,13 @@
 	{
 		struct s_module *module = &modules[i];
 		if((module->type & MOD_CONN_SERIAL) && module->s_handler)
-			{ module->s_handler(NULL, NULL, i); }
+			module->s_handler(NULL, NULL, i);
+	}
+	//
+	// sky(sim)
+	if (g_factoy_products) {
+		free_reader_for_factoy_products();
 	}
-
 	// main loop function
 	process_clients();
 
@@ -1672,6 +1797,9 @@
 	// Cleanup
 	webif_close();
 	azbox_close();
+//	#if defined(WITH_HISILICON)
+//		hidemuxapi_Deinit();
+//	#endif
 	coolapi_close_all();
 	mca_close();
 
@@ -1710,9 +1838,9 @@
 		}
 	}
 
-	if(oscam_pidfile)
-		{ unlink(oscam_pidfile); }
-
+	if (oscam_pidfile) {
+		unlink(oscam_pidfile);
+	}
 	free_cache();
 	cacheex_free_hitcache();
 	webif_tpls_free();
Index: reader-bulcrypt.c
===================================================================
--- reader-bulcrypt.c	(revision 10670)
+++ reader-bulcrypt.c	(working copy)
@@ -60,20 +60,17 @@
 static const uchar sess_key[]      = { 0xF2, 0x21, 0xC5, 0x69,
 									   0x28, 0x86, 0xFB, 0x9E,
 									   0xC0, 0x20, 0x28, 0x06,
-									   0xD2, 0x23, 0x72, 0x31
-									 };
+                                       0xD2, 0x23, 0x72, 0x31 };
 
 static const uchar cmd_set_key[]   = { 0xDE, 0x1C, 0x00, 0x00, 0x0A,
 									   0x12, 0x08,
 									   0x56, 0x47, 0x38, 0x29,
-									   0x10, 0xAF, 0xBE, 0xCD
-									 };
+                                       0x10, 0xAF, 0xBE, 0xCD };
 
 static const uchar cmd_set_key_v2[] = { 0xDE, 0x1C, 0x00, 0x00, 0x0A,
 										0x12, 0x08,
 										0x00, 0x00, 0x00, 0x00,
-										0x00, 0x00, 0x00, 0x00
-									  };
+                                       0x00, 0x00, 0x00, 0x00 };
 // Response: 90 00
 
 // V2
@@ -130,8 +127,7 @@
 static const uchar cmd_sub_info2[] = { 0xDE, 0x1E, 0x00, 0x00, 0x2B, 0x00 };
 // See bulcrypt_card_info() for reponse description
 
-struct bulcrypt_data
-{
+struct bulcrypt_data {
 	uint8_t         bulcrypt_version;
 };
 
@@ -148,8 +144,7 @@
 
 	if(memcmp(atr, atr_carpet, MIN(sizeof(atr_carpet), atr_size)) != 0)
 	{
-		if(atr_size == 3)
-		{
+		if (atr_size == 3) {
 			rdr_log(reader, "ATR_len=3 but ATR is unknown: %s",
 					cs_hexdump(1, atr, atr_size, tmp, sizeof(tmp)));
 		}
@@ -157,7 +152,7 @@
 	}
 
 	if(!cs_malloc(&reader->csystem_data, sizeof(struct bulcrypt_data)))
-		{ return ERROR; }
+		return ERROR;
 	struct bulcrypt_data *csystem_data = reader->csystem_data;
 
 	reader->nprov = 1;
@@ -175,9 +170,7 @@
 		// The card is v1
 		csystem_data->bulcrypt_version = 1;
 		set_key_command = cmd_set_key;
-	}
-	else
-	{
+	} else {
 		// The card is v2
 		csystem_data->bulcrypt_version = 2;
 		set_key_command = cmd_set_key_v2;
@@ -242,6 +235,8 @@
 		if(!isdigit((uchar)card_serial[i]))
 			{ card_serial[i] = '*'; }
 	}
+	// sky(oscam.smartcard)
+	strcpy(reader->ascserial, card_serial);
 
 	// Write empty ECM, *FIXME* why are we doing this? To prepare the card somehow?
 	write_cmd(cmd_ecm_empty, NULL);
@@ -260,12 +255,10 @@
 static int cw_is_valid(struct s_reader *reader, unsigned char *cw)
 {
 	unsigned int i = 0, cnt = 0;
-	do
-	{
+	do {
 		if(cw[i++] == 0)
-			{ cnt++; }
-	}
-	while(i < 8);
+			cnt++;
+	} while (i < 8);
 
 	if(cnt == 8)
 	{
@@ -278,9 +271,9 @@
 	if(cksum1 != cw[3] || cksum2 != cw[7])
 	{
 		if(cksum1 != cw[3])
-			{ rdr_log(reader, "Invalid CW (cksum1 mismatch expected 0x%02x got 0x%02x)", cksum1, cw[3]); }
+			rdr_log(reader, "Invalid CW (cksum1 mismatch expected 0x%02x got 0x%02x)", cksum1, cw[3]);
 		if(cksum2 != cw[7])
-			{ rdr_log(reader, "Invalid CW (cksum2 mismatch expected 0x%02x got 0x%02x)", cksum2, cw[7]); }
+			rdr_log(reader, "Invalid CW (cksum2 mismatch expected 0x%02x got 0x%02x)", cksum2, cw[7]);
 		return ERROR;
 	}
 
@@ -366,11 +359,9 @@
 
 	// Remove code word obfuscation
 	uchar *cw = cta_res + 3;
-	if(csystem_data->bulcrypt_version == 1)
-	{
+	if (csystem_data->bulcrypt_version == 1) {
 		int i;
-		for(i = 0 ; i < 16; i++)
-		{
+		for (i = 0 ; i < 16; i++) {
 			cw[i] = cw[i] ^ sess_key[i];
 		}
 	}
@@ -380,16 +371,14 @@
 		// Even/Odd CWs should be exchanged
 		memcpy(ea->cw, cw + 8, 8);
 		memcpy(ea->cw + 8, cw, 8);
-	}
-	else
-	{
+	} else {
 		memcpy(ea->cw, cw, 8);
 		memcpy(ea->cw + 8, cw + 8, 8);
 	}
 
 	// Check if DCW is valid
 	if(!cw_is_valid(reader, ea->cw) || !cw_is_valid(reader, ea->cw + 8))
-		{ return ERROR; }
+		return ERROR;
 
 	return OK;
 }
@@ -457,28 +446,16 @@
 	}
 
 	ep->type = UNKNOWN;
-	switch(ep->emm[0])
-	{
-	case BULCRYPT_EMM_UNIQUE_82:
-		ep->type = UNIQUE;
-		break; // Bulsatcom
-	case BULCRYPT_EMM_UNIQUE_8a:
-		ep->type = UNIQUE;
-		break; // Polaris
-	case BULCRYPT_EMM_SHARED_84:
-		ep->type = SHARED;
-		break;
-	case BULCRYPT_EMM_GLOBAL_85:
-		ep->type = GLOBAL;
-		break; // Bulsatcom
-	case BULCRYPT_EMM_GLOBAL_8b:
-		ep->type = GLOBAL;
-		break; // Polaris
+	switch (ep->emm[0]) {
+	case BULCRYPT_EMM_UNIQUE_82: ep->type = UNIQUE; break; // Bulsatcom
+	case BULCRYPT_EMM_UNIQUE_8a: ep->type = UNIQUE; break; // Polaris
+	case BULCRYPT_EMM_SHARED_84: ep->type = SHARED; break;
+	case BULCRYPT_EMM_GLOBAL_85: ep->type = GLOBAL; break; // Bulsatcom
+	case BULCRYPT_EMM_GLOBAL_8b: ep->type = GLOBAL; break; // Polaris
 	}
 
 	bool ret = false;
-	if(ep->type == UNIQUE)
-	{
+	if (ep->type == UNIQUE) {
 		// The serial numbers looks like this:
 		//   aa bb cc dd
 		memcpy(ep->hexserial, ep->emm + 3, 4);
@@ -486,9 +463,7 @@
 			  reader->hexserial[1] == ep->hexserial[1] &&
 			  reader->hexserial[2] == ep->hexserial[2] &&
 			  ((reader->hexserial[3] & 0xF0) == (ep->hexserial[3] & 0xF0));
-	}
-	else
-	{
+	} else {
 		// To match EMM_84, EMM_85, EMM_8b
 		//   aa bb -- --
 		memcpy(ep->hexserial, ep->emm + 3, 2);
@@ -496,8 +471,7 @@
 			  reader->hexserial[1] == ep->hexserial[1];
 	}
 
-	if(ret)
-	{
+	if (ret) {
 		char dump_card_sn[64];
 		cs_hexdump(1, reader->hexserial, 4, dump_card_sn, sizeof(dump_card_sn));
 		cs_hexdump(1, ep->hexserial, 4, dump_emm_sn, sizeof(dump_emm_sn));
@@ -515,11 +489,10 @@
 
 static int32_t bulcrypt_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count)
 {
-	if(*emm_filters == NULL)
-	{
+  if (*emm_filters == NULL) {
 		const unsigned int max_filter_count = 5;
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+      return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
@@ -604,8 +577,7 @@
 	memcpy(emm_cmd, cmd_emm1, sizeof(cmd_emm1));
 	memcpy(emm_cmd + sizeof(cmd_emm1), ep->emm + 7, 176);
 
-	switch(ep->emm[0])
-	{
+	switch (ep->emm[0]) {
 	case BULCRYPT_EMM_UNIQUE_82:
 		emm_cmd[2] = ep->emm[0]; // 0x82
 		break;
@@ -732,8 +704,8 @@
 		// 5581:0080|Unknown Package 80
 		for(i = 1; i < 256; i <<= 1)
 		{
-			if((subs1 & i) == i)
-			{
+  	  		// sky(n)
+			if ((subs1 & i) == i) {
 				cs_add_entitlement(reader, 0x4AEE,
 								   0, /* provid */
 								   i, /* id  */
@@ -741,8 +713,8 @@
 								   last_upd_ts, /* start_ts */
 								   subs_end_ts, /* end_ts */
 								   4, /* type: Tier */
-								   1  /* add */
-								  );
+					NULL,
+					1);  /* add */
 				cs_add_entitlement(reader, 0x5581,
 								   0, /* provid */
 								   i, /* id  */
@@ -750,8 +722,8 @@
 								   last_upd_ts, /* start_ts */
 								   subs_end_ts, /* end_ts */
 								   4, /* type: Tier */
-								   1  /* add */
-								  );
+					NULL,
+					1);  /* add */
 				get_tiername(i, 0x4aee, tmp);
 				if(tmp[0] == 0x00)
 					{ get_tiername(i, 0x5581, tmp); }
Index: reader-common.c
===================================================================
--- reader-common.c	(revision 10670)
+++ reader-common.c	(working copy)
@@ -1,7 +1,8 @@
 #include "globals.h"
 
 #ifdef WITH_CARDREADER
-
+#include "cscrypt/bn.h"
+#include "csctapi/icc_async.h"
 #include "module-led.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -12,12 +13,104 @@
 #include "oscam-work.h"
 #include "oscam-reader.h"
 #include "reader-common.h"
-//#include "csctapi/atr.h"
-#include "csctapi/icc_async.h"
 
 extern const struct s_cardsystem *cardsystems[];
 extern char *RDR_CD_TXT[];
 
+#if defined(WITH_HISILICON)
+extern uint16_t HISCIAPI_ChkCardstatus (struct s_reader *reader);
+extern char *   HISCIAPI_ChkCardsystem (struct s_reader *reader);
+extern bool     HISCIAPI_SaveCardstatus(struct s_reader *reader);
+#endif
+
+// sky
+// move reader-cryptoworks.c
+static void RotateBytes1(unsigned char *out, unsigned char *in, int32_t n)
+{
+	// loop is executed atleast once, so it's not a good idea to
+	// call with n=0 !!
+	out += n;
+	do {
+		*(--out) = *(in++);
+	} while (--n);
+}
+
+static void RotateBytes2(unsigned char *in, int32_t n)
+{
+	// loop is executed atleast once, so it's not a good idea to
+	// call with n=0 !!
+	unsigned char *e = in+n-1;
+	do
+	{
+		unsigned char temp = *in;
+		*in++ = *e;
+		*e--  = temp;
+	} while (in<e);
+}
+
+static int32_t cbn_Input(BIGNUM *d, unsigned char *in, int32_t n, int32_t le)
+{
+	if (le)
+	{
+		unsigned char tmp[n];
+		RotateBytes1(tmp,in,n);
+		return(BN_bin2bn(tmp,n,d) != 0);
+	}
+	return(BN_bin2bn(in,n,d) != 0);
+}
+
+static int32_t cbn_Output(struct s_reader *reader, unsigned char *out, int32_t n, BIGNUM *r, int32_t le)
+{
+	int32_t s=BN_num_bytes(r);
+	if (s>n)
+	{
+		unsigned char buff[s];
+		rdr_log_dbg(reader, D_READER, "rsa: RSA len %d > %d, truncating", s, n);
+		BN_bn2bin(r,buff);
+		memcpy(out,buff+s-n,n);
+	}
+	else if (s<n)
+	{
+		int32_t l=n-s;
+		rdr_log_dbg(reader, D_READER, "rsa: RSA len %d < %d, padding", s, n);
+		memset(out,0,l);
+		BN_bn2bin(r,out+l);
+	}
+	else {
+		BN_bn2bin(r,out);
+	}
+
+	if (le) {
+		RotateBytes2(out,n);
+	}
+	return(s);
+}
+// rename(sky.cw_RSA)
+int32_t rdr_RSA_decrypt(struct s_reader *reader, unsigned char *out, unsigned char *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int32_t le)
+{
+	int32_t rc = 0;
+	BN_CTX  *ctx;
+	BIGNUM  *r, *d;
+
+	myprintf("### rdr_RSA_decrypt\n");
+	ctx= BN_CTX_new();
+	r	= BN_new();
+	d	= BN_new();
+	if (cbn_Input(d,in,n,le))
+	{
+		if (BN_mod_exp(r,d,exp,mod,ctx)) {
+		  	rc = cbn_Output(reader, out,n,r,le);
+		}
+		else {
+			if (reader) rdr_log(reader, "rsa: mod-exp failed");
+		}
+	}
+	BN_CTX_free(ctx);
+	BN_free(d);
+	BN_free(r);
+	return(rc);
+}
+
 int32_t check_sct_len(const uchar *data, int32_t off)
 {
 	int32_t len = SCT_LEN(data);
@@ -37,7 +130,10 @@
 	memset(reader->prid     , 0xFF, sizeof(reader->prid));
 	reader->caid = 0;
 	reader->nprov = 0;
+	reader->card_atr_length = 0;
 	cs_clear_entitlement(reader);
+	// sky(n)
+	cs_clean_cardinformation();
 }
 
 int32_t reader_cmd2icc(struct s_reader *reader, const uchar *buf, const int32_t l, uchar *cta_res, uint16_t *p_cta_lr)
@@ -105,7 +201,7 @@
 	if(ret) { return (0); }
 
 	//  rdr_log("ATR: %s", cs_hexdump(1, atr, atr_size, tmp, sizeof(tmp)));//FIXME
-	cs_sleepms(1000);
+	cs_sleepms(800);
 	return (1);
 }
 
@@ -121,6 +217,8 @@
 		{
 			reader->csystem->card_info(reader);
 		}
+		// sky(oscam.smartcard)
+		cs_save_cardinformation(reader);
 	}
 }
 
@@ -143,6 +241,7 @@
 		if(csystem->card_init(reader, atr))
 		{
 			rdr_log(reader, "found card system %s", csystem->desc);
+			myprintf("mycard:found card system(%04X} %s\n", reader->caid, csystem->desc);
 			reader->csystem = csystem;
 			reader->csystem_active = true;
 			led_status_found_cardsystem();
@@ -173,20 +272,20 @@
 	int32_t ret = 0;
 	int16_t i = 0;
 	int16_t j = 0;
-	if (reader->typ == R_SMART && reader->smartdev_found >= 4) j = 1; else j = 1; // back to a single start
+	if (reader->typ == R_SMART && reader->smartdev_found >= 4) j = 1;
+	else j = 1; // back to a single start
 
 	for (i= 0; i < j; i++) {
 
 		ret = ICC_Async_Reset(reader, &atr, reader_activate_card, reader_get_cardsystem);
-
-		if(ret == -1)
-			{ return; }
+	   if (ret == -1) return;
 
 		if(ret == 0)
 		{
 			uint16_t y;
 			uint16_t deprecated;
-			if (reader->typ == R_SMART && reader->smartdev_found >= 4) y = 2; else y= 2;
+			if (reader->typ == R_SMART && reader->smartdev_found >= 4) y = 2;
+			else y = 2;
 //			rdr_log(reader, "the restart atempts in deprecated is %u", y);
 			for(deprecated = reader->deprecated; deprecated < y; deprecated++)
 			{
@@ -199,7 +298,7 @@
 			}
 		}
 			if (ret){
-				rdr_log(reader,"THIS WAS A SUCCESSFUL START ATTEMPT No  %u out of max alloted of %u", (i+1), j);
+		// rdr_log(reader,"THIS WAS A SUCCESSFUL START ATTEMPT No  %u out of max alloted of %u", (i+1), j);
 				break;
 			}
 			else {
@@ -208,19 +307,27 @@
 	}
 	if(!ret)
 	{
-		reader->card_status = CARD_FAILURE;
 		rdr_log(reader, "card initializing error");
+		reader->card_status = CARD_FAILURE;
 		ICC_Async_DisplayMsg(reader, "AER");
 		led_status_card_activation_error();
+// sky(oscam.smartcard)
+#if defined(WITH_HISILICON)
+		HISCIAPI_SaveCardstatus(reader);
+#endif
+		cs_save_cardinformation(reader);
 	}
 	else
 	{
 		cardreader_get_card_info(reader);
 		reader->card_status = CARD_INSERTED;
-		do_emm_from_file(reader);
 		ICC_Async_DisplayMsg(reader, "AOK");
+// sky(oscam.smartcard)
+#if defined(WITH_HISILICON)
+		HISCIAPI_SaveCardstatus(reader);
+#endif
+		do_emm_from_file(reader);
 	}
-
 	return;
 }
 
@@ -227,31 +334,39 @@
 static int32_t cardreader_device_init(struct s_reader *reader)
 {
 	int32_t rc = -1; //FIXME
-	if(ICC_Async_Device_Init(reader))
-		{ rdr_log(reader, "Cannot open device: %s", reader->device); }
+	reader->card_status = NO_CARD;
+#if defined(WITH_HISILICON)
+	HISCIAPI_SaveCardstatus(reader);
+#endif
+	if (ICC_Async_Device_Init(reader)) {
+		rdr_log(reader, "Cannot open device: %s", reader->device);
+	}
 	else
-		{ rc = OK; }
+		rc = OK;
 	return ((rc != OK) ? 2 : 0); //exit code 2 means keep retrying, exit code 0 means all OK
 }
 
 int32_t cardreader_do_checkhealth(struct s_reader *reader)
 {
+	if (!reader) return 0;
 	struct s_client *cl = reader->client;
+
 	if(reader_card_inserted(reader))
 	{
-		if(reader->card_status == NO_CARD || reader->card_status == UNKNOWN)
-		{
+		if (reader->card_status == NO_CARD || reader->card_status == UNKNOWN) {
 			rdr_log(reader, "card detected");
-			led_status_card_detected();
 			reader->card_status = CARD_NEED_INIT;
+			led_status_card_detected();
+#if defined(WITH_HISILICON)
+			HISCIAPI_SaveCardstatus(reader);
+#endif
 			add_job(cl, ACTION_READER_RESET, NULL, 0);
 		}
 	}
 	else
 	{
-		rdr_log_dbg(reader, D_READER, "%s: !reader_card_inserted", __func__);
-		if(reader->card_status == CARD_INSERTED || reader->card_status == CARD_NEED_INIT)
-		{
+//		rdr_log_dbg(reader, D_READER, "%s: !reader_card_inserted", __func__);
+		if (reader->card_status == CARD_INSERTED || reader->card_status == CARD_NEED_INIT) {
 			rdr_log(reader, "card ejected");
 			reader_nullcard(reader);
 			if(reader->csystem && reader->csystem->card_done)
@@ -262,20 +377,23 @@
 				cl->lastemm = 0;
 				cl->lastecm = 0;
 			}
+			reader->card_status = NO_CARD;
 			led_status_card_ejected();
+#if defined(WITH_HISILICON)
+			HISCIAPI_SaveCardstatus(reader);
+#endif
 		}
 		reader->card_status = NO_CARD;
 	}
-	rdr_log_dbg(reader, D_READER, "%s: reader->card_status = %d, ret = %d", __func__,
-				   reader->card_status, reader->card_status == CARD_INSERTED);
-	return reader->card_status == CARD_INSERTED;
+//	rdr_log_dbg(reader, D_READER, "%s: reader->card_status = %d, ret = %d", __func__,
+//			reader->card_status, reader->card_status == CARD_INSERTED);
+	return (reader->card_status == CARD_INSERTED);
 }
 
 // Check for card inserted or card removed on pysical reader
 void cardreader_checkhealth(struct s_client *cl, struct s_reader *rdr)
 {
-	if(!rdr || !rdr->enable || !rdr->active)
-		{ return; }
+	if (!rdr || !rdr->enable || !rdr->active) return;
 	add_job(cl, ACTION_READER_CHECK_HEALTH, NULL, 0);
 }
 
@@ -304,11 +422,17 @@
 	}
 	if (i >= 10)
 	{
+#if defined(WITH_HISILICON)
+		if (!IS_CARD_READER(reader))
+#endif
+		{
+			myprintf("cardreader_init.%s fail.\n", reader->label);
 		reader->card_status = READER_DEVICE_ERROR;
 		cardreader_close(reader);
 		reader->enable = 0;
 		return false;
 	}
+	}
 	else 
 	{
 		if(reader->typ == R_INTERNAL)
@@ -375,7 +499,9 @@
 						reader->detect & 0x80 ? "!" : "",
 						RDR_CD_TXT[reader->detect & 0x7f],
 						reader->cardmhz);
-			} else {
+		   }
+		   else
+		   {
 				rdr_log(reader, "Reader initialized (device=%s, detect=%s%s, mhz=%d, cardmhz=%d)",
 						reader->device,
 						reader->detect & 0x80 ? "!" : "",
@@ -386,8 +512,8 @@
 					rdr_log(reader,"Reader sci internal, detected box type: %s", boxtype_get());
 			}
 		}
-		return true;
 	}
+	return true;
 }
 
 void cardreader_close(struct s_reader *reader)
@@ -436,7 +563,8 @@
 	int32_t rc;
 	if (reader->typ == R_SMART ) {  // check health does not work with new card status check but is actually not needed for emm.
 	rc = 1;
-	} else {
+	}
+	else {
 	rc = -1;
 	rc = cardreader_do_checkhealth(reader);
 	}
@@ -468,6 +596,7 @@
 	cs_ftime(&tpe);
 	
 	rdr_log_dbg(reader, D_READER, "%s: cardreader_do_ecm returned rc=%d (ERROR=%d)", __func__, rc, ERROR);
+	MYCARD_TRACE("mycard:cardreader_process_ecm{%d}{%02X.%s}\n", rc, reader->typ, reader->label);
 
 	ea.rc = E_FOUND; //default assume found
 	ea.rcEx = 0; //no special flag
@@ -480,6 +609,7 @@
 		ea.rc = E_NOTFOUND;
 		ea.rcEx = 0;
 		ICC_Async_DisplayMsg(reader, "Eer");
+//		snprintf(ea.msglog, MSGLOGSIZE, "card transmission?");
 	}
 
 	if(rc == E_CORRUPT)
@@ -489,10 +619,10 @@
 					   er->caid, er->srvid, get_servicename(cl, er->srvid, er->caid, buf));
 		ea.rc = E_NOTFOUND;
 		ea.rcEx = E2_WRONG_CHKSUM; //flag it as wrong checksum
-		memcpy(ea.msglog, "Invalid ecm type for card", 25);
+		snprintf(ea.msglog, MSGLOGSIZE, "Invalid ecm type for card");
 	}
 
-	write_ecm_answer(reader, er, ea.rc, ea.rcEx, ea.cw, ea.msglog);
+	write_ecm_answer(reader, er, ea.rc, ea.rcEx, ea.cw, NULL, ea.msglog);
 	
 	cl->lastecm = time((time_t *)0);
 	char ecmd5[17 * 3];
Index: reader-common.h
===================================================================
--- reader-common.h	(revision 10670)
+++ reader-common.h	(working copy)
@@ -5,11 +5,23 @@
 #define SKIPPED 2
 #define OK      1
 #define ERROR   0
+// sky(n)
+#define RETRY   3
 
 #include "csctapi/atr.h"
 #include "oscam-string.h"
 #include "oscam-reader.h"
-
+//
+//
+//
+#if 1
+	#define	MYCARD_TRACE		myprintf
+#else
+	#define	MYSCI_TRACE(...)
+#endif
+//
+//
+//
 int32_t reader_cmd2icc(struct s_reader *reader, const uchar *buf, const int32_t l, uchar *response, uint16_t *response_length);
 int32_t card_write(struct s_reader *reader, const uchar *, const uchar *, uchar *, uint16_t *);
 
@@ -55,25 +67,13 @@
 int32_t check_sct_len(const unsigned char *data, int32_t off);
 #else
 static inline void cardreader_init_locks(void) { }
-static inline bool cardreader_init(struct s_reader *UNUSED(reader))
-{
-	return true;
-}
+static inline bool cardreader_init(struct s_reader *UNUSED(reader)) { return true; }
 static inline void cardreader_close(struct s_reader *UNUSED(reader)) { }
-static inline void cardreader_do_reset(struct s_reader *UNUSED(reader))
-{
-	return;
-}
+static inline void cardreader_do_reset(struct s_reader *UNUSED(reader)) { return; }
 static inline void cardreader_reset(struct s_client *UNUSED(cl)) { }
-static inline int32_t cardreader_do_checkhealth(struct s_reader *UNUSED(reader))
-{
-	return false;
-}
+static inline int32_t cardreader_do_checkhealth(struct s_reader *UNUSED(reader)) { return false; }
 static inline void cardreader_checkhealth(struct s_client *UNUSED(cl), struct s_reader *UNUSED(rdr)) { }
-static inline int32_t cardreader_do_emm(struct s_reader *UNUSED(reader), EMM_PACKET *UNUSED(ep))
-{
-	return 0;
-}
+static inline int32_t cardreader_do_emm(struct s_reader *UNUSED(reader), EMM_PACKET *UNUSED(ep)) { return 0; }
 static inline void cardreader_process_ecm(struct s_reader *UNUSED(reader), struct s_client *UNUSED(cl), ECM_REQUEST *UNUSED(er)) { }
 static inline void cardreader_get_card_info(struct s_reader *UNUSED(reader)) { }
 static inline void cardreader_poll_status(struct s_reader *UNUSED(reader)) { }
Index: reader-conax.c
===================================================================
--- reader-conax.c	(revision 10670)
+++ reader-conax.c	(working copy)
@@ -81,14 +81,15 @@
 	time_t rc = 0;
 	struct tm timeinfo;
 	memset(&timeinfo, 0, sizeof(struct tm));
-	if(buf)
-	{
+   if (buf) {
 		timeinfo.tm_year = 90 + (ptr[1] >> 4) + (((ptr[0] >> 5) & 7) * 10);
 		timeinfo.tm_mon = (ptr[1] & 0xf) - 1;
 		timeinfo.tm_mday = ptr[0] & 0x1f;
 		timeinfo.tm_isdst = -1;
 		rc = mktime(&timeinfo);
-		strftime(buf, l, "%Y/%m/%d", &timeinfo);
+	// sky((date))
+	//	strftime(buf, l, "%Y/%m/%d", &timeinfo);
+		strftime(buf, l, "%d/%m/%Y", &timeinfo);
 	}
 	return (rc);
 }
@@ -100,12 +101,12 @@
 
 	write_cmd(cmd, data);     // select record
 	if(cta_res[0] != 0x98)
-		{ return (-1); }
+		return(-1);
 
 	insCA[4] = cta_res[1];    // get len
 	write_cmd(insCA, NULL);   // read record
 	if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1]))
-		{ return (-1); }
+		return(-1);
 	return (cta_lr - 2);
 }
 
@@ -115,7 +116,7 @@
 	uchar ins26[] = {0xDD, 0x26, 0x00, 0x00, 0x03, 0x10, 0x01, 0x00};
 	uint8_t cnxcurrecm = 0;
 
-	if(0x0 != reader->rsa_mod[0] && n > 3 &&
+	if (0x00 != reader->rsa_mod[0] && n > 3 &&
 			0x54 == er->ecm[n - 3] &&
 			0x02 == er->ecm[n - 2] &&
 			0x00 == er->ecm[n - 1])
@@ -142,10 +143,14 @@
 	unsigned char cta_res[CTA_RES_LEN];
 	int32_t i, j, n;
 	static const uchar ins26[] = {0xDD, 0x26, 0x00, 0x00, 0x03, 0x10, 0x01, 0x40};
-	uchar ins82[] = {0xDD, 0x82, 0x00, 0x00, 0x11, 0x11, 0x0f, 0x01, 0xb0, 0x0f, 0xff, \
-					 0xff, 0xfb, 0x00, 0x00, 0x09, 0x04, 0x0b, 0x00, 0xe0, 0x30, 0x2b
+	static const uchar insC2[]= {0xDD, 0xC2, 0x00, 0x00, 0x02, 0x66, 0x00};
+	uchar ins82[] = {0xDD, 0x82, 0x00, 0x00, 0x11,
+						  0x11, 0x0f,
+	//					  0x01, 0xb0, 0x0f, 0xff, 0xff, 0xfb, 0x00, 0x00, 0x09, 0x04,
+	//					  0x0b, 0x00, 0xe0, 0x30, 0x2b
+	/* CAT */		  0x01, 0xB0, 0x0F, 0xFF, 0xFF, 0xD7, 0x00, 0x00, 0x09, 0x04,
+						  0x0B, 0x00, 0xE0, 0x20, 0x1C, 0x76, 0x6A, 0xFA,
 					};
-
 	uchar cardver = 0;
 
 	get_hist;
@@ -150,49 +155,64 @@
 
 	get_hist;
 	if((hist_size < 4) || (memcmp(hist, "0B00", 4)))
-		{ return ERROR; }
+		return ERROR;
 
 	reader->caid = 0xB00;
 
-	if((n = read_record(reader, ins26, ins26 + 5, cta_res)) <= 0) { return ERROR; }  // read caid, card-version
-
-	for(i = 0; i < n; i += cta_res[i + 1] + 2)
+	if ((n=read_record(reader, ins26, ins26+5, cta_res))<=0) return ERROR;   // read caid, card-version
+//	myascdump("ins26", cta_res, n);
+	for (i=0; i<n; i+=cta_res[i+1]+2) {
 		switch(cta_res[i])
 		{
-		case 0x20:
-			cardver = cta_res[i + 2];
-			break;
-		case 0x28:
-			reader->caid = (cta_res[i + 2] << 8) | cta_res[i + 3];
+			case 0x20: cardver = cta_res[i+2]; break;
+			case 0x28: reader->caid = (cta_res[i+2]<<8)|cta_res[i+3]; break;
+			// sky(n)
+			case 0x30: reader->maturity = cta_res[i+2]; break;
+		}
 		}
 
+	if ((n=read_record(reader, insC2, insC2+5, cta_res))<=0) return ERROR;   // read req_card_number
+
 	// Ins82 command needs to use the correct CAID reported in nano 0x28
 	ins82[17] = (reader->caid >> 8) & 0xFF;
 	ins82[18] = (reader->caid) & 0xFF;
-
-	if((n = read_record(reader, ins82, ins82 + 5, cta_res)) <= 0) { return ERROR; }  // read serial
-
+	if ((n=read_record(reader, ins82, ins82+5, cta_res))<=0) return ERROR; // read serial
+//	myascdump("ins82", cta_res, n);
 	reader->nprov = 0;
-
-	for(j = 0, i = 2; i < n; i += cta_res[i + 1] + 2)
+	// sky(Add)
+	for (j=0, i=2; i<n; i+=cta_res[i+1]+2) {
+		unsigned char oaa_res[14];
 		switch(cta_res[i])
 		{
 		case 0x23:
-			if(cta_res[i + 5] != 0x00)
-			{
+				memcpy(oaa_res, &cta_res[i+2], 7);
+				if (cta_res[i+5] != 0x00) {
 				memcpy(reader->hexserial, &cta_res[i + 3], 6);
 			}
-			else
-			{
+				else {
 				memcpy(reader->sa[j], &cta_res[i + 5], 4);
-				j++;
 				reader->nprov++;
+				  	j++;
 			}
 			break;
+			case 0x24:
+				memcpy(oaa_res, &cta_res[i+2], 14);
+				break;
+		}
 		}
-
 	memset(reader->prid, 0x00, sizeof(reader->prid));
 
+	// sky(oscam.smartcard)
+	{
+		uint32_t ulserial;
+		ulserial = ((reader->hexserial[2] * 0x1000000)+
+			  	 	    	 (reader->hexserial[3] * 0x10000)+
+			  		  	    (reader->hexserial[4] * 0x100)+
+			   		     reader->hexserial[5]);
+		sprintf(reader->ascserial,"%03i.%04i.%04i", ulserial/100000000, (ulserial%100000000)/10000, ulserial%10000);
+		reader->cardver = cardver;
+	}
+
 	rdr_log_sensitive(reader, "type: Conax, caid: %04X, serial: {%llu}, hex serial: {%02x%02x%02x%02x}, card: v%d",
 					  reader->caid, (unsigned long long) b2ll(6, reader->hexserial), reader->hexserial[2],
 					  reader->hexserial[3], reader->hexserial[4], reader->hexserial[5], cardver);
@@ -228,7 +248,7 @@
 	unsigned char insCA[]  = { 0xDD, 0xCA, 0x00, 0x00, 0x00 };
 
 	unsigned char exp[] = {0x01, 0x00, 0x01};
-	unsigned char buf[256];
+	unsigned char buf[MAX_LEN];
 
 	if((n = check_sct_len(er->ecm, 3)) < 0)
 		{ return ERROR; }
@@ -278,7 +298,7 @@
 					case 0x31:
 						if((cta_res[i + 1] == 0x02  && cta_res[i + 2] == 0x00  && cta_res[i + 3] == 0x00) || \
 								(cta_res[i + 1] == 0x02  && cta_res[i + 2] == 0x40  && cta_res[i + 3] == 0x00))
-							{ break; }
+							  	break;
 						else if(strcmp(reader->pincode, "none"))
 						{
 							conax_send_pin(reader);
@@ -333,10 +353,11 @@
 		reader->card_status = UNKNOWN;
 	}
 
-	if(rc == 3)
-		{ return OK; }
-	else
-		{ return ERROR; }
+	if (rc==3) return OK;
+	else {
+		myprintf("conax card rc=%d\n", rc);
+		return ERROR;
+	}
 }
 
 static int32_t conax_get_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
@@ -346,32 +367,27 @@
 
 	rdr_log_dbg(rdr, D_EMM, "Entered conax_get_emm_type ep->emm[2]=%02x", ep->emm[2]);
 
-	for(i = 0; i < rdr->nprov; i++)
-	{
+	for (i = 0; i < rdr->nprov; i++) {
 		ok = (!memcmp(&ep->emm[6], rdr->sa[i], 4));
-		if(ok) { break; }
+		if (ok) break;
 	}
 
-	if(ok)
-	{
+	if (ok) {
 		ep->type = SHARED;
 		memset(ep->hexserial, 0, 8);
 		memcpy(ep->hexserial, &ep->emm[6], 4);
 		rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED, ep->hexserial = {%s}", cs_hexdump(1, ep->hexserial, 8, tmp_dbg, sizeof(tmp_dbg)));
 		return 1;
 	}
-	else
-	{
-		if(!memcmp(&ep->emm[6], rdr->hexserial + 2, 4))
-		{
+	else {
+		if (!memcmp(&ep->emm[6], rdr->hexserial+2, 4)) {
 			ep->type = UNIQUE;
 			memset(ep->hexserial, 0, 8);
 			memcpy(ep->hexserial + 2, &ep->emm[6], 4);
 			rdr_log_dbg_sensitive(rdr, D_EMM, "UNIQUE, ep->hexserial = {%s}", cs_hexdump(1, ep->hexserial, 8, tmp_dbg, sizeof(tmp_dbg)));
 			return 1;
 		}
-		else
-		{
+		else {
 			ep->type = GLOBAL;
 			rdr_log_dbg(rdr, D_EMM, "GLOBAL");
 			memset(ep->hexserial, 0, 8);
@@ -382,11 +398,10 @@
 
 static int32_t conax_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count)
 {
-	if(*emm_filters == NULL)
-	{
+	if (*emm_filters == NULL) {
 		const unsigned int max_filter_count = 2 + rdr->nprov;
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+			return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
@@ -396,17 +411,16 @@
 		filters[idx].type = EMM_GLOBAL;
 		filters[idx].enabled   = 0; // FIXME: dont see any conax global EMM yet
 		filters[idx].filter[0] = 0x82;
-		filters[idx].mask[0]   = 0xFF;
+		filters[idx].mask[0]   = 0xF0;
 		filters[idx].filter[8] = 0x70;
 		filters[idx].mask[8]   = 0xFF;
 		idx++;
 
-		for(prov = 0; prov < rdr->nprov; prov++)
-		{
+		for (prov = 0; prov < rdr->nprov; prov++) {
 			filters[idx].type = EMM_SHARED;
 			filters[idx].enabled  = 1;
 			filters[idx].filter[0] = 0x82;
-			filters[idx].mask[0]   = 0xFF;
+			filters[idx].mask[0]   = 0xF0;
 			memcpy(&filters[idx].filter[4], rdr->sa[prov], 4);
 			memset(&filters[idx].mask[4], 0xFF, 4);
 			idx++;
@@ -415,7 +429,7 @@
 		filters[idx].type = EMM_UNIQUE;
 		filters[idx].enabled  = 1;
 		filters[idx].filter[0] = 0x82;
-		filters[idx].mask[0]   = 0xFF;
+		filters[idx].mask[0]   = 0xF0;
 		memcpy(&filters[idx].filter[4], rdr->hexserial + 2, 4);
 		memset(&filters[idx].mask[4], 0xFF, 4);
 		idx++;
@@ -441,9 +455,7 @@
 	buf[1] = l + 3;
 	memcpy(buf + 2, ep->emm, buf[1]);
 	write_cmd(insEMM, buf);
-
-	if(cta_res[0] == 0x98)
-	{
+	if (cta_res[0] == 0x98) {
 		insCA[4] = cta_res[1];
 		write_cmd(insCA, NULL);
 	}
@@ -451,9 +463,9 @@
 	rc = ((cta_res[0] == 0x90) && (cta_res[1] == 0x00));
 
 	if(rc)
-		{ return OK; }
+		return OK;
 	else
-		{ return ERROR; }
+		return ERROR;
 }
 
 static int32_t conax_card_info(struct s_reader *reader)
@@ -472,44 +484,40 @@
 
 	cs_clear_entitlement(reader); // reset the entitlements
 
-	for(type = 0; type < 2; type++)
-	{
+	for (type=0; type<2; type++) {
 		n = 0;
 		write_cmd(cmd[type], cmd[type] + 5);
-		while(cta_res[cta_lr - 2] == 0x98)
-		{
+		while (cta_res[cta_lr-2]==0x98) {
 			insCA[4] = cta_res[cta_lr - 1]; // get len
 			write_cmd(insCA, NULL);     // read
-			if((cta_res[cta_lr - 2] == 0x90) || (cta_res[cta_lr - 2] == 0x98))
-			{
-				for(j = 0; j < cta_lr - 2; j += cta_res[j + 1] + 2)
-				{
+			if ((cta_res[cta_lr-2]==0x90) || (cta_res[cta_lr-2]==0x98)) {
+				for (j=0; j<cta_lr-2; j+=cta_res[j+1]+2) {
 					provid = (cta_res[j + 2 + type] << 8) | cta_res[j + 3 + type];
 					chid[0] = '\0';
-					for(k = 0, i = j + 4 + type; (i < j + cta_res[j + 1]); i += cta_res[i + 1] + 2)
-					{
-						switch(cta_res[i])
-						{
+					provname[0] = '\0';
+					for (k=0, i=j+4+type; (i<j+cta_res[j+1]); i+=cta_res[i+1]+2) {
+						switch (cta_res[i]) {
 						case 0x01:
 							l = (cta_res[i + 1] < (sizeof(provname) - 1)) ? cta_res[i + 1] : sizeof(provname) - 1;
 							memcpy(provname, cta_res + i + 2, l);
 							provname[l] = '\0';
 							break;
 						case 0x30:
-							if(k > 1)
-							{
+								if (k > 1) {
 								rdr_log(reader, "%s: %d, id: %04X%s, date: %s - %s, name: %s", txt[type], ++n, provid, chid, pdate, pdate + 16, trim(provname));
 
 								// add entitlements to list
-								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type + 1, 1);
+									// sky(oscam.smartcard)
+									cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type+1, provname, 1);
 
 								k = 0;
 								chid[0] = '\0';
 							}
-							if(k == 0) { start_t = chid_date(cta_res + i + 2, pdate, 15); }
-							else { end_t = chid_date(cta_res + i + 2, pdate + 16, 15) /* add 23:59:59 here: */ + 0x1517F; }
+								if (k == 0) start_t = chid_date(cta_res+i+2, pdate, 15);
+								else end_t = chid_date(cta_res+i+2, pdate+16, 15) /* add 23:59:59 here: */ + 0x1517F;
 							++k;
 							break;
+
 						case 0x20: // Provider classes
 						case 0x90: // (?) not sure what this is, saw it once in log
 							snprintf(chid, sizeof(chid), ", classes: %02X%02X%02X%02X", cta_res[i + 2], cta_res[i + 3], cta_res[i + 4] , cta_res[i + 5]);
@@ -520,12 +528,18 @@
 					rdr_log(reader, "%s: %d, id: %04X%s, date: %s - %s, name: %s", txt[type], ++n, provid, chid, pdate, pdate + 16, trim(provname));
 
 					// add entitlements to list
-					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type + 1, 1);
+					// sky(oscam.smartcard)
+					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type+1, provname, 1);
 				}
 			}
 		}
 	}
+// sky(test)
+//	if (strcmp(reader->pincode, "none")) {
+//		conax_send_pin(reader);
+//	}
 	rdr_log(reader, "ready for requests");
+
 	return OK;
 }
 
Index: reader-cryptoworks.c
===================================================================
--- reader-cryptoworks.c	(revision 10670)
+++ reader-cryptoworks.c	(working copy)
@@ -5,12 +5,14 @@
 #include "oscam-emm.h"
 #include "reader-common.h"
 
-struct cryptoworks_data
-{
+struct cryptoworks_data {
+	uchar		algotype;
 	BIGNUM          exp;
 	BIGNUM          ucpk;
 	int32_t         ucpk_valid;
 };
+// move(renamed cw_RSA) reader_common.c
+extern int32_t rdr_RSA_decrypt(struct s_reader *reader, uint8_t *out, uint8_t *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int32_t LE);
 
 #define CMD_LEN 5
 
@@ -54,101 +56,19 @@
 	return rc;
 }
 
-static void RotateBytes1(unsigned char *out, unsigned char *in, int32_t n)
-{
-	// loop is executed atleast once, so it's not a good idea to
-	// call with n=0 !!
-	out += n;
-	do
-	{
-		*(--out) = *(in++);
-	}
-	while(--n);
-}
-
-static void RotateBytes2(unsigned char *in, int32_t n)
-{
-	// loop is executed atleast once, so it's not a good idea to
-	// call with n=0 !!
-	unsigned char *e = in + n - 1;
-	do
-	{
-		unsigned char temp = *in;
-		*in++ = *e;
-		*e-- = temp;
-	}
-	while(in < e);
-}
-
-static int32_t Input(BIGNUM *d, unsigned char *in, int32_t n, int32_t LE)
-{
-	if(LE)
-	{
-		unsigned char tmp[n];
-		RotateBytes1(tmp, in, n);
-		return (BN_bin2bn(tmp, n, d) != 0);
-	}
-	else
-		{ return (BN_bin2bn(in, n, d) != 0); }
-}
-
-static int32_t Output(struct s_reader *reader, unsigned char *out, int32_t n, BIGNUM *r, int32_t LE)
-{
-	int32_t s = BN_num_bytes(r);
-	if(s > n)
-	{
-		unsigned char buff[s];
-		rdr_log_dbg(reader, D_READER, "rsa: RSA len %d > %d, truncating", s, n);
-		BN_bn2bin(r, buff);
-		memcpy(out, buff + s - n, n);
-	}
-	else if(s < n)
-	{
-		int32_t l = n - s;
-		rdr_log_dbg(reader, D_READER, "rsa: RSA len %d < %d, padding", s, n);
-		memset(out, 0, l);
-		BN_bn2bin(r, out + l);
-	}
-	else
-		{ BN_bn2bin(r, out); }
-	if(LE)
-		{ RotateBytes2(out, n); }
-	return (s);
-}
-
-static int32_t cw_RSA(struct s_reader *reader, unsigned char *out, unsigned char *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int32_t LE)
-{
-	int32_t rc = 0;
-	BN_CTX *ctx;
-	BIGNUM *r, *d;
-	ctx = BN_CTX_new();
-	r = BN_new();
-	d = BN_new();
-	if(Input(d, in, n, LE))
-	{
-		if(BN_mod_exp(r, d, exp, mod, ctx))
-			{ rc = Output(reader, out, n, r, LE); }
-		else
-			{ rdr_log(reader, "rsa: mod-exp failed"); }
-	}
-	BN_CTX_free(ctx);
-	BN_free(d);
-	BN_free(r);
-	return (rc);
-}
-
 static time_t chid_date(uchar *ptr, char *buf, int32_t l)
 {
 	time_t rc = 0;
 	struct tm timeinfo;
 	memset(&timeinfo, 0, sizeof(struct tm));
-	if(buf)
-	{
+	if (buf) {
 		timeinfo.tm_year = 90 + (ptr[0] >> 1);
 		timeinfo.tm_mon = (((ptr[0] & 1) << 3) | (ptr[1] >> 5)) - 1;
 		timeinfo.tm_mday = ptr[1] & 0x1f;
 		rc = mktime(&timeinfo);
-		strftime(buf, l, "%Y/%m/%d", &timeinfo);
+	// sky(date)
+	//	strftime(buf, l, "%Y/%m/%d", &timeinfo);
+		strftime(buf, l, "%d/%m/%Y", &timeinfo);
 	}
 	return (rc);
 }
@@ -156,7 +76,7 @@
 
 static int32_t select_file(struct s_reader *reader, uchar f1, uchar f2, uchar *cta_res, uint16_t *p_cta_lr)
 {
-	uint16_t cta_lr;
+	uint16_t cta_lr = 0;
 	uchar insA4[] = {0xA4, 0xA4, 0x00, 0x00, 0x02, 0x00, 0x00};
 	insA4[5] = f1;
 	insA4[6] = f2;
@@ -165,20 +85,21 @@
 	return ((cta_res[0] == 0x9f) && (cta_res[1] == 0x11));
 }
 
-static int32_t read_record(struct s_reader *reader, uchar rec, uchar *cta_res)
+static int32_t read_record(struct s_reader *reader, uchar rec, uchar *cta_res, uint16_t *p_cta_lr)
 {
-	uint16_t cta_lr;
+	uint16_t cta_lr = 0;
 	uchar insA2[] = {0xA4, 0xA2, 0x00, 0x00, 0x01, 0x00};
 	uchar insB2[] = {0xA4, 0xB2, 0x00, 0x00, 0x00};
 
 	insA2[5] = rec;
 	write_cmd(insA2, insA2 + 5);  // select record
 	if(cta_res[0] != 0x9f)
-		{ return (-1); }
+		return (-1);
 	insB2[4] = cta_res[1];    // get len
 	write_cmd(insB2, NULL);   // read record
 	if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1]))
-		{ return (-1); }
+		return (-1);
+	*p_cta_lr = cta_lr;
 	return (cta_lr - 2);
 }
 
@@ -213,9 +134,11 @@
 
 		write_cmd(insPIN, insPIN + 5);
 		rdr_log(reader, "disable pincode to card");
-		if((cta_res[0] == 0x98) && (cta_res[1] == 0x04)) { rdr_log(reader, "bad pincode"); }
+		if ((cta_res[0]==0x98) && (cta_res[1]==0x04)) {
+			rdr_log(reader, "bad pincode");
 		return ERROR;
 	}
+	}
 	return OK;
 }
 
@@ -232,14 +155,14 @@
 	char issuer[20] = {0}, tmp[11];
 	char *unknown = "unknown", *pin = unknown, ptxt[CS_MAXPROV << 2] = {0};
 
-	if((atr[6] != 0xC4) || (atr[9] != 0x8F) || (atr[10] != 0xF1)) { return ERROR; }
+	if ((atr[6]!=0xC4) || (atr[9]!=0x8F) || (atr[10]!=0xF1)) return ERROR;
 
 	if(!cs_malloc(&reader->csystem_data, sizeof(struct cryptoworks_data)))
-		{ return ERROR; }
+		return ERROR;
 	struct cryptoworks_data *csystem_data = reader->csystem_data;
 
 	rdr_log(reader, "card detected");
-	rdr_log(reader, "type: CryptoWorks");
+	rdr_log(reader, "type: cryptoworks");
 
 	reader->caid = 0xD00;
 	reader->nprov = 0;
@@ -247,14 +170,14 @@
 
 	write_cmd(insA4C, NULL);      // read masterfile-ID
 	if((cta_res[0] == 0xDF) && (cta_res[1] >= 6))
-		{ mfid = (cta_res[6] << 8) | cta_res[7]; }
+		mfid = (cta_res[6]<<8)|cta_res[7];
 
 	select_file(reader, 0x3f, 0x20, cta_res, &cta_lr);
 	insB8[2] = insB8[3] = 0;  // first
 	for(cta_res[0] = 0xdf; cta_res[0] == 0xdf;)
 	{
 		write_cmd(insB8, NULL);     // read provider id's
-		if(cta_res[0] != 0xdf) { break; }
+		if (cta_res[0]!=0xdf) break;
 		if(((cta_res[4] & 0x1f) == 0x1f) && (reader->nprov < CS_MAXPROV))
 		{
 			snprintf(ptxt + strlen(ptxt), sizeof(ptxt) - strlen(ptxt), ",%02X", cta_res[5]);
@@ -263,18 +186,49 @@
 		insB8[2] = insB8[3] = 0xff; // next
 	}
 	for(i = reader->nprov; i < CS_MAXPROV; i++)
-		{ memset(&reader->prid[i][0], 0xff, 4); }
+		memset(&reader->prid[i][0], 0xff, 4);
 
 	select_file(reader, 0x2f, 0x01, cta_res, &cta_lr);        // read caid
-	if(read_record(reader, 0xD1, cta_res) >= 4)
-		{ reader->caid = (cta_res[2] << 8) | cta_res[3]; }
-
-	if(read_record(reader, 0x80, cta_res) >= 7)       // read serial
-		{ memcpy(reader->hexserial, cta_res + 2, 5); }
-	rdr_log_sensitive(reader, "type: CryptoWorks, caid: %04X, ascii serial: {%llu}, hex serial: {%s}",
-					  reader->caid, (unsigned long long) b2ll(5, reader->hexserial), cs_hexdump(0, reader->hexserial, 5, tmp, sizeof(tmp)));
+	if (read_record(reader, 0xD1, cta_res, &cta_lr)>=4) {
+		reader->caid = (cta_res[2]<<8)|cta_res[3];
+	// sky(?)
+	//	for (i=2;i<cta_lr;i+=2) {
+	//		myrdr_log(reader, "card_cryptoworks_caid:%04X\n", (cta_res[i]<<8)|cta_res[i+1]);
+	//	}
+	}
+	// sky(n)
+	if (read_record(reader, 0xC3, cta_res, &cta_lr)>=4) {
+		for (i=2;i<cta_lr-2;i++) {
+			/* adds last 5 bytes together, if not FF */
+			if (cta_res[i] != 0xff) csystem_data->algotype |= cta_res[i];
+		}
+		csystem_data->algotype |= 0x80;
+	}
+
+	if (read_record(reader, 0x80, cta_res, &cta_lr)>=7) // read serial
+		memcpy(reader->hexserial, cta_res+2, 5);
+
+//	myascdump("cryptowork hexserial", cta_res, cta_lr);
+	// sky(oscam.smartcard)
+	{
+		uint64_t  ulserial;
+		ulserial  = (uint64_t)b2i(4, reader->hexserial) * 256;
+		ulserial += (uint64_t)reader->hexserial[4];
+		sprintf(reader->ascserial, "%d.%d.%d.%d",
+						(uint32_t)(ulserial / 100000000) / 10000,
+						(uint32_t)(ulserial / 100000000) % 10000,
+						(uint32_t)(ulserial / 10000) % 10000,
+						(uint32_t)(ulserial % 10000));
+	//	sprintf(reader->ascserial, "%llu", b2ll(5, reader->hexserial));
+	}
+
+	rdr_log_sensitive(reader, "type: cryptoworks, caid: %04X, ascii serial: {%llu}, hex serial: {%s}",
+	        reader->caid,
+	        (unsigned long long) b2ll(5, reader->hexserial),
+	        cs_hexdump(0, reader->hexserial, 5, tmp, sizeof(tmp)));
+	myrdr_log(reader, "algo: %02X", csystem_data->algotype);
 
-	if(read_record(reader, 0x9E, cta_res) >= 66)  // read ISK
+	if (read_record(reader, 0x9E, cta_res, &cta_lr) >= 66)	// read ISK
 	{
 		uchar keybuf[256];
 		BIGNUM *ipk;
@@ -283,7 +237,7 @@
 			ipk = BN_new();
 			BN_bin2bn(cwexp, sizeof(cwexp), &csystem_data->exp);
 			BN_bin2bn(keybuf, 64, ipk);
-			cw_RSA(reader, cta_res + 2, cta_res + 2, 0x40, &csystem_data->exp, ipk, 0);
+			rdr_RSA_decrypt(reader, cta_res+2, cta_res+2, 0x40, &csystem_data->exp, ipk, 0);
 			BN_free(ipk);
 			csystem_data->ucpk_valid = (cta_res[2] == ((mfid & 0xFF) >> 1));
 			if(csystem_data->ucpk_valid)
@@ -300,24 +254,33 @@
 					BN_bin2bn(keybuf, 0x40, &csystem_data->ucpk);
 					rdr_log_dump_dbg(reader, D_READER, keybuf, 0x40, "session-key found:");
 				}
-				else
-					{ rdr_log(reader, "invalid IPK or session-key for CAID %04X !", reader->caid); }
+				else {
+				  	rdr_log(reader, "invalid IPK or session-key for CAID %04X !", reader->caid);
 			}
 		}
 	}
-	if(read_record(reader, 0x9F, cta_res) >= 3)
-		{ issuerid = cta_res[2]; }
-	if(read_record(reader, 0xC0, cta_res) >= 16)
+	}
+
+	if (read_record(reader, 0x9F, cta_res, &cta_lr)>=3) issuerid = cta_res[2];
+	if (read_record(reader, 0xC0, cta_res, &cta_lr)>=16)
 	{
 		cs_strncpy(issuer, (const char *)cta_res + 2, sizeof(issuer));
 		trim(issuer);
 	}
-	else
-		{ cs_strncpy(issuer, unknown, sizeof(issuer)); }
+	else {
+		cs_strncpy(issuer, unknown, sizeof(issuer));
+	}
+	// sky(oscam.smartcard)
+	select_file(reader, 0x3f, 0x20, cta_res, &cta_lr);
+	select_file(reader, 0x2f, 0x03, cta_res, &cta_lr);	// read maturity
+	if (read_record(reader, 0xC0, cta_res, &cta_lr)>=3)
+	{
+		reader->maturity = cta_res[2];
+	}
 
 	select_file(reader, 0x3f, 0x20, cta_res, &cta_lr);
 	select_file(reader, 0x2f, 0x11, cta_res, &cta_lr);        // read pin
-	if(read_record(reader, atr[8], cta_res) >= 7)
+	if (read_record(reader, atr[8], cta_res, &cta_lr)>=7)
 	{
 		cta_res[6] = 0;
 		pin = (char *)cta_res + 2;
@@ -352,7 +315,7 @@
 			nanoD4[0] = 0xD4;
 			nanoD4[1] = 0x08;
 			for(i = 2; i < (int)sizeof(nanoD4); i++)
-				{ nanoD4[i] = rand(); }
+				nanoD4[i]=rand();
 			memcpy(&buff[secLen], nanoD4, sizeof(nanoD4));
 			ecm = buff;
 			secLen += sizeof(nanoD4);
@@ -375,8 +338,7 @@
 					break;
 				case 0xD4:
 					rdr_log_dbg(reader, D_READER, "nano D4 (rand)");
-					if(n < 8 || memcmp(&cta_res[i], nanoD4, sizeof(nanoD4)))
-					{
+						if (n<8 || memcmp(&cta_res[i],nanoD4,sizeof(nanoD4))) {
 						rdr_log_dbg(reader, D_READER, "random data check failed after decrypt");
 					}
 					break;
@@ -393,13 +355,13 @@
 					if(n == 0x08)
 					{
 						if((cta_res[i + 2] & 0x50) == 0x50 && !(cta_res[i + 3] & 0x01) && (cta_res[i + 5] & 0x80))
-							{ r |= 2; }
+								r|=2;
 					}
 					else if(n == 0x40)  // camcrypt
 					{
 						if(csystem_data->ucpk_valid)
 						{
-							cw_RSA(reader, &cta_res[i + 2], &cta_res[i + 2], n, &csystem_data->exp, &csystem_data->ucpk, 0);
+								rdr_RSA_decrypt(reader, &cta_res[i+2],&cta_res[i+2], n, &csystem_data->exp, &csystem_data->ucpk, 0);
 							rdr_log_dbg(reader, D_READER, "after camcrypt");
 							r = 0;
 							secLen = n - 4;
@@ -445,13 +407,11 @@
 	uint32_t provid = 0;
 	int32_t i = 0;
 
-	for(i = 0; i < len;)
-	{
-		switch(buffer[i])
-		{
+	for (i=0; i<len;) {
+		switch (buffer[i]) {
 		case 0x83:
 			provid = buffer[i + 2] & 0xfc;
-			return provid;
+				return (provid);
 			break;
 		default:
 			i += buffer[i + 1] + 2;
@@ -459,7 +419,7 @@
 		}
 
 	}
-	return provid;
+	return (provid);
 }
 
 static int32_t cryptoworks_get_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
@@ -467,23 +427,28 @@
 	char dumprdrserial[16], dumpemmserial[16];
 
 	rdr_log_dbg(rdr, D_EMM, "Entered cryptoworks_get_emm_type ep->emm[0]=%02x", ep->emm[0]);
-	switch(ep->emm[0])
-	{
+	switch (ep->emm[0]) {
 	case 0x82:
-		if(ep->emm[3] == 0xA9 && ep->emm[4] == 0xFF && ep->emm[13] == 0x80 && ep->emm[14] == 0x05)
+			if (ep->emm[3]==0xA9 && ep->emm[4]==0xFF
+				 && (ep->emm[13]==0x80 && ep->emm[14]==0x05))
 		{
 			ep->type = UNIQUE;
 			memset(ep->hexserial, 0, 8);
 			memcpy(ep->hexserial, ep->emm + 5, 5);
 			cs_hexdump(1, rdr->hexserial, 5, dumprdrserial, sizeof(dumprdrserial));
 			cs_hexdump(1, ep->hexserial, 5, dumpemmserial, sizeof(dumpemmserial));
-			i2b_buf(4, cryptoworks_get_emm_provid(ep->emm + 12, ep->emmlen - 12), ep->provid);
-			rdr_log_dbg_sensitive(rdr, D_EMM, "UNIQUE, ep = {%s} rdr = {%s}", dumpemmserial, dumprdrserial);
+				i2b_buf(4, cryptoworks_get_emm_provid(ep->emm+13, ep->emmlen-13), ep->provid);
+				rdr_log_dbg_sensitive(rdr, D_EMM, "UNIQUE, ep = {%s}{%02x} rdr = {%s}",
+						dumpemmserial, b2i(4,ep->provid), dumprdrserial);
 			return (!memcmp(ep->emm + 5, rdr->hexserial, 5)); // check for serial
 		}
+			else {
+				myrdr_debug(rdr, D_EMM, "UNIQUE invalid");
+			}
 		break;
 	case 0x84:
-		if(ep->emm[3] == 0xA9 && ep->emm[4] == 0xFF && ep->emm[12] == 0x80 && ep->emm[13] == 0x04)
+			if (ep->emm[3]==0xA9 && ep->emm[4]==0xFF
+				 && (ep->emm[12]==0x80 && ep->emm[13]==0x04))
 		{
 			ep->type = SHARED;
 			memset(ep->hexserial, 0, 8);
@@ -491,38 +456,49 @@
 			cs_hexdump(1, rdr->hexserial, 4, dumprdrserial, sizeof(dumprdrserial));
 			cs_hexdump(1, ep->hexserial, 4, dumpemmserial, sizeof(dumpemmserial));
 			i2b_buf(4, cryptoworks_get_emm_provid(ep->emm + 12, ep->emmlen - 12), ep->provid);
-			rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED, ep = {%s} rdr = {%s}", dumpemmserial, dumprdrserial);
+				rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED, ep = {%s}{%02x} rdr = {%s}",
+						dumpemmserial, b2i(4,ep->provid), dumprdrserial);
 			return (!memcmp(ep->emm + 5, rdr->hexserial, 4)); // check for SA
 		}
+			else {
+				myrdr_debug(rdr, D_EMM, "SHARED84 invalid");
+			}
 		break;
 	case 0x86:
-		if(ep->emm[3] == 0xA9 && ep->emm[4] == 0xFF && ep->emm[5] == 0x83
-				&& ep->emm[6] == 0x01 && (ep->emm[8] == 0x85 || ep->emm[8] == 0x84 || ep->emm[8] == 0x8C))
+			if (ep->emm[3]==0xA9 && ep->emm[4]==0xFF
+				 && (ep->emm[5]==0x83 && ep->emm[6]==0x01)
+				 && (ep->emm[8]==0x85 || ep->emm[8]==0x84 || ep->emm[8]==0x8C))
 		{
 			rdr_log_dbg(rdr, D_EMM, "SHARED (Header)");
 			ep->type = SHARED;
-			i2b_buf(4, cryptoworks_get_emm_provid(ep->emm + 8, ep->emmlen - 8), ep->provid);
+				i2b_buf(4, cryptoworks_get_emm_provid(ep->emm+5, ep->emmlen-5), ep->provid);
 			// We need those packets to pass otherwise we would never
 			// be able to complete EMM reassembly
 			return 1;
 		}
+			else {
+				myrdr_debug(rdr, D_EMM, "SHARED86 invalid");
+			}
 		break;
 	case 0x88:
 	case 0x89:
-		if(ep->emm[3] == 0xA9 && ep->emm[4] == 0xFF && ep->emm[8] == 0x83 && ep->emm[9] == 0x01)
+			if (ep->emm[3]==0xA9 && ep->emm[4]==0xFF
+				&& (ep->emm[8]==0x83 && ep->emm[9]==0x01))
 		{
 			rdr_log_dbg(rdr, D_EMM, "GLOBAL");
 			ep->type = GLOBAL;
 			i2b_buf(4, cryptoworks_get_emm_provid(ep->emm + 8, ep->emmlen - 8), ep->provid);
 			return 1;
 		}
+			else {
+				myrdr_debug(rdr, D_EMM, "GLOBAL invalid");
+			}
 		break;
 	case 0x8F:
 		ep->type = UNKNOWN;
 		rdr_log_dbg(rdr, D_EMM, "0x8F via camd3");
 
-		switch(ep->emm[4])
-		{
+			switch (ep->emm[4]) {
 		case 0x44:
 			i2b_buf(4, cryptoworks_get_emm_provid(ep->emm + 8, ep->emmlen - 8), ep->provid);
 			ep->type = GLOBAL;
@@ -545,7 +521,7 @@
 		return 0; // skip emm
 	}
 
-	rdr_log_dbg(rdr, D_EMM, "invalid");
+	myrdr_debug(rdr, D_EMM, "invalid");
 	return 0;
 }
 
@@ -555,21 +531,23 @@
 	{
 		const unsigned int max_filter_count = 4;
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+		  	return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
 
 		int32_t idx = 0;
 
-		filters[idx].type = EMM_GLOBAL;
+		filters[idx].type = EMM_UNIQUE;
 		filters[idx].enabled   = 1;
-		filters[idx].filter[0] = 0x88;
-		filters[idx].mask[0]   = 0xFE;
+		filters[idx].filter[0] = 0x82;
+		filters[idx].mask  [0] = 0xFF;
 		filters[idx].filter[1] = 0xA9;
 		filters[idx].mask[1]   = 0xFF;
 		filters[idx].filter[2] = 0xFF;
 		filters[idx].mask[2]   = 0xFF;
+		memcpy(&filters[idx].filter[3], rdr->hexserial, 5);
+		memset(&filters[idx].mask  [3], 0xFF, 5);
 		idx++;
 
 		filters[idx].type = EMM_SHARED;
@@ -594,16 +572,14 @@
 		memset(&filters[idx].mask[3], 0xFF, 4);
 		idx++;
 
-		filters[idx].type = EMM_UNIQUE;
+		filters[idx].type = EMM_GLOBAL;
 		filters[idx].enabled   = 1;
-		filters[idx].filter[0] = 0x82;
-		filters[idx].mask[0]   = 0xFF;
+		filters[idx].filter[0] = 0x88;
+		filters[idx].mask  [0] = 0xFE;
 		filters[idx].filter[1] = 0xA9;
 		filters[idx].mask[1]   = 0xFF;
 		filters[idx].filter[2] = 0xFF;
 		filters[idx].mask[2]   = 0xFF;
-		memcpy(&filters[idx].filter[3], rdr->hexserial, 5);
-		memset(&filters[idx].mask[3], 0xFF, 5);
 		idx++;
 
 		*filter_count = idx;
@@ -615,12 +591,13 @@
 static int32_t cryptoworks_do_emm(struct s_reader *reader, EMM_PACKET *ep)
 {
 	def_resp;
+	uchar insEMM_UA[] = {0xA4, 0x42, 0x00, 0x00, 0x00};
 	uchar insEMM_GA[] = {0xA4, 0x44, 0x00, 0x00, 0x00};
 	uchar insEMM_SA[] = {0xA4, 0x48, 0x00, 0x00, 0x00};
-	uchar insEMM_UA[] = {0xA4, 0x42, 0x00, 0x00, 0x00};
 	int32_t rc = 0;
 	uchar *emm = ep->emm;
 
+	myprdump("@@@ cryptoworks_do_emm", emm, ep->emmlen);
 	if(emm[0] == 0x8f && emm[3] == 0xA4)
 	{
 		//camd3 emm
@@ -629,43 +606,49 @@
 		return (rc);
 	}
 
-	switch(ep->type)
-	{
+	switch (ep->type) {
 		//GA
 	case GLOBAL:
 		insEMM_GA[4] = ep->emm[2] - 2;
-		if(emm[7] == insEMM_GA[4] - 3)
-		{
+			if (emm[ 7]==insEMM_GA[4]-3) {
 			write_cmd(insEMM_GA, emm + 5);
 			rc = ((cta_res[0] == 0x90) && (cta_res[1] == 0x00));
 		}
+			else {
+				myrdr_debug(reader, D_EMM, "global emm(%x!=%x)", emm[7], insEMM_GA[4]-3);
+			}
 		break;
 
 		//SA
 	case SHARED:
 		insEMM_SA[4] = ep->emm[2] - 6;
-		if(emm[11] == insEMM_SA[4] - 3)
-		{
+			if (emm[11]==insEMM_SA[4]-3) {
 			write_cmd(insEMM_SA, emm + 9);
 			rc = ((cta_res[0] == 0x90) && (cta_res[1] == 0x00));
 		}
+			else {
+				myrdr_debug(reader, D_EMM, "shared emm(%x!=%x)", emm[11], insEMM_SA[4]-3);
+			}
 		break;
 
 		//UA
 	case UNIQUE:
 		insEMM_UA[4] = ep->emm[2] - 7;
-		if(emm[12] == insEMM_UA[4] - 3)
-		{
+			if (emm[12]==insEMM_UA[4]-3)	{
 			//cryptoworks_send_pin(); //?? may be
 			write_cmd(insEMM_UA, emm + 10);
 			rc = ((cta_res[0] == 0x90) && (cta_res[1] == 0x00));
 		}
+			else {
+				myrdr_debug(reader, D_EMM, "unique emm(%x!=%x)", emm[12], insEMM_UA[4]-3);
+			}
 		break;
 	}
 
-	if(!rc)
-		{ rdr_log_dbg(reader, D_EMM, "%s(): type %d - %02X %02X", __func__, ep->type, cta_res[0], cta_res[1]); }
-
+	if (!rc) {
+		rdr_log_dbg(reader, D_EMM, "%s(): type %d - %02X %02X", __func__, ep->type, cta_res[0], cta_res[1]);
+	}
+	myprintf("[cryptoworks]type %d:%02X%02X\n", ep->type, cta_res[0], cta_res[1]);
 	return (rc);
 }
 
@@ -684,7 +667,7 @@
 		l_name[8] = 0;
 		select_file(reader, 0x1f, reader->prid[i][3], cta_res, &cta_lr);    // select provider
 		select_file(reader, 0x0e, 0x11, cta_res, &cta_lr);      // read provider name
-		if(read_record(reader, 0xD6, cta_res) >= 16)
+		if (read_record(reader, 0xD6, cta_res, &cta_lr)>=16)
 		{
 			cs_strncpy(l_name + 8, (const char *)cta_res + 2, sizeof(l_name) - 9);
 			l_name[sizeof(l_name) - 1] = 0;
@@ -705,9 +689,10 @@
 					char ds[16], de[16];
 
 					// todo: add entitlements to list but produces a warning related to date variable
-					cs_add_entitlement(reader, reader->caid, reader->prid[i][3], b2i(2, cta_res + 6), 0,
+               // sky(!)
+					cs_add_entitlement(reader, reader->caid, reader->prid[i][3], b2i(2, cta_res + 7), 0,
 									   chid_date(cta_res + 28, ds, sizeof(ds) - 1),
-									   chid_date(cta_res + 30, de, sizeof(de) - 1), 3, 1);
+							chid_date(cta_res+30, de, sizeof(de)-1), 3, NULL, 1);
 
 					rdr_log(reader, "chid: %02X%02X, date: %s - %s, name: %s",
 							cta_res[6], cta_res[7], ds, de, trim((char *) cta_res + 10));
@@ -730,7 +715,7 @@
 					// todo: add entitlements to list but produces a warning related to date variable
 					cs_add_entitlement(reader, reader->caid, reader->prid[i][3], b2i(2, cta_res + 6), 0,
 									   chid_date(cta_res + 28, ds, sizeof(ds) - 1),
-									   chid_date(cta_res + 30, de, sizeof(de) - 1), 3, 1);
+							chid_date(cta_res+30, de, sizeof(de)-1), 3, NULL, 1);
 
 					cta_res[27] = 0;
 					rdr_log(reader, "chid: %02X%02X, date: %s - %s, name: %s",
@@ -755,7 +740,7 @@
 	//   with table id 0x84 has to be build containing all nano commands from both the
 	//    original EMM-SH and EMM-SB in ascending order.
 	//
-	if(*len > 500) { return 0; }
+	if (*len > 500) return 0;
 
 	if (!client->cw_rass && !cs_malloc(&client->cw_rass, sizeof(*client->cw_rass)))
 	{
@@ -768,28 +753,30 @@
 	{
 	case 0x82 : // emm-u
 		rdr_log_dbg(rdr, D_EMM, "unique emm (EMM-U)");
+			myprintf("[cryptoworks]unique emm (EMM-U)\n");
 		break;
 
 	case 0x84: // emm-sh
 		rdr_log_dbg(rdr, D_EMM, "shared emm (EMM-SH)");
-		if(!memcmp(r_emm->emm, buffer, *len))
-			{ return 0; }
-
-		if(ep->emm[11] == ep->emm[2] - 9)
-		{
+			if (ep->emm[11]==ep->emm[2]-9) {
 			rdr_log_dbg(rdr, D_EMM, "received assembled EMM-S");
+				myprintf("[cryptoworks]received assembled EMM-S\n");
 			return 1;
 		}
+			if (!memcmp(r_emm->emm, buffer, *len)) {
+				myprintf("[cryptoworks]received same EMM-S\n");
+				return 0;
+			}
 
 		memcpy(r_emm->emm, buffer, *len);
 		r_emm->emmlen = *len;
 		rdr_log_dbg(rdr, D_EMM, "EMM-SH only in memcpy");
+			myprintf("[cryptoworks]re-assembled EMM-SH\n");
 		return 0;
 
 	case 0x86: // emm-sb
 		rdr_log_dbg(rdr, D_EMM, "shared emm (EMM-SB)");
-		if(!r_emm->emmlen)
-			{ return 0; }
+			if (!r_emm->emmlen) return 0;
 
 		// we keep the first 12 bytes of the 0x84 emm (EMM-SH)
 		// now we need to append the payload of the 0x86 emm (EMM-SB)
@@ -803,18 +790,15 @@
 
 		emm_len = *len - 5 + r_emm->emmlen - 12;
 		unsigned char *tmp, *assembled;
-		if(!cs_malloc(&tmp, emm_len))
-			{ return 0; }
-		if(!cs_malloc(&assembled, emm_len + 12))
-		{
-			free(tmp);
+			if (!cs_malloc(&tmp, emm_len)) return 0;
+			if (!cs_malloc(&assembled, emm_len + 12)) {
+				NULLFREE(tmp);
 			return 0;
 		}
 		unsigned char *assembled_EMM;
-		if(!cs_malloc(&assembled_EMM, emm_len + 12))
-		{
-			free(assembled);
-			free(tmp);
+			if (!cs_malloc(&assembled_EMM, emm_len + 12)) {
+				NULLFREE(assembled);
+				NULLFREE(tmp);
 			return 0;
 		}
 		memcpy(tmp, &buffer[5], *len - 5);
@@ -837,13 +821,13 @@
 		memcpy(buffer, assembled_EMM, emm_len + 12);
 		*len = emm_len + 12;
 
-		free(tmp);
-		free(assembled);
+			NULLFREE(tmp);
+			NULLFREE(assembled);
 
 		r_emm->emmlen = 0;
 
 		rdr_log_dump_dbg(rdr, D_EMM, buffer, *len, "shared emm (assembled):");
-		free(assembled_EMM);
+        	NULLFREE(assembled_EMM);
 		break;
 
 	case 0x88: // emm-g
Index: reader-dgcrypt.c
===================================================================
--- reader-dgcrypt.c	(revision 10670)
+++ reader-dgcrypt.c	(working copy)
@@ -12,8 +12,7 @@
 //static const uint8_t cmd_SUBSYS[5]  = { 0x81, 0xDD, 0x00, 0x10, 0x04 };
 static const uint8_t cmd_ECM[3]     = { 0x80, 0xEA, 0x80 };
 
-struct dgcrypt_data
-{
+struct dgcrypt_data {
 	uint8_t         session_key[16];
 };
 
@@ -21,30 +20,25 @@
 {
 	rdr->ifsc = 195;
 	rdr->ns   = 1;
-	if(DEBUG)
-	{
+	if (DEBUG) {
 		char tmp[512];
 		rdr_log(rdr, "SEND -> %s(%d)", cs_hexdump(1, buf, buflen, tmp, sizeof(tmp)), buflen);
 	}
 	int32_t ret = reader_cmd2icc(rdr, buf, buflen, response, response_length);
-	if(DEBUG)
-	{
+	if (DEBUG) {
 		char tmp[512];
 		rdr_log(rdr, "RECV <- %s(%d) ret=%d", cs_hexdump(1, response, *response_length, tmp, sizeof(tmp)), *response_length, ret);
 	}
 	// reader_cmd2icc retuns ERROR=1, OK=0 - the opposite of OK and ERROR defines in reader-common.h
-	if(ret)
-	{
+	if (ret) {
 		rdr_log(rdr, "ERROR: reader_cmd2icc() ret=%d", ret);
 		return ERROR;
 	}
-	if(*response_length < 2 || *response_length < min_response_len)
-	{
+	if (*response_length < 2 || *response_length < min_response_len) {
 		rdr_log(rdr, "ERROR: response_length=%d < min_response_length=%d", *response_length, min_response_len);
 		return ERROR; // Response is two short
 	}
-	if(response[*response_length - 2] != 0x90 || response[*response_length - 1] != 0x00)
-	{
+	if (response[*response_length - 2] != 0x90 || response[*response_length - 1] != 0x00) {
 		rdr_log(rdr, "ERROR: response[-2] != 0x90 its 0x%02X", response[*response_length - 2]);
 		rdr_log(rdr, "ERROR: response[-1] != 0x00 its 0x%02X", response[*response_length - 1]);
 		return ERROR; // The reader responded with "command not OK"
@@ -58,14 +52,14 @@
 
 	get_atr
 	if(atr_size < sizeof(dgcrypt_atr))
-		{ return ERROR; }
+		return ERROR;
 
 	// Full ATR: 3B E9 00 00 81 31 C3 45 99 63 74 69 19 99 12 56 10 EC
 	if(memcmp(atr, dgcrypt_atr, sizeof(dgcrypt_atr)) != 0)
-		{ return ERROR; }
+		return ERROR;
 
 	if(!cs_malloc(&rdr->csystem_data, sizeof(struct dgcrypt_data)))
-		{ return ERROR; }
+		return ERROR;
 	struct dgcrypt_data *csystem_data = rdr->csystem_data;
 
 	rdr_log(rdr, "[dgcrypt-reader] card detected.");
@@ -81,7 +75,7 @@
 	//   Send: 81 D0 00 01 08
 	//   Recv: 32 86 17 D5 2C 66 61 14 90 00
 	if(!dgcrypt_cmd(rdr, cmd_CWKEY, sizeof(cmd_CWKEY), cta_res, &cta_lr, 8))
-		{ return ERROR; }
+		return ERROR;
 	memcpy(csystem_data->session_key + 0, cta_res, 8);
 	memcpy(csystem_data->session_key + 8, cta_res, 8);
 
@@ -96,7 +90,7 @@
 	//   Send: 81 D1 00 01 10
 	//   Recv: 00 0D DB 08 71 0D D5 0C 30 30 30 30 30 30 30 30 90 00
 	if(!dgcrypt_cmd(rdr, cmd_SERIAL, sizeof(cmd_SERIAL), cta_res, &cta_lr, 8))
-		{ return ERROR; }
+		return ERROR;
 	memcpy(rdr->hexserial, cta_res + 1, 7);
 
 	// Get LABEL
@@ -104,7 +98,7 @@
 	//   Recv: 50 61 79 5F 54 56 5F 43 61 72 64 00 00 00 00 00 90 00
 	//    Txt: P  a  y  _  T  V  _  C  a  r  d
 	if(!dgcrypt_cmd(rdr, cmd_LABEL, sizeof(cmd_LABEL), cta_res, &cta_lr, 16))
-		{ return ERROR; }
+		return ERROR;
 	char label[17];
 	memset(label, 0, sizeof(label));
 	memcpy(label, cta_res, 16);
@@ -113,8 +107,10 @@
 	//   Send: 81 DD 00 10 04
 	//   Recv: 00 55 00 55 90 00
 	if(!dgcrypt_cmd(rdr, cmd_LABEL, sizeof(cmd_LABEL), cta_res, &cta_lr, 4))
-		{ return ERROR; }
+		return ERROR;
 
+	// sky(oscam.smartcard)
+	sprintf(rdr->ascserial, "%"PRIu64"", b2ll(7, rdr->hexserial));
 	rdr_log_sensitive(rdr, "CAID: 0x%04X, Serial: {%"PRIu64"} HexSerial: {%02X %02X %02X %02X %02X %02X %02X} Label: {%s}",
 					  rdr->caid,
 					  b2ll(7, rdr->hexserial),
@@ -139,13 +135,12 @@
 	//   Send: 80 EA 80 00 55 00 00 3F 90 03 00 00 18 5D 82 4E 01 C4 2D 60 12 ED 34 37 ED 72 .. .. ..
 	//   Recv: 72 25 8D A1 0D 0D D2 44 EE ED 51 2F 3B 5D 19 63 E6 90 00
 	if(!dgcrypt_cmd(rdr, cmd_buffer, er->ecm[2] + 3, cta_res, &cta_lr, 17))
-		{ return ERROR; }
+		return ERROR;
 	if(cta_res[0] != 0x72)  // CW response MUST start with 0x72
-		{ return ERROR; }
+		return ERROR;
 
 	int i;
-	for(i = 0; i < 16; i++)
-	{
+	for (i = 0; i < 16; i++) {
 		ea->cw[i] = cta_res[1 + i] ^ csystem_data->session_key[i];
 	}
 	return OK;
Index: reader-dre.c
===================================================================
--- reader-dre.c	(revision 10670)
+++ reader-dre.c	(working copy)
@@ -2,45 +2,53 @@
 #ifdef READER_DRE
 #include "cscrypt/des.h"
 #include "reader-common.h"
+#include "oscam-string.h"
 
-struct dre_data
-{
+struct dre_data {
+	uint8_t	version;
+	uint8_t	prcode;
 	uint8_t     provider;
 };
 
 #define OK_RESPONSE 0x61
 #define CMD_BYTE 0x59
 
-static uchar xor(const uchar *cmd, int32_t cmdlen)
+static uchar dre_xor(const uchar *cmd, int32_t cmdlen)
 {
 	int32_t i;
 	uchar checksum = 0x00;
 	for(i = 0; i < cmdlen; i++)
-		{ checksum ^= cmd[i]; }
+		checksum ^= cmd[i];
 	return checksum;
 }
-
-static int32_t dre_command(struct s_reader *reader, const uchar *cmd, int32_t cmdlen, unsigned char *cta_res, uint16_t *p_cta_lr)       //attention: inputcommand will be changed!!!! answer will be in cta_res, length cta_lr ; returning 1 = no error, return ERROR = err
+// attention: inputcommand will be changed!!!! answer will be in cta_res, length cta_lr ; returning 1 = no error, return ERROR = err
+static int32_t dre_transmission(struct s_reader *reader, const uchar *cmd, int32_t cmdlen, unsigned char *cta_res, uint16_t *p_cta_lr, unsigned char *startcmd)
 {
-	uchar startcmd[] = { 0x80, 0xFF, 0x10, 0x01, 0x05 };  //any command starts with this,
+	uchar starthdrs[5];
+//	uchar startcmd [] = { 0x80,0xFF,0x10,0x01,0x05 };	// any command starts with this,
+//	uchar startcmd3[] = { 0x80,0xFF,0x01,0x01,0x05 };
+	// 80 00 00 00 05/80 00 01 01 05
 	//last byte is nr of bytes of the command that will be sent
 	//after the startcmd
 	//response on startcmd+cmd:     = { 0x61, 0x05 }  //0x61 = "OK", last byte is nr. of bytes card will send
-	uchar reqans[] = { 0x00, 0xC0, 0x00, 0x00, 0x08 };    //after command answer has to be requested,
+	uchar reqanswer[] = { 0x00,0xC0,0x00,0x00,0x08 };	// after command answer has to be requested,
 	//last byte must be nr. of bytes that card has reported to send
 	uchar command[256];
 	char tmp[256];
-	int32_t headerlen = sizeof(startcmd);
-	startcmd[4] = cmdlen + 3; //commandlength + type + len + checksum bytes
-	memcpy(command, startcmd, headerlen);
+	int32_t headerlen = sizeof(starthdrs);
+
+	memcpy(starthdrs, startcmd, headerlen);
+	starthdrs[4] = cmdlen + 3;	//commandlength + type + len + checksum bytes
+	memcpy(command, starthdrs, headerlen);
 	command[headerlen++] = CMD_BYTE;  //type
 	command[headerlen++] = cmdlen + 1;    //len = command + 1 checksum byte
 	memcpy(command + headerlen, cmd, cmdlen);
 
-	uchar checksum = ~xor(cmd, cmdlen);
+	uchar checksum = ~(dre_xor(cmd, cmdlen));
 	//rdr_log_dbg(reader, D_READER, "Checksum: %02x", checksum);
 	cmdlen += headerlen;
 	command[cmdlen++] = checksum;
+	myprdump("drecommand", (void *)command, cmdlen);
 
 	reader_cmd2icc(reader, command, cmdlen, cta_res, p_cta_lr);
 
@@ -51,44 +59,47 @@
 		return ERROR;           //error
 	}
 
-	reqans[4] = cta_res[1];   //adapt length byte
-	reader_cmd2icc(reader, reqans, 5, cta_res, p_cta_lr);
+	reqanswer[4] = cta_res[1];	//adapt length byte
+	myprdump("reqanswer", (void *)reqanswer, 5);
+	reader_cmd2icc(reader, reqanswer, 5, cta_res, p_cta_lr);
 
-	if(cta_res[0] != CMD_BYTE)
-	{
+	if (cta_res[0] != CMD_BYTE) {
 		rdr_log(reader, "unknown response: cta_res[0] expected to be %02x, is %02x", CMD_BYTE, cta_res[0]);
 		return ERROR;
 	}
 	if((cta_res[1] == 0x03) && (cta_res[2] == 0xe2))
 	{
-		switch(cta_res[3])
-		{
+		switch (cta_res[3]) {
 		case 0xe1:
 			rdr_log(reader, "checksum error: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
+				myprintf("checksum error: %s.",  cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
 			break;
 		case 0xe2:
 			rdr_log(reader, "wrong provider: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
+				myprintf("wrong provider: %s.",  cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
 			break;
 		case 0xe3:
 			rdr_log(reader, "illegal command: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
+				myprintf("illegal command: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
 			break;
 		case 0xec:
 			rdr_log(reader, "wrong signature: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
+				myprintf("wrong signature: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
 			break;
 		default:
 			rdr_log_dbg(reader, D_READER, "unknown error: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
+				myrdr_debug(reader, D_READER, "unknown error: %s.", cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
 			break;
 		}
 		return ERROR;           //error
 	}
 	int32_t length_excl_leader = *p_cta_lr;
 	if((cta_res[*p_cta_lr - 2] == 0x90) && (cta_res[*p_cta_lr - 1] == 0x00))
-		{ length_excl_leader -= 2; }
+		length_excl_leader -= 2;
 
-	checksum = ~xor(cta_res + 2, length_excl_leader - 3);
+	checksum = ~(dre_xor(cta_res + 2, length_excl_leader - 3));
 
-	if(cta_res[length_excl_leader - 1] != checksum)
-	{
+	if (cta_res[length_excl_leader - 1] != checksum) {
 		rdr_log(reader, "checksum does not match, expected %02x received %02x:%s", checksum,
 				cta_res[length_excl_leader - 1], cs_hexdump(0, cta_res, *p_cta_lr, tmp, sizeof(tmp)));
 		return ERROR;           //error
@@ -98,21 +109,36 @@
 
 #define dre_cmd(cmd) \
     { \
-        dre_command(reader, cmd, sizeof(cmd),cta_res,&cta_lr); \
+	uchar startcmd1[] = { 0x80,0xFF,0x10,0x01,0x05 }; \
+	uchar startcmd3[] = { 0x80,0x00,0x00,0x00,0x05 }; \
+	uchar *pstartcmd; \
+	pstartcmd = (reader->DRE_3s || \
+					(reader->DRE_type==TRICOLOR_PHMEDIA || \
+					 reader->DRE_type==TRICOLOR_SYBERIA || \
+					 reader->DRE_type==TRICOLOR_TVDRE3)) ? startcmd3 : startcmd1; \
+  	dre_transmission(reader, cmd, sizeof(cmd),cta_res,&cta_lr,pstartcmd); \
+}
+
+#define dre3_cmds(cmd) \
+{ 	\
+	uchar startcmd3[] = { 0x80,0x00,0x01,0x01,0x05 }; \
+  	dre_transmission(reader, cmd, sizeof(cmd),cta_res,&cta_lr,startcmd3); \
     }
 
 static int32_t dre_set_provider_info(struct s_reader *reader)
 {
 	def_resp;
-	int32_t i;
-	uchar cmd59[] = { 0x59, 0x14 };   // subscriptions
-	uchar cmd5b[] = { 0x5b, 0x00, 0x14 }; //validity dates
+	uchar cmd59[] = { 0x59,0x14 };	// get subscriptions
+	uchar cmd5b[] = { 0x5b,0x00,0x14 };	// get validity dates
 	struct dre_data *csystem_data = reader->csystem_data;
+	int32_t i, oksucced = 0;
 
 	cs_clear_entitlement(reader);
 
 	cmd59[1] = csystem_data->provider;
-	if((dre_cmd(cmd59)))      //ask subscription packages, returns error on 0x11 card
+	oksucced = (dre_cmd(cmd59));
+	myascdump("drex pbmresp", cta_res, cta_lr);
+	if (oksucced) // ask subscription packages, returns error on 0x11 card
 	{
 		uchar pbm[32];
 		char tmp_dbg[65];
@@ -119,23 +146,103 @@
 		memcpy(pbm, cta_res + 3, cta_lr - 6);
 		rdr_log_dbg(reader, D_READER, "pbm: %s", cs_hexdump(0, pbm, 32, tmp_dbg, sizeof(tmp_dbg)));
 
-		if(pbm[0] == 0xff)
-			{ rdr_log(reader, "no active packages"); }
-		else
-			for(i = 0; i < 32; i++)
-				if(pbm[i] != 0xff)
-				{
+		if (pbm[0] == 0xff) {
+			rdr_log(reader, "no active packages");
+		}
+		else {
+			for (i = 0; i < 32; i++) {
+				if (pbm[i] != 0xff) {
 					cmd5b[1] = i;
 					cmd5b[2] = csystem_data->provider;
 					dre_cmd(cmd5b);   //ask for validity dates
+					myascdump("drex packageresp", cta_res, cta_lr);
+
+					time_t start, end;
+					struct tm temp;
 
-					time_t start;
-					time_t end;
 					start = (cta_res[3] << 24) | (cta_res[4] << 16) | (cta_res[5] << 8) | cta_res[6];
 					end = (cta_res[7] << 24) | (cta_res[8] << 16) | (cta_res[9] << 8) | cta_res[10];
+					localtime_r(&start, &temp);
+					int32_t startyear  = temp.tm_year + 1900;
+					int32_t startmonth = temp.tm_mon + 1;
+					int32_t startday   = temp.tm_mday;
+					localtime_r(&end, &temp);
+					int32_t endyear    = temp.tm_year + 1900;
+					int32_t endmonth   = temp.tm_mon + 1;
+					int32_t endday     = temp.tm_mday;
+				// sky(date)
+				//	rdr_log(reader, "active package %i valid from %04i/%02i/%02i to %04i/%02i/%02i",
+				//				i,
+				//				startyear, startmonth, startday,
+				//	  			endyear, endmonth, endday);
+					rdr_log(reader, "active package %i valid from %02i/%02i/%04i to %02i/%02i/%04i",
+								i+1,
+								startday, startmonth, startyear,
+								endday, endmonth, endyear);
+					// sky(!)
+					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, 0, start, end, 1, NULL, 1);
+				}
+			}
+		}
+	}
+	else {
+		myrdr_log(reader, "dre packages failure.");
+	}
+	return OK;
+}
+
+// sky(DRE3)
+static int32_t dre_set_dre3_providers(struct s_reader *reader)
+{
+	def_resp;
+	uchar cmd84[] = { 0x84,0x00,0x40,0x02 }; // sky(DRE3)
+	uchar cmd85[] = { 0x85,0x00,0x02 };
+	uchar pbm[0x80];
+	char  tmp_dbg[65];
+	struct dre_data *csystem_data = reader->csystem_data;
+	int32_t i, oksucced = 0;
+
+	cs_clear_entitlement(reader);
 
+	// 84 00 40 02/84 40 40 02
+	cmd84[1] = 0x00;
+	cmd84[2] = 0x5f;
+	cmd84[3] = csystem_data->provider;
+	oksucced = (dre_cmd(cmd84));
+	myascdump("dre3 pbmresp(00)", cta_res, cta_lr);
+	if (oksucced) // ask subscription packages, returns error on 0x11 card
+	{
+		memset(pbm, 0xff, sizeof(pbm));
+		memcpy(pbm, cta_res+3, cta_lr-6);
+		rdr_log_dbg(reader, D_READER, "pbm00: %s", cs_hexdump(0, pbm, 32, tmp_dbg, sizeof(tmp_dbg)));
+
+		cmd84[1] = 0x5f;
+		cmd84[2] = 0x21;
+		cmd84[3] = csystem_data->provider;
+		oksucced = (dre_cmd(cmd84));
+		myascdump("dre3 pbmresp(5f)", cta_res, cta_lr);
+		if (oksucced) // ask subscription packages, returns error on 0x11 card
+		{
+			memcpy(pbm+0x5f, cta_res+3, cta_lr-6);
+			rdr_log_dbg(reader, D_READER, "pbm5f: %s", cs_hexdump(0, pbm+0x5f, 32, tmp_dbg, sizeof(tmp_dbg)));
+
+			if (pbm[0] == 0xff) {
+				rdr_log(reader, "no active packages");
+			}
+			else {
+				for (i = 0; i < 0x80; i++) {
+					if (pbm[i] != 0xff) {
+						// sky(DRE3)
+						cmd85[1] = i;
+						cmd85[2] = csystem_data->provider;
+						dre_cmd(cmd85);	// ask for validity dates
+						myascdump("dre3 packageresp", cta_res, cta_lr);
+
+						time_t start, end;
 					struct tm temp;
 
+						start = (cta_res[3] << 24) | (cta_res[4] << 16) | (cta_res[5] << 8) | cta_res[6];
+						end   = (cta_res[7] << 24) | (cta_res[8] << 16) | (cta_res[9] << 8) | cta_res[10];
 					localtime_r(&start, &temp);
 					int32_t startyear = temp.tm_year + 1900;
 					int32_t startmonth = temp.tm_mon + 1;
@@ -144,11 +251,25 @@
 					int32_t endyear = temp.tm_year + 1900;
 					int32_t endmonth = temp.tm_mon + 1;
 					int32_t endday = temp.tm_mday;
-					rdr_log(reader, "active package %i valid from %04i/%02i/%02i to %04i/%02i/%02i", i, startyear, startmonth, startday,
-							endyear, endmonth, endday);
-					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, 0, start, end, 1, 1);
+					// sky(date)
+					//	rdr_log(reader, "active package %i valid from %04i/%02i/%02i to %04i/%02i/%02i",
+					//				i,
+					//				startyear, startmonth, startday,
+					//	  			endyear, endmonth, endday);
+						rdr_log(reader, "active package %i valid from %02i/%02i/%04i to %02i/%02i/%04i",
+									i+1,
+									startday, startmonth, startyear,
+									endday, endmonth, endyear);
+						// sky(!)
+						cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, 0, start, end, 1, NULL, 1);
 				}
 	}
+			}
+		}
+	}
+	else {
+		myrdr_log(reader, "dre packages failure.");
+	}
 	return OK;
 }
 
@@ -156,112 +277,190 @@
 {
 	get_atr;
 	def_resp;
-	uchar ua[] = { 0x43, 0x15 };  // get serial number (UA)
-	uchar providers[] = { 0x49, 0x15 };   // get providers
-	int32_t i;
-	char *card;
+	char 	stcard[256];
 	char tmp[9];
-
-	if((atr[0] != 0x3b) || (atr[1] != 0x15) || (atr[2] != 0x11) || (atr[3] != 0x12) || (
-				((atr[4] != 0xca) || (atr[5] != 0x07)) &&
+	uchar checksum;
+	int32_t i;
+	// sky:3B 15 11 12 CA 07 00 DB
+	if ( (atr[0] != 0x3B) || (atr[1] != 0x15) || (atr[2] != 0x11) || (atr[3] != 0x12) || (
+		 ((atr[4] != 0xCA) || (atr[5] != 0x07)) &&
 				((atr[4] != 0x01) || (atr[5] != 0x01))
 			))
-		{ return ERROR; }
+	{
+		return ERROR;
+	}
+	checksum = dre_xor(atr + 1, 6);
+	if (checksum != atr[7]) {
+		rdr_log(reader, "warning: expected ATR checksum %02x, smartcard reports %02x", checksum, atr[7]);
+	}
 
-	if(!cs_malloc(&reader->csystem_data, sizeof(struct dre_data)))
-		{ return ERROR; }
+	if (!cs_malloc(&reader->csystem_data, sizeof(struct dre_data))) return ERROR;
 	struct dre_data *csystem_data = reader->csystem_data;
-
-	csystem_data->provider = atr[6];
-	uchar checksum = xor(atr + 1, 6);
-
-	if(checksum != atr[7])
-		{ rdr_log(reader, "warning: expected ATR checksum %02x, smartcard reports %02x", checksum, atr[7]); }
-
-	switch(atr[6])
-	{
+	reader->DRE_3s = 0;
+	csystem_data->provider = csystem_data->prcode = atr[6];
+	switch (atr[6]) {
 	case 0x11:
-		card = "Tricolor Centr";
-		reader->caid = 0x4ae1;
+			strcpy(stcard, "Tricolor Centr");
+			reader->caid = 0x4AE0;
+			reader->DRE_3s = 0;
+			reader->DRE_type = TRICOLOR_CENTR;
+			reader->DRE_cass = 41;
 		break;          //59 type card = MSP (74 type = ATMEL)
 	case 0x12:
-		card = "Cable TV";
-		reader->caid = 0x4ae1;  //TODO not sure about this one
+			strcpy(stcard, "Cable TV");
+			reader->caid = 0x4AE0; //TODO not sure about this one
+			reader->DRE_3s = 0;
+			reader->DRE_type = TRICOLOR_CABLETV;
+			reader->DRE_cass = 41;
 		break;
+		case 0x13:
+			strcpy(stcard, "Tricolor PH_MEDIA");
+			reader->caid = 0x4AE1;
+			reader->DRE_3s = 0;
+			reader->DRE_type = TRICOLOR_PHMEDIA;
+			reader->DRE_cass = 51;
+			break;	// 59 type card
 	case 0x14:
-		card = "Tricolor Syberia / Platforma HD new";
-		reader->caid = 0x4ae1;
+			strcpy(stcard, "Tricolor Syberia/Platforma HD new");
+			reader->caid = 0x4AE1;
+			reader->DRE_3s = 0;
+			reader->DRE_type = TRICOLOR_SYBERIA;
+			reader->DRE_cass = 51;
 		break;          //59 type card
 	case 0x15:
-		card = "Platforma HD / DW old";
-		reader->caid = 0x4ae1;
+			strcpy(stcard, "Platforma HD/DW old");
+			reader->caid = 0x4AE1;
+			reader->DRE_3s = 0;
+			reader->DRE_type = TRICOLOR_PLATFORMAHD;
+			reader->DRE_cass = 51;
 		break;          //59 type card
+		// sky(DRE3)
+		case 0x00:
+			strcpy(stcard, "DRE3");
+			reader->caid = 0x4AE1; /* 0x2710(?) */
+			reader->DRE_3s = 3;
+			reader->DRE_type = TRICOLOR_TVDRE3;
+			reader->DRE_cass = 51;
+			csystem_data->provider = 0x02;
+			break;	// DRE3/Exset
 	default:
-		card = "Unknown";
-		reader->caid = 0x4ae1;
+			strcpy(stcard, "Unknown");
+			reader->caid = 0x4AE1;
 		break;
 	}
 
-	memset(reader->prid, 0x00, 8);
+	memset(reader->prid, 0, sizeof(reader->prid));
+	// sky(DRE3)
+	if (reader->DRE_3s) {
+		uchar pridcmd[] = { 0x56,0x00 }; // get provider ID
+		if ((dre_cmd(pridcmd))) {
+			myascdump("dre3 pridresp", cta_res, cta_lr); // 59 04 93 01 02 6F
+			if ((cta_res[cta_lr-2] == 0x90) && (cta_res[cta_lr-1] == 0x00)) {
+				csystem_data->provider = cta_res[4];
+				if (csystem_data->provider==0x06) {
+					strcpy(stcard, "Lybid TV");
+					reader->caid = 0x2710;
+					reader->DRE_3s = 4;
+					reader->DRE_type = TRICOLOR_LYBIDTV;
+				}
+			}
+		}
+		else {
+			myrdr_log(reader, "dre3 provid failure");
+		}
+	}
 
-	static const uchar cmd30[] =
-	{
-		0x30, 0x81, 0x00, 0x81, 0x82, 0x03, 0x84, 0x05, 0x06, 0x87, 0x08, 0x09, 0x00, 0x81, 0x82, 0x03, 0x84, 0x05,
-		0x00
+	if (reader->DRE_3s) {
+	}
+	else {
+		static const uchar cmd30[] = {
+			0x30,0x81,0x00,0x81,0x82,0x03,0x84,0x05,0x06,0x87,0x08,0x09,0x00,0x81,0x82,0x03,
+			0x84,0x05,0x00
 	};
 	dre_cmd(cmd30);       //unknown command, generates error on card 0x11 and 0x14
-	/*
-	response:
-	59 03 E2 E3
-	FE 48 */
-
-	uchar cmd54[] = { 0x54, 0x14 };   // geocode
-	cmd54[1] = csystem_data->provider;
+		/*	response: 59 03 E2 E3 FE 48 */
+	}
 	uchar geocode = 0;
-	if((dre_cmd(cmd54)))      //error would not be fatal, like on 0x11 cards
-		{ geocode = cta_res[3]; }
+	uchar geocmd[] = { 0x54,0x14 }; // get geocode
+	geocmd[1] = csystem_data->provider;
+	if ((dre_cmd(geocmd))) { //error would not be fatal, like on 0x11 cards
+		geocode = cta_res[3];
+	}
 
-	providers[1] = csystem_data->provider;
-	if(!(dre_cmd(providers)))
-		{ return ERROR; }           //fatal error
-	if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-		{ return ERROR; }
 	uchar provname[128];
-	for(i = 0; ((i < cta_res[2] - 6) && (i < 128)); i++)
-	{
+	uchar provcmd [] = { 0x49,0x14 }; // get providers
+	provcmd[1] = csystem_data->provider;
+	// sky(DRE3):ok
+	if (reader->DRE_3s) {
+		provcmd[0] = 0x83; // get providers
+		provcmd[1] = csystem_data->provider;
+	}
+	if (!(dre_cmd(provcmd))) return ERROR; //fatal error
+	myascdump("drex provresp", cta_res, cta_lr);
+	if ((cta_res[cta_lr-2] != 0x90) || (cta_res[cta_lr-1] != 0x00))
+		return ERROR;
+	for (i = 0;((i < cta_res[2]- 6) && (i < 128)); i++) {
 		provname[i] = cta_res[6 + i];
-		if(provname[i] == 0x00)
-			{ break; }
+		if (provname[i] == 0x00) break;
 	}
-	int32_t major_version = cta_res[3];
-	int32_t minor_version = cta_res[4];
-
-	ua[1] = csystem_data->provider;
-	dre_cmd(ua);          //error would not be fatal
-
-	int32_t hexlength = cta_res[1] - 2;   //discard first and last byte, last byte is always checksum, first is answer code
-
+	int32_t majorversion = cta_res[3];
+	int32_t minorversion = cta_res[4];
+	csystem_data->version= majorversion;
+
+	uchar uacmd[] = { 0x43,0x14 };	// get serial number(UA)
+	uacmd[1] = csystem_data->provider;
+	dre_cmd(uacmd); //error would not be fatal
+	myascdump("drex uaresp", cta_res, cta_lr);
 	reader->hexserial[0] = 0;
 	reader->hexserial[1] = 0;
+	int32_t hexlength    = cta_res[1] - 2;	// discard first and last byte, last byte is always checksum, first is answer code
 	memcpy(reader->hexserial + 2, cta_res + 3, hexlength);
 
-	int32_t low_dre_id = ((cta_res[4] << 16) | (cta_res[5] << 8) | cta_res[6]) - 48608;
+	int32_t dre_low_id;
 	int32_t dre_chksum = 0;
-	uchar buf[32];
-	snprintf((char *)buf, sizeof(buf), "%i%i%08i", csystem_data->provider - 16, major_version + 1, low_dre_id);
-	for(i = 0; i < 32; i++)
-	{
-		if(buf[i] == 0x00)
-			{ break; }
-		dre_chksum += buf[i] - 48;
-	}
-
-	rdr_log(reader, "type: DRE Crypt, caid: %04X, serial: {%s}, dre id: %i%i%i%08i, geocode %i, card: %s v%i.%i",
-			reader->caid, cs_hexdump(0, reader->hexserial + 2, 4, tmp, sizeof(tmp)), dre_chksum, csystem_data->provider - 16,
-			major_version + 1, low_dre_id, geocode, card, major_version, minor_version);
+	uchar   dre_stid[32];
+	// sky(DRE3)
+	// DRE1-2:2912.02115539, DRE3:250023.14422151
+	if (reader->DRE_3s) {
+		dre_low_id = ((cta_res[4] << 16) | (cta_res[5] << 8) | cta_res[6]);
+		snprintf((char *)dre_stid, sizeof(dre_stid), "%02i%i%i%08i",
+				csystem_data->prcode,
+				csystem_data->provider,
+				majorversion,
+				dre_low_id);
+	}
+	else {
+		dre_low_id = ((cta_res[4] << 16) | (cta_res[5] << 8) | cta_res[6]) - 48608;
+		snprintf((char *)dre_stid, sizeof(dre_stid), "%i%i%08i",
+				csystem_data->provider - 0x10,
+				(csystem_data->provider==0x15) ? minorversion : majorversion + 1,
+				dre_low_id);
+	}
+	for (i = 0; i < 32; i++) {
+		if (dre_stid[i] == 0x00) break;
+		dre_chksum += dre_stid[i] - 48;
+	}
+
+	// sky(oscam.smartcard)
+	sprintf(reader->ascserial, "%i%s", dre_chksum, dre_stid);
+	rdr_log_sensitive(reader, "type: DRE Crypt, caid: %04X, serial: {%s}, dre id: %i%s, geocode %i, card: %s v%i.%i",
+				reader->caid,
+				cs_hexdump(0, reader->hexserial + 2, 4, tmp, sizeof(tmp)),
+				dre_chksum,
+				dre_stid,
+				geocode,
+				stcard,
+				majorversion, minorversion);
+	myprintf("type: DRE Crypt, caid: %04X, serial: {%s}, dre id: %i%s, geocode %i, card: %s v%i.%i",
+				reader->caid,
+				cs_hexdump(0, reader->hexserial + 2, 4, tmp, sizeof(tmp)),
+				dre_chksum,
+				dre_stid,
+				geocode,
+				stcard,
+				majorversion, minorversion);
 	rdr_log(reader, "Provider name:%s.", provname);
 
-
 	memset(reader->sa, 0, sizeof(reader->sa));
 	memcpy(reader->sa[0], reader->hexserial + 2, 1);  //copy first byte of unique address also in shared address, because we dont know what it is...
 
@@ -265,14 +464,50 @@
 	memset(reader->sa, 0, sizeof(reader->sa));
 	memcpy(reader->sa[0], reader->hexserial + 2, 1);  //copy first byte of unique address also in shared address, because we dont know what it is...
 
-	rdr_log_sensitive(reader, "SA = %02X%02X%02X%02X, UA = {%s}", reader->sa[0][0], reader->sa[0][1], reader->sa[0][2],
+	rdr_log_sensitive(reader, "SA = %02X%02X%02X%02X, UA = {%s}",
+			reader->sa[0][0], reader->sa[0][1], reader->sa[0][2],
 					  reader->sa[0][3], cs_hexdump(0, reader->hexserial + 2, 4, tmp, sizeof(tmp)));
-
+	myprintf("SA = %02X%02X%02X%02X, UA = {%s}",
+			reader->sa[0][0], reader->sa[0][1], reader->sa[0][2],
+			reader->sa[0][3], cs_hexdump(0, reader->hexserial + 2, 4, tmp, sizeof(tmp)));
+	// set provider infor.
 	reader->nprov = 1;
-
+	// sky(DRE3)
+	if (csystem_data->provider == 0x13) {
+		if (csystem_data->version == 0x01) {
+			reader->caid = 0x4AE0;
+			reader->DRE_cass = 41;
+		}
+		else {
+			reader->caid = 0x4AE1;
+			reader->DRE_cass = 51;
+		}
+	}
+	if (reader->DRE_3s) {
+		reader->prid[0][3] = csystem_data->provider;
+		if (!dre_set_dre3_providers(reader))
+			return ERROR; //fatal error
+	}
+	else {
+		if ((csystem_data->provider == 0x15) &&
+			 (csystem_data->version >= 0x04) && (strcmp("Tricolor_NC1", (char *)provname) == 0)) {
+			reader->caid = 0x4AE0;
+			reader->DRE_type = TRICOLOR_NC1;
+			reader->DRE_cass = 41;
+		}
+		else if (csystem_data->version >= 0x02)	{
+			reader->DRE_cass = 51;
+			if (csystem_data->provider == 0x11)	{
+				reader->caid = 0x4AE1;
+				reader->DRE_type = TRICOLOR_TV;
+			}
+		}
+		else {
+			reader->DRE_cass = 41;
+		}
 	if(!dre_set_provider_info(reader))
-		{ return ERROR; }           //fatal error
-
+			return ERROR; //fatal error
+	}
 	rdr_log(reader, "ready for requests");
 	return OK;
 }
@@ -297,7 +532,7 @@
 	0x49, 0xD3, 0x33, 0xC2, 0xEB, 0x71, 0xD3, 0x14 // 0F
 };
 
-static void DREover(const unsigned char *ECMdata, unsigned char *DW)
+static void dre_over(const unsigned char *ECMdata, unsigned char *DW)
 {
 	uchar key[8];
 	if(ECMdata[2] >= (43 + 4) && ECMdata[40] == 0x3A && ECMdata[41] == 0x4B)
@@ -316,27 +552,56 @@
 	def_resp;
 	char tmp_dbg[256];
 	struct dre_data *csystem_data = reader->csystem_data;
-	if(reader->caid == 0x4ae0)
+	// sky(DRE3)
+	if (reader->DRE_3s)
+	{
+		myprdump("dreecm", (void *)er->ecm, er->ecmlen);
+		uchar ecmcmd3[0x39];
+		memset(ecmcmd3, 0, sizeof(ecmcmd3));
+		memcpy(ecmcmd3, er->ecm + 0x11, 0x38 /* er->ecmlen-0x15 */);
+		ecmcmd3[0x38] = csystem_data->provider;
+//		myprintf("[dre]provider:%02x{%02x}\n", csystem_data->provider, type);
+//		myprintf("[dre]unused ECM front:%s\n", cs_hexdump(0, er->ecm, 0x11, tmp_dbg, sizeof(tmp_dbg)));
+//		myprintf("[dre]unused ECM back :%s\n", cs_hexdump(0, er->ecm+ 0x49, 4, tmp_dbg, sizeof(tmp_dbg)));
+		if ((dre3_cmds(ecmcmd3))) // ecm request
 	{
+			if ((cta_res[cta_lr-2] != 0x90) || (cta_res[cta_lr-1] != 0x00)) return ERROR; //exit if response is not 90 00
+			memcpy(ea->cw,   cta_res+11, 8);
+			memcpy(ea->cw+8, cta_res+3,  8);
+			return OK;
+		}
+	}
+	else
+	if (reader->DRE_cass == 0x41)
+	{
+		if ((er->ecm[3] == 0x56 && er->ecm[4] == 0x0b)
+			&& (csystem_data->version  >= 0x04)
+			&& (csystem_data->provider == 0x15)
+			&& (reader->caid == 0x4AE0))
+		{
+			memcpy(ea->cw,   &er->ecm[16], 8);
+			memcpy(ea->cw+8, &er->ecm[ 8], 8);
+			return OK;
+
+		}
+
 		uchar ecmcmd41[] = { 0x41,
 							 0x58, 0x1f, 0x00,     //fixed part, dont change
 							 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,   //0x01 - 0x08: next key
 							 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,   //0x11 - 0x18: current key
-							 0x3b, 0x59, 0x11      //0x3b = keynumber, can be a value 56 ;; 0x59 number of package = 58+1 - Pay Package ;; 0x11 = provider
+						0x3b,0x59,0x11, // 0x3b = keynumber, can be a value 56 ;; 0x59 number of package = 58+1 - Pay Package ;; 0x11 = provider
 						   };
 		ecmcmd41[22] = csystem_data->provider;
 		memcpy(ecmcmd41 + 4, er->ecm + 8, 16);
 		ecmcmd41[20] = er->ecm[6];  //keynumber
 		ecmcmd41[21] = 0x58 + er->ecm[25];  //package number
-		rdr_log_dbg(reader, D_READER, "unused ECM info front:%s", cs_hexdump(0, er->ecm, 8, tmp_dbg, sizeof(tmp_dbg)));
-		rdr_log_dbg(reader, D_READER, "unused ECM info back:%s", cs_hexdump(0, er->ecm + 24, er->ecm[2] + 2 - 24, tmp_dbg, sizeof(tmp_dbg)));
+		rdr_log_dbg(reader, D_READER, "unused ECM front:%s", cs_hexdump(0, er->ecm, 8, tmp_dbg, sizeof(tmp_dbg)));
+		rdr_log_dbg(reader, D_READER, "unused ECM back :%s", cs_hexdump(0, er->ecm+24, er->ecm[2]+2-24, tmp_dbg, sizeof(tmp_dbg)));
 		if((dre_cmd(ecmcmd41)))     //ecm request
 		{
-			if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-				{ return ERROR; }       //exit if response is not 90 00
+			if ((cta_res[cta_lr-2] != 0x90) || (cta_res[cta_lr-1] != 0x00)) return ERROR; // exit if response is not 90 00
 			memcpy(ea->cw, cta_res + 11, 8);
 			memcpy(ea->cw + 8, cta_res + 3, 8);
-
 			return OK;
 		}
 	}
@@ -348,17 +612,18 @@
 							 0xC1, 0x71, 0x21, 0x06, 0xF0, 0x14, 0xA7, 0x0E,   //next key?
 							 0x89, 0xDA, 0xC9, 0xD7, 0xFD, 0xB9, 0x06, 0xFD,   //current key?
 							 0xD5, 0x1E, 0x2A, 0xA3, 0xB5, 0xA0, 0x82, 0x11,   //key or signature?
-							 0x14          //provider
+						0x14,	// provider
 						   };
 		memcpy(ecmcmd51 + 1, er->ecm + 5, 0x21);
-		rdr_log_dbg(reader, D_READER, "unused ECM info front:%s", cs_hexdump(0, er->ecm, 5, tmp_dbg, sizeof(tmp_dbg)));
-		rdr_log_dbg(reader, D_READER, "unused ECM info back:%s", cs_hexdump(0, er->ecm + 37, 4, tmp_dbg, sizeof(tmp_dbg)));
+		rdr_log_dbg(reader, D_READER, "unused ECM front:%s", cs_hexdump(0, er->ecm, 5, tmp_dbg, sizeof(tmp_dbg)));
+		rdr_log_dbg(reader, D_READER, "unused ECM back :%s", cs_hexdump(0, er->ecm + 37, 4, tmp_dbg, sizeof(tmp_dbg)));
 		ecmcmd51[33] = csystem_data->provider;  //no part of sig
 		if((dre_cmd(ecmcmd51)))     //ecm request
 		{
-			if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-				{ return ERROR; }       //exit if response is not 90 00
-			DREover(er->ecm, cta_res + 3);
+			if ((cta_res[cta_lr-2] != 0x90) || (cta_res[cta_lr-1] != 0x00)) return ERROR; //exit if response is not 90 00
+			if (reader->caid == 0x4AE1) {
+				dre_over(er->ecm, cta_res + 3);
+			}
 			memcpy(ea->cw, cta_res + 11, 8);
 			memcpy(ea->cw + 8, cta_res + 3, 8);
 			return OK;
@@ -371,32 +636,42 @@
 {
 	switch(ep->emm[0])
 	{
-	case 0x87:
-		ep->type = UNIQUE;
-		return 1; //FIXME: no filling of ep->hexserial
-
 	case 0x83:
 	case 0x89:
 		ep->type = SHARED;
-		// FIXME: Seems to be that SA is only used with caid 0x4ae1
-		if(rdr->caid == 0x4ae1)
-		{
+			// FIXME: Seems to be that SA is only used with caid 0x4AE1
+			if (rdr->DRE_cass==51) {
 			memset(ep->hexserial, 0, 8);
 			memcpy(ep->hexserial, ep->emm + 3, 4);
-			return (!memcmp(&rdr->sa[0][0], ep->emm + 3, 4));
+			//	return (!memcmp(&rdr->sa[0][0], ep->emm + 3, 4));
+				return (ep->hexserial[0] == rdr->sa[0][0]);
+			}
+			else {
+				return 1;
 		}
-		else
-			{ return 1; }
 
 	case 0x80:
 	case 0x82:
 	case 0x86:
+		case 0x88: // sky(DRE!)
 	case 0x8c:
 		ep->type = SHARED;
 		memset(ep->hexserial, 0, 8);
 		ep->hexserial[0] = ep->emm[3];
-		return ep->hexserial[0] == rdr->sa[0][0];
+			return (ep->hexserial[0] == rdr->sa[0][0]);
 
+		case 0x87: // sky(DRE?)
+		case 0x8b: // sky(DRE3)
+			ep->type = UNIQUE;
+			if (rdr->DRE_cass==51) {
+				memset(ep->hexserial, 0, 8);
+				memcpy(ep->hexserial, ep->emm + 3, 4);
+				return (!memcmp(rdr->hexserial+2, ep->hexserial, 4));
+			}
+			else {
+				return 1;
+			}
+			break;
 	default:
 		ep->type = UNKNOWN;
 		return 1;
@@ -405,17 +680,16 @@
 
 static int32_t dre_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count)
 {
-	if(*emm_filters == NULL)
-	{
-		const unsigned int max_filter_count = 7;
+	if (*emm_filters == NULL) {
+		const unsigned int max_filter_count = 9; // sky(DRE!)
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+		  	return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
 
 		int32_t idx = 0;
-
+#if 0
 		filters[idx].type = EMM_SHARED;
 		filters[idx].enabled   = 1;
 		filters[idx].filter[0] = 0x80;
@@ -423,12 +697,13 @@
 		filters[idx].mask[0]   = 0xF2;
 		filters[idx].mask[1]   = 0xFF;
 		idx++;
+#endif
 
 		filters[idx].type = EMM_SHARED;
 		filters[idx].enabled   = 1;
 		filters[idx].filter[0] = 0x82;
 		filters[idx].filter[1] = rdr->sa[0][0];
-		filters[idx].mask[0]   = 0xF3;
+		filters[idx].mask  [0] = 0xFF;
 		filters[idx].mask[1]   = 0xFF;
 		idx++;
 
@@ -436,13 +711,25 @@
 		filters[idx].enabled   = 1;
 		filters[idx].filter[0] = 0x83;
 		filters[idx].filter[1] = rdr->sa[0][0];
-		filters[idx].mask[0]   = 0xF3;
-		if(rdr->caid == 0x4ae1)
-		{
+		filters[idx].mask  [0] = 0xFF;
+		filters[idx].mask  [1] = 0xFF;
+		if (rdr->DRE_cass==51) {
 			memcpy(&filters[idx].filter[1], &rdr->sa[0][0], 4);
 			memset(&filters[idx].mask[1], 0xFF, 4);
 		}
+		idx++;
+
+		filters[idx].type = EMM_SHARED;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x83;
+		filters[idx].filter[1] = rdr->sa[0][0];
+		filters[idx].mask  [0] = 0xFF;
 		filters[idx].mask[1]   = 0xFF;
+		// FIXME: Seems to be that SA is only used with caid 0x4AE1
+		if (rdr->DRE_cass==51) {
+			memcpy(&filters[idx].filter[1], &rdr->sa[0][0], 4);
+			memset(&filters[idx].mask  [1], 0xFF, 4);
+		}
 		idx++;
 
 		filters[idx].type = EMM_SHARED;
@@ -453,31 +740,45 @@
 		filters[idx].mask[1]   = 0xFF;
 		idx++;
 
+		// sky(DRE!)
 		filters[idx].type = EMM_SHARED;
 		filters[idx].enabled   = 1;
-		filters[idx].filter[0] = 0x8c;
+		filters[idx].filter[0] = 0x88;
 		filters[idx].filter[1] = rdr->sa[0][0];
 		filters[idx].mask[0]   = 0xFF;
 		filters[idx].mask[1]   = 0xFF;
 		idx++;
 
+		// sky(DRE3)
 		filters[idx].type = EMM_SHARED;
 		filters[idx].enabled   = 1;
-		filters[idx].filter[0] = 0x89;
+		filters[idx].filter[0] = 0x8C;
+		filters[idx].filter[1] = rdr->sa[0][0];
 		filters[idx].mask[0]   = 0xFF;
-		// FIXME: Seems to be that SA is only used with caid 0x4ae1
-		if(rdr->caid == 0x4ae1)
-		{
-			memcpy(&filters[idx].filter[1], &rdr->sa[0][0], 4);
-			memset(&filters[idx].mask[1], 0xFF, 4);
-		}
+		filters[idx].mask  [1] = 0xFF;
 		idx++;
 
+		// EMM-Unique
 		filters[idx].type = EMM_UNIQUE;
 		filters[idx].enabled   = 1;
 		filters[idx].filter[0] = 0x87;
 		filters[idx].mask[0]   = 0xFF;
 		//FIXME: No filter for hexserial
+		if (rdr->DRE_cass==51) {
+			memcpy(&filters[idx].filter[1], rdr->hexserial+2, 4);
+			memset(&filters[idx].mask  [1], 0xFF, 4);
+		}
+		idx++;
+
+		// sky(DRE3)
+		filters[idx].type = EMM_UNIQUE;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x8b;
+		filters[idx].mask  [0] = 0xFF;
+		if (rdr->DRE_cass==51) {
+			memcpy(&filters[idx].filter[1], rdr->hexserial+2, 4);
+			memset(&filters[idx].mask  [1], 0xFF, 4);
+		}
 		idx++;
 
 		*filter_count = idx;
@@ -490,67 +791,110 @@
 {
 	def_resp;
 	struct dre_data *csystem_data = reader->csystem_data;
+	int32_t i;
 
-	if(reader->caid == 0x4ae1)
+	// sky(DRE3)
+	if (reader->DRE_cass==51) {
+		if (reader->DRE_3s)
+		{
+			if (ep->emm[0]==0x8B) // 0x8B
+			{	/* For new package activation. */
+				uchar emmcmd3[0x39];
+				memcpy(emmcmd3, ep->emm + 0x13, 0x38);
+				emmcmd3[0x38] = csystem_data->provider; // sky(DRE!)
+				if ((dre3_cmds(emmcmd3)))
+					if ((cta_res[cta_lr-2] != 0x90) || (cta_res[cta_lr-1] != 0x00))
+						return ERROR;
+			}
+			else // 0x8C
 	{
-		if(ep->type == UNIQUE && ep->emm[39] == 0x3d)
+				// check for shared address
+				if (ep->emm[3] != reader->sa[0][0]) return OK; // ignore, wrong address
+				uchar emmcmd3[0x49];
+				for (i=0; i<ep->emmlen-0x17; i+=0x48) {
+					memcpy(emmcmd3, ep->emm + 0x13 + i, 0x48);
+					emmcmd3[0x48] = csystem_data->provider;
+					if ((dre3_cmds(emmcmd3)))
+						if ((cta_res[cta_lr-2] != 0x90) || (cta_res[cta_lr-1] != 0x00))
+					    	return ERROR; //exit if response is not 90 00
+				}
+			}
+			return OK; //success
+		}
+		if (reader->DRE_type==TRICOLOR_TV)
 		{
+			if (ep->emm[39] == 0x3d || ep->emm[39] == 0x3b || ep->emm[39] == 0x3a) { // sky(DRE!)
 			/* For new package activation. */
-			uchar emmcmd58[26];
-			emmcmd58[0] = 0x58;
+				uchar emmcmd58[26]  = {0x58, };
 			memcpy(&emmcmd58[1], &ep->emm[40], 24);
-			emmcmd58[25] = 0x15;
+			//	emmcmd58[25] = 0x15;
+				emmcmd58[25] = csystem_data->provider; // sky(DRE!)
 			if((dre_cmd(emmcmd58)))
 				if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-					{ return ERROR; }
+						return ERROR;
+				return OK; //success
 		}
-		else
+		}
+		if ((ep->emm[4] != 0) || (ep->emm[5] != 0) || (ep->emm[6] != 0))
 		{
-			uchar emmcmd52[0x3a];
-			emmcmd52[0] = 0x52;
-			int32_t i;
-			for(i = 0; i < 2; i++)
+			if ((ep->emm[40] == reader->sa[0][0]) &&
+				 (ep->emm[41] == 0x00 && ep->emm[42] == 0x00 && ep->emm[43] == 0x00))
 			{
-				memcpy(emmcmd52 + 1, ep->emm + 5 + 32 + i * 56, 56);
+				i = 0;
+			}
+			else if (memcmp(&ep->emm[3], reader->hexserial+2, 4))
+			{
+				return ERROR;
+			}
+		}
+		// 0x86
 				// check for shared address
-				if(ep->emm[3] != reader->sa[0][0])
-					{ return OK; } // ignore, wrong address
+		if (ep->emm[3] != reader->sa[0][0]) return OK; // ignore, wrong address
+		uchar emmcmd52[0x3a] = {0x52, };
+		for (i=0; i<2; i++) {
+			memcpy(emmcmd52 + 1, ep->emm + 5 + 32 + i * 56, 56);
 				emmcmd52[0x39] = csystem_data->provider;
 				if((dre_cmd(emmcmd52)))
 					if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-						{ return ERROR; } //exit if response is not 90 00
-			}
+			    	return ERROR; //exit if response is not 90 00
 		}
 	}
 	else
 	{
-		uchar emmcmd42[] =
+		if ((ep->emm[4] != 0) || (ep->emm[5] != 0) || (ep->emm[6] != 0))
+		{
+			if ((ep->emm[ 9] == reader->sa[0][0]) &&
+				 (ep->emm[10] == 0x00 && ep->emm[11] == 0x00 && ep->emm[12] == 0x00))
+			{
+				i = 0;
+			}
+			else if (memcmp(&ep->emm[3], reader->hexserial+2, 4))
 		{
-			0x42, 0x85, 0x58, 0x01, 0xC8, 0x00, 0x00, 0x00, 0x05, 0xB8, 0x0C, 0xBD, 0x7B, 0x07, 0x04, 0xC8,
+				return ERROR;
+			}
+		}
+		uchar emmcmd42[] =
+		{ 	0x42,0x85,0x58,0x01,0xC8,0x00,0x00,0x00,0x05,0xB8,0x0C,0xBD,0x7B,0x07,0x04,0xC8,
 			0x77, 0x31, 0x95, 0xF2, 0x30, 0xB7, 0xE9, 0xEE, 0x0F, 0x81, 0x39, 0x1C, 0x1F, 0xA9, 0x11, 0x3E,
 			0xE5, 0x0E, 0x8E, 0x50, 0xA4, 0x31, 0xBB, 0x01, 0x00, 0xD6, 0xAF, 0x69, 0x60, 0x04, 0x70, 0x3A,
 			0x91,
 			0x56, 0x58, 0x11
 		};
-		int32_t i;
-		switch(ep->type)
-		{
-		case UNIQUE:
-			for(i = 0; i < 2; i++)
+		if (ep->emm[0]==0x87)
 			{
+			for (i = 0; i < 2; i++) {
 				memcpy(emmcmd42 + 1, ep->emm + 42 + i * 49, 48);
 				emmcmd42[49] = ep->emm[i * 49 + 41]; //keynr
 				emmcmd42[50] = 0x58 + ep->emm[40]; //package nr
 				emmcmd42[51] = csystem_data->provider;
-				if((dre_cmd(emmcmd42)))
-				{
+				if ((dre_cmd(emmcmd42))) {
 					if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-						{ return ERROR; }       //exit if response is not 90 00
+						return ERROR; //exit if response is not 90 00
 				}
 			}
-			break;
-		case SHARED:
-		default:
+		}
+		else
+		{
 			memcpy(emmcmd42 + 1, ep->emm + 6, 48);
 			emmcmd42[51] = csystem_data->provider;
 			//emmcmd42[50] = ecmcmd42[2]; //TODO package nr could also be fixed 0x58
@@ -559,10 +903,9 @@
 			/* response:
 			   59 05 A2 02 05 01 5B
 			   90 00 */
-			if((dre_cmd(emmcmd42)))     //first emm request
-			{
+			if ((dre_cmd(emmcmd42))) {	 //first emm request
 				if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-					{ return ERROR; }       //exit if response is not 90 00
+					return ERROR; //exit if response is not 90 00
 
 				memcpy(emmcmd42 + 1, ep->emm + 55, 7);    //TODO OR next two lines?
 				/*memcpy (emmcmd42 + 1, ep->emm + 55, 7);  //FIXME either I cant count or my EMM log contains errors
@@ -571,10 +914,9 @@
 				//emmcmd42[50] = ecmcmd42[2]; //TODO package nr could also be fixed 0x58
 				emmcmd42[50] = 0x58;
 				emmcmd42[49] = ep->emm[54];   //keynr
-				if((dre_cmd(emmcmd42)))       //second emm request
-				{
+				if ((dre_cmd(emmcmd42))) {	 //second emm request
 					if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
-						{ return ERROR; }       //exit if response is not 90 00
+						return ERROR; //exit if response is not 90 00
 				}
 			}
 		}
@@ -590,13 +932,14 @@
 const struct s_cardsystem reader_dre =
 {
 	.desc           = "dre",
-	.caids          = (uint16_t[]){ 0x4AE0, 0x4AE1, 0x7BE0, 0x7BE1, 0 },
+	.caids          = (uint16_t[]){ 0x4AE0, 0x4AE1, 0x7BE0, 0x7BE1, 0x2710, 0 }, // sky(DRE4/EXSET)
 	.do_emm         = dre_do_emm,
 	.do_ecm         = dre_do_ecm,
 	.card_info      = dre_card_info,
 	.card_init      = dre_card_init,
 	.get_emm_type   = dre_get_emm_type,
 	.get_emm_filter = dre_get_emm_filter,
+	.caidsvarious   = 1,
 };
 
 #endif
Index: reader-griffin.c
===================================================================
--- reader-griffin.c	(revision 10670)
+++ reader-griffin.c	(working copy)
@@ -157,8 +157,7 @@
 
 #define cmd_buf_len  512
 
-struct griffin_data
-{
+struct griffin_data {
 	uint8_t         cmd_base; // Command base, depends on the card
 };
 
@@ -173,10 +172,9 @@
 	cmd_buf[3] = 0x00;
 	cmd_buf[4] = data_len; // Set payload length
 	if(data && data_len)
-		{ memcpy(cmd_buf + cmd_len, data, data_len); }
+		memcpy(cmd_buf + cmd_len, data, data_len);
 	uint32_t len = cmd_len + (data ? data_len : 0);
-	if(DEBUG)
-	{
+	if (DEBUG) {
 		char tmp[1024];
 		rdr_log(rdr, "SEND[-] -> %s", cs_hexdump(1, cmd_buf, len, tmp, sizeof(tmp)));
 	}
@@ -191,32 +189,30 @@
 	int32_t ret = reader_cmd2icc(rdr, buf,
 								 griffin_init_cmd(rdr, buf, csystem_data->cmd_base + cmd_op, data, data_len),
 								 response, response_length);
-	if(DEBUG)
-	{
+	if (DEBUG) {
 		char tmp[1024];
 		rdr_log(rdr, "RECV[1] <- %s (ret=%d resp_len=%d)", cs_hexdump(1, response, *response_length, tmp, sizeof(tmp)), ret, *response_length);
 	}
-	if(ret || *response_length < 2) { return ERROR; }  // Response is two short
-	if(response[0] != 0x90)         { return ERROR; }  // Invalid response
-	if(response[1] == 0)            { return OK; }     // Nothing to retrieve, command OK
+	if (ret || *response_length < 2) return ERROR; // Response is two short
+	if (response[0] != 0x90)         return ERROR; // Invalid response
+	if (response[1] == 0)            return OK;    // Nothing to retrieve, command OK
 
 	// Retrieve response
 	uint8_t cmd_read_response = 0x02;
 	if(csystem_data->cmd_base > 0x10)
-		{ cmd_read_response += csystem_data->cmd_base - 0x10; }
+		cmd_read_response += csystem_data->cmd_base - 0x10;
 
 	ret = reader_cmd2icc(rdr, buf,
 						 griffin_init_cmd(rdr, buf, cmd_read_response, NULL, response[1]),
 						 response, response_length);
 
-	if(DEBUG)
-	{
+	if (DEBUG) {
 		char tmp[1024];
 		rdr_log(rdr, "RECV[2] <- %s (ret=%d resp_len=%d)", cs_hexdump(1, response, *response_length, tmp, sizeof(tmp)), ret, *response_length);
 	}
-	if(ret || *response_length < 2)            { return ERROR; }  // Response is two short
-	if(response[*response_length - 2] != 0x90) { return ERROR; }  // Invalid response
-	if(response[*response_length - 1] != 0x00) { return ERROR; }  // We don't expect command_op 0x12 to return more data
+	if (ret || *response_length < 2)            return ERROR; // Response is two short
+	if (response[*response_length - 2] != 0x90) return ERROR; // Invalid response
+	if (response[*response_length - 1] != 0x00) return ERROR; // We don't expect command_op 0x12 to return more data
 	return OK;
 }
 
@@ -233,15 +229,15 @@
 	def_resp
 
 	if(atr_size < 10)
-		{ return ERROR; }
+		return ERROR;
 
 	//       0  1  2  3  4  5  6  7  8  9
 	// ATR: 3B 08 yy 01 xx xx xx xx 10 00
 	if(atr[0] != 0x3b || atr[1] != 0x08 || atr[3] != 0x01 || atr[9] != 0x00)
-		{ return ERROR; }
+		return ERROR;
 
 	if(!cs_malloc(&rdr->csystem_data, sizeof(struct griffin_data)))
-		{ return ERROR; }
+		return ERROR;
 	struct griffin_data *csystem_data = rdr->csystem_data;
 
 	rdr->nprov = 1;
@@ -270,14 +266,15 @@
 	griffin_cmd(GRIFFIN_CMD_GET_ASCII_SERIAL, NULL, 0, 14);
 	memcpy(serial, cta_res + 2, 12);
 
+	// sky(oscam.smartcard)
+	strcpy(rdr->ascserial, serial);
+
 	griffin_cmd(GRIFFIN_CMD_GET_CAID, NULL, 0, 4);
 	rdr->caid = (cta_res[2] << 8) | cta_res[3];
 
 	griffin_cmd(GRIFFIN_CMD_GET_CARD_ADDRESS, NULL, 0, 48);
-	for(i = 1 ; i < CS_MAXPROV; i++)
-	{
-		if(3 + (i * 16) + 4 > cta_lr)
-			{ break; }
+	for (i = 1 ; i < CS_MAXPROV; i++) {
+		if (3 + (i * 16) + 4 > cta_lr) break;
 		memcpy(rdr->sa[i - 1], cta_res + 3 + (i * 16), 4);
 	}
 
@@ -288,10 +285,8 @@
 	//griffin_cmd(0x2a, NULL, 0, 2);
 	//griffin_cmd(0x30, NULL, 0, 2);
 
-	for(i = 0 ; i < CS_MAXPROV; i++)
-	{
-		if(check_filled(rdr->sa[i], 4))
-		{
+	for (i = 0 ; i < CS_MAXPROV; i++) {
+		if (check_filled(rdr->sa[i], 4)) {
 			rdr_log_sensitive(rdr, "CAID: 0x%04X, Serial: {%s}, HexSerial: {%02X %02X %02X %02X} Addr: {%02X %02X %02X %02X}",
 							  rdr->caid, serial,
 							  rdr->hexserial[0], rdr->hexserial[1], rdr->hexserial[2], rdr->hexserial[3],
@@ -311,22 +306,18 @@
 	return OK;
 }
 
-static int32_t griffin_get_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
-{
+static int32_t griffin_get_emm_type(EMM_PACKET *ep, struct s_reader *rdr) {
 	memcpy(ep->hexserial, ep->emm + 3, 4);
-	switch(ep->emm[0])
-	{
+	switch (ep->emm[0]) {
 	case 0x82:
 	case 0x83:
-		if(memcmp(ep->hexserial, rdr->sa[0], 4) == 0)
-		{
+		if (memcmp(ep->hexserial, rdr->sa[0], 4) == 0) {
 			if(DEBUG)
 				rdr_log_sensitive(rdr, "SHARED EMM TYPE:%02X SA:{%02X %02X %02X %02X}",
 								  ep->emm[0], ep->emm[3], ep->emm[4], ep->emm[5], ep->emm[6]);
 			ep->type = SHARED;
 		}
-		if(memcmp(ep->hexserial, rdr->sa[1], 4) == 0)
-		{
+		if (memcmp(ep->hexserial, rdr->sa[1], 4) == 0) {
 			if(DEBUG)
 				rdr_log_sensitive(rdr, "UNIQUE EMM TYPE:%02X SA:{%02X %02X %02X %02X}",
 								  ep->emm[0], ep->emm[3], ep->emm[4], ep->emm[5], ep->emm[6]);
@@ -351,11 +342,10 @@
 
 static int32_t griffin_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count)
 {
-	if(*emm_filters == NULL)
-	{
+  if (*emm_filters == NULL) {
 		const unsigned int max_filter_count = 4;
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+      return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
@@ -431,19 +421,14 @@
 	rdr_log(rdr, "Reading subscription info.");
 
 	griffin_cmd(GRIFFIN_CMD_SUBSCRIPTION_INFO, NULL, 0, 16);
-	if(cta_res[0] == 0x0b)    // Old cards
-	{
-		for(i = 0; i < cta_lr - 8; i += 9)
-		{
+	if (cta_res[0] == 0x0b) { // Old cards
+		for (i = 0; i < cta_lr - 8; i += 9) {
 			rdr_log(rdr, " Subscription stream %d - %c%c%c%c%c%c",
 					r++, cta_res[i + 2], cta_res[i + 3], cta_res[i + 4],
 					cta_res[i + 5], cta_res[i + 6], cta_res[i + 7]);
 		}
-	}
-	else if(cta_res[0] == 0x1b)      // Newer cards
-	{
-		for(i = 0; i < cta_lr; i += 4)
-		{
+	} else if (cta_res[0] == 0x1b) { // Newer cards
+		for (i = 0; i < cta_lr; i += 4) {
 			rdr_log(rdr, " Subscription stream #%02d - 0x%04x",
 					r++, b2i(2, cta_res + i + 2));
 		}
Index: reader-irdeto.c
===================================================================
--- reader-irdeto.c	(revision 10670)
+++ reader-irdeto.c	(working copy)
@@ -3,6 +3,17 @@
 #include "oscam-time.h"
 #include "reader-common.h"
 #include "reader-irdeto.h"
+/*
+ident	 = 0624:000000
+rsakey = 2598FE21A1CEF05BBC459F495FCE8F1E811B126FA8933D8DDB6480A93D43CFA7255F009E875814BECF53DA7610D675D20EEBA8A212F9079CBD1D2FAD65362B42
+boxkey = 4FD3B1C6E406AA69
+
+raduga
+boxkey = A2A3A4A5A6A7A8A9
+rsakey = 45D2D094A62F1AC323A257C848549BEC3EBE992B8E68A125B513A69D01764760DBC4FC160077677DC28B7E708F38F014E7388E96817AC9DDC8149984EB43A12F
+camkey = A0A1A2A3A4A5A6A7
+camkey_data = CAFB64CA970D10DEDF769EDA1A570713C50BE71CA871194FF5820BF7B54606BBB8EC7A1D51B1649A3ED222B53EC58F5638F1E2699F509F3089AFE291CAF5E23C
+*/
 
 static const uchar CryptTable[256] =
 {
@@ -82,16 +93,14 @@
 #define ACS57GET  0xD2
 /* end define */
 
-typedef struct chid_base_date
-{
+typedef struct chid_base_date {
 	uint16_t caid;
 	uint16_t acs;
 	char c_code[4];
 	uint32_t base;
 } CHID_BASE_DATE;
 
-struct irdeto_data
-{
+struct irdeto_data {
 	int32_t  acs57;             // A flag for the ACS57 ITA DVB-T
 	uint16_t acs;
 	char     country_code[3];   // irdeto country code.
@@ -138,8 +147,7 @@
 static unsigned char XorSum(const unsigned char *mem, int len)
 {
 	unsigned char cs = 0;
-	while(len > 0)
-	{
+	while (len>0) {
 		cs ^= *mem++;
 		len--;
 	}
@@ -159,7 +167,8 @@
 	// this is the known default value.
 	uint32_t date_base = 870393600L; // this is actually 01.08.1997, 00:00
 	// CAID, ACS, Country, base date       D . M.   Y, h : m
-	CHID_BASE_DATE table[] = { {0x0604, 0x1541, "GRC", 977817600L},    // 26.12.2000, 00:00
+    CHID_BASE_DATE table[] = {
+			{0x0604, 0x1541, "GRC",  977817600L}, 	// 26.12.2000, 00:00
 		{0x0604, 0x1542, "GRC", 977817600L},    // 26.12.2000, 00:00
 		{0x0604, 0x1543, "GRC", 977817600L},    // 26.12.2000, 00:00
 		{0x0604, 0x1544, "GRC", 977817600L},    // 26.12.2000, 17:00
@@ -204,10 +213,8 @@
 	// now check for specific providers base date
 	int32_t i = 0;
 	struct irdeto_data *csystem_data = reader->csystem_data;
-	while(table[i].caid)
-	{
-		if(reader->caid == table[i].caid && csystem_data->acs == table[i].acs && !memcmp(csystem_data->country_code, table[i].c_code, 3))
-		{
+	while (table[i].caid) {
+		if (reader->caid==table[i].caid && csystem_data->acs==table[i].acs && !memcmp(csystem_data->country_code,table[i].c_code,3) ) {
 			date_base = table[i].base;
 			break;
 		}
@@ -215,11 +222,12 @@
 	}
 
 	time_t ut = date_base + date * (24 * 3600);
-	if(buf)
-	{
+	if (buf) {
 		struct tm t;
 		cs_gmtime_r(&ut, &t);
-		snprintf(buf, l, "%04d/%02d/%02d", t.tm_year + 1900, t.tm_mon + 1, t.tm_mday);
+	// sky(date)
+	//	snprintf(buf, l, "%04d/%02d/%02d", t.tm_year+1900, t.tm_mon+1, t.tm_mday);
+		snprintf(buf, l, "%02d/%02d/%04d", t.tm_mday, t.tm_mon + 1, t.tm_year + 1900);
 	}
 	return (ut);
 }
@@ -228,9 +236,9 @@
 {
 	int32_t rc;
 	if((rc = reader_cmd2icc(reader, buf, buf[4] + 5, cta_res, p_cta_lr)))
-		{ return (rc); }        // result may be 0 (success) or negative
+		return (rc);			// result may be 0 (success) or negative
 	if(*p_cta_lr < 2)
-		{ return (0x7F7F); }    // this should never happen
+		return (0x7F7F);		// this should never happen
 	return (good != b2i(2, cta_res + *p_cta_lr - 2));
 }
 
@@ -256,8 +264,7 @@
 	for(buf[0] = i = p = 0; i < reader->nprov; i++)
 	{
 		int32_t acspadd = 0;
-		if(csystem_data->acs57 == 1)
-		{
+		if (csystem_data->acs57==1) {
 			acspadd = 8;
 			sc_Acs57Prov[3] = i;
 			irdeto_do_cmd(reader, sc_Acs57Prov, 0x9021, cta_res, &cta_lr);
@@ -267,8 +274,7 @@
 			sc_Acs57Prov[5]++;
 			sc_Acs57_Cmd[3]++;
 		}
-		else
-		{
+		else {
 			sc_GetProvider[3] = i;
 			reader_chk_cmd(sc_GetProvider, 0);
 		}
@@ -289,12 +295,13 @@
 
 			snprintf((char *) buf + strlen((char *)buf), sizeof(buf) - strlen((char *)buf), ",%06x", b2i(3, &reader->prid[i][1]));
 		}
-		else
-			{ reader->prid[i][0] = 0xf; }
+		else {
+			reader->prid[i][0] = 0xf;
+		}
+	}
+	if (p) {
+		rdr_log(reader, "active providers: %d (%s)", p, buf + 1);
 	}
-	if(p)
-		{ rdr_log(reader, "active providers: %d (%s)", p, buf + 1); }
-
 	return OK;
 }
 
@@ -316,6 +323,16 @@
 								  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 								  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
 								};
+	uchar	sc_AcsCamkeyNone[]	= { 0x02, 0x09, 0x03, 0x00, 0x40,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		                          	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+										  };
 
 	uchar   sc_GetASCIISerial[] = { 0x02, 0x00, 0x03, 0x00, 0x00 },
 								  sc_GetHEXSerial[]   = { 0x02, 0x01, 0x00, 0x00, 0x00 },
@@ -333,123 +350,94 @@
 	int32_t acspadd = 0;
 	int32_t acs57 = 0;
 	if(!memcmp(atr + 4, "IRDETO", 6))
-		{ acs57 = 0; }
-	else
-	{
-		if((!memcmp(atr + 5, "IRDETO", 6)) || ((atr[6] == 0xC4 && atr[9] == 0x8F && atr[10] == 0xF1) && reader->force_irdeto))
-		{
+		acs57=0;
+	else {
+		if ((!memcmp(atr+5, "IRDETO", 6)) || ((atr[6]==0xC4 && atr[9]==0x8F && atr[10]==0xF1) && reader->force_irdeto)) {
 			acs57 = 1;
 			acspadd = 8;
 			rdr_log(reader, "Hist. Bytes: %s", atr + 5);
 		}
-		else
-		{
+		else {
 			return ERROR;
 		}
 	}
 
 	if(!cs_malloc(&reader->csystem_data, sizeof(struct irdeto_data)))
-		{ return ERROR; }
+		return ERROR;
 	struct irdeto_data *csystem_data = reader->csystem_data;
 	csystem_data->acs57 = acs57;
 
-	rdr_log(reader, "detect irdeto card");
-	if(check_filled(reader->rsa_mod, 64) > 0 && (!reader->force_irdeto || csystem_data->acs57))  // we use rsa from config as camkey
-	{
-		char tmp_dbg[65];
-		rdr_log_dbg(reader, D_READER, "using camkey data from config");
-		rdr_log_dbg(reader, D_READER, "     camkey: %s", cs_hexdump(0, reader->boxkey, sizeof(reader->boxkey), tmp_dbg, sizeof(tmp_dbg)));
-		if(csystem_data->acs57 == 1)
-		{
-			memcpy(&sc_Acs57CamKey[5], reader->rsa_mod, 0x40);
-			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_Acs57CamKey[5], 32, tmp_dbg, sizeof(tmp_dbg)));
-			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_Acs57CamKey[37], 32, tmp_dbg, sizeof(tmp_dbg)));
-		}
-		else
-		{
-			memcpy(&sc_GetCamKey383C[5], reader->rsa_mod, 0x40);
-			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_GetCamKey383C[5], 32, tmp_dbg, sizeof(tmp_dbg)));
-			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_GetCamKey383C[37], 32, tmp_dbg, sizeof(tmp_dbg)));
-		}
-	}
-	else
-	{
-		if(csystem_data->acs57 == 1)
-		{
-			rdr_log(reader, "WARNING: ACS57 card can require the CamKey from config");
-		}
-		else
-		{
-			memcpy(reader->boxkey, "\x11\x22\x33\x44\x55\x66\x77\x88", 8);
-		}
-	}
+	rdr_log(reader, "detect irdeto card{%d,%d}", reader->force_irdeto, csystem_data->acs57);
 	/*
 	 * Get Irdeto Smartcard Details - version - patch level etc
 	 */
-	if(csystem_data->acs57 == 0)
-	{
+	if (csystem_data->acs57==0) {
 		if(!irdeto_do_cmd(reader, sc_GetSCDetails, 0, cta_res, &cta_lr))
-			rdr_log(reader, "Irdeto SC %0x version %0x revision %0x, patch level %0x", cta_res[0 + acspadd],
+			rdr_log(reader,"Irdeto SC %0x version %0x revision %0x, patch level %0x",
+						cta_res[0+acspadd],
 					cta_res[1 + acspadd], cta_res[2 + acspadd], cta_res[5 + acspadd]);
 	}
 	/*
 	 * CountryCode
 	 */
-	if(csystem_data->acs57 == 1)
-	{
+	if (csystem_data->acs57==1) {
 		irdeto_do_cmd(reader, sc_Acs57Country, 0x9019, cta_res, &cta_lr);
 		int32_t acslength = cta_res[cta_lr - 1];
 		sc_Acs57_Cmd[4] = acslength;
 		reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
 	}
-	else
-	{
+	else {
 		reader_chk_cmd(sc_GetCountryCode, 18);
 	}
 	csystem_data->acs = (cta_res[0 + acspadd] << 8) | cta_res[1 + acspadd];
 	reader->caid = (cta_res[5 + acspadd] << 8) | cta_res[6 + acspadd];
 	memcpy(csystem_data->country_code, cta_res + 13 + acspadd, 3);
 	rdr_log(reader, "caid: %04X, acs: %x.%02x, country code: %c%c%c",
-			reader->caid, cta_res[0 + acspadd], cta_res[1 + acspadd], cta_res[13 + acspadd], cta_res[14 + acspadd], cta_res[15 + acspadd]);
+				reader->caid,
+				cta_res[0+acspadd], cta_res[1+acspadd], cta_res[13+acspadd], cta_res[14+acspadd], cta_res[15+acspadd]);
 
 	/*
 	 * Ascii/Hex-Serial
 	 */
-	if(csystem_data->acs57 == 1)
-	{
+	if (csystem_data->acs57==1) {
 		irdeto_do_cmd(reader, sc_Acs57Ascii, 0x901D, cta_res, &cta_lr);
 		int32_t acslength = cta_res[cta_lr - 1];
 		sc_Acs57_Cmd[4] = acslength;
 		reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
 	}
-	else
-	{
+	else {
 		reader_chk_cmd(sc_GetASCIISerial, 22);
 	}
 	memcpy(buf, cta_res + acspadd, 10);
 	buf[10] = 0;
-	if(csystem_data->acs57 == 1)
-	{
+	//
+	// sky(oscam.smartcard)
+	reader->acs = csystem_data->acs;
+	memcpy(reader->country_code, csystem_data->country_code, 3);
+	strcpy(reader->ascserial, (char *)buf);
+	//
+	//
+	if (csystem_data->acs57==1) {
 		irdeto_do_cmd(reader, sc_Acs57Hex, 0x903E, cta_res, &cta_lr);
 		int32_t acslength = cta_res[cta_lr - 1];
 		sc_Acs57_Cmd[4] = acslength;
 		reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
 	}
-	else
-	{
+	else {
 		reader_chk_cmd(sc_GetHEXSerial, 18);
 	}
 	reader->nprov = cta_res[10 + acspadd];
+	if (reader->nprov > CS_MAXPROV) reader->nprov = CS_MAXPROV;
 	memcpy(reader->hexserial, cta_res + 12 + acspadd, 4);
 
 	rdr_log_sensitive(reader, "providers: %d, ascii serial: {%s}, hex serial: {%02X%02X%02X}, hex base: {%02X}",
-					  reader->nprov, buf, reader->hexserial[0], reader->hexserial[1], reader->hexserial[2], reader->hexserial[3]);
+				reader->nprov, buf,
+				reader->hexserial[0], reader->hexserial[1], reader->hexserial[2], reader->hexserial[3]);
 
 	/*
 	 * CardFile
 	 */
-	if(csystem_data->acs57 == 1)
-	{
+	if (csystem_data->acs57==1) {
 		irdeto_do_cmd(reader, sc_Acs57CFile, 0x9049, cta_res, &cta_lr);
 		int32_t acslength = cta_res[cta_lr - 1];
 		sc_Acs57_Cmd[4] = acslength;
@@ -463,10 +451,9 @@
 		reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
 		sc_Acs57_Cmd[2] = 0x00;
 	}
-	else
-	{
+	else {
 		for(sc_GetCardFile[2] = 2; sc_GetCardFile[2] < 4; sc_GetCardFile[2]++)
-			{ reader_chk_cmd(sc_GetCardFile, 0); }
+			reader_chk_cmd(sc_GetCardFile, 0);
 	}
 
 	/*
@@ -476,27 +463,52 @@
 	{
 		switch(reader->caid)
 		{
-		case 0x1702:
-			camkey = 1;
-			break;
-		case 0x1722:
-			camkey = 2;
-			break;
-		case 0x1762:
-			camkey = 3;
-			break;
+			case 0x1702: camkey = 1; break;
+			case 0x1722: camkey = 2; break;
+			case 0x1762: camkey = 3; break;
 			//      case 0x0624: camkey = 4; break; //ice 0D96/0624 has short ATR
-		default    :
-			camkey = 5;
-			break;
+			default    : camkey = 5; break;
 		}
 	}
 
-	if((reader->caid == 0x0648) || (reader->caid == 0x0666) || (reader->caid == 0x0624))    // acs 6.08 and ice 0D96/0624
-	{
+	if ((reader->caid == 0x0648) || (reader->caid == 0x0666) || (reader->caid == 0x0624)) { // acs 6.08 and ice 0D96/0624
 		camkey = 4;
 		sc_Acs57CamKey[2] = 0;
 	}
+	// sky(!)
+	rdr_log_dbg(reader, D_READER, "using camkey data{%d,%d} from config", csystem_data->acs57, camkey);
+	if (check_filled(reader->rsa_mod, 64) > 0 && (!reader->force_irdeto || csystem_data->acs57)) // we use rsa from config as camkey
+	{
+		char tmp_dbg[65];
+		rdr_log_dbg(reader, D_READER, "      camkey: %s",   cs_hexdump(0, reader->boxkey, 8, tmp_dbg, sizeof(tmp_dbg)));
+		if (csystem_data->acs57==1) {
+			memcpy(&sc_Acs57CamKey[5], reader->rsa_mod, 0x40);
+			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_Acs57CamKey[ 5], 32, tmp_dbg, sizeof(tmp_dbg)));
+			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_Acs57CamKey[37], 32, tmp_dbg, sizeof(tmp_dbg)));
+		}
+		else if (camkey>1 && camkey<4) {
+			memcpy(&sc_GetCamKey383C[5], reader->rsa_mod, 0x40);
+			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_GetCamKey383C[ 5], 32, tmp_dbg, sizeof(tmp_dbg)));
+			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_GetCamKey383C[37], 32, tmp_dbg, sizeof(tmp_dbg)));
+		}
+		else {
+			memcpy(&sc_AcsCamkeyNone[5], reader->rsa_mod, 0x40);
+			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_AcsCamkeyNone[ 5], 32, tmp_dbg, sizeof(tmp_dbg)));
+			rdr_log_dbg(reader, D_READER, "camkey-data: %s", cs_hexdump(0, &sc_AcsCamkeyNone[37], 32, tmp_dbg, sizeof(tmp_dbg)));
+		}
+	}
+	else {
+		if (csystem_data->acs57==1) {
+			rdr_log(reader, "WARNING: ACS57 card can require the CamKey from config");
+			memset(&sc_Acs57CamKey[5], 0x0, 0x40);
+		}
+		else if (camkey>1 && camkey<4) {
+			memcpy(reader->boxkey, "\x11\x22\x33\x44\x55\x66\x77\x88", 8);
+		}
+		else {
+			memset(&sc_AcsCamkeyNone[5], 0x0, 0x40);
+		}
+	}
 // Dirthy hack for Ziggo will be removed when optimum values are find on these T14 cards for v2 and triple
 // There are also other readers suffering from simmilar issue for those cards.
     if(((reader->caid == 0x0604) || (reader->caid == 0x1722)) && (reader->typ == R_SMART) &&  (reader->smart_type >= 2)) 
@@ -523,19 +535,19 @@
 		crc ^= 0x01, crc ^= 0x02, crc ^= 0x09;
 		crc ^= sc_Acs57CamKey[2], crc ^= sc_Acs57CamKey[3], crc ^= (sc_Acs57CamKey[4] + 1);
 		for(i = 5; i < (int)sizeof(sc_Acs57CamKey) - 1; i++)
-			{ crc ^= sc_Acs57CamKey[i]; }
+					crc^=sc_Acs57CamKey[i];
 		sc_Acs57CamKey[69] = crc;
-		if((reader->caid == 0x0648) || (reader->caid == 0x0666) || (reader->caid == 0x0624))
-		{
+				if ((reader->caid == 0x0648) || (reader->caid == 0x0666) || (reader->caid == 0x0624)) {
 			sc_Acs57CamKey[69] = XorSum(sc_Acs57CamKey, 69) ^ 0x3f ^(sc_Acs57CamKey[0] & 0xf0) ^ 0x1b;
-			if(irdeto_do_cmd(reader, sc_Acs57CamKey, 0x9011, cta_res, &cta_lr))
-			{
+					if (irdeto_do_cmd(reader, sc_Acs57CamKey, 0x9011, cta_res, &cta_lr)) {
 				rdr_log(reader, "You have a bad Cam Key set");
-				return ERROR;
+						mycs_trace(D_ADB, "mycard:irdeto cam key fail");
+					//	return ERROR;
 			}
 		}
-		else
-			{ irdeto_do_cmd(reader, sc_Acs57CamKey, 0x9012, cta_res, &cta_lr); }
+				else {
+					irdeto_do_cmd(reader, sc_Acs57CamKey, 0x9012, cta_res, &cta_lr);
+				}
 		int32_t acslength = cta_res[cta_lr - 1];
 		sc_Acs57_Cmd[4] = acslength;
 		reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
@@ -554,21 +566,22 @@
     break; 
 // end dirthy hack
 	default:
-		if(csystem_data->acs57 == 1)
-		{
+			if (csystem_data->acs57==1) {
 			int32_t i, crc = 0x76;
 			for(i = 6; i < (int)sizeof(sc_Acs57CamKey) - 1; i++)
-				{ crc ^= sc_Acs57CamKey[i]; }
+					crc^=sc_Acs57CamKey[i];
 			sc_Acs57CamKey[69] = crc;
 			irdeto_do_cmd(reader, sc_Acs57CamKey, 0x9012, cta_res, &cta_lr);
 			int32_t acslength = cta_res[cta_lr - 1];
 			sc_Acs57_Cmd[4] = acslength;
 			reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
 		}
-		else
-		{
+			else if (camkey>1 && camkey<4) {
 			reader_chk_cmd(sc_GetCamKey383C, 0);
 		}
+			else {
+				reader_chk_cmd(sc_AcsCamkeyNone, 0);
+			}
 		break;
 	}
 	if((reader->cardmhz != 600 && reader->typ != R_INTERNAL) || (reader->typ == R_INTERNAL && (reader->mhz < 510 || reader->cardmhz > 690)))
@@ -588,12 +601,10 @@
 	struct irdeto_data *csystem_data = reader->csystem_data;
 
 	int32_t i = 0, acspadd = 0;
-	if(csystem_data->acs57 == 1)
-	{
+	if (csystem_data->acs57==1) {
 		int32_t crc = 63;
 		sc_Acs57Ecm[4] = er->ecm[2] - 2;
-		if((reader->caid == 0x0648) || (reader->caid == 0x0666) || (reader->caid == 0x0624))    //crc for orf, cslink, skylink
-		{
+		if ((reader->caid == 0x0648) || (reader->caid == 0x0666) || (reader->caid == 0x0624)) {	//crc for orf, cslink, skylink
 			sc_Acs57Ecm[2] = 0;
 			crc ^= 0x01;
 			crc ^= 0x05;
@@ -601,10 +612,9 @@
 			crc ^= sc_Acs57Ecm[3];
 			crc ^= (sc_Acs57Ecm[4] - 1);
 			for(i = 6; i < er->ecm[2] + 4; i++)
-				{ crc ^= er->ecm[i]; }
+				crc^=er->ecm[i];
 		}
-		else
-		{
+		else {
 			sc_Acs57Ecm[2] = er->ecm[6];
 			crc ^= 0x01;
 			crc ^= 0x05;
@@ -612,7 +622,7 @@
 			crc ^= sc_Acs57Ecm[3];
 			crc ^= (sc_Acs57Ecm[4] - 1);
 			for(i = 6; i < er->ecm[3] - 5; i++)
-				{ crc ^= er->ecm[i]; }
+				crc^=er->ecm[i];
 		}
 		memcpy(cta_cmd, sc_Acs57Ecm, sizeof(sc_Acs57Ecm));
 		memcpy(cta_cmd + 5, er->ecm + 6, er->ecm[2] - 1);
@@ -621,10 +631,8 @@
 		irdeto_do_cmd(reader, cta_cmd, 0, cta_res, &cta_lr);
 		int32_t acslength = cta_res[cta_lr - 1];
 		// If acslength != 0x1F you don't have the entitlements or you camkey is bad
-		if(acslength != 0x1F)
-		{
-			switch(acslength)
-			{
+		if (acslength!=0x1F) {
+			switch (acslength) {
 			case 0x09:
 				rdr_log(reader, "Maybe you don't have the entitlements for this channel");
 				break;
@@ -639,27 +647,23 @@
 		reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
 		acspadd = 8;
 	}
-	else
-	{
+	else {
 		memcpy(cta_cmd, sc_EcmCmd, sizeof(sc_EcmCmd));
 		cta_cmd[4] = (er->ecm[2]) - 3;
 		memcpy(cta_cmd + sizeof(sc_EcmCmd), &er->ecm[6], cta_cmd[4]);
 
 		int32_t try = 1;
 		int32_t ret;
-		do
-		{
+		do {
 			if(try > 1)
 					snprintf(ea->msglog, MSGLOGSIZE, "%s irdeto_do_cmd try nr %i", reader->label, try);
 			ret = (irdeto_do_cmd(reader, cta_cmd, 0x9D00, cta_res, &cta_lr));
 			ret = ret || (cta_lr < 24);
 			if(ret)
-				{ snprintf(ea->msglog, MSGLOGSIZE, "%s irdeto_do_cmd [%d] %02x %02x", reader->label, cta_lr, cta_res[cta_lr - 2], cta_res[cta_lr - 1]); }
+				snprintf( ea->msglog, MSGLOGSIZE, "%s irdeto_do_cmd [%d] %02x %02x", reader->label, cta_lr, cta_res[cta_lr - 2], cta_res[cta_lr - 1] );
 			try++;
-		}
-		while((try < 3) && (ret));
-		if(ret)
-			{ return ERROR; }
+		} while ((try < 3) && (ret));
+		if (ret) return ERROR;
 	}
 	ReverseSessionKeyCrypt(reader->boxkey, cta_res + 6 + acspadd);
 	ReverseSessionKeyCrypt(reader->boxkey, cta_res + 14 + acspadd);
@@ -676,25 +680,21 @@
 
 	rdr_log_dbg(rdr, D_EMM, "Entered irdeto_get_emm_type ep->emm[3]=%02x", ep->emm[3]);
 
-	switch(l)
-	{
+	switch (l) {
 
 	case 0:
 		// global emm, 0 bytes addressed
 		ep->type = GLOBAL;
 		rdr_log_dbg(rdr, D_EMM, "GLOBAL base = %02x", base);
-		if(base & 0x10)   // hex serial based?
-		{
-			if(base == rdr->hexserial[3])   // does base match?
-			{
+			if (base & 0x10) { // hex serial based?
+				if (base == rdr->hexserial[3]) { // does base match?
 				return 1;
 			}
-			else
-			{
+				else {
 				return 0; // base doesnt match!
 			}
 		}
-		else { return 1; } // provider based, match all!
+			else return 1; // provider based, match all!
 
 	case 2:
 		// shared emm, 2 bytes addressed
@@ -706,20 +706,18 @@
 		rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED l = %d ep = {%s} rdr = {%s} base = %02x", l,
 								 dumpemmserial, dumprdrserial, base);
 
-		if(base & 0x10)
-		{
+			if (base & 0x10) {
 			// hex addressed
 			return (base == rdr->hexserial[3] && !memcmp(ep->emm + 4, rdr->hexserial, l));
 		}
-		else
-		{
+			else {
 			if(!memcmp(ep->emm + 4, rdr->hexserial, l))
-				{ return 1; }
+					return 1;
 
 			// provider addressed
 			for(i = 0; i < rdr->nprov; i++)
 				if(base == rdr->prid[i][0] && !memcmp(ep->emm + 4, &rdr->prid[i][1], l))
-					{ return 1; }
+						return 1;
 		}
 		rdr_log_dbg(rdr, D_EMM, "neither hex nor provider addressed or unknown provider id");
 		return 0;
@@ -736,16 +734,15 @@
 
 		if(base & 0x10)
 			// unique hex addressed
-			{ return (base == rdr->hexserial[3] && !memcmp(ep->emm + 4, rdr->hexserial, l)); }
-		else
-		{
+				return (base == rdr->hexserial[3] && !memcmp(ep->emm + 4, rdr->hexserial, l));
+			else {
 			if(!memcmp(ep->emm + 4, rdr->hexserial, l))
-				{ return 1; }
+					return 1;
 
 			// unique provider addressed
 			for(i = 0; i < rdr->nprov; i++)
 				if(base == rdr->prid[i][0] && !memcmp(ep->emm + 4, &rdr->prid[i][1], l))
-					{ return 1; }
+						return 1;
 		}
 		rdr_log_dbg(rdr, D_EMM, "neither hex nor provider addressed or unknown provider id");
 		return 0;
@@ -762,9 +759,9 @@
 {
 	if(*emm_filters == NULL)
 	{
-		const unsigned int max_filter_count = 3 + (rdr->nprov * 2);
-		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+		const unsigned int max_filters = 3 + (rdr->nprov * 2);
+		if (!cs_malloc(emm_filters, max_filters * sizeof(struct s_csystem_emm_filter)))
+			return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
@@ -841,9 +838,9 @@
 {
 	if(*emm_filters == NULL)
 	{
-		const unsigned int max_filter_count = 3;
-		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+      const unsigned int max_filters = 3;
+    	if (!cs_malloc(emm_filters, max_filters * sizeof(struct s_csystem_emm_filter)))
+      	return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
@@ -891,31 +888,28 @@
 	memset(bt_emm, 0, sizeof(bt_emm));
 
 	ep->type = UNKNOWN;
-	if(ep->emm[0] == 0x83 && ep->emm[5] == 0x10)
-	{
+	if (ep->emm[0] == 0x83 && ep->emm[5] == 0x10) {
 		if(ep->emm[7] == 0x00)
-			{ ep->type = UNIQUE; }
+			ep->type = UNIQUE;
 		else
-			{ ep->type = SHARED; }
+			ep->type = SHARED;
 	}
-	else
-	{
+	else {
 		if(ep->emm[0] == 0x82)
-			{ ep->type = GLOBAL; }
+			ep->type = GLOBAL;
 	}
 
 	if(ep->type != UNKNOWN && ep->emmlen == 142)
-		{ cs_log_dbg(D_EMM, "[TUN_EMM] Type: %s - rewriting header", typtext[ep->type]); }
+		cs_log_dbg(D_EMM, "[TUN_EMM] Type: %s - rewriting header", typtext[ep->type]);
 	else
-		{ return; }
+		return;
 
 	// BETACRYPT/IRDETO EMM HEADER:
 	static uint8_t headerD0[6] = { 0x82, 0x70, 0x89, 0xd0, 0x01, 0x00 };  // GLOBAL
 	static uint8_t headerD2[8] = { 0x82, 0x70, 0x8b, 0xd2, 0x00, 0x00, 0x01, 0x00 };   // SHARED
 	static uint8_t headerD3[9] = { 0x82, 0x70, 0x8c, 0xd3, 0x00, 0x00, 0x00, 0x01, 0x00 };  // UNIQUE
 
-	switch(ep->type)
-	{
+	switch (ep->type) {
 	case UNIQUE:
 		memcpy(bt_emm, headerD3, sizeof(headerD3));
 		memcpy(bt_emm + sizeof(headerD3), ep->emm + 8, ep->emmlen - 8);
@@ -951,8 +945,7 @@
 	struct irdeto_data *csystem_data = reader->csystem_data;
 
 	uchar cta_cmd[272];
-	if(ep->emm[0] != 0x82)
-	{
+	if (ep->emm[0] != 0x82) {
 		rdr_log_dbg(reader, D_EMM, "Invalid EMM: Has to start with 0x82, but starts with %02x!", ep->emm[0]);
 		return ERROR;
 	}
@@ -961,44 +954,35 @@
 	int32_t mode = (ep->emm[3] >> 3);
 	uchar *emm = ep->emm;
 
-	if(mode & 0x10)
-	{
+	if (mode & 0x10) {
 		// hex addressed
 		ok = (mode == reader->hexserial[3] && (!l || !memcmp(&emm[4], reader->hexserial, l)));
 	}
-	else
-	{
+	else {
 		ok = !memcmp(&emm[4], reader->hexserial, l);
 
 		// provider addressed
-		for(i = 0; i < reader->nprov && !ok; i++)
-		{
+		for (i = 0; i < reader->nprov && !ok; i++) {
 			ok = (mode == reader->prid[i][0] && (!l || !memcmp(&emm[4], &reader->prid[i][1], l)));
 		}
 	}
 
-	if(ok)
-	{
+ 	if (ok) {
 		l++;
-		if(l <= ADDRLEN)
-		{
-			if(csystem_data->acs57 == 1)
-			{
+ 		if (l <= ADDRLEN) {
+			if (csystem_data->acs57==1) {
 				int32_t dataLen = 0;
-				if(ep->type == UNIQUE)
-				{
+				if (ep->type==UNIQUE) {
 					dataLen = ep->emm[2] - 1;
 				}
-				else
-				{
+				else {
 					dataLen = ep->emm[2];
 				}
-				if(dataLen < 7 || dataLen > (int32_t)sizeof(ep->emm) - 6 || dataLen > (int32_t)sizeof(cta_cmd) - 9)
-				{
+				if (dataLen < 7 || dataLen > (int32_t)sizeof(ep->emm) - 6 || dataLen > (int32_t)sizeof(cta_cmd) - 9) {
 					rdr_log_dbg(reader, D_EMM, "dataLen %d seems wrong, faulty EMM?", dataLen);
 					return ERROR;
 				}
-				if(ep->type == GLOBAL && (reader->caid == 0x0624 || reader->caid == 0x0648 || reader->caid == 0x0666)) { dataLen += 2; }
+				if (ep->type==GLOBAL && (reader->caid==0x0624 || reader->caid==0x0648 || reader->caid == 0x0666)) dataLen+=2;
 				int32_t crc = 63;
 				sc_Acs57Emm[4] = dataLen;
 				memcpy(&cta_cmd, sc_Acs57Emm, sizeof(sc_Acs57Emm));
@@ -1009,29 +993,24 @@
 				crc ^= 0x00;
 				crc ^= (dataLen - 1);
 				memcpy(&cta_cmd[5], &ep->emm[3], 10);
-				if(ep->type == UNIQUE)
-				{
+				if (ep->type==UNIQUE) {
 					memcpy(&cta_cmd[9], &ep->emm[9], dataLen - 4);
 				}
-				else
-				{
-					if(ep->type == GLOBAL && (reader->caid == 0x0624 || reader->caid == 0x0648 || reader->caid == 0x0666))
-					{
+				else {
+					if (ep->type==GLOBAL && (reader->caid==0x0624 || reader->caid==0x0648 || reader->caid == 0x0666)) {
 						memcpy(&cta_cmd[9], &ep->emm[6], 1);
 						memcpy(&cta_cmd[10], &ep->emm[7], dataLen - 6);
 						//                      cta_cmd[9]=0x00;
 					}
-					else if(reader->caid == 0x0624 || reader->caid == 0x0648 || reader->caid == 0x0666)     //only orf, cslink, skylink
-					{
+					else if (reader->caid==0x0624 || reader->caid==0x0648 || reader->caid == 0x0666) {	//only orf, cslink, skylink
 						memcpy(&cta_cmd[9], &ep->emm[8], dataLen - 4);
 					}
-					else
-					{
+					else {
 						memcpy(&cta_cmd[10], &ep->emm[9], dataLen - 6);
 					}
 				}
 				for(i = 5; i < dataLen + 4; i++)
-					{ crc ^= cta_cmd[i]; }
+					crc^=cta_cmd[i];
 				cta_cmd[dataLen - 1 + 5] = crc;
 				irdeto_do_cmd(reader, cta_cmd, 0, cta_res, &cta_lr);
 				int32_t acslength = cta_res[cta_lr - 1];
@@ -1095,16 +1074,14 @@
 	 * ContryCode2
 	 */
 	int32_t acspadd = 0;
-	if(csystem_data->acs57 == 1)
-	{
+	if (csystem_data->acs57==1) {
 		acspadd = 8;
 		reader_chk_cmd(sc_Acs57Code, 0);
 		int32_t acslength = cta_res[cta_lr - 1];
 		sc_Acs57_Cmd[4] = acslength;
 		reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
 	}
-	else
-	{
+	else {
 		reader_chk_cmd(sc_GetCountryCode2, 0);
 	}
 
@@ -1129,8 +1106,7 @@
 				// shouldn't it me the max chid value we read above ?!
 				while(1)  // will exit if cta_lr < 61 .. which is the correct break condition.
 				{
-					if(csystem_data->acs57 == 1)
-					{
+					if (csystem_data->acs57==1) {
 						int32_t crc = 63;
 						sc_Acs57Prid[5] = j;
 						crc ^= 0x01;
@@ -1143,25 +1119,28 @@
 						sc_Acs57Prid[6] = crc;
 						irdeto_do_cmd(reader, sc_Acs57Prid, 0x903C, cta_res, &cta_lr);
 						int32_t acslength = cta_res[cta_lr - 1];
-						if(acslength == 0x09) { break; }
+						if (acslength==0x09) break;
 						sc_Acs57_Cmd[4] = acslength;
 						reader_chk_cmd(sc_Acs57_Cmd, acslength + 2);
-						if(cta_res[10] == 0xFF) { break; }
+						if (cta_res[10]==0xFF) break;
 						cta_res[cta_lr - 3] = 0xff;
 						cta_res[cta_lr - 2] = 0xff;
 						cta_res[cta_lr - 1] = 0xff;
 						acspadd = 8;
 					}
-					else
-					{
+					else {
 						sc_GetChanelIds[5] = j; // chid at index j for provider at index i
 						reader_chk_cmd(sc_GetChanelIds, 0);
 					}
 					// if (cta_lr<61) break; // why 61 (0 to 60 in steps of 6 .. is it 10*6 from the 10 in the for loop ?
 					// what happen if the card only send back.. 9 chids (or less)... we don't see them
 					// so we should check whether or not we have at least 6 bytes (1 chid).
-					if(cta_lr < 6) { break; }
-
+					if (cta_lr<6) break;
+					// sky(for speedup init)
+					if (cs_Isff(cta_res+acspadd,cta_lr-2)) {
+						mycs_trace(D_ADB, "mycard:irdeto chid.cancellation{%d,%d}", i, j);
+						break;
+					}
 					for(k = 0 + acspadd; k < cta_lr; k += 6)
 					{
 						chid = b2i(2, cta_res + k);
@@ -1173,7 +1152,8 @@
 							end_t = chid_date(reader, date + cta_res[k + 4], t + 16, 16);
 
 							// todo: add entitlements to list but produces a warning related to date variable
-							cs_add_entitlement(reader, reader->caid, b2i(3, &reader->prid[i][1]), chid, 0, start_t, end_t, 3, 1);
+                  	// sky(!)
+							cs_add_entitlement(reader, reader->caid, b2i(3, &reader->prid[i][1]), chid, 0, start_t, end_t, 3, NULL, 1);
 
 							if(first)
 							{
Index: reader-nagra.c
===================================================================
--- reader-nagra.c	(revision 10670)
+++ reader-nagra.c	(working copy)
@@ -6,8 +6,7 @@
 #include "reader-common.h"
 #include "oscam-work.h"
 
-struct nagra_data
-{
+struct nagra_data {
 	IDEA_KEY_SCHEDULE ksSession;
 	int8_t          is_pure_nagra;
 	int8_t          is_tiger;
@@ -22,7 +21,429 @@
 	uint8_t         signature[8];
 	uint8_t         cam_state[3];
 };
+// sky()
+// boxKey_Tigers
+//	0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
+static  uint8_t	rsaMod_Tigers[120] = {
+	0xA9,0x2D,0xA7,0x2F,0xEE,0xAC,0xF2,0x94,0x7B,0x00,0x3E,0xD6,0x52,0x15,0x3B,0x18,
+	0x9E,0x40,0x43,0xB0,0x13,0x8C,0x36,0x8B,0xDF,0x6B,0x9E,0xD7,0x7D,0xDA,0xD6,0xC0,
+	0x76,0x1A,0x21,0x98,0xAE,0xB3,0xFC,0x97,0xA1,0x9C,0x9D,0x01,0xCA,0x76,0x9B,0x3F,
+	0xFF,0xE4,0xF6,0xE7,0x0F,0xA4,0xE0,0x69,0x6A,0x89,0x80,0xE1,0x8D,0x8C,0x58,0xE1,
+	0x1D,0x81,0x71,0x21,0x34,0x6E,0x3E,0x66,0x45,0x7F,0xDD,0x84,0xCF,0xA7,0x25,0x89,
+	0xB2,0x5B,0x53,0x8E,0xFC,0x30,0x43,0x61,0xB5,0x48,0x45,0xF3,0x9E,0x9E,0xFA,0x52,
+	0xD8,0x05,0xE5,0xFD,0x86,0xB5,0x95,0xB3,0x66,0xC3,0x57,0x16,0xAB,0xC9,0x1F,0xA3,
+	0xDC,0x15,0x9C,0x9F,0x4D,0x81,0x64,0xB5,
+};
+
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//
+//
+// sky()
+//	#define __simulation_ukcable__
+//
+//
+#if defined(__simulation_ukcable__)
+	#define __UK_CABLE__
+//	#define __EPCS_SOURCE_BOX__
+//	#define __BRAZIL__
+
+	#define UKCABLE_DATALENN	(4+8+64)	// irdid(4),boxkey(signature)(8),rsakey(64)
+
+	static uint8_t	ukcable_dt08_natives[][UKCABLE_DATALENN] = {
+			#if defined(__BRAZIL__)
+				{	0x61,0x1E,0x1E,0xFE,
+					0x0E,0x5C,0x0A,0xDB,0x94,0x31,0x47,0x6A,
+					0xD3,0x65,0xAF,0xF9,0x7D,0x08,0x05,0x38,0x02,0xC5,0xBC,0x3E,0x78,0x5A,0xC8,0x59,
+					0x34,0x80,0x4C,0x06,0x09,0x97,0xB8,0x1B,0x18,0x42,0xE7,0x3C,0xA8,0x13,0x7B,0x82,
+					0x79,0x58,0x23,0x83,0x63,0x0F,0x25,0x9E,0x9E,0x6B,0x7A,0x6C,0x7A,0xE1,0x96,0xA5,
+					0x9F,0xA1,0xD4,0x8A,0xEB,0x1B,0x6D,0x05,0x93,0x68,0x0A,0xF6,0xCC,0x9C,0x95,0x6B,
+				},
+				{	0x63,0x6F,0xDB,0xD7,
+					0x52,0xE9,0xA0,0x5F,0xC4,0xFB,0xBD,0x1B,
+					0x89,0x8E,0xC5,0xD0,0x22,0xB2,0x96,0x3C,0x5F,0x7C,0x39,0x23,0xBE,0xCF,0xB2,0x3B,
+					0x9A,0xBB,0x3B,0xF8,0x81,0x3E,0xD3,0x35,0x2C,0x9A,0x92,0x1A,0x78,0x96,0xCC,0xE6,
+					0xB4,0x55,0x67,0x21,0x61,0x29,0x68,0xE9,0x65,0x0E,0x16,0xC2,0x2B,0x52,0xAC,0xF5,
+					0x06,0x1E,0x6B,0x5E,0x9E,0xC8,0xDE,0x48,0x79,0x8B,0x13,0x86,0x91,0x11,0xF8,0x67,
+				},
+				{	0x61,0x18,0xEC,0xF4,
+					0xA7,0x3F,0x03,0x0D,0x00,0xF1,0x54,0xD6,
+					0xA9,0xB7,0xD4,0x7F,0x9A,0x8D,0x59,0xCB,0xF4,0xDE,0x4F,0x78,0x89,0x0D,0xD6,0x8E,
+					0x50,0x3E,0x94,0x12,0xA1,0x03,0xAD,0x42,0xE2,0xF2,0xD9,0x8B,0x7B,0x5E,0x2F,0x1F,
+					0x24,0xB3,0xF8,0xBE,0x11,0xD7,0x04,0x26,0x62,0x4C,0x66,0x33,0x87,0x4F,0x50,0x4E,
+					0x73,0x6D,0x13,0x28,0xA1,0xB7,0x8B,0xBC,0x45,0x44,0xB8,0x04,0x6E,0xBF,0xC1,0x99,
+				},
+				{	0x61,0x16,0x4F,0xF9,
+					0x45,0xB0,0xA7,0x20,0x74,0xCF,0x7B,0x69,
+					0x94,0x8A,0xFB,0x14,0x5C,0x59,0x68,0x73,0x6C,0x94,0x38,0xBA,0x91,0x08,0x15,0x58,
+					0x5D,0x58,0x3F,0x60,0x03,0xB0,0x30,0xB7,0x80,0x99,0x3C,0x29,0xBD,0x99,0x5E,0x74,
+					0x92,0xF1,0x38,0x35,0xD9,0xF1,0xE7,0x72,0x65,0x49,0x53,0x24,0x7D,0xEE,0x5E,0xE6,
+					0xAD,0x9A,0xBF,0x94,0xBF,0xD2,0x53,0x45,0x19,0x89,0x92,0xBB,0x14,0xFA,0xCE,0x7B,
+				},
+				{	0x64,0x67,0x72,0xFF,	//Embratel
+					0x9D,0x87,0x4C,0x29,0xDA,0xA1,0x2D,0x53,
+					0xE6,0xDA,0xA7,0x8A,0x57,0x87,0x56,0x18,0xBD,0x41,0x7C,0x0E,0xF6,0x9E,0x2E,0xD8,
+					0xB9,0x4E,0x6E,0x1B,0x37,0x71,0x77,0x26,0x7F,0x47,0x22,0x24,0xBF,0x17,0x2B,0x37,
+					0x8B,0x31,0x32,0x43,0x2F,0xF3,0x0E,0x5B,0x1C,0x32,0x5E,0x2E,0x5F,0xB3,0x39,0x51,
+					0x9D,0xD4,0x05,0x53,0x7B,0xFB,0x95,0x12,0x1F,0x0B,0x77,0xA6,0x8B,0x7B,0x56,0x1B,
+				},
+				{	0x64,0x66,0xB3,0xE8,	//Embratel
+					0x54,0x48,0xDD,0x34,0xDD,0x79,0x01,0x1F,
+					0x86,0x13,0xCD,0x01,0xF0,0xF3,0x10,0xA8,0xB2,0x12,0xC3,0xB3,0x20,0x27,0xD1,0xAD,
+					0x2F,0xF1,0x72,0x50,0x52,0xBC,0x15,0x54,0xBD,0x10,0x68,0xC5,0xA6,0x1D,0x5D,0x15,
+					0x7D,0x28,0xC2,0xCB,0xE5,0x22,0x7E,0x5F,0x88,0x71,0xBD,0x59,0x08,0xEE,0x64,0xE6,
+					0x3C,0x00,0x50,0x24,0x9E,0x6D,0xF6,0x93,0x45,0xA7,0x96,0x33,0xDB,0xAB,0x3A,0x93
+				},
+			#endif
+			#if defined(__UK_CABLE__)
+				// BATA:ok
+				{	0x66,0xBD,0x68,0x81,
+					0x3E,0x13,0x2F,0x62,0x23,0x6A,0x0F,0xDF,
+					0x90,0x72,0xE1,0x57,0x2C,0x3A,0x2A,0x6C,0xA0,0xE3,0x25,0xA6,0x47,0xD6,0x8D,0x39,
+					0xFD,0x35,0x67,0x98,0x2C,0x80,0x95,0x83,0x4B,0x04,0x16,0xF1,0x06,0xD2,0x50,0x1E,
+					0x54,0xD1,0x62,0x36,0xFF,0x28,0x83,0x56,0x84,0x4A,0xB4,0xCA,0xA7,0x46,0xDD,0xDF,
+					0x58,0x91,0xAB,0x4C,0xF7,0x9D,0xB7,0xEF,0xAF,0xB2,0x91,0xFE,0x68,0x3C,0x4B,0x41,
+				},
+			/*
+				// VSTVcard
+				{	0x66,0xA1,0xDC,0xA4,
+					0x37,0x93,0x7D,0xE0,0xF0,0x97,0x67,0x37,
+					0xB1,0x23,0xA1,0x2F,0x8B,0x84,0xC4,0x2B,0x64,0x97,0x23,0xC9,0x27,0xA0,0xFC,0x40,
+					0xDA,0x4A,0xD3,0x85,0x38,0xEC,0xA1,0x5C,0xC1,0xE0,0x38,0xBD,0xB6,0xEF,0x91,0x5F,
+					0x22,0x57,0x8B,0xF9,0xED,0x2A,0xAA,0x51,0xA7,0x7B,0xF7,0xDD,0xC1,0x3B,0xD8,0x54,
+					0xD1,0x4A,0x4B,0xA6,0xAC,0xE9,0xC1,0xE5,0xE7,0x3E630xCC,0x3F,0xC1,0x4C,0xE7,0x21,0x65,
+				},
+			*/
+				{	0x3E,0x6E,0x9C,0x2A,
+					0xB5,0xF9,0x8C,0xC5,0x02,0x20,0xA7,0x03,
+					0x8A,0x33,0xC9,0xBA,0x20,0xFC,0x09,0x19,0x3A,0x60,0x0C,0x5B,0xEB,0xCF,0xB2,0x54,
+					0x71,0xDD,0x56,0xEF,0x76,0x40,0x05,0xFE,0x60,0xC4,0x84,0x49,0x12,0xED,0xD1,0x8F,
+					0x37,0x51,0x27,0x0E,0xE0,0x83,0x42,0x7E,0x79,0x9C,0x92,0x7F,0xD8,0x96,0xE9,0x7D,
+					0xF3,0xF9,0x40,0x0E,0x11,0xEC,0xDD,0x58,0x7E,0xCA,0x90,0x38,0x69,0xC6,0xFF,0xCF,
+				},
+				#ifdef __EPCS_SOURCE_BOX__
+				{	0x63,0xBC,0x70,0x9D,
+					0xEE,0x0F,0xF7,0x78,0x66,0xFE,0x9F,0xE6,
+					0xA0,0x1B,0xB1,0xDC,0xD0,0x5D,0x36,0xFE,0xEB,0x05,0x97,0x6C,0x43,0x27,0x5A,0x0A,
+					0xC3,0xE4,0xC3,0x20,0x01,0xCD,0xC7,0xEF,0xBA,0x6E,0x95,0x91,0x10,0x80,0x7E,0xFC,
+					0x25,0x42,0x6A,0x47,0xA0,0x60,0x79,0xCA,0x43,0x58,0x0D,0x40,0xB7,0x82,0xF9,0xCC,
+					0xAC,0x6C,0xD1,0x02,0x3F,0x03,0xAB,0x72,0x4B,0x66,0x75,0x22,0x7F,0x24,0xE5,0x15,
+				},
+				{	0x3E,0x68,0xD7,0x01,
+					0x5E,0xB7,0x6F,0xAC,0x63,0xB1,0x0E,0xEE,
+					0xC9,0x6E,0x0D,0x24,0xF1,0xB3,0x58,0x15,0x66,0x08,0x2E,0x6B,0xC1,0xFA,0x40,0x26,
+					0x16,0xCC,0xD8,0x87,0x83,0x59,0x6D,0xAB,0xA0,0xFE,0x26,0x05,0x6D,0xBC,0xAE,0x17,
+					0x7A,0xC2,0x81,0x12,0xCC,0xAE,0x77,0xE2,0x4C,0x56,0x21,0x58,0xD3,0xC9,0xC0,0xCC,
+					0x78,0x58,0x14,0x8D,0x9B,0xA2,0x38,0xFF,0xA0,0x1D,0x65,0xBB,0xB4,0xBA,0xA1,0xCB,
+				},
+				{	0x66,0xB8,0x96,0x10,
+					0xE4,0xA1,0x17,0x08,0x9E,0x22,0xF3,0x8E,
+					0x8E,0xCD,0xD2,0x1E,0x9E,0xF3,0x9D,0x69,0x9B,0xA2,0x1D,0x6D,0x24,0x31,0x3A,0xEF,
+					0xA8,0xFA,0xB3,0xD5,0x3C,0x04,0x3D,0x81,0xAA,0x0A,0xC4,0xC7,0xBC,0xB7,0x99,0xFA,
+					0xFB,0x33,0x93,0x9A,0xCA,0x0B,0x86,0xA1,0x9E,0xE3,0x48,0x61,0xA9,0x3E,0x84,0xEE,
+					0xC0,0xCD,0xF0,0x68,0xAA,0x39,0xA2,0xC8,0xE2,0xC9,0x8A,0x38,0xF5,0xC6,0x66,0x4B,
+				},
+				{	0x3e,0x75,0x00,0x02,
+					0x4E,0xC9,0x9C,0xBC,0x3B,0x6D,0x67,0x3A,
+					0xC1,0xA8,0x9E,0xDC,0xEC,0x6E,0x70,0xC6,0x1A,0xB9,0x77,0x11,0x6A,0x87,0xE9,0x2C,
+					0xF7,0xDD,0x14,0x15,0x1E,0x53,0x7D,0x40,0xC1,0x99,0xBF,0x36,0xAC,0x8C,0x70,0x15,
+					0xC3,0xC8,0x5D,0x4B,0x4E,0x6E,0xC3,0xBD,0x70,0xE6,0x21,0x23,0x2C,0xF0,0x81,0xE8,
+					0x87,0xEA,0x6F,0x46,0x11,0x53,0x1E,0x32,0x4A,0x2A,0xF2,0x02,0x79,0x89,0x9C,0x21,
+				},
+				{	0x66,0xB7,0xE8,0xFE,
+					0x6C,0x14,0x73,0x24,0x2A,0x7F,0x93,0xA6,
+					0x89,0x9E,0x74,0xC3,0x7C,0x8E,0x78,0x31,0xB7,0xAB,0x5A,0x12,0xE5,0x1E,0x0D,0xAE,
+					0x95,0x00,0x93,0xAA,0xB3,0x7F,0xD0,0x26,0x65,0xA0,0x90,0x4E,0x4F,0xD6,0xC3,0xA6,
+					0xC6,0x7E,0x64,0x0C,0x0D,0x43,0xEA,0x84,0xB0,0x7D,0xAF,0x21,0x02,0x37,0xE5,0xCA,
+					0x40,0x8A,0xAC,0x93,0xF2,0xBE,0x4B,0x7D,0x82,0x90,0x98,0x90,0x32,0x8C,0x82,0x2D,
+				},
+				{	0x66,0xB0,0x51,0xF7,//203432462850//
+					0x4D,0xC3,0x52,0xB5,0x33,0xCA,0xA5,0x37,
+					0x99,0x4C,0x2E,0x93,0x91,0x95,0x57,0x60,0xCF,0x1D,0x23,0x58,0x1A,0xBC,0x7D,0xEA,
+					0x18,0xFE,0x1C,0x5C,0x8C,0x05,0x40,0x3A,0x5F,0xE3,0x81,0x92,0x48,0xCD,0xBB,0xB1,
+					0xF2,0xCE,0x95,0xA3,0x5E,0x08,0xE0,0xA9,0x9E,0xB8,0xEC,0x3C,0xBE,0x04,0x19,0xB0,
+					0x46,0x55,0x8B,0xF2,0x62,0xD5,0x02,0xC9,0x17,0x5A,0x3D,0x2E,0x5B,0x05,0xDF,0xA3,
+				},
+				{	0x3E,0x63,0x00,0x8A,
+					0x8C,0xC8,0x83,0x76,0x68,0xA0,0xC5,0xC5,
+					0xD4,0x9C,0x16,0x2C,0xAC,0xEE,0xDA,0x22,0xB4,0x04,0x7D,0x6C,0x43,0x54,0xA8,0xE5,
+					0x97,0xC0,0x51,0x5C,0x9D,0x71,0x14,0xB3,0x64,0x72,0x06,0xE0,0xCE,0x36,0x36,0xAE,
+					0x89,0x1E,0x7B,0x04,0xAD,0xA4,0x61,0xC2,0x46,0x72,0xE6,0x51,0x6B,0xC3,0x2B,0x38,
+					0x76,0xB3,0xAE,0xF8,0xDF,0xCD,0xFF,0xAB,0x87,0x04,0x3A,0x2F,0xEB,0x16,0xE3,0xD3,
+				},
+				{	0x66,0xB9,0x41,0x77,
+					0x23,0xC3,0xBD,0x44,0xC4,0xDB,0xFD,0xAE,
+					0x9C,0xF3,0xDC,0xA2,0x8A,0x54,0xBE,0x76,0xFB,0xA7,0x87,0x8C,0x54,0xAE,0x10,0x02,
+					0x5D,0x84,0xBD,0xCA,0xC4,0xE3,0x25,0x0C,0x09,0x1C,0x3B,0x9C,0xB9,0xCF,0x38,0x8C,
+					0xAD,0xA8,0x2F,0x6E,0x5F,0x8C,0xE7,0xB1,0x0D,0x65,0xE8,0x01,0xD8,0xF9,0xE8,0xA1,
+					0x1E,0xF1,0x31,0xFA,0x5B,0xA9,0x0B,0xB5,0xBC,0x9A,0xDA,0xE7,0x0C,0x5C,0x1B,0x95,
+				},
+				{	0x66,0xBA,0xBB,0xD6,	//////\C1\D7\C0\BD.2011.5.12
+					0x42,0x90,0xED,0x19,0x68,0xB7,0xC4,0x3D,
+					0xC9,0xBC,0x3B,0x7C,0xBC,0x14,0xFE,0xB5,0xFA,0x47,0xAC,0xD4,0x90,0x28,0xEE,0xB2,
+					0xB4,0x5A,0x37,0x7E,0x56,0x18,0x63,0x24,0x6C,0x0D,0x7F,0xDE,0x09,0x15,0x68,0xF8,
+					0xC7,0xD9,0x84,0xEA,0xEB,0x44,0x7B,0x97,0x26,0x2F,0x54,0xE8,0x3B,0x22,0xD9,0x2A,
+					0xC6,0x35,0x0B,0x4A,0xCD,0xB2,0x22,0x30,0x71,0xFD,0x06,0x1A,0xB2,0x33,0xB7,0x55,
+				},
+				{	0x66,0xBB,0x9C,0x06,	//2011.5.23
+					0xAF,0x8A,0x65,0xE0,0x9A,0xAB,0x1A,0xE4,
+					0xA3,0x9B,0x2C,0x06,0xA6,0xDF,0x50,0x24,0xCE,0x95,0xC5,0xA9,0x00,0x38,0xCE,0x3F,
+					0x40,0xAC,0x7A,0xBE,0xA2,0xAC,0x7E,0xB4,0x74,0x20,0xF7,0xF0,0xAB,0x73,0xD9,0x4D,
+					0x2B,0x28,0xED,0x24,0x2C,0x2A,0xD5,0x7B,0xCA,0xDE,0x64,0xB0,0x94,0x5A,0x4B,0xCD,
+					0x3E,0xD1,0xA3,0xB8,0xE2,0x39,0x5E,0xCB,0x8E,0x59,0x24,0xAC,0xF9,0xC5,0xC0,0x3F,
+				},
+				{	0x66,0xBA,0x43,0xF6,	//2011.5.23
+					0xC2,0x4A,0xED,0xE3,0x22,0x09,0x75,0x8A,
+					0xAE,0xAD,0xF0,0xCB,0xE3,0xD6,0x49,0x85,0x97,0xAE,0x3D,0x0B,0x32,0xFA,0xF6,0x1F,
+					0xD2,0x55,0xD7,0x13,0xFD,0xF1,0x39,0x51,0xD3,0x56,0x23,0x5F,0xB6,0xCD,0x78,0x1F,
+					0xAE,0x6B,0x25,0x40,0xF1,0x3F,0xC7,0xD1,0x9A,0x2F,0x8A,0x05,0x2A,0xB9,0xCB,0x0A,
+					0x15,0xFE,0xF7,0x89,0x23,0x57,0x0B,0xE6,0xA6,0x90,0xD5,0x78,0x45,0xEA,0x98,0x67,
+				},
+				{	0x66,0xBC,0xDB,0x99,	//2011.5.28:2031171137  :2011.11.7
+					0x2A,0xC3,0x8F,0xF4,0x7F,0x6C,0x22,0x53,
+					0xBB,0xBC,0x95,0xB0,0xF3,0xAF,0xF9,0x67,0xDD,0xE2,0x67,0x44,0x2C,0x60,0xA7,0xD4,
+					0x11,0x87,0x65,0xE9,0x82,0x8C,0xBC,0x36,0x2E,0x60,0x29,0x8C,0xB9,0x0F,0xF0,0x88,
+					0xD8,0xCB,0x7F,0x9E,0x71,0x8B,0xDB,0x59,0x62,0x92,0x6F,0x18,0x9C,0x13,0x8F,0xCC,
+					0xBA,0xAB,0xBE,0xBA,0xE5,0x88,0xD7,0x94,0xA6,0x52,0xE1,0x60,0x4B,0x67,0x9C,0xE5,
+				},
+				{	0x66,0xB6,0xA4,0xE1,
+					0x27,0x16,0xC7,0xDF,0x99,0xB1,0xC1,0xF0,
+					0x85,0x31,0xCA,0x06,0x86,0xD9,0x6C,0x3E,0xA9,0x5A,0xC7,0x9F,0xFE,0xDA,0xEB,0xF9,
+					0xC3,0xBA,0xD1,0xC9,0x2B,0x91,0xE3,0xDC,0x9B,0xE8,0x4C,0x60,0x60,0xB6,0x58,0x29,
+					0x66,0x05,0x9B,0xFD,0x51,0xA0,0x3C,0xFB,0x41,0xE4,0xF5,0x81,0xBF,0xC4,0x3B,0xE7,
+					0xC5,0x85,0x73,0xE8,0xDE,0x9D,0xA2,0x42,0xFD,0x01,0x4C,0xAB,0xAE,0x66,0x28,0xDB,
+				},
+				{	0x69,0x33,0x5A,0x55,
+					0x65,0xA1,0x95,0x85,0x6F,0x63,0x20,0x3E,
+					0xB0,0xCB,0x20,0xCE,0xA9,0x5C,0x13,0xCD,0x0B,0x71,0x9D,0x6D,0xCB,0xEC,0xD7,0xFF,
+					0x0E,0xA7,0x5D,0x90,0x72,0x1D,0x73,0xBE,0xC4,0xFE,0x5A,0xEB,0xA1,0xA5,0xF6,0x84,
+					0x8B,0x0B,0x13,0xFD,0x1B,0xAC,0x95,0xE1,0xED,0x1B,0x7E,0x2D,0x51,0x5E,0xAA,0x8C,
+					0x4F,0xFE,0xD1,0xA5,0xE8,0xF3,0x84,0x9B,0xB7,0x3E,0x4B,0xEC,0x08,0xF8,0x09,0x5F,
+				},
+				{	0x66,0xB5,0x51,0x50,
+					0xFC,0x12,0xAA,0x41,0xD8,0xBA,0x99,0xD8,
+					0xC0,0x45,0xE3,0x75,0x3E,0x4E,0xAA,0x18,0x13,0x91,0x2F,0x3D,0x4A,0xE0,0xC2,0x1A,
+					0x44,0x85,0x9B,0x14,0x53,0xEE,0xD1,0x3B,0xAD,0xAB,0x20,0x54,0xCF,0x34,0xFB,0xF1,
+					0x20,0xB4,0xFF,0xA2,0x23,0xE3,0x4D,0xF8,0x0A,0x4B,0x6C,0x00,0x75,0xC1,0x12,0x51,
+					0x0B,0x51,0xD1,0x18,0xFA,0x87,0xCF,0xFC,0x7D,0x8C,0xAC,0x0B,0x00,0x90,0x5B,0x9D,
+				},
+				{	0x66,0xB3,0xF0,0x1F,
+					0x51,0xF8,0x4F,0x2D,0x22,0x73,0xFD,0xAA,
+					0x8E,0x3E,0x5A,0x64,0xD3,0x99,0x53,0x42,0x58,0xE7,0x3D,0xDC,0x63,0xAA,0xEF,0x72,
+					0x44,0x00,0xF1,0x72,0xED,0xA1,0xA5,0x11,0x71,0x09,0x4F,0xA5,0x2F,0x87,0x20,0xCE,
+					0x37,0xDE,0x57,0x5D,0xFC,0xE7,0x83,0x85,0xE0,0x59,0x8F,0x08,0xCF,0x88,0x24,0x57,
+					0x3B,0x3F,0x42,0x97,0x6A,0x83,0x0A,0x47,0xF2,0x64,0x32,0xF2,0xD8,0x8B,0x38,0x95,
+				},
+				{	0x66,0xBD,0xC4,0xBA,
+					0xC1,0x9B,0x5A,0x6B,0x28,0x27,0x62,0x1F,
+					0xD6,0x5C,0x70,0xE1,0x54,0x98,0x06,0x16,0xB4,0xFE,0xD1,0x4E,0xFC,0x96,0xEF,0x6C,
+					0x5F,0xC0,0x96,0xD3,0xC2,0x19,0x1C,0xC0,0xA0,0x42,0xDB,0x02,0x8D,0x28,0x3F,0x78,
+					0xE9,0x5B,0x97,0xC1,0x05,0x5C,0xC9,0xDF,0xCF,0x06,0xCA,0xA4,0x3A,0x65,0xF9,0xEC,
+					0x99,0xA2,0x84,0x91,0x49,0xE3,0x8E,0x82,0xC7,0x95,0x3E,0xC3,0x93,0x80,0xCD,0x65,
+				},
+				{	0x69,0x33,0xFA,0x7D,
+					0xE0,0x02,0x0C,0x70,0x8E,0x73,0x4F,0xAE,
+					0x97,0x53,0xB0,0xA1,0x41,0xC4,0x69,0x68,0x27,0xD4,0xCB,0x2C,0x35,0x69,0x56,0x40,
+					0x7F,0xEE,0x5B,0x8D,0x05,0x9B,0x67,0x9F,0xB1,0x3C,0x2F,0xD8,0x0E,0xCB,0x7E,0x12,
+					0x0B,0x03,0xEB,0x16,0x31,0x27,0x4B,0x4C,0xFF,0xFB,0x6B,0xC8,0x6D,0xC9,0x19,0xEE,
+					0x12,0x06,0x33,0xD4,0xF4,0xBD,0x6A,0x94,0x94,0x75,0x53,0xDF,0x63,0xC2,0x0D,0x2D,
+				},
+				{	0x69,0x33,0xCC,0x65,
+					0xB3,0x49,0xA9,0xA9,0x0B,0x8A,0x5A,0xCA,
+					0xC3,0x1C,0x02,0x43,0xF8,0x40,0x9C,0x05,0x5B,0xAB,0xF9,0x21,0x66,0x8B,0x3D,0xBF,
+					0xE7,0x59,0x29,0x98,0xA1,0xF0,0x56,0xD0,0x36,0xF7,0x82,0xE1,0x44,0x96,0x5F,0xF0,
+					0x1F,0x69,0x6F,0x91,0x0C,0x08,0x19,0xB8,0x74,0x0A,0xA7,0x45,0xC2,0x48,0xA6,0xA7,
+					0xFF,0x9B,0x1E,0x79,0x78,0x34,0xC7,0x84,0x4A,0x9C,0xA3,0x4A,0xF6,0x0C,0xEC,0x65,
+				},
+				{	0x69,0x00,0x43,0xEC,
+					0xA0,0x84,0xE0,0xBB,0xED,0xB0,0xDC,0xE5,
+					0xC2,0xD8,0x47,0xAD,0xBC,0x1E,0x7E,0x12,0x24,0xB3,0x8D,0xE9,0x23,0x68,0x67,0x22,
+					0x58,0xCB,0x3C,0x0F,0x6B,0x06,0x66,0xD9,0x08,0x35,0x3A,0xD8,0xA8,0xE8,0x6B,0x2A,
+					0xDB,0x31,0xA5,0x96,0x7F,0x39,0x75,0x15,0xD0,0xF4,0x7E,0xD7,0x1C,0xFF,0x3A,0x2D,
+					0xBD,0x11,0x6D,0xC3,0xA6,0xA2,0x7E,0xC6,0x77,0x1E,0x4F,0x5A,0xD1,0x19,0x6D,0x85,
+				},
+				{	0x69,0x32,0x80,0x9E,               //2031950953
+					0x43,0xBB,0x32,0x1B,0xB5,0x03,0x60,0xB4,
+					0xC4,0x80,0x51,0xA7,0xC1,0xED,0xA8,0x30,0x03,0x32,0xF6,0x6C,0x30,0x34,0x13,0xF8,
+					0xFF,0x32,0x9A,0xBA,0x80,0xF4,0xBB,0x34,0x11,0xF5,0x60,0x58,0xD9,0xBF,0xE7,0x3D,
+					0xE2,0xBD,0x2A,0x14,0x07,0x5B,0x32,0x9D,0x9A,0x7E,0x29,0x8B,0xAA,0x70,0x8C,0x19,
+					0x0A,0xB9,0xC9,0x6B,0x0E,0x99,0x32,0x90,0x82,0x45,0x40,0xEC,0x63,0x59,0xD6,0xA3,
+				},
+				{	0x66,0xB4,0x07,0x02,               //2034571476
+					0x3C,0xC2,0x94,0x7B,0xA7,0x4E,0x23,0x79,
+					0x96,0x81,0xCD,0x90,0xE6,0x70,0xCC,0xD2,0x9A,0xD5,0x9B,0x9B,0x5C,0x0B,0x7E,0xB9,
+					0xF7,0xD4,0xB0,0xC9,0x6C,0x89,0x1A,0x4A,0xD8,0x0D,0xFB,0x82,0xE4,0x6F,0x59,0x07,
+					0x29,0x3C,0xD3,0xE6,0x55,0x9D,0xCC,0xB2,0x6F,0xEC,0x96,0x1A,0xB6,0x12,0x58,0x34,
+					0xA9,0x72,0x94,0x4C,0xB3,0xD5,0x6A,0x16,0x8F,0xB1,0x93,0x07,0x68,0x0F,0xB7,0x4B,
+				},
+
+				{	0x63,0xB8,0x0B,0x85,								//2034717681
+					0x45,0x1D,0x44,0x5D,0x00,0x75,0x17,0xB6,
+					0x98,0xD1,0xE4,0x21,0x48,0x82,0xAD,0x74,0xE4,0x10,0xAF,0x9A,0x74,0x70,0x45,0xB9,
+					0xA3,0x04,0x44,0x00,0xAB,0x20,0x21,0xE3,0x1D,0x95,0x3B,0x8D,0xEB,0xFA,0xF9,0x1B,
+					0xC2,0xF5,0x81,0x42,0xB5,0xD3,0xB1,0x55,0xD5,0x2D,0x7C,0x7E,0xA3,0x00,0xFD,0x72,
+					0x80,0xB9,0xF4,0x21,0x4E,0xDA,0x97,0xB2,0x48,0x78,0x58,0xF0,0x24,0x31,0x3D,0xC9,
+				},
+
+				{	0x69,0x39,0x3A,0x11,		//2034686452
+					0xC1,0x1C,0x50,0x9A,0x53,0x40,0x5A,0xE9,
+					0x82,0xA5,0x62,0x88,0xC0,0xFE,0xB8,0xA9,0xCE,0x61,0x72,0xA8,0x8C,0xF1,0x9E,0x5B,
+					0x9C,0xE3,0x8C,0x54,0x22,0x4E,0xE0,0xE3,0x50,0xFE,0x2B,0x8C,0x85,0x0B,0x27,0x07,
+					0x56,0x2D,0xA7,0x42,0x22,0xA9,0xF5,0xC5,0x1F,0xFD,0x7F,0x6C,0xB3,0xEA,0x63,0x13,
+					0x8F,0x08,0xE6,0x88,0x35,0x70,0x13,0xB6,0x64,0x8E,0x95,0xCA,0x93,0x1C,0x10,0x5D,
+				},
+				{	0x69,0x39,0x3A,0x4B, //2046202768
+					0x6B,0xB0,0x06,0xC9,0xD2,0xB3,0x71,0xC5,
+					0x8C,0x78,0x63,0xFA,0xEC,0xE5,0xDC,0x9B,0x22,0xC2,0x6E,0xF8,0x37,0x7A,0xC5,0xAC,
+					0xF6,0x9A,0x7B,0x7A,0xE6,0xC8,0xA2,0xA4,0x66,0xA6,0xD3,0xFC,0x10,0x08,0x1C,0x8E,
+					0xF0,0x43,0x9E,0xA7,0x9B,0x90,0x10,0x72,0x2C,0x1A,0xB5,0xA4,0x47,0xAA,0xBD,0x86,
+					0x87,0x30,0x29,0xDC,0x86,0xA3,0x73,0x83,0x87,0x69,0xCE,0xBE,0x87,0x3A,0x00,0xA3,
+				},
+				{	0x66,0xB0,0xD6,0xE6,
+					0x74,0xC0,0xB6,0x2D,0x3A,0x22,0x9C,0x76,
+					0x9E,0x51,0x52,0xCF,0xDF,0xF8,0x22,0x8C,0x47,0x63,0x38,0xBB,0xA8,0x2C,0x2F,0xDF,
+					0xC8,0xEF,0x1B,0xC1,0x75,0x33,0xBD,0x78,0x8C,0xE1,0x17,0x84,0xB0,0x8D,0x1A,0x33,
+					0x9F,0xA5,0xDF,0x93,0x91,0x82,0x3A,0xB0,0x5F,0xE5,0xE1,0x5B,0xAD,0x21,0x22,0x1D,
+					0xCD,0xBA,0x44,0xBA,0x78,0xF0,0x88,0xDF,0x9F,0x22,0xA3,0x8A,0xF0,0x13,0x24,0x51,
+				},
+				{	0x66,0xB4,0xFD,0x8E,
+					0xC3,0xA5,0xA7,0x6F,0x45,0x04,0x37,0xAD,
+					0xCF,0x4B,0x86,0x1E,0xA7,0xFA,0x0D,0xB1,0x3C,0x8D,0x42,0x62,0x37,0x0F,0x60,0xED,
+					0x62,0x7D,0x79,0x07,0xDF,0xF7,0xFE,0xCD,0xAD,0x67,0xD6,0x74,0x92,0xE3,0x09,0xA7,
+					0x7F,0x70,0xDD,0x30,0x54,0xB0,0xE9,0x2A,0x34,0x29,0x07,0xBA,0xFD,0x33,0x57,0xEC,
+					0x59,0x31,0x86,0xC0,0xDD,0xA8,0x84,0x06,0xE9,0xBE,0xC0,0x37,0xEC,0x30,0x58,0x9F,
+				},
+				{	0x66,0xB9,0xEE,0xC3,
+					0xBF,0x6D,0x95,0xA0,0xA7,0xF6,0x3F,0xAE,
+					0xA7,0xA6,0xB9,0xD0,0x4F,0xBF,0xD6,0x57,0xCF,0x7A,0x12,0x86,0x95,0x91,0x8A,0xB2,
+					0xF4,0xFB,0xBF,0xC0,0xBE,0xBB,0x09,0xBC,0xE3,0x09,0x2C,0xA9,0x4B,0x81,0x36,0x64,
+					0x9F,0xB3,0x88,0x89,0x44,0x96,0x18,0xD0,0xCD,0xAE,0xA9,0xBD,0x32,0xE3,0x18,0x7B,
+					0x92,0x08,0x4E,0x9D,0x5C,0x99,0xF9,0x7C,0x50,0x67,0x9B,0x0B,0x52,0x70,0x90,0xBD,
+				},
+				{	0x69,0x39,0x0C,0x3B,  //203662626378
+					0xBD,0xD4,0x6A,0x78,0x9D,0xE8,0xC4,0x1E,
+					0x85,0x08,0xFA,0xC5,0x06,0xA4,0x87,0x6D,0x13,0x90,0xB4,0xF6,0x97,0xE8,0x59,0x5D,
+					0x76,0xF4,0xB0,0xBC,0x88,0x98,0x69,0xC0,0xC1,0x7A,0x0D,0x7C,0x31,0xD0,0x9C,0x42,
+					0xBB,0xFD,0xA8,0xFF,0x4A,0x1A,0x83,0xBC,0x82,0x51,0x69,0xFF,0xEF,0x23,0xCD,0x1E,
+					0x4A,0x55,0x75,0x4B,0x90,0x76,0x3A,0x76,0x44,0x23,0x1E,0x9B,0xD0,0x1D,0xCD,0x17,
+				},
+				{	0x69,0x39,0x3A,0x34,  //2046332733
+					0xDB,0x45,0x12,0x73,0xA1,0x9B,0x00,0x38,
+					0xC9,0x25,0x4C,0xC9,0x1F,0x95,0xA7,0xA8,0x9C,0xF8,0x52,0xCF,0xDF,0x30,0x05,0x39,
+					0x37,0xDE,0x9F,0xF2,0xA7,0x97,0xF4,0x46,0xC0,0xB0,0xF4,0x3B,0x18,0xE3,0xBC,0x9C,
+					0x52,0x53,0x99,0x4C,0xE7,0xEE,0x0F,0x9C,0x0E,0xB3,0x24,0x9E,0x27,0x3B,0xEA,0xB3,
+					0xD3,0x00,0x59,0x0D,0x70,0x60,0x48,0x91,0x3A,0xD3,0xC0,0x1B,0x89,0xE1,0x37,0x23,
+				},
+				{	0x66,0xB6,0x73,0x23, //2034376128
+					0xB9,0x37,0x4F,0x2E,0x7D,0x0B,0xC3,0xAA,
+					0x81,0x4F,0x5F,0xBF,0x68,0xF6,0x7B,0x87,0x79,0x4B,0x4A,0x3A,0x22,0xA3,0x5F,0x30,
+					0x90,0xD2,0x93,0x70,0x44,0xAB,0x9F,0xA3,0xED,0xE0,0x7F,0x3B,0xCE,0x16,0x49,0x74,
+					0x68,0x69,0x1D,0xA8,0x0C,0x9C,0x60,0xBC,0x4F,0x57,0xCE,0x98,0x67,0xD2,0x7C,0x2C,
+					0x00,0x80,0xAA,0x8A,0xCB,0xB6,0x66,0xDF,0x17,0x30,0x84,0xEE,0x6A,0x6E,0x25,0x99,
+				},
+				{	0x6B,0x8D,0x00,0xDC, //2036875675
+					0x18,0xB5,0x66,0xEE,0x61,0x8B,0xA9,0xC2,
+					0x85,0xE4,0xCD,0xDC,0x45,0x2C,0x05,0x2E,0xED,0xB3,0x82,0x82,0x2B,0xAF,0x03,0x93,
+					0x61,0xDF,0x2D,0xC8,0x00,0x89,0x7D,0xB3,0xCF,0xFC,0x24,0x72,0x9E,0x5D,0x2A,0x8D,
+					0xE4,0xDD,0xF6,0x19,0xF9,0x2B,0x28,0xCB,0xA0,0x84,0x41,0x34,0x7B,0x33,0x22,0xAD,
+					0x1F,0x65,0x8E,0x93,0x27,0x6E,0x5F,0xFD,0x23,0x9D,0xA5,0xF5,0x9A,0x97,0x4F,0x43,
+				},
+				{	0x66,0xB8,0x3B,0xA0,//203707703651
+					0x08,0x25,0x77,0xF9,0x2A,0x86,0x63,0x91,
+					0x92,0xE9,0x79,0xBE,0xA0,0xC2,0x1A,0xC6,0x78,0xBA,0xB6,0xA6,0x09,0xB4,0x2B,0x82,
+					0x56,0x10,0xA0,0x93,0x46,0xA0,0x99,0xB8,0xCC,0x35,0xA9,0xE9,0xC8,0xE3,0x3E,0xA8,
+					0xF0,0xDC,0x8D,0x75,0x79,0x98,0x05,0x85,0x8C,0xED,0xA4,0x78,0x41,0xCC,0xC3,0x8D,
+					0xB9,0x17,0x7D,0xC2,0xAB,0xB3,0x78,0x08,0x1B,0x96,0x2C,0x46,0x0D,0x4E,0xB7,0x73,
+				},
+				{	0x6B,0x86,0x5D,0xC5,//203707703954
+					0xF3,0x17,0x72,0xFB,0xEA,0xF7,0x56,0x7C,
+					0x97,0x02,0xAC,0x76,0x9D,0xF1,0xBB,0x57,0xDF,0x3A,0xE4,0x10,0x45,0x2C,0x8A,0x34,
+					0xCD,0xF0,0x79,0x25,0x17,0x68,0xEE,0xE3,0xCD,0xF2,0xEF,0x8E,0xE9,0xB1,0xBD,0x2D,
+					0xF6,0x04,0xDB,0x89,0xBC,0x08,0xCD,0x92,0x89,0x10,0x09,0x2B,0x98,0x5A,0xC7,0x47,
+					0x39,0x8F,0xF0,0x26,0xF1,0x18,0xC7,0x1A,0x96,0xD4,0x9E,0x97,0x43,0x4C,0xF6,0x49,
+				},
+				{	0x66,0xBD,0x68,0x81,//203707703550
+					0x3E,0x13,0x2F,0x62,0x23,0x6A,0x0F,0xDF,
+					0x90,0x72,0xE1,0x57,0x2C,0x3A,0x2A,0x6C,0xA0,0xE3,0x25,0xA6,0x47,0xD6,0x8D,0x39,
+					0xFD,0x35,0x67,0x98,0x2C,0x80,0x95,0x83,0x4B,0x04,0x16,0xF1,0x06,0xD2,0x50,0x1E,
+					0x54,0xD1,0x62,0x36,0xFF,0x28,0x83,0x56,0x84,0x4A,0xB4,0xCA,0xA7,0x46,0xDD,0xDF,
+					0x58,0x91,0xAB,0x4C,0xF7,0x9D,0xB7,0xEF,0xAF,0xB2,0x91,0xFE,0x68,0x3C,0x4B,0x41,
+				},
+				{	0x69,0x38,0x3E,0xC4,//203643589616
+					0x79,0x32,0xCA,0x45,0xAD,0x1C,0x93,0x16,
+					0x82,0xCF,0x77,0x1F,0x2A,0x2E,0x29,0x22,0xBD,0xA8,0x9C,0x79,0xE6,0xCF,0xCB,0xF8,
+					0xC5,0x2B,0x1F,0x50,0x96,0x87,0xD9,0x35,0xBD,0x27,0x4E,0x07,0xFD,0xAE,0x99,0x2A,
+					0x94,0xB8,0xA1,0x1F,0xFD,0x05,0xE3,0x22,0x6D,0x31,0x0E,0x67,0x26,0xCF,0x82,0xA5,
+					0x88,0x33,0x35,0x5D,0x04,0x0F,0xCF,0x0E,0x8C,0x79,0x85,0xB0,0xAD,0x77,0x2C,0xA3,
+				},
+				{	0x69,0x03,0x86,0x4D, //203497733148-->203526702137:CARDONLY
+					0x88,0x57,0x27,0x4D,0x4B,0xB0,0xFA,0x66,
+					0x88,0xF1,0x71,0x78,0x50,0x26,0x4D,0x59,0x7B,0xB8,0x5A,0x11,0x71,0x6B,0xA5,0x57,
+					0x3A,0xEC,0xEE,0xC6,0x35,0x36,0x80,0x6E,0x55,0x5E,0x6D,0xA4,0xF0,0xDE,0xB8,0x93,
+					0xC1,0x5D,0xEA,0xD4,0x70,0xE1,0x9B,0x81,0xE3,0xC9,0x92,0x19,0x8C,0x1F,0x07,0x89,
+					0x6D,0xD2,0xF4,0x92,0xD9,0x98,0x15,0xA8,0x48,0xBF,0x27,0x7D,0xF5,0x9E,0x62,0x37,
+				},
+				{	0x69,0x33,0x5D,0xBA,//203114220613==>1
+					0x56,0xC2,0xD3,0xF6,0xCE,0x1F,0x37,0x16,
+					0xCB,0x98,0x67,0x0F,0xE6,0x3D,0xD2,0xA5,0x57,0xE6,0xAE,0xD3,0x35,0x0A,0x68,0x28,
+					0x97,0x39,0xCB,0x7E,0x5C,0xDA,0x01,0x96,0x99,0xDB,0x7E,0x0D,0x24,0xBD,0x70,0xB8,
+					0x4C,0x6B,0x4B,0xF3,0x19,0x4F,0x23,0x5E,0xE2,0xA6,0x30,0x38,0x27,0xA4,0x3F,0x5E,
+					0x1B,0x1C,0x8E,0xCC,0x40,0xDB,0x53,0xB8,0x28,0xCA,0x1C,0x9B,0x0F,0x76,0x4B,0xDB,
+				},
+				{	0x66,0xB4,0x53,0x47,//203434125559==>2
+					0x29,0xB1,0xFD,0x6B,0xB5,0xAC,0x97,0x2B,
+					0x84,0x33,0x03,0xE5,0x28,0xEB,0x86,0xD5,0x19,0xF7,0x9D,0x41,0xBE,0xD9,0x53,0xC1,
+					0x38,0x83,0xD3,0x6C,0xF4,0x0D,0xB8,0xCB,0xB8,0x0E,0xF4,0x72,0x2C,0xC7,0xC9,0x5A,
+					0x31,0x20,0xD8,0xFC,0xEB,0x10,0x45,0xD7,0x25,0xC7,0xED,0xCF,0xA7,0xFB,0x5D,0x01,
+					0xB3,0x74,0xCB,0x8A,0x50,0x2A,0x56,0xCF,0x1D,0x1E,0xD2,0xB8,0x15,0x75,0x85,0xD3,
+				},
+				{	0x69,0x32,0x03,0x41, //203192623135==>3
+					0xC8,0x4C,0x64,0xAE,0x12,0x55,0x5D,0xDD,
+					0x91,0x2A,0x20,0x61,0x8F,0x4E,0x41,0xE5,0x0E,0xB4,0x6B,0x86,0xB9,0x19,0x86,0xC9,
+					0xC8,0x4C,0xE1,0x01,0x95,0x88,0x7F,0xBD,0xDC,0x58,0xEE,0xC0,0x2E,0x60,0xD0,0x68,
+					0x86,0x43,0x48,0xD9,0xDB,0x2C,0x79,0xA6,0x1D,0x56,0x63,0xD3,0x03,0x2C,0x45,0x7C,
+					0x96,0xB9,0xA1,0xBC,0x37,0xB7,0x03,0xD4,0xC8,0x50,0xCB,0x41,0xD2,0xBD,0x50,0x1B,
+				},
+				{	0x6B,0x92,0xD0,0xBA,//203589588284==>4
+					0x4F,0x17,0x37,0x76,0xEB,0xC4,0xBB,0x9A,
+					0x8C,0x44,0xA2,0xA1,0xFE,0x95,0x0E,0xB1,0x16,0x38,0x20,0x6F,0xB0,0xA0,0x79,0xF4,
+					0x49,0x18,0x91,0xBD,0xD4,0xB7,0xB7,0x14,0x88,0x4B,0x65,0x03,0xFF,0x24,0x8F,0x8A,
+					0x8C,0x44,0x9D,0x25,0xE0,0x2F,0xBF,0xE1,0xC1,0x4B,0x2C,0x04,0x73,0xA1,0xB0,0x7B,
+					0x63,0x79,0x44,0x50,0x6B,0x36,0x95,0xBC,0xCB,0x3D,0xE1,0x5A,0x5C,0xA2,0x38,0x37,
+				},
+				{	0x66,0xB2,0x10,0x41,//203643579616==>5
+					0x17,0xBD,0xA7,0x88,0x27,0x97,0x3B,0x37,
+					0x87,0xED,0x4C,0xE3,0x9A,0xC1,0x5E,0xCF,0xB4,0xDD,0xAC,0xB7,0x82,0xE2,0xB5,0x7C,
+					0x8B,0xC9,0x8F,0x78,0x2C,0xC6,0x67,0xDE,0x9B,0x6A,0x34,0xE0,0xE2,0x57,0x17,0x15,
+					0x98,0x5D,0xBA,0xC4,0x7E,0x43,0x71,0xFB,0x3C,0x20,0xBE,0xA8,0xB1,0xFC,0x14,0xDA,
+					0xAD,0xD2,0x88,0xFE,0xE6,0xF7,0xBE,0xCA,0x41,0x6F,0xFA,0xEE,0xAF,0xBA,0x79,0xA1,
+				},
+				#endif
+			#else
+				{	0x66,0xA1,0xDC,0xA4,
+					0x37,0x93,0x7D,0xE0,0xF0,0x97,0x67,0x37,
+					0xB1,0x23,0xA1,0x2F,0x8B,0x84,0xC4,0x2B,0x64,0x97,0x23,0xC9,0x27,0xA0,0xFC,0x40,
+					0xDA,0x4A,0xD3,0x85,0x38,0xEC,0xA1,0x5C,0xC1,0xE0,0x38,0xBD,0xB6,0xEF,0x91,0x5F,
+					0x22,0x57,0x8B,0xF9,0xED,0x2A,0xAA,0x51,0xA7,0x7B,0xF7,0xDD,0xC1,0x3B,0xD8,0x54,
+					0xD1,0x4A,0x4B,0xA6,0xAC,0xE9,0xC1,0xE5,0xE7,0xCC,0x3F,0xC1,0x4C,0xE7,0x21,0x65,
+				},
+			#endif
+	};
 
+	static int ChkDT08OfIrdIds(uint8_t *irdid)
+	{
+		int i, num;
+		num = sizeof(ukcable_dt08_natives) / UKCABLE_DATALENN;
+		for(i=0; i<num; i++) {
+			if (memcmp(irdid, ukcable_dt08_natives[i], 4) == 0) return i;
+		}
+		return -1;
+	}
+#endif // defined(__simulation_ukcable__)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
 // Card Status checks
 #define HAS_CW()      ((csystem_data->cam_state[2]&6)==6)
 #define RENEW_SESSIONKEY() ((csystem_data->cam_state[0]&128)==128 || (csystem_data->cam_state[0]&64)==64 || (csystem_data->cam_state[0]&32)==32 || (csystem_data->cam_state[2]&8)==8)
@@ -46,7 +467,9 @@
 		struct tm t;
         t.tm_isdst = -1;
 		cs_gmtime_r(&ut, &t);
-		snprintf(buf, l, "%04d/%02d/%02d", t.tm_year + 1900, t.tm_mon + 1, t.tm_mday);
+	//	sky(date)
+	//	snprintf(buf, l, "%04d/%02d/%02d", t.tm_year+1900, t.tm_mon+1, t.tm_mday);
+		snprintf(buf, l, "%02d/%02d/%04d", t.tm_mday, t.tm_mon + 1, t.tm_year + 1900);
 	}
 	return ut;
 }
@@ -59,19 +482,21 @@
 	int32_t days = (ndays[0] << 8 | ndays[1]) + offset;
 	int32_t sec = 0;
 	if(!csystem_data->is_tiger)
-		{ sec = (ndays[2] << 8 | ndays[3]); }
+		sec = (ndays[2] << 8 | ndays[3]);
 	if(days > 0x41B4 && sizeof(time_t) < 8)  // to overcome 32-bit systems limitations
-		{ days = 0x41A2; }                   // 01-01-2038
+		days = 0x41A2;                   // 01-01-2038
 	tms.tm_year = 92;
 	tms.tm_mday = days + 1;
 	tms.tm_sec = sec;
 	time_t ut = mktime(&tms);
 	if(t)
-		{ *t = ut; }
+		*t = ut;
 	if(csystem_data->is_tiger)
-		{ snprintf(result, 11, "%02d/%02d/%04d", tms.tm_mday, tms.tm_mon + 1, tms.tm_year + 1900); }
+		snprintf(result, 11, "%02d/%02d/%04d", tms.tm_mday, tms.tm_mon + 1, tms.tm_year + 1900);
 	else
-		{ snprintf(result, 17, "%04d/%02d/%02d %02d:%02d", tms.tm_year + 1900, tms.tm_mon + 1, tms.tm_mday, tms.tm_hour, tms.tm_min); }
+   //	sky(date)
+	//	snprintf(result, 17, "%04d/%02d/%02d %02d:%02d", tms.tm_year + 1900, tms.tm_mon + 1, tms.tm_mday, tms.tm_hour, tms.tm_min);
+		snprintf(result, 17, "%02d/%02d/%04d %02d:%02d", tms.tm_mday, tms.tm_mon + 1, tms.tm_year + 1900, tms.tm_hour, tms.tm_min);
 	return result;
 }
 
@@ -95,7 +520,7 @@
 	msg[5] = cmd;
 	int32_t dlen = ilen - 2;
 	msg[6] = dlen;
-	if(data && dlen > 0) { memcpy(msg + 7, data, dlen); }
+	if (data && dlen>0) memcpy(msg+7,data,dlen);
 	msg[dlen + 7] = rlen;
 	if(dlen < 0)
 	{
@@ -150,7 +575,7 @@
 		idea_set_encrypt_key(b200, &ks);
 		memset(v, 0, sizeof(v));
 		idea_cbc_encrypt(msg + i, b0f0, 8, &ks, v, IDEA_DECRYPT);
-		for(j = 7; j >= 0; j--) { b0f0[j] ^= msg[i + j]; }
+		for (j=7; j>=0; j--) b0f0[j]^=msg[i+j];
 		memcpy(b200 + 0, b0f0, 8);
 		memcpy(b200 + 8, b0f0, 8);
 	}
@@ -183,7 +608,11 @@
 	{
 		rdr_log_dbg(reader, D_READER, "DateTimeCMD failed!");
 	}
-
+#if __ADB_TRACE__
+	char dd[20];
+	tier_date(b2i(2, cta_res+2)-0x7f7, dd, 15);
+	myprintf("datetime:%s\n", dd);
+#endif
 }
 
 static int32_t NegotiateSessionKey_Tiger(struct s_reader *reader)
@@ -209,14 +638,16 @@
 	}
 
 	BN_CTX *ctx = BN_CTX_new();
-#ifdef WITH_LIBCRYPTO
+#ifdef WITH_LIBCRYPTO_sky
 	BN_CTX_start(ctx);
 #endif
 	BIGNUM *bnN = BN_CTX_get(ctx);
 	BIGNUM *bnE = BN_CTX_get(ctx);
 	BIGNUM *bnCT = BN_CTX_get(ctx);
 	BIGNUM *bnPT = BN_CTX_get(ctx);
-	BN_bin2bn(reader->rsa_mod, 120, bnN);
+	// sky()
+	unsigned char *pRsaMod = (cs_Iszero(reader->rsa_mod,120)) ? rsaMod_Tigers : reader->rsa_mod;
+	BN_bin2bn(pRsaMod, 120, bnN);
 	BN_bin2bn(&exponent, 1, bnE);
 	BN_bin2bn(&cta_res[90], 120, bnCT);
 	BN_mod_exp(bnPT, bnCT, bnE, bnN, ctx);
@@ -249,7 +680,7 @@
 
 	ReverseMem(cta_res + 2, 88);
 	BN_CTX *ctx1 = BN_CTX_new();
-#ifdef WITH_LIBCRYPTO
+#ifdef WITH_LIBCRYPTO_sky
 	BN_CTX_start(ctx1);
 #endif
 	BIGNUM *bnN1 = BN_CTX_get(ctx1);
@@ -287,7 +718,7 @@
 
 
 	BN_CTX *ctx3 = BN_CTX_new();
-#ifdef WITH_LIBCRYPTO
+#ifdef WITH_LIBCRYPTO_sky
 	BN_CTX_start(ctx3);
 #endif
 	BIGNUM *bnN3 = BN_CTX_get(ctx3);
@@ -316,27 +747,28 @@
 		idea_set_encrypt_key(csystem_data->sessi, &ks);
 		idea_set_decrypt_key(&ks, &csystem_data->ksSession);
 		rdr_log_dbg(reader, D_READER, "Tiger session key negotiated");
+		reader->nagra_negotiate = 1;
 		return OK;
 	}
 	rdr_log(reader, "Negotiate sessionkey was not successful! Please check tivusat rsa key");
-	return ERROR;
-
+//	return ERROR;
+	return OK; /* sky */
 }
 
 static int32_t NegotiateSessionKey(struct s_reader *reader)
 {
 	def_resp;
 	unsigned char negot[64];
-	unsigned char cmd2b[] = {0x21, 0x40, 0x4D, 0xA0, 0xCA, 0x00, 0x00, 0x47, 0x27, 0x45,
-							 0x1C, 0x54, 0xd1, 0x26, 0xe7, 0xe2, 0x40, 0x20,
-							 0xd1, 0x66, 0xf4, 0x18, 0x97, 0x9d, 0x5f, 0x16,
-							 0x8f, 0x7f, 0x7a, 0x55, 0x15, 0x82, 0x31, 0x14,
-							 0x06, 0x57, 0x1a, 0x3f, 0xf0, 0x75, 0x62, 0x41,
-							 0xc2, 0x84, 0xda, 0x4c, 0x2e, 0x84, 0xe9, 0x29,
-							 0x13, 0x81, 0xee, 0xd6, 0xa9, 0xf5, 0xe9, 0xdb,
-							 0xaf, 0x22, 0x51, 0x3d, 0x44, 0xb3, 0x20, 0x83,
-							 0xde, 0xcb, 0x5f, 0x35, 0x2b, 0xb0, 0xce, 0x70,
-							 0x01, 0x02, 0x03, 0x04, //IRD nr
+	unsigned char cmd2b[] = {0x21, 0x40, 0x4D, 0xA0, 0xCA, 0x00, 0x00, 0x47, 0x27, 0x45, // 0
+                            0x1C, 0x54, 0xd1, 0x26, 0xe7, 0xe2, 0x40, 0x20, // 10
+                            0xd1, 0x66, 0xf4, 0x18, 0x97, 0x9d, 0x5f, 0x16, // 18
+                            0x8f, 0x7f, 0x7a, 0x55, 0x15, 0x82, 0x31, 0x14, // 26
+                            0x06, 0x57, 0x1a, 0x3f, 0xf0, 0x75, 0x62, 0x41, // 34
+                            0xc2, 0x84, 0xda, 0x4c, 0x2e, 0x84, 0xe9, 0x29, // 42
+                            0x13, 0x81, 0xee, 0xd6, 0xa9, 0xf5, 0xe9, 0xdb, // 50
+                            0xaf, 0x22, 0x51, 0x3d, 0x44, 0xb3, 0x20, 0x83, // 58
+                            0xde, 0xcb, 0x5f, 0x35, 0x2b, 0xb0, 0xce, 0x70, // 66
+                            0x01, 0x02, 0x03, 0x04, //IRD nr                // 74
 							 0x00
 							};//keynr
 	unsigned char tmp[64];
@@ -361,10 +793,23 @@
 		rdr_log_dbg(reader, D_READER, "No valid DT08 calc using rsa from config and serial from card");
 		memcpy(csystem_data->plainDT08RSA, reader->rsa_mod, 64);
 		memcpy(csystem_data->signature, reader->boxkey, 8);
+		#if defined(__simulation_ukcable__)
+			if (cs_Iszero(reader->rsa_mod,64) && cs_Iszero(reader->boxkey,8))
+			{
+				int idx;
+				if ((idx = ChkDT08OfIrdIds(reader->irdId))>=0) {
+					memcpy(csystem_data->plainDT08RSA, &ukcable_dt08_natives[idx][4+8], 64);
+					memcpy(csystem_data->signature, &ukcable_dt08_natives[idx][4], 8);
+					memcpy(reader->boxkey, &ukcable_dt08_natives[idx][4], 8);
+				}
+				rdr_log_dbg(reader, D_READER, "ChkDT08OfIrdIds{%02X.%02X.%02X.%02X}", reader->irdId[0], reader->irdId[1], reader->irdId[2], reader->irdId[3]);
+			}
+		//	myprdump("plainDT08RSA", csystem_data->plainDT08RSA, 64);
+		//	myprdump("signature", csystem_data->signature, 8);
+		#endif // defined(__simulation_ukcable__)
 	}
 
-	if((csystem_data->is_n3_na) && (!do_cmd(reader, 0x29, 0x02, 0xA9, 0x04, NULL, cta_res, &cta_lr)))
-	{
+	if ((csystem_data->is_n3_na) && (!do_cmd(reader, 0x29,0x02,0xA9,0x04, NULL,cta_res,&cta_lr))) {
 		rdr_log_dbg(reader, D_READER, "Nagra3: CMD$29 failed");
 		return ERROR;
 	}
@@ -372,16 +817,13 @@
 	memcpy(tmp, reader->irdId, 4);
 	tmp[4] = 0; //keynr 0
 
-	if(!csystem_data->is_n3_na)
-	{
-		if(!do_cmd(reader, 0x2a, 0x02, 0xaa, 0x42, NULL, cta_res, &cta_lr))
-		{
+	if (!csystem_data->is_n3_na) {
+		if (!do_cmd(reader, 0x2a,0x02,0xaa,0x42,NULL,cta_res,&cta_lr)) {
 			rdr_log_dbg(reader, D_READER, "CMD$2A failed");
 			return ERROR;
 		}
 	}
-	else if(!do_cmd(reader, 0x26, 0x07, 0xa6, 0x42, tmp, cta_res, &cta_lr))
-	{
+	else if (!do_cmd(reader, 0x26,0x07,0xa6, 0x42, tmp,cta_res,&cta_lr)) {
 		rdr_log_dbg(reader, D_READER, "CMD$26 failed");
 		return ERROR;
 	}
@@ -390,7 +832,7 @@
 	ReverseMem(cta_res + 2, 64);
 	unsigned char vFixed[] = {0, 1, 2, 3};
 	BN_CTX *ctx = BN_CTX_new();
-#ifdef WITH_LIBCRYPTO
+#ifdef WITH_LIBCRYPTO_sky
 	BN_CTX_start(ctx);
 #endif
 	BIGNUM *bnN = BN_CTX_get(ctx);
@@ -439,19 +881,18 @@
 	memcpy(cmd2b + 74, reader->irdId, 4);
 	cmd2b[78] = 0; //keynr
 
-	if(!csystem_data->is_n3_na)
-	{
-		if(!do_cmd(reader, 0x2b, 0x42, 0xab, 0x02, cmd2b + 10, cta_res, &cta_lr))
-		{
+	if (!csystem_data->is_n3_na) {
+		if (!do_cmd(reader, 0x2b,0x42,0xab,0x02, cmd2b+10,cta_res,&cta_lr)) {
 			rdr_log_dbg(reader, D_READER, "CMD$2B failed");
 			return ERROR;
 		}
 	}
-	else if(!do_cmd(reader, 0x27, 0x47, 0xa7, 0x02, cmd2b + 10, cta_res, &cta_lr))
-	{
+	else {
+		if (!do_cmd(reader, 0x27,0x47,0xa7,0x02,cmd2b+10,cta_res,&cta_lr)) {
 		rdr_log_dbg(reader, D_READER, "CMD$27 failed");
 		return ERROR;
 	}
+	}
 
 	rdr_log_dbg(reader, D_READER, "session key negotiated");
 
@@ -465,9 +906,12 @@
 	if RENEW_SESSIONKEY()
 	{
 		rdr_log(reader, "Negotiate sessionkey was not successful! Please check rsa key and boxkey");
-		return ERROR;
+		myprintf("nagra:Please check rsa key and boxkey\n");
+	//	return ERROR; /* sky(!) */
+	}
+	else {
+		reader->nagra_negotiate = 1;
 	}
-
 	return OK;
 }
 
@@ -492,8 +936,7 @@
 	bn_data = BN_new();
 	bn_res = BN_new();
 	ctx = BN_CTX_new();
-	if(ctx == NULL)
-	{
+	if (ctx == NULL) {
 		rdr_log_dbg(reader, D_READER, "RSA Error in dt08 decrypt");
 	}
 	ReverseMem(static_dt08 + 1, 64);
@@ -513,7 +956,7 @@
 	memcpy(&csystem_data->IdeaCamKey[0], reader->boxkey, 8);
 	memcpy(&csystem_data->IdeaCamKey[8], reader->irdId, 4);
 	for(i = 0; i < 4; i++)
-		{ csystem_data->IdeaCamKey[12 + i] = ~reader->irdId[i]; }
+		csystem_data->IdeaCamKey[12 + i] = ~reader->irdId[i];
 
 	// now IDEA decrypt
 	IDEA_KEY_SCHEDULE ks;
@@ -612,6 +1055,7 @@
 		if(reader->csystem_active)          // do not output on init but only afterwards in card_info
 		{
 			rdr_log_sensitive(reader, "IRD ID: {%s}", cs_hexdump(1, reader->irdId, 4, ds, sizeof(ds)));
+				myprintf("nagra:IRD ID: {%s}\n", cs_hexdump(1, reader->irdId, 4, ds, sizeof(ds)));
 			nagra_datetime(reader, cta_res + 24, 0, ds, &reader->card_valid_to);
 			rdr_log(reader, "active to: %s", ds);
 		}
@@ -625,6 +1069,7 @@
 							&& chid == 0x0BEA) ? -21 : 0;
             
 			// todo: add entitlements to list
+				// sky(!)
 			cs_add_entitlement(reader,
 							   reader->caid,
 							   id,
@@ -633,6 +1078,7 @@
 							   tier_date(b2i(2, cta_res + 20) - 0x7f7, ds, 15),
 							   tier_date(b2i(2, cta_res + 13) - 0x7f7 + offset, de, 15),
 							   4,
+							NULL,
 							   1);
 
 
@@ -643,18 +1089,25 @@
 		}
 	case 0x08:
 	case 0x88:
-		if(cta_res[11] == 0x49) { decryptDT08(reader, cta_res); }
+			if (cta_res[11] == 0x49) {
+				myprintf("nagra:decryptDT08\n");
+				decryptDT08(reader, cta_res);
+    		}
+   		break;
 	default:
 		return OK;
 	}
 	return ERROR;
 }
 
+#define MAX_REC	20
 static int32_t GetDataType(struct s_reader *reader, unsigned char dt, int32_t len)
 {
 	def_resp;
 	int32_t result = OK;
-	while(result == OK)
+	int shots = 0;
+
+	while(result == OK && ++shots < MAX_REC)
 	{
 		if(!do_cmd(reader, 0x22, 0x03, 0xA2, len, &dt, cta_res, &cta_lr))
 		{
@@ -668,7 +1121,7 @@
 			result = OK;
 			break;
 		}
-
+		myprintf("nagra:dtparser.%02x\n", dt);
 		if(!ParseDataType(reader, dt & 0x0F, cta_res, cta_lr))
 		{
 			result = ERROR;
@@ -699,6 +1152,7 @@
 	int8_t is_n3_na = 0;
 	memset(reader->irdId, 0xff, 4);
 	memset(reader->hexserial, 0, 8);
+	reader->nagra_negotiate = 0;
 
 	cs_clear_entitlement(reader); // reset the entitlements
 
@@ -734,8 +1188,7 @@
 		}
 		rdr_log(reader, "rsa key configured -> using nagra mode");
 		is_pure_nagra = 1;
-		if(!cs_malloc(&reader->csystem_data, sizeof(struct nagra_data)))
-			{ return ERROR; }
+		if (!cs_malloc(&reader->csystem_data, sizeof(struct nagra_data))) return ERROR;
 		struct nagra_data *csystem_data = reader->csystem_data;
 		csystem_data->is_pure_nagra = is_pure_nagra;
 		if(!do_cmd(reader, 0x10, 0x02, 0x90, 0x11, 0, cta_res, &cta_lr))
@@ -788,10 +1241,8 @@
 	else { return ERROR; }
 	
 	// Private data may be already allocated, see above (the irdeto check).
-	if(!reader->csystem_data)
-	{
-		if(!cs_malloc(&reader->csystem_data, sizeof(struct nagra_data)))
-			{ return ERROR; }
+	if (!reader->csystem_data) {
+		if (!cs_malloc(&reader->csystem_data, sizeof(struct nagra_data))) return ERROR;
 	}
 	struct nagra_data *csystem_data = reader->csystem_data;
 	csystem_data->is_pure_nagra = is_pure_nagra;
@@ -811,18 +1262,18 @@
 		memcpy(reader->hexserial + 2, cta_res + 2, 4);
 		memcpy(reader->sa[0], cta_res + 2, 2);
 
-		if(!GetDataType(reader, DT01, 0x0E)) { return ERROR; }
+		if (!GetDataType(reader, DT01,0x0E)) return ERROR;
 		rdr_log_dbg(reader, D_READER, "DT01 DONE");
 		CamStateRequest(reader);
-		if(!GetDataType(reader, IRDINFO, 0x39)) { return ERROR; }
+		if (!GetDataType(reader, IRDINFO,0x39)) return ERROR;
 		rdr_log_dbg(reader, D_READER, "IRDINFO DONE");
 		CamStateRequest(reader);
-		if(!GetDataType(reader, CAMDATA, 0x55)) { return ERROR; }
+		if (!GetDataType(reader, CAMDATA,0x55)) return ERROR;
 		rdr_log_dbg(reader, D_READER, "CAMDATA Done");
-		if(!GetDataType(reader, 0x04, 0x44)) { return ERROR; }
+		if (!GetDataType(reader, 0x04,0x44)) return ERROR;
 		rdr_log_dbg(reader, D_READER, "DT04 DONE");
 		CamStateRequest(reader);
-		if(!GetDataType(reader, DT06, 0x16)) { return ERROR; }
+		if (!GetDataType(reader, DT06,0x16)) return ERROR;
 		rdr_log_dbg(reader, D_READER, "DT06 DONE");
 		CamStateRequest(reader);
 	}
@@ -897,6 +1348,14 @@
 	{
 		rdr_log(reader, "Prv.ID: %s", cs_hexdump(1, reader->prid[i], 4, tmp, sizeof(tmp)));
 	}
+   // sky(oscam.smartcard)
+	uint32_t ulserial;
+	ulserial = b2i(4,reader->hexserial+2);
+	sprintf(reader->ascserial, "%02d.%04d.%04d.??",
+			  ulserial / 100000000,
+			 (ulserial / 10000) % 10000,
+			 (ulserial % 10000));
+
 	cs_clear_entitlement(reader); //reset the entitlements
 	if(csystem_data->is_tiger)
 	{
@@ -967,9 +1426,9 @@
 				}
 			}
 			if(reader->nagra_read == 1)
-				{ qsort(records, num_records, sizeof(ncmed_rec), reccmp); }
+			 	qsort(records, num_records, sizeof(ncmed_rec), reccmp);
 			else
-				{ qsort(records, num_records, sizeof(ncmed_rec), reccmp2); }
+			 	qsort(records, num_records, sizeof(ncmed_rec), reccmp2);
 
 			int32_t  euro = 0;
 			char tiername[83];
@@ -996,7 +1455,8 @@
 							rdr_log(reader, "Activation     : ( %04X ) from %s to %s  (%3d euro) %s",
 									records[i].value, records[i].date1, records[i].date2, euro, get_tiername(records[i].value, reader->caid, tiername));
 						}
-						cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, 1);
+					      // sky(!)
+					      cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, NULL, 1);
 					}
 					break;
 
@@ -1009,14 +1469,15 @@
 							rdr_log(reader, "Tier : %04X, expiry date: %s %s",
 									records[i].value, records[i].date2, get_tiername(records[i].value, reader->caid, tiername));
 						}
-						cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, 1);
+					      // sky(!)
+					      cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, NULL, 1);
 					}
 					break;
 				}
 				if(reader->nagra_read == 2)
 				{
 					while(i < num_records - 1 && records[i].value == records[i + 1].value)
-						{ ++i; }
+					   ++i;
 				}
 			}
 
@@ -1049,20 +1510,19 @@
 
 				case 0x29:
 					euro = records[i].price / 100;
-					if(reader->nagra_read == 1) { credit -= euro; }
+					   if (reader->nagra_read == 1) credit -= euro;
 					rdr_log(reader, "Event purchase : ( %04X ) from %s to %s  (%3d euro)",
 							records[i].value, records[i].date1, records[i].date2, euro);
 					break;
 				}
 			}
 			if(reader->nagra_read == 1)
-				{ rdr_log(reader, "Credit         :                                          %3d euro", credit); }
+				rdr_log(reader, "Credit         :                                          %3d euro", credit);
 			else
-				{ rdr_log(reader, "Credit : %3d euro", balance); }
+				rdr_log(reader, "Credit : %3d euro", balance);
 		}
 	}
-	else
-	{
+	else {
 		def_resp;
 		char tmp_dbg[13];
 		CamStateRequest(reader);
@@ -1075,7 +1535,7 @@
 		rdr_log_dbg_sensitive(reader, D_READER, "SER:  {%s}", cs_hexdump(1, reader->hexserial + 2, 4, tmp_dbg, sizeof(tmp_dbg)));
 		memcpy(reader->sa[0], cta_res + 2, 2);
 		reader->nprov = 1;
-		if(!GetDataType(reader, IRDINFO, 0x39)) { return ERROR; }
+		if (!GetDataType(reader, IRDINFO,0x39)) return ERROR;
 		rdr_log_dbg(reader, D_READER, "IRDINFO DONE");
 		CamStateRequest(reader);
 
@@ -1084,11 +1544,12 @@
 			rdr_log(reader, "-----------------------------------------");
 			rdr_log(reader, "|id  |tier    |valid from  |valid to    |");
 			rdr_log(reader, "+----+--------+------------+------------+");
-			if(!GetDataType(reader, TIERS, 0x57)) { return ERROR; }
+			if (!GetDataType(reader, TIERS,0x57)) return ERROR;
 			rdr_log(reader, "-----------------------------------------");
 			CamStateRequest(reader);
 		}
 	}
+	rdr_log(reader, "ready for requests");
 	return OK;
 }
 
@@ -1098,8 +1559,8 @@
 	if(!csystem_data->is_tiger)
 	{
 		CamStateRequest(reader);
-		if RENEW_SESSIONKEY() { NegotiateSessionKey(reader); }
-		if SENDDATETIME() { DateTimeCMD(reader); }
+		if RENEW_SESSIONKEY() NegotiateSessionKey(reader);
+		if SENDDATETIME() DateTimeCMD(reader);
 	}
 }
 
@@ -1110,18 +1571,15 @@
 	if(!csystem_data->is_tiger)
 	{
 		int32_t retry = 0;
-		if(csystem_data->is_n3_na)
-		{
+		if (csystem_data->is_n3_na) {
 			unsigned char ecm_pkt[256 + 16];
 			memset(ecm_pkt, 0, sizeof(ecm_pkt));
 			memcpy(ecm_pkt, er->ecm + 3 + 2, er->ecm[4]);
 
-			while(!do_cmd(reader, er->ecm[3] + 1, er->ecm[4] + 5 + 2, 0x88, 0x04, ecm_pkt, cta_res, &cta_lr))
-			{
+			while (!do_cmd(reader, er->ecm[3]+1,er->ecm[4]+5+2,0x88,0x04, ecm_pkt,cta_res,&cta_lr)) {
 				if(retry == 0)
-					{ rdr_log_dbg(reader, D_READER, "nagra2_do_ecm (N3_NA) failed, retry"); }
-				else
-				{
+					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm (N3_NA) failed, retry");
+				else {
 					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm (N3_NA) failed, retry failed!");
 					return ERROR;
 				}
@@ -1129,47 +1587,39 @@
 				cs_sleepms(10);
 			}
 		}
-		else
-		{
-			if(reader->ecmcommand < 5)    // cache ecm commands until ecmcommand cache is full
-			{
+		else {
+			if (reader->ecmcommand < 5) { // cache ecm commands until ecmcommand cache is full
 				reader->ecmcommandcache[reader->ecmcommand] = er->ecm[3];
 				reader->ecmcommand++;
-				if(reader->ecmcommand == 5)   // cache is full, comparing!
-				{
+				if (reader->ecmcommand == 5) { // cache is full, comparing!
 					int32_t t = 0;
 					int32_t matchfound = 0;
 					reader->ecmcommand++; // No more caching of ecm commands, next ecms will be compared!
-					while(t < 5)
-					{
-						if(reader->ecmcommandcache[t] == er->ecm[3]) { matchfound++; }
+					while (t < 5) {
+						if (reader->ecmcommandcache[t] == er->ecm[3]) matchfound++;
 						t++;
 					}
-					if(matchfound != 5)
-					{
+					if (matchfound != 5) {
 						reader->ecmcommand = 0; // reset ecm filter, start a new auto filter attempt
 						rdr_log_dbg(reader, D_READER, "Auto ecm command filter caid %04X failed!", reader->caid);
 					}
-					else
-					{
+					else {
 						reader->ecmcommandcache[0] = er->ecm[3]; // Passed the filter, store the normal ecm command for this reader!
 						rdr_log_dbg(reader, D_READER, "Auto ecm command filter caid %04X set to command %02X", reader->caid, er->ecm[3]);
 					}
 				}
 			}
-			else if(reader->ecmcommandcache[0] != er->ecm[3])
-			{
+			else if (reader->ecmcommandcache[0] != er->ecm[3]) {
 				rdr_log_dbg(reader, D_READER, "Warning: received an abnominal ecm command %02X for caid: %04X, ignoring!", er->ecm[3], reader->caid);
 				memset(ea, 0, sizeof(struct s_ecm_answer)); // give it back 00000000 to not disturb the loadbalancer for valid ecm requests on this channel.
 				return OK;
 			}
-
+			myprintf("nagra:ecm send\n");
 			while(!do_cmd(reader, er->ecm[3], er->ecm[4] + 2, 0x87, 0x02, er->ecm + 3 + 2, cta_res, &cta_lr))
 			{
 				if(retry == 0)
-					{ rdr_log_dbg(reader, D_READER, "nagra2_do_ecm failed, retry"); }
-				else
-				{
+					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm failed, retry");
+				else {
 					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm failed, retry failed!");
 					return ERROR;
 				}
@@ -1186,6 +1636,7 @@
 			retry++;
 			cs_sleepms(10);
 		}
+		myprintf("nagra:has_cw{%d}\n", HAS_CW());
 		if(HAS_CW() && (do_cmd(reader, 0x1C, 0x02, 0x9C, 0x36, NULL, cta_res, &cta_lr)))
 		{
 			unsigned char v[8];
@@ -1208,7 +1659,7 @@
 	{
 		//check ECM prov id
 		if(memcmp(&reader->prid[0][2], er->ecm + 5, 2))
-			{ return ERROR; }
+			return ERROR;
 
 		//                  ecm_data: 80 30 89 D3 87 54 11 10 DA A6 0F 4B 92 05 34 00 ...
 		//serial_data: A0 CA 00 00 8C D3 8A 00 00 00 00 00 10 DA A6 0F .
@@ -1236,20 +1687,17 @@
 
 int32_t nagra2_get_emm_type(EMM_PACKET *ep, struct s_reader *rdr)  //returns 1 if shared emm matches SA, unique emm matches serial, or global or unknown
 {
-	switch(ep->emm[0])
-	{
+	switch (ep->emm[0]) {
 	case 0x83:
 		memset(ep->hexserial, 0, 8);
 		ep->hexserial[0] = ep->emm[5];
 		ep->hexserial[1] = ep->emm[4];
 		ep->hexserial[2] = ep->emm[3];
-		if(ep->emm[7] == 0x10)
-		{
+			if (ep->emm[7] == 0x10) {
 			ep->type = SHARED;
 			return (!memcmp(rdr->hexserial + 2, ep->hexserial, 3));
 		}
-		else
-		{
+			else {
 			ep->hexserial[3] = ep->emm[6];
 			ep->type = UNIQUE;
 			return (!memcmp(rdr->hexserial + 2, ep->hexserial, 4));
@@ -1265,11 +1713,10 @@
 
 static int32_t nagra2_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count)
 {
-	if(*emm_filters == NULL)
-	{
+	if (*emm_filters == NULL) {
 		const unsigned int max_filter_count = 3;
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+		  	return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
Index: reader-seca.c
===================================================================
--- reader-seca.c	(revision 10670)
+++ reader-seca.c	(working copy)
@@ -89,8 +89,11 @@
 		{ add_provider(0x0100, provid, l_name + 8, "", ""); }
 	struct seca_data *csystem_data = reader->csystem_data;
 	csystem_data->valid_provider[i] = valid;
-	rdr_log(reader, "provider %d: %04X, valid: %i%s, expiry date: %4d/%02d/%02d",
-			i + 1, provid, valid, l_name, year, month, day);
+//	sky(!)
+//	rdr_log(reader, "provider %d: %04X, valid: %i%s, expiry date: %4d/%02d/%02d",
+//       i + 1, provid, valid, l_name, year, month, day);
+	rdr_log(reader, "provider %d: %04X, valid: %i%s, expiry date: %2d/%02d/%04d",
+			   i + 1, provid, valid, l_name, day, month, year);
 	memcpy(&reader->sa[i][0], cta_res + 18, 4);
 	if(valid)  //if not expired
 		{ rdr_log_sensitive(reader, "SA: {%s}", cs_hexdump(0, cta_res + 18, 4, tmp, sizeof(tmp))); }
@@ -104,25 +107,23 @@
 	// Check if entitlement entry exists
 	LL_ITER it = ll_iter_create(reader->ll_entitlements);
 	S_ENTITLEMENT *entry = NULL;
-	do
-	{
+	do {
 		entry = ll_iter_next(&it);
 		if((entry) && (entry->provid == provid))
-			{ break; }
-	}
-	while(entry);
+			break;
+	} while (entry);
 
-	if(entry)
-	{
+	if (entry) {
 		// update entitlement info if found
 		entry->end = mktime(&lt);
 		entry->id = get_pbm(reader, i);
 		entry->type = (i) ? 6 : 7;
 	}
-	else
+	else {
 		// add entitlement info
-		{ cs_add_entitlement(reader, reader->caid, provid, get_pbm(reader, i), 0, 0, mktime(&lt), (i) ? 6 : 7, 1); }
-
+		// sky(!)
+		cs_add_entitlement(reader, reader->caid, provid, get_pbm(reader, i), 0, 0, mktime(&lt), (i)?6:7, NULL, 1);
+	}
 	return OK;
 }
 
@@ -161,28 +162,23 @@
 
 	def_resp;
 
-	if(strcmp(reader->pincode, "none"))
-	{
+	if (strcmp(reader->pincode, "none")) {
 		rdr_log(reader, "Using PIN %s", reader->pincode);
 		// the pin need to be coded in bcd, so we need to convert from ascii to bcd, so '1234' -> 0x12 0x34
 		ins30data[6] = ((reader->pincode[0] - 0x30) << 4) | ((reader->pincode[1] - 0x30) & 0x0f);
 		ins30data[7] = ((reader->pincode[2] - 0x30) << 4) | ((reader->pincode[3] - 0x30) & 0x0f);
 	}
-	else
-	{
+	else {
 		rdr_log(reader, "Using PIN 0000!");
 	}
 
 	write_cmd(ins30, ins30data);
 	rdr_log_dbg(reader, D_READER, "ins30_answer: %02x%02x", cta_res[0], cta_res[1]);
-	if(!(cta_res[cta_lr - 2] == 0x90 && cta_res[cta_lr - 1] == 0))
-	{
-		if(strcmp(reader->pincode, "none"))
-		{
+	if ( !(cta_res[cta_lr-2]==0x90 && cta_res[cta_lr-1]==0) ) {
+		if (strcmp(reader->pincode, "none")) {
 			rdr_log(reader, "Can't disable parental lock. Wrong PIN? OSCam used %s!", reader->pincode);
 		}
-		else
-		{
+		else {
 			rdr_log(reader, "Can't disable parental lock. Wrong PIN? OSCam used 0000!");
 		}
 	}
@@ -240,6 +236,20 @@
 	write_cmd(ins0e, NULL); // read unique id
 	memcpy(reader->hexserial, cta_res + 2, 6);
 	serial = b2ll(5, cta_res + 3) ;
+	// sky(oscam.smartcard)
+	{
+		uint16_t sn_h;
+		uint32_t sn_l;
+		sn_h = b2i(2, reader->hexserial);
+		sn_l = b2i(4, reader->hexserial+2);
+
+		sprintf(reader->ascserial, "%02d.%03d.%03d.%03d",
+			 (sn_h % 100),
+			 (sn_l / 1000000),
+			 (sn_l / 1000) % 1000,
+			 (sn_l % 1000));
+	}
+
 	rdr_log_sensitive(reader, "type: SECA, caid: %04X, serial: {%llu}, card: %s v%d.%d",
 					  reader->caid, (unsigned long long) serial, card, atr[9] & 0x0F, atr[9] >> 4);
 	
@@ -280,7 +290,7 @@
 	int32_t prov;
 	for(prov = 0; prov < rdr->nprov; prov++)  //search for provider index
 		if(!memcmp(provid, &rdr->prid[prov][2], 2))
-			{ return (prov); }
+			return(prov);
 	return (-1);
 }
 
@@ -324,51 +334,44 @@
 	ins3c[4] = (((er->ecm[1] & 0x0f) << 8) | er->ecm[2]) - 0x05;
 	int32_t try = 1;
 	int32_t ret;
-	do
-	{
+	do {
 		if(try > 1)
 				snprintf(ea->msglog, MSGLOGSIZE, "ins3c try nr %i", try);
 		write_cmd(ins3c, er->ecm + 8); //ecm request
 		unsigned char ins30[] = { 0xC1, 0x30, 0x00, 0x02, 0x09 };
 		unsigned char ins30data[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF };
 		/* We need to use a token */
-		if(cta_res[0] == 0x90 && cta_res[1] == 0x1a)
-		{
+		if (cta_res[0] == 0x90 && cta_res[1] == 0x1a) {
 			write_cmd(ins30, ins30data);
 			write_cmd(ins3c, er->ecm + 8); //ecm request
 		}
 		ret = (((cta_res[0] != 0x90) && (cta_res[0] != 0x93) && (cta_res[0] != 0x96)) || ((cta_res[1] != 0x00) && (cta_res[1] != 0x02)));
 		// Handle all not initial 90 00 ecm of with a get decoding cw does avoid the need off card reset after a lot off them
 		// the try ++ has been removed as it triggers the anti share mode off seca cards due to not recorded extra ecm's by rate limiter
-		if((cta_res[0] == 0x93) && (cta_res[1] == 0x02))
-		{
+		if ((cta_res[0] == 0x93) && (cta_res[1] == 0x02)) {
 			write_cmd(ins3a, NULL); //get cw
 			snprintf(ea->msglog, MSGLOGSIZE, "unsubscribed 93 02");
 			return ERROR;
-		}; // exit if unsubscribed
-		if((cta_res[0] == 0x96)  && (cta_res[1] == 0x00))
-		{
+		}	// exit if unsubscribed
+		if ((cta_res[0] == 0x96)  && (cta_res[1] == 0x00)) {
 			write_cmd(ins3a, NULL); //get cw
 			snprintf(ea->msglog, MSGLOGSIZE, "fake 96 00 ecm");
 			return ERROR;
-		}; //exit if fake 96 00 ecm
-		if(ret)
-		{
+		}	//exit if fake 96 00 ecm
+		if (ret) {
 			snprintf(ea->msglog, MSGLOGSIZE, "%s ins3c card res: %02x %02x", reader->label, cta_res[0] , cta_res[1]);
 			write_cmd(ins3a, NULL); //get cw
 			return ERROR;
-		}; //exit on other's then 96 00 or 93 02
-	}
-	while((try < 2) && (ret));
+		}	//exit on other's then 96 00 or 93 02
+	} while ((try < 2) && (ret));
 	if(ret)
-		{ return ERROR; }
+		return ERROR;
 
 	write_cmd(ins3a, NULL); //get cw's
-	if((cta_res[16] != 0x90) || (cta_res[17] != 0x00))
-	{
+	if ((cta_res[16] != 0x90) || (cta_res[17] != 0x00)) {
 		snprintf(ea->msglog, MSGLOGSIZE, "ins3a card response: %02x %02x", cta_res[16] , cta_res[17]);
 		return ERROR;
-	};// exit if response not 90 00
+	}	// exit if response not 90 00
 	//TODO: if response is 9027 ppv mode is possible!
 	
 	if (er->ecm[5]==0x01 && ((reader->card_atr[9] & 0X0F) == 10)) // seca3: nano 01 in effect?
@@ -426,7 +429,7 @@
 		i = get_prov_index(rdr, ep->emm + 3);
 		rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED, ep->hexserial = {%s}", cs_hexdump(1, ep->hexserial, 3, tmp_dbg, sizeof(tmp_dbg)));
 		if(i == -1)  //provider not found on this card
-			{ return 0; } //do not pass this EMM
+            return 0; //do not pass this EMM
 		rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED, rdr->sa[%i] = {%s}", i, cs_hexdump(1, rdr->sa[i], 3, tmp_dbg, sizeof(tmp_dbg)));
 		return (!memcmp(rdr->sa[i], ep->hexserial, 3));
 		break;
@@ -461,11 +464,10 @@
 
 static int32_t seca_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count)
 {
-	if(*emm_filters == NULL)
-	{
+	if (*emm_filters == NULL) {
 		const unsigned int max_filter_count = 1 + (2 * rdr->nprov);
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
-			{ return ERROR; }
+		return ERROR;
 
 		struct s_csystem_emm_filter *filters = *emm_filters;
 		*filter_count = 0;
@@ -481,9 +483,8 @@
 		idx++;
 
 		int32_t prov;
-		for(prov = 0; prov < rdr->nprov; prov++)
-		{
-			if(!memcmp(rdr->sa[prov], "\x00\x00\x00", 3)) { continue; }   // if sa == null skip update by shared & global (provid inactive)
+	for (prov=0; prov<rdr->nprov; prov++) {
+		if (!memcmp (rdr->sa[prov], "\x00\x00\x00", 3)) continue;// if sa == null skip update by shared & global (provid inactive)
 
 			filters[idx].type = EMM_GLOBAL; //global by provider
 			filters[idx].enabled   = 1;
@@ -518,8 +519,7 @@
 	int32_t emm_length = ((ep->emm[1] & 0x0f) << 8) + ep->emm[2];
 	uint8_t *prov_id_ptr;
 
-	switch(ep->type)
-	{
+   switch (ep->type) {
 	case SHARED:
 		ins40[3] = ep->emm[9];
 		ins40[4] = emm_length - 0x07;
@@ -557,19 +557,17 @@
 
 	ins40[2] = (ep->emm[ins40data_offset - 2] & 0xF0) | (i & 0x0F);
 	write_cmd(ins40, ep->emm + ins40data_offset); //emm request
-	if(cta_res[0] == 0x97)
-	{
+   if (cta_res[0] == 0x97) {
 		if(!(cta_res[1] & 4))  // date updated
-			{ set_provider_info(reader, i); }
+	 	 	set_provider_info(reader, i);
 		else
-			{ rdr_log(reader, "EMM: Update not necessary."); }
+	 	 	rdr_log(reader, "EMM: Update not necessary.");
 		return OK; //Update not necessary
 	}
-	if((cta_res[0] == 0x90) && ((cta_res[1] == 0x00) || (cta_res[1] == 0x19)))
-	{
-		if(ep->type == GLOBAL) { return OK; }  //do not print new provider info after global emm
+	if ((cta_res[0] == 0x90) && ((cta_res[1] == 0x00) || (cta_res[1] == 0x19))) {
+		if (ep->type == GLOBAL) return OK; //do not print new provider info after global emm
 		if(set_provider_info(reader, i) == OK)  //after successful EMM, print32_t new provider info
-			{ return OK; }
+			return OK;
 	}
 	return ERROR;
 }
Index: reader-tongfang.c
===================================================================
--- reader-tongfang.c	(revision 10670)
+++ reader-tongfang.c	(working copy)
@@ -44,7 +44,7 @@
 	def_resp;
 	get_hist;
 
-	if((hist_size < 4) || (memcmp(hist, "NTIC", 4))) { return ERROR; }
+  if ((hist_size < 4) || (memcmp(hist, "NTIC",4))) return ERROR;
 
 	reader->caid = 0x4A02;
 	// For now, only one provider, 0000
@@ -54,14 +54,14 @@
 	rdr_log(reader, "Tongfang card detected");
 
 	write_cmd(begin_cmd, begin_cmd + 5);
-	if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00)) { return ERROR; }
+  if ((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00)) return ERROR;
 
 	write_cmd(get_serial_cmd, get_serial_cmd + 5);
-	if((cta_res[cta_lr - 2] & 0xf0) != 0x60) { return ERROR; }
+  if ((cta_res[cta_lr - 2] & 0xf0) != 0x60) return ERROR;
 	data_len = tongfang_read_data(reader, cta_res[cta_lr - 1], data, &status);
 
-	if(data_len < 0) { return ERROR; }
-	if(status != 0x9000) { return ERROR; }
+  if (data_len < 0) return ERROR;
+  if (status != 0x9000) return ERROR;
 
 	memset(reader->hexserial, 0, 8);
 	memcpy(reader->hexserial + 2, data, 4); // might be incorrect offset
@@ -77,6 +77,9 @@
 	memcpy(pairing_cmd + 5, boxID, sizeof(boxID));
 	write_cmd(pairing_cmd, pairing_cmd + 5);
 
+  // sky(oscam.smartcard)
+  sprintf(reader->ascserial, "%llu", b2ll(6, reader->hexserial));
+
 	rdr_log_sensitive(reader, "type: Tongfang, caid: %04X, serial: {%llu}, hex serial: {%02x%02x%02x%02x}, BoxID: {%02X%02X%02X%02X}",
 					  reader->caid, (unsigned long long) b2ll(6, reader->hexserial), reader->hexserial[2],
 					  reader->hexserial[3], reader->hexserial[4], reader->hexserial[5],
@@ -109,9 +112,8 @@
 	int32_t data_len = 0;
 	uint16_t status = 0;
 
-	if((ecm_len = check_sct_len(er->ecm, 3)) < 0) { return ERROR; }
-	if(cs_malloc(&tmp, ecm_len * 3 + 1))
-	{
+  if ((ecm_len = check_sct_len(er->ecm, 3)) < 0) return ERROR;
+	if (cs_malloc(&tmp, ecm_len * 3 + 1)) {
 		rdr_log_dbg(reader, D_IFD, "ECM: %s", cs_hexdump(1, er->ecm, ecm_len, tmp, ecm_len * 3 + 1));
 		NULLFREE(tmp);
 	}
@@ -148,7 +150,7 @@
 
 	data_len = tongfang_read_data(reader, read_size, data, &status);
 
-	if(data_len < 23) { return ERROR; }
+  if (data_len < 23) return ERROR;
 
 	if(!(er->ecm[0] & 0x01))
 	{
@@ -161,7 +163,7 @@
 	}
 
 	// All zeroes is no valid CW, can be a result of wrong boxid
-	if(!cw_is_valid(ea->cw) || !cw_is_valid(ea->cw + 8)) { return ERROR; }
+  if (!cw_is_valid(ea->cw) || !cw_is_valid(ea->cw + 8)) return ERROR;
 
 	return OK;
 }
@@ -178,7 +180,7 @@
 	def_resp;
 	int32_t write_len;
 
-	if(ep->emm[2] < 5) { return ERROR; }
+  if (ep->emm[2] < 5) return ERROR;
 
 	write_len = ep->emm[15] + 5;
 	memcpy(emm_cmd, ep->emm + 11, write_len);
@@ -195,7 +197,7 @@
 	int32_t i;
 
 	write_cmd(get_provider_cmd, NULL);
-	if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00)) { return ERROR; }
+  if ((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00)) return ERROR;
 
 	for(i = 0; i < 4; i++)
 	{
Index: reader-viaccess.c
===================================================================
--- reader-viaccess.c	(revision 10670)
+++ reader-viaccess.c	(working copy)
@@ -2,6 +2,7 @@
 #ifdef READER_VIACCESS
 #include "oscam-aes.h"
 #include "oscam-time.h"
+#include "oscam-chk.h"
 #include "oscam-emm.h"
 #include "reader-common.h"
 
@@ -18,6 +19,48 @@
 	struct geo_cache    last_geo;
 	uint8_t             availkeys[CS_MAXPROV][16];
 };
+// sky(n)
+static uint8_t 		mytntsat_aeskeys[512] =
+		{0x28,0x44,0x25,0x87,0x92,0xF6,0xD9,0x52,0x9A,0x32,0x8B,0x3E,0x8C,0xD2,0xFD,0x0E,	// E0
+//		 0xA7,0x9A,0xC0,0xDB,0xEC,0x9C,0x92,0x51,0xD1,0x91,0x5F,0x05,0x88,0x62,0xAF,0x26,	// E1
+//		 0x82,0x1F,0x45,0x56,0x23,0x8D,0xDE,0x0F,0xA0,0xBD,0x31,0x8F,0x08,0x3E,0x84,0xBC,	// E1  /* 2014.06.12 */
+//		 0xF1,0xDC,0xB1,0x5A,0x3D,0xE3,0xFA,0x1D,0x7E,0x29,0x98,0xDA,0x7D,0xD4,0x89,0x8A,	// E1  /* 2014.06.30 */
+		 0xF7,0x86,0xE2,0x1F,0x17,0x82,0xBE,0x09,0x75,0x53,0xB0,0xD3,0x49,0xE0,0x36,0x2A,	// E1  /* 2014.07.09 */
+//		 0xEF,0x3C,0xB8,0xD3,0x6A,0x86,0x20,0x97,0xA3,0x3F,0xC4,0x71,0x01,0x04,0x1B,0xE3,	// E2
+//		 0x9B,0x63,0xA9,0x7D,0xA5,0xC8,0x0A,0x87,0xA8,0x7E,0xF1,0x6C,0xB2,0x8E,0xF1,0xAB,	// E2  /* 2014.06.17 */
+ 		 0x48,0xC1,0x9B,0x86,0xA4,0xE2,0xEB,0x72,0x88,0xDF,0xDC,0xE7,0xC2,0xBB,0x75,0x77,	// E2  /* 2014.06.30 */
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E3
+		 0x6B,0x1B,0x02,0x4D,0x36,0xF6,0x09,0x74,0x97,0x3C,0xB8,0x1F,0xA5,0xE8,0xF0,0x1C,	// E4
+		 0x12,0x70,0x03,0xF8,0xE9,0x51,0x00,0x36,0x7A,0x55,0x61,0x21,0xC7,0x79,0xFB,0x6E,	// E5
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E6
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E7
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E8
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E9
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EA
+ 		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// EB
+		 0x9A,0x3E,0xAB,0x02,0x03,0xEB,0xFF,0xCA,0x85,0xB4,0xF1,0x82,0x80,0x74,0x9F,0x56,	// EC
+		 0x25,0x04,0xB3,0x82,0xB1,0x6D,0x8C,0x67,0x58,0xDB,0x96,0x0E,0x31,0x1E,0x93,0x51,	// ED
+		 0x34,0x98,0x83,0xE5,0x4D,0x58,0x33,0x6D,0xCA,0x75,0x0A,0x87,0x8A,0xCC,0x5C,0xD5,	// EE
+//		 0x12,0x70,0x03,0xF8,0xE9,0x51,0x00,0x36,0x7A,0x55,0x61,0x21,0xC7,0x79,0xFB,0x6E,	// EF
+		 0x4A,0x26,0xAD,0x25,0x17,0x95,0xA5,0x8A,0x11,0xBB,0xC0,0x7B,0x53,0xC4,0x43,0x48,	// EF  /* 2014.06.23 */
+
+		 0x28,0x44,0x25,0x87,0x92,0xF6,0xD9,0x52,0x9A,0x32,0x8B,0x3E,0x8C,0xD2,0xFD,0x0E,	// E10 /* 2014.06.26 */
+		 0xF6,0x2C,0x3B,0xE3,0x00,0xE9,0x8B,0xBB,0x37,0x8D,0xFA,0x38,0xBB,0x6E,0xEE,0xF1,   // E11 /* 2014.06.26 */
+ 		 0xDD,0x39,0x0F,0xED,0x21,0x91,0xD2,0x82,0x01,0x60,0x25,0x09,0x3E,0xE0,0x91,0xBA,	// E12 /* 2014.06.26 */
+		 0x8C,0x61,0x99,0xE0,0xB8,0x87,0x7F,0x4B,0xD2,0x13,0x6E,0xF6,0xD1,0x14,0x2D,0x15,	// E13
+		 0x6B,0x1B,0x02,0x4D,0x36,0xF6,0x09,0x74,0x97,0x3C,0xB8,0x1F,0xA5,0xE8,0xF0,0x1C,	// E14
+		 0x12,0x70,0x03,0xF8,0xE9,0x51,0x00,0x36,0x7A,0x55,0x61,0x21,0xC7,0x79,0xFB,0x6E,	// E15
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E16
+		 0x1D,0xE0,0xC4,0x62,0x3A,0x8C,0x79,0x8B,0xD7,0x69,0x3C,0xCB,0xE6,0x4C,0x9A,0xC0,	// E17
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E18
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E19
+		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E1A
+ 		 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// E1B
+		 0x9A,0x3E,0xAB,0x02,0x03,0xEB,0xFF,0xCA,0x85,0xB4,0xF1,0x82,0x80,0x74,0x9F,0x56,	// E1C
+		 0x25,0x04,0xB3,0x82,0xB1,0x6D,0x8C,0x67,0x58,0xDB,0x96,0x0E,0x31,0x1E,0x93,0x51,	// E1D
+		 0x34,0x98,0x83,0xE5,0x4D,0x58,0x33,0x6D,0xCA,0x75,0x0A,0x87,0x8A,0xCC,0x5C,0xD5,	// E1E
+		 0x4A,0x26,0xAD,0x25,0x17,0x95,0xA5,0x8A,0x11,0xBB,0xC0,0x7B,0x53,0xC4,0x43,0x48,	// E1F
+		};
 
 struct via_date
 {
@@ -124,16 +167,21 @@
 				parse_via_date(b - 4, &vd, 1);
 				cls = (l - (j + 1)) * 8 + i;
 				if(p)
-				{
-					rdr_log(reader, "%sclass: %02X, expiry date: %04d/%02d/%02d - %04d/%02d/%02d", p, cls,
-							vd.year_s + 1980, vd.month_s, vd.day_s,
-							vd.year_e + 1980, vd.month_e, vd.day_e);
-				}
-				else
-				{
-					rdr_log(reader, "class: %02X, expiry date: %04d/%02d/%02d - %04d/%02d/%02d", cls,
-							vd.year_s + 1980, vd.month_s, vd.day_s,
-							vd.year_e + 1980, vd.month_e, vd.day_e);
+				// sky(date)
+				//	rdr_log(reader, "%sclass: %02X, expiry date: %04d/%02d/%02d - %04d/%02d/%02d", p, cls,
+				//				vd.year_s+1980, vd.month_s, vd.day_s,
+				//				vd.year_e+1980, vd.month_e, vd.day_e);
+					rdr_log(reader, "%sclass: %02X, expiry date: %02d/%02d/%04d - %02d/%02d/%04d", p, cls,
+								vd.day_s, vd.month_s, vd.year_s+1980,
+								vd.day_e, vd.month_e, vd.year_e+1980);
+				else {
+				// sky(date)
+				//	rdr_log(reader, "class: %02X, expiry date: %04d/%02d/%02d - %04d/%02d/%02d", cls,
+				//				vd.year_s+1980, vd.month_s, vd.day_s,
+				//				vd.year_e+1980, vd.month_e, vd.day_e);
+					rdr_log(reader, "class: %02X, expiry date: %02d/%02d/%04d - %02d/%02d/%04d", cls,
+								vd.day_s, vd.month_s, vd.year_s+1980,
+								vd.day_e, vd.month_e, vd.year_e+1980);
 
 					time_t start_t, end_t;
 					struct tm tm;
@@ -148,8 +196,8 @@
 					tm.tm_mon = vd.month_e - 1; // january is 0 in tm_mon
 					tm.tm_mday = vd.day_e;
 					end_t = cs_timegm(&tm);
-
-					cs_add_entitlement(reader, reader->caid, provid, cls, cls, start_t, end_t, 5, 1);
+// sky(!)
+					cs_add_entitlement(reader, reader->caid, provid, cls, cls, start_t, end_t, 5, NULL, 1);
 				}
 			}
 }
@@ -169,7 +217,7 @@
 			{
 				uchar cls;
 				cls = (l - (j + 1)) * 8 + i;
-				if(cs_add_entitlement(reader, reader->caid, provid, cls, cls, 0, 0, 5, 0) == NULL)
+				if (cs_add_entitlement(reader, reader->caid, provid, cls, cls, 0, 0, 5, NULL, 0) == NULL)
 				{
 					rdr_log(reader, "provid %06X class %02X not found!", provid, cls);
 					return 0; // class not found!
@@ -923,12 +971,30 @@
 	//  }
 
 	reader->caid = 0x500;
+// sky(n)
+#if 0
+	insac[2]=0x06;
+	write_cmd(insac, NULL); // request maturity
+	insb8[4]=0x03;
+	write_cmd(insb8, NULL);
+	reader->maturity = cta_res[2];
+#endif
 	memset(reader->prid, 0xff, sizeof(reader->prid));
 	insac[2] = 0xa4;
 	write_cmd(insac, NULL); // request unique id
 	insb8[4] = 0x07;
 	write_cmd(insb8, NULL); // read unique id
 	memcpy(reader->hexserial, cta_res + 2, 5);
+
+   // sky(oscam.smartcard)
+   {
+	  	uint32_t userial;
+	    if (reader->hexserial[0]==0) userial = b2i(4, &(reader->hexserial[1]));
+		else
+	    if (reader->hexserial[4]==0) userial = b2le(4, &(reader->hexserial[1]));
+		else                          userial = b2i(4, &(reader->hexserial[0]));
+		sprintf(reader->ascserial, "%i%i", userial/10000, userial%10000);
+ 	}
 	//  rdr_log(reader, "[viaccess-reader] type: Viaccess, ver: %s serial: %llu", ver, b2ll(5, cta_res+2));
 	rdr_log_sensitive(reader, "type: Viaccess (%sstandard atr), caid: %04X, serial: {%llu}",
 					  atr[9] == 0x68 ? "" : "non-", reader->caid, (unsigned long long) b2ll(5, cta_res + 2));
@@ -972,9 +1038,7 @@
 
 	get_maturity(reader);
 	if(cfg.ulparent)
-		{ 
-			unlock_parental(reader);
-		}
+		{ unlock_parental(reader); }
 
 	rdr_log(reader, "ready for requests");
 	return OK;
@@ -1153,13 +1217,24 @@
 			{
 				// check that we have the AES key to decode the CW
 				// if not there is no need to send the ecm to the card
-				if(!aes_present(reader->aes_list, 0x500, (uint32_t)(provid & 0xFFFFF0) , D2KeyID))
-					{ return ERROR; }
+				if (!aes_present(reader->aes_list, 0x500, (uint32_t)(provid & 0xFFFFF0), (D2KeyID&0xf))) {
+					// sky(n)
+					uint8_t	akoff = (D2KeyID&0x1f) * 16;
+					if ((provid & 0xFFFFF0) == 0x030b00) {
+						add_aes_entry(&(reader->aes_list), 0x500, (provid & 0xFFFFF0), (D2KeyID&0x1f), &mytntsat_aeskeys[akoff]);
+						MYCARD_TRACE("mycard:AES{%06X.%02X} Add\n", provid, D2KeyID);
+					}
+					else {
+						MYCARD_TRACE("mycard:AES{%06X.%02X} None\n",provid, D2KeyID);
+						return ERROR;
+					}
+				}
 			}
 
 
 			if(!chk_prov(reader, ident, keynr))
 			{
+				MYCARD_TRACE("mycard:viacess provider{%06X} not found on card\n", provid);
 				rdr_log_dbg(reader, D_READER, "ECM: provider or key not found on card");
 				snprintf(ea->msglog, MSGLOGSIZE, "provider(%02x%02x%02x) or key(%d) not found on card", ident[0], ident[1], ident[2], keynr);
 				return ERROR;
@@ -1221,8 +1296,16 @@
 
 				// use AES from list to decrypt CW
 				rdr_log_dbg(reader, D_READER, "Decoding CW : using AES key id %d for provider %06x", D2KeyID, (provid & 0xFFFFF0));
-				if(aes_decrypt_from_list(reader->aes_list, 0x500, (uint32_t)(provid & 0xFFFFF0), D2KeyID, &ecm88DataCW[0], 16) == 0)
-					{ snprintf(ea->msglog, MSGLOGSIZE, "Missing AES key(%d)[aka E%X]",D2KeyID, D2KeyID); }
+				if (aes_decrypt_from_list(reader->aes_list,
+							0x500,
+							(uint32_t)(provid & 0xFFFFF0),
+							(D2KeyID&0xf),
+							&ecm88DataCW[0],
+							16) == 0)
+				{
+					MYCARD_TRACE("mycard:AES1{%06X} error\n", provid);
+					snprintf(ea->msglog, MSGLOGSIZE, "Missing AES key(%d)[aka E%X]",D2KeyID, D2KeyID);
+				}
 				if(nanoD2 == 0x0f)
 				{
 					hdSurEncPhase1_D2_0F_11(ecm88DataCW);
@@ -1269,6 +1352,7 @@
 				if(l > 256 || curEcm88len <= 6)    //don't known if this is ok...
 				{
 					rdr_log(reader, "ecm invalid/too long! len=%d", curEcm88len);
+					MYCARD_TRACE("mycard:ecm invalid/too long! len=%d\n", curEcm88len);
 					return ERROR;
 				}
 				memcpy(DE04 + 6, (uchar *)ecm88Data, l);
@@ -1346,9 +1430,17 @@
 			hdSurEncPhase1_D2_13_15(ea->cw);
 		}
 		rdr_log_dbg(reader, D_READER, "Decoding CW : using AES key id %d for provider %06x", D2KeyID, (provid & 0xFFFFF0));
-		rc = aes_decrypt_from_list(reader->aes_list, 0x500, (uint32_t)(provid & 0xFFFFF0), D2KeyID, ea->cw, 16);
+		rc = aes_decrypt_from_list(reader->aes_list,
+					0x500,
+					(uint32_t)(provid & 0xFFFFF0),
+					(D2KeyID&0xf),
+					ea->cw,
+					16);
 		if(rc == 0)
-			{ snprintf(ea->msglog, MSGLOGSIZE, "Missing AES key(%d)[aka E%X]",D2KeyID, D2KeyID); }
+		{
+			snprintf(ea->msglog, MSGLOGSIZE, "Missing AES key(%d)[aka E%X]",D2KeyID, D2KeyID);
+			MYCARD_TRACE("mycard:AES2{%06X} error\n", provid);
+		}
 		if(nanoD2 == 0x11)
 		{
 			hdSurEncPhase1_D2_0F_11(ea->cw);
@@ -1572,7 +1664,7 @@
 	int32_t emmLen = SCT_LEN(ep->emm) - emmdatastart;
 	int32_t rc = 0;
 
-	rdr_log_dump(reader, ep->emm, emmLen+emmdatastart, "RECEIVED EMM VIACCESS");
+//	rdr_log_dump(reader, ep->emm, emmLen+emmdatastart, "RECEIVED EMM VIACCESS");
 
 	int32_t emmUpToEnd;
 	uchar *emmParsed = ep->emm + emmdatastart;
@@ -1590,7 +1682,7 @@
 
 	for(emmUpToEnd = emmLen; (emmParsed[1] != 0) && (emmUpToEnd > 0); emmUpToEnd -= (2 + emmParsed[1]), emmParsed += (2 + emmParsed[1]))
 	{
-		rdr_log_dump(reader, emmParsed, emmParsed[1] + 2, "NANO");
+	//	rdr_log_dump(reader, emmParsed, emmParsed[1] + 2, "NANO");
 
 		if(emmParsed[0] == 0x90 && emmParsed[1] == 0x03)
 		{
Index: reader-videoguard-common.h
===================================================================
--- reader-videoguard-common.h	(revision 10670)
+++ reader-videoguard-common.h	(working copy)
@@ -9,16 +9,14 @@
 #define NDS12    12
 #define NDS2    2
 
-struct s_CmdTabEntry
-{
+struct s_CmdTabEntry {
 	uint8_t cla;
 	uint8_t cmd;
 	uint8_t len;
 	uint8_t mode;
 };
 
-struct s_CmdTab
-{
+struct s_CmdTab {
 	uint8_t index;
 	uint8_t size;
 	uint8_t Nentries;
@@ -26,8 +24,7 @@
 	struct s_CmdTabEntry e[1];
 };
 
-struct videoguard_data
-{
+struct videoguard_data {
 	const char      *card_desc;
 	int32_t         card_baseyear;
 	int32_t         card_tierstart;
@@ -40,8 +37,7 @@
 	AES_KEY         astrokey;
 };
 
-typedef struct nds_atr
-{
+typedef struct nds_atr {
 	uchar atr[MAX_ATR_LEN];
 	uint16_t atr_len;
 	int32_t base_year;
Index: reader-videoguard1.c
===================================================================
--- reader-videoguard1.c	(revision 10670)
+++ reader-videoguard1.c	(working copy)
@@ -90,8 +90,10 @@
 		memset(&timeinfo, 0, sizeof(struct tm));
 		rev_date_calc_tm(&cta_res[4], &timeinfo, csystem_data->card_baseyear);
 		char tiername[83];
-		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, 1);
-		rdr_log(reader, "tier: %04x, expiry date: %04d/%02d/%02d-%02d:%02d:%02d %s", tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
+		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, NULL, 1);
+	// sky(date)
+	//	rdr_log(reader, "tier: %04x, expiry date: %04d/%02d/%02d-%02d:%02d:%02d %s",tier_id,timeinfo.tm_year+1900,timeinfo.tm_mon+1,timeinfo.tm_mday,timeinfo.tm_hour,timeinfo.tm_min,timeinfo.tm_sec,get_tiername(tier_id, reader->caid, tiername));
+		rdr_log(reader, "tier: %04x, expiry date: %02d/%02d/%04d-%02d:%02d:%02d %s", tier_id, timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 	}
 }
 
@@ -102,6 +104,7 @@
 	/* 40 B0 09 4A 50 01 4E 5A */
 	if((hist_size < 7) || (hist[1] != 0xB0) || (hist[3] != 0x4A) || (hist[4] != 0x50))
 	{
+	//	rdr_log(reader, "videoguard1 hist smaller than 7");
 		return ERROR;
 	}
 
@@ -121,6 +124,7 @@
 		   or unknown ATR and not forced to NDS1
 		   or known NDS1 ATR and forced to another NDS version
 		   ... probably not NDS1 */
+		rdr_log(reader, "Unknown ATR or not forced to NDS1");
 		return ERROR;
 	}
 
@@ -285,6 +289,14 @@
 	reader->nprov = 1;
 	memset(reader->prid, 0x00, sizeof(reader->prid));
 
+  // sky(oscam.smartcard)
+  {
+    uint32_t ulsno = b2i(4,reader->hexserial+2);
+    sprintf(reader->ascserial, "%04d.%04d.%03d?",
+		  		  ulsno / 10000000,
+		  		 (ulsno / 1000) % 10000,
+		  		 (ulsno % 1000));
+  }
 	rdr_log_sensitive(reader, "type: VideoGuard, caid: %04X, serial: {%02X%02X%02X%02X}, BoxID: {%02X%02X%02X%02X}",
 					  reader->caid, reader->hexserial[2], reader->hexserial[3], reader->hexserial[4], reader->hexserial[5],
 					  boxID[0], boxID[1], boxID[2], boxID[3]);
Index: reader-videoguard12.c
===================================================================
--- reader-videoguard12.c	(revision 10670)
+++ reader-videoguard12.c	(working copy)
@@ -88,9 +88,11 @@
 		struct tm timeinfo;
 		memset(&timeinfo, 0, sizeof(struct tm));
 		rev_date_calc_tm(&cta_res[4], &timeinfo, csystem_data->card_baseyear);
-		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, 1);
+		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, NULL, 1);
 		char tiername[83];
-		rdr_log(reader, "tier: %04x, expiry date: %04d/%02d/%02d-%02d:%02d:%02d %s", tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
+	// sky(date)
+	//	rdr_log(reader, "tier: %04x, expiry date: %04d/%02d/%02d-%02d:%02d:%02d %s",tier_id,timeinfo.tm_year+1900,timeinfo.tm_mon+1,timeinfo.tm_mday,timeinfo.tm_hour,timeinfo.tm_min,timeinfo.tm_sec,get_tiername(tier_id, reader->caid, tiername));
+		rdr_log(reader, "tier: %04x, expiry date: %02d/%02d/%04d-%02d:%02d:%02d %s", tier_id, timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 	}
 }
 
@@ -101,7 +103,7 @@
 
 	if((hist_size < 7) || (hist[1] != 0xB0) || (hist[4] != 0xFF) || (hist[5] != 0x4A) || (hist[6] != 0x50))
 	{
-		rdr_log_dbg(reader, D_READER, "failed history check");
+//		rdr_log_dbg(reader, D_READER, "failed history check");
 		return ERROR;
 	}
 	rdr_log_dbg(reader, D_READER, "passed history check");
@@ -334,6 +336,14 @@
 		rdr_log(reader, "class49 ins0C: failed");
 		//return ERROR;
 	}
+  // sky(oscam.smartcard)
+  {
+    uint32_t ulsno = b2i(4,reader->hexserial+2);
+    sprintf(reader->ascserial, "%04d.%04d.%03d?",
+		  		  ulsno / 10000000,
+		  		 (ulsno / 1000) % 10000,
+		  		 (ulsno % 1000));
+  }
 
 	rdr_log_sensitive(reader,
 					  "type: VideoGuard, caid: %04X, serial: {%02X%02X%02X%02X}, BoxID: {%02X%02X%02X%02X}",
@@ -361,6 +371,7 @@
 		l = vg12_do_cmd(reader, ins54, NULL, rbuff, cta_res);
 		if(l > 0 && status_ok(cta_res + l))
 		{
+//			if (!cw_is_valid(rbuff + 5) && ((reader->caid == 0x09CD) || (reader->caid == 0x093B) || (reader->caid == 0x0919)))  //sky cards report 90 00 = ok but send cw = 00 when channel not subscribed
 			if(!cw_is_valid(rbuff + 5))   //sky cards report 90 00 = ok but send cw = 00 when channel not subscribed
 			{
 				rdr_log(reader, "class4B ins54 status 90 00 but cw=00 -> channel not subscribed");
Index: reader-videoguard2.c
===================================================================
--- reader-videoguard2.c	(revision 10670)
+++ reader-videoguard2.c	(working copy)
@@ -287,14 +287,14 @@
 							{
 								tier_id = 0;
 								tier_id = ((TierClass<<8) + (word<<3) + bitnum);
-								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, 1);
+								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, NULL, 1);
 								rdr_log(reader, "|-- %02x ---|-- %04x --| %04d/%02d/%02d-%02d:%02d:%02d | %s", TierClass, tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 							}
 							if((cta_res[word+1+2] >> bitnum) & 1)
 							{
 								tier_id = 0;
 								tier_id = ((TierClass<<8) + (word<<3) + bitnum + 8);
-								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, 1);
+								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, NULL, 1);
 								rdr_log(reader, "|-- %02x ---|-- %04x --| %04d/%02d/%02d-%02d:%02d:%02d | %s", TierClass, tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 							}
 						}
@@ -371,7 +371,7 @@
 				struct tm timeinfo;
 				memset(&timeinfo, 0, sizeof(struct tm));
 				rev_date_calc_tm(&cta_res[4], &timeinfo, csystem_data->card_baseyear);
-				cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, 1);
+      	   cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, NULL, 1);
 
 				if(!stopemptytier)
 				{
@@ -560,6 +560,7 @@
 	{
 		/* known ATR and not NDS2
 		   or known NDS2 ATR and forced to another NDS version */
+    	rdr_log_dbg(reader, D_READER, "no NDS2");
 		return ERROR;
 	}
 
@@ -1061,6 +1062,14 @@
 		{ dimeno_magic[a] = dimeno_magic[a] ^ boxID[a]; }
 	AES_set_decrypt_key(dimeno_magic, 128, &(csystem_data->astrokey));
 
+  	// sky(oscam.smartcard)
+  	{
+    	uint32_t ulsno = b2i(4,reader->hexserial+2);
+    	sprintf(reader->ascserial, "%04d.%04d.%03d?",
+		  		  ulsno / 10000000,
+		  		 (ulsno / 1000) % 10000,
+		  		 (ulsno % 1000));
+  	}
 	rdr_log(reader, "type: %s, caid: %04X",
 			csystem_data->card_desc,
 			reader->caid);
Index: utils/list_smargo.c
===================================================================
--- utils/list_smargo.c	(revision 10670)
+++ utils/list_smargo.c	(working copy)
@@ -21,7 +21,6 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <string.h>
-#include <strings.h>
 #include "../globals.h"
 #include "../csctapi/ifd_smartreader_types.h"
 
Index: webif/api.xml/mystatus.xml
===================================================================
--- webif/api.xml/mystatus.xml	(revision 10670)
+++ webif/api.xml/mystatus.xml	(nonexistent)
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+	<log><![CDATA[
+   ##LOGHISTORY##
+	]]></log>
Index: webif/config/menu_webif.html
===================================================================
--- webif/config/menu_webif.html	(revision 10670)
+++ webif/config/menu_webif.html	(working copy)
@@ -0,0 +1 @@
+			<LI CLASS="##CMENUACTIVE12##"><A HREF="config.html?part=webif">WebIf</A></LI>
Index: webif/config/webif_httpforcesslv3.html
===================================================================
--- webif/config/webif_httpforcesslv3.html	(revision 10670)
+++ webif/config/webif_httpforcesslv3.html	(working copy)
@@ -0,0 +1,2 @@
+			<TR><TH COLSPAN="2">SSL</TH></TR>
+			<TR><TD><A>Force more secure v3 of ssl:</A></TD><TD><input name="httpforcesslv3" value="0" type="hidden"><input name="httpforcesslv3" value="1" type="checkbox" ##HTTPFORCESSLV3SELECT##><label></label></TD></TR>
Index: webif/files/menu.html
===================================================================
--- webif/files/menu.html	(revision 10670)
+++ webif/files/menu.html	(working copy)
@@ -9,13 +9,21 @@
 ##TPLFILEMENUANTICASC##
 		<LI CLASS="##CMENUACTIVE20##"><A HREF="files.html?file=logfile">logfile</A></LI>
 		<LI CLASS="##CMENUACTIVE21##"><A HREF="files.html?file=userfile">userfile</A></LI>
-		<LI CLASS="##CMENUACTIVE16## ##CMENUACTIVE18## ##CMENUACTIVE19## ##CMENUACTIVE25## ##CMENUACTIVE26## ##CMENUACTIVE27##"><A HREF="#"  class="drop">other file<b class="subcaret"></b></A>
+		<!-- sky() -->
+		<LI CLASS="##CMENUACTIVE16## ##CMENUACTIVE18## ##CMENUACTIVE19## ##CMENUACTIVE25## ##CMENUACTIVE26## ##CMENUACTIVE27## ##CMENUACTIVE28## ##CMENUACTIVE29##"><A HREF="#"  class="drop">other file<b class="subcaret"></b></A>
 			<UL CLASS="dropdown_nav">
 				<LI CLASS="##CMENUACTIVE16##"><A HREF="files.html?file=oscam.services">oscam.services</A></LI>
 				<LI CLASS="##CMENUACTIVE18##"><A HREF="files.html?file=oscam.provid">oscam.provid</A></LI>
 				<LI CLASS="##CMENUACTIVE19##"><A HREF="files.html?file=oscam.tiers">oscam.tiers</A></LI>
 				<LI CLASS="##CMENUACTIVE25##"><A HREF="files.html?file=oscam.whitelist">oscam.whitelist</A></LI>
 				<LI CLASS="##CMENUACTIVE26##"><A HREF="files.html?file=oscam.ratelimit">oscam.ratelimit</A></LI>
+<!-- sky -->
+<!-- sky,__HISILICON_MANUFACTORY__ -->
+				<LI CLASS="##CMENUACTIVE27##"><A HREF="files.html?file=oscam.smartcard">smartcard.info</A></LI>
+				<LI CLASS="##CMENUACTIVE28##"><A HREF="files.html?file=oscam.keys">oscam.keys</A></LI>
+				<LI CLASS="##CMENUACTIVE29##"><A HREF="files.html?file=constant.cw">constant.cw</A></LI>
+<!-- sky,__HISILICON_MANUFACTORY__ -->
+<!-- sky -->
                 ##FILEEDITCSS_SHOW##
 			</UL>
 		</LI>
Index: webif/include/logobit.html
===================================================================
--- webif/include/logobit.html	(revision 10670)
+++ webif/include/logobit.html	(working copy)
@@ -1 +1,2 @@
-<DIV CLASS="logo"><A HREF="http://www.streamboard.tv/wbb2/portal.php" TARGET="_blank" TITLE="OSCam Streamboard">##LOGO_INS##</A></DIV>
\ Nincs j sor a fjl vgn
+<!-- sky() -->
+<DIV CLASS="logo">##LOGO_INS##</A></DIV>
\ Nincs j sor a fjl vgn
Index: webif/logpage/logpage_debugmenu.html
===================================================================
--- webif/logpage/logpage_debugmenu.html	(revision 10670)
+++ webif/logpage/logpage_debugmenu.html	(working copy)
@@ -14,5 +14,6 @@
 				<SPAN CLASS="debugl"><A id="debug1024" sendval="1024" CLASS="debugl" HREF="#" TITLE="Client ECM logging">&nbsp;1024&nbsp;</A></SPAN>
 				<SPAN CLASS="debugl"><A id="debug2048" sendval="2048" CLASS="debugl" HREF="#" TITLE="CSP logging">&nbsp;2048&nbsp;</A></SPAN>
 				<SPAN CLASS="debugl"><A id="debug4096" sendval="4096" CLASS="debugl" HREF="#" TITLE="CWC logging">&nbsp;4096&nbsp;</A></SPAN>
+				<SPAN CLASS="debugl"><A id="debug8192" sendval ="8192" CLASS="debugl" HREF="#" TITLE="iks logging">&nbsp;8192&nbsp;</A></SPAN>
 				<SPAN CLASS="debugl"><A id="debug65535" sendval="65535" CLASS="debugl" HREF="#" TITLE="debug all">&nbsp;ALL&nbsp;</A></SPAN>
 			</DIV>
\ Nincs j sor a fjl vgn
Index: webif/pages_index.txt
===================================================================
--- webif/pages_index.txt	(revision 10670)
+++ webif/pages_index.txt	(working copy)
@@ -34,6 +34,9 @@
 APIREADERSTATSECMBIT          api.xml/readerstats_ecmstats.xml
 APIREADERSTATSEMMBIT          api.xml/readerstats_emmstats.xml
 APISTATUS                     api.xml/status.xml
+#- sky(A)
+APIMYSTATUS                   api.xml/mystatus.xml
+#--
 APISTATUSBIT                  api.xml/status_statusbits.xml
 APIUSERCONFIGLIST             api.xml/userconfiglist.xml
 APIUSERCONFIGLISTBIT          api.xml/userconfiglist_userconfigs.xml
@@ -189,6 +191,8 @@
 READERCONFIGLBWEIGHT          readerconfig/readerconfig_lbweight.html                     WITH_LB
 READERCONFIGNCD525BIT         readerconfig/readerconfig_ncd525bit.html                    MODULE_NEWCAMD
 READERCONFIGNCD524BIT         readerconfig/readerconfig_ncd524bit.html                    MODULE_NEWCAMD
+#- sky(A)
+READERCONFIGNCDAVATARBIT      readerconfig/readerconfig_ncdavatarbit.html                 MODULE_NEWCAMD
 READERCONFIGRADEGASTBIT       readerconfig/readerconfig_radegastbit.html                  MODULE_RADEGAST
 READERCONFIGSCAMBIT           readerconfig/readerconfig_scambit.html                      MODULE_SCAM
 READERCONFIGSID               readerconfig/readerconfig_sid.html
@@ -236,6 +239,9 @@
 SHUTDOWN                      shutdown/shutdown.html
 
 STATUS                        status/status.html
+#- sky(A)
+MYSTATUS                   	status/mystatus.html
+#--
 CACHEEXINFOBIT                status/status_cacheexinfo.html                              CS_CACHEEX
 CLIENTHEADLINE                status/status_cheadline.html
 CLIENTHEADLINEADD             status/status_cheadlineadd.html
Index: webif/readerconfig/readerconfig_ncdavatarbit.html
===================================================================
--- webif/readerconfig/readerconfig_ncdavatarbit.html	(nonexistent)
+++ webif/readerconfig/readerconfig_ncdavatarbit.html	(working copy)
@@ -0,0 +1,4 @@
+			<TR><TD><A>Activation code:</A></TD><TD><input name="exkey" class="longer" type="text" maxlength="10" value="##NCD_EXKEY##"></TD></TR>
+			<TR><TD><A>Connect on init:</A><input name="connectoninit" type="hidden" value="0"></TD><TD><input name="connectoninit" type="checkbox" value="1" ##CONNECTONINITCHECKED##><label></label></TD></TR>
+			<TR><TD><A>Inactivity timeout:</A></TD><TD><input name="inactivitytimeout" class="withunit short" type="text" maxlength="5" value="##INACTIVITYTIMEOUT##"> s</TD></TR>
+
Index: webif/status/mystatus.html
===================================================================
--- webif/status/mystatus.html	(nonexistent)
+++ webif/status/mystatus.html	(working copy)
@@ -0,0 +1,12 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><HTML>
+<HEAD>
+	<TITLE>mystatus</TITLE>
+	<meta http-equiv="Content-Type" content="text/html; charset=##HTTP_CHARSET##">
+</HEAD>
+<BODY>
+	<DIV CLASS="log">
+##LOGHISTORY##
+	</DIV>
+</BODY>
+</HTML>
+
Index: webif/status/status.html
===================================================================
--- webif/status/status.html	(revision 10670)
+++ webif/status/status.html	(working copy)
@@ -19,7 +19,8 @@
 <DIV ID="subnav">
 	<UL ID="nav">
 		<LI><B>##HTTPOSCAMLABEL## r##CS_SVN_VERSION##</B></LI>
-		<LI CLASS="configmenu"><A HREF="http://www.streamboard.tv/oscam/timeline" TARGET="_blank">Timeline</A></LI>
+		<!-- sky() -->
+		<LI CLASS="configmenu"></LI>
 		<LI CLASS="configmenu"><A HREF="#statusfooter">Status</A></LI>
 		<LI ID="poll" CLASS="pollselect" style="display: none;">Pollintervall:<input type="text" name="pintervall" class="pintervall" value="" readonly>sec.<button id="dec">&ndash;</button><button id="inc">+</button></LI>
 	</UL>
Index: webif/status/status_sdebug.html
===================================================================
--- webif/status/status_sdebug.html	(revision 10670)
+++ webif/status/status_sdebug.html	(working copy)
@@ -14,5 +14,7 @@
 	<SPAN CLASS="debugs"><A CLASS="##DCLASS1024##" HREF="##NEXTPAGE##?debug=##DEBUGVAL1024####CUSTOMPARAM##" TITLE="Client ECM logging">&nbsp;1024&nbsp;</A></SPAN>
 	<SPAN CLASS="debugs"><A CLASS="##DCLASS2048##" HREF="##NEXTPAGE##?debug=##DEBUGVAL2048####CUSTOMPARAM##" TITLE="CSP logging">&nbsp;2048&nbsp;</A></SPAN>
 	<SPAN CLASS="debugs"><A CLASS="##DCLASS4096##" HREF="##NEXTPAGE##?debug=##DEBUGVAL4096####CUSTOMPARAM##" TITLE="CWC logging">&nbsp;4096&nbsp;</A></SPAN>
+	<!-- sky(8192) -->
+	<SPAN CLASS="debugs"><A CLASS="##DCLASS8192##" HREF="##NEXTPAGE##?debug=##DEBUGVAL8192####CUSTOMPARAM##" TITLE="Iks logging">&nbsp;8192&nbsp;</A></SPAN>
 	<SPAN CLASS="debugs"><A CLASS="##DCLASS65535##" HREF="##NEXTPAGE##?debug=65535##CUSTOMPARAM##" TITLE="debug all">&nbsp;ALL&nbsp;</A></SPAN>
 </DIV>
