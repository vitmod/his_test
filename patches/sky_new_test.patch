Index: Makefile
===================================================================
--- Makefile	(revision 1587)
+++ Makefile	(working copy)
@@ -170,6 +170,7 @@
 $(eval $(call prepare_use_flags,COOLAPI2,coolapi2))
 $(eval $(call prepare_use_flags,SU980,su980))
 $(eval $(call prepare_use_flags,AZBOX,azbox))
+$(eval $(call prepare_use_flags,HISKY,his))
 $(eval $(call prepare_use_flags,MCA,mca))
 $(eval $(call prepare_use_flags,SSL,ssl))
 $(eval $(call prepare_use_flags,LIBCRYPTO,))
@@ -310,6 +311,7 @@
 SRC-$(CONFIG_WITH_SU980) += module-dvbapi-coolapi.c
 SRC-$(CONFIG_WITH_STAPI) += module-dvbapi-stapi.c
 SRC-$(CONFIG_WITH_STAPI5) += module-dvbapi-stapi5.c
+SRC-$(CONFIG_WITH_HISILICON) += module-dvbapi-his.c
 SRC-$(CONFIG_HAVE_DVBAPI) += module-dvbapi-chancache.c
 SRC-$(CONFIG_HAVE_DVBAPI) += module-dvbapi.c
 SRC-$(CONFIG_MODULE_GBOX) += module-gbox-helper.c
@@ -658,6 +660,14 @@
                      In order for USE_SU980 to work you have to have libentropic.a\n\
                      library in your cross compilation toolchain.\n\
 \n\
+   USE_HISKY=1    - Request support for HISKY (android)\n\
+                    box. The variables that control the build are:\n\
+                     HISKY_FLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_CFLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_LDFLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_LIB='$(DEFAULT_HISKY_LIB)'\n\
+                     Using USE_HISKY=1 adds to '-hisky' to PLUS_TARGET.\n\
+\n\
    USE_AZBOX=1    - Request support for AZBOX (openxcas)\n\
                     box. The variables that control the build are:\n\
                          AZBOX_FLAGS='$(DEFAULT_AZBOX_FLAGS)'\n\
@@ -798,6 +808,8 @@
      make CROSS=arm-cx2450x-linux-gnueabi- USE_COOLAPI=1\n\n\
    Build OSCam for ARM with COOLAPI2 (coolstream aka NeutrinoHD):\n\
      make CROSS=arm-pnx8400-linux-uclibcgnueabi- USE_COOLAPI2=1\n\n\
+   Build OSCam for ARM ANDROID with HISKY support:\n\
+     make CROSS=arm-linux-android- USE_HISKY=1\n\n\
    Build OSCam for MIPSEL with AZBOX support:\n\
      make CROSS=mipsel-linux-uclibc- USE_AZBOX=1\n\n\
    Build OSCam for ARM with MCA support:\n\
Index: Makefile.extra
===================================================================
--- Makefile.extra	(revision 1587)
+++ Makefile.extra	(working copy)
@@ -294,6 +294,14 @@
 		CROSS=arm-linux-androideabi- \
 		$(MAKEFLAGS)
 
+android-arm-hisky:
+	$(MAKE) --no-print-directory \
+		LIB_RT= \
+		LIB_PTHREAD= \
+		CROSS=arm-linux-androideabi- \
+		USE_HISKY=1 \
+		$(MAKEFLAGS)
+
 uclinux:
 	$(MAKE) --no-print-directory \
 		LIB_DL= STRIP=true \
Index: config.h
===================================================================
--- config.h	(revision 1587)
+++ config.h	(working copy)
@@ -12,7 +12,7 @@
 #endif
 //#define WITH_NEUTRINO 1
 #define READ_SDT_CHARSETS 1
-#define CLOCKFIX 1
+//#define CLOCKFIX 1
 #define IRDETO_GUESSING 1
 #define CS_ANTICASC 1
 #define WITH_DEBUG 1
Index: config.sh
===================================================================
--- config.sh	(revision 1587)
+++ config.sh	(working copy)
@@ -311,6 +311,7 @@
 	have_flag USE_COOLAPI && echo "CONFIG_WITH_COOLAPI=y" || echo "# CONFIG_WITH_COOLAPI=n"
 	have_flag USE_COOLAPI2 && echo "CONFIG_WITH_COOLAPI2=y" || echo "# CONFIG_WITH_COOLAPI2=n"
 	have_flag USE_SU980 && echo "CONFIG_WITH_SU980=y" || echo "# CONFIG_WITH_SU980=n"
+	have_flag USE_HISKY && echo "CONFIG_WITH_HISILICON=y" || echo "# CONFIG_WITH_HISILICON=n"
 	have_flag USE_AZBOX && echo "CONFIG_WITH_AZBOX=y" || echo "# CONFIG_WITH_AZBOX=n"
 	have_flag USE_MCA && echo "CONFIG_WITH_MCA=y" || echo "# CONFIG_WITH_MCA=n"
 	have_flag USE_LIBCRYPTO && echo "CONFIG_WITH_LIBCRYPTO=y" || echo "# CONFIG_WITH_LIBCRYPTO=n"
@@ -698,12 +699,7 @@
 		break
 	;;
 	'-r'|'--oscam-revision')
-		revision=`(svnversion -n . 2>/dev/null || printf 0) | sed 's/.*://; s/[^0-9]*$//; s/^$/0/'`
-		if [ "$revision" = "0" ] 
-		then
-			which git > /dev/null 2>&1 && revision=`git log -10 --pretty=%B | grep git-svn-id | head -n 1 | sed -n -e 's/^.*trunk@\([0-9]*\) .*$/\1/p'`
-		fi
-		echo $revision
+		echo "$OSCAM_VERSION_NUMBER"
 		break
 	;;
 	'-O'|'--detect-osx-sdk-version')
Index: globals.h
===================================================================
--- globals.h	(revision 1587)
+++ globals.h	(working copy)
@@ -593,6 +593,8 @@
 
 #define REQUEST_SENT            0x10
 #define REQUEST_ANSWERED        0x20
+// sky(n)
+#define REQUEST_BYPASS          (REQUEST_SENT|0x80)
 
 #define CW_MODE_ONE_CW 0
 #define CW_MODE_MULTIPLE_CW 1
Index: module-dvbapi-his.c
===================================================================
--- module-dvbapi-his.c	(nonexistent)
+++ module-dvbapi-his.c	(working copy)
@@ -0,0 +1,1190 @@
+/* Reversed from libhistream.so, this comes without any warranty */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include "globals.h"
+
+#if defined(WITH_HISILICON)
+
+#define DVBAPI_LOG_PREFIX 		1
+#include "module-dvbapi.h"
+#include "module-dvbapi-his.h"
+#include "oscam-string.h"
+#include "oscam-client.h"
+#include "oscam-time.h"
+
+#undef	UNUSED
+#include "hi_unf_demux.h"
+
+/***************************** Macro Definition ************************/
+#define TUNER0	0
+#define TUNER1	1
+#if defined(SDKV600)
+	// demux id 0 to 6
+	#define HIPORT_TUNER_ID 	HI_UNF_DMX_PORT_TSI_0
+	#define HIPORT_INTERNAL_ID HI_UNF_DMX_PORT_TSI_1
+	#define HIDEMUX_OSCAM_ID 	0
+	#define HIDEMUX_OSCAM1_ID 	HIDEMUX_OSCAM_ID
+	#define HIDEMUX_OSCAM2_ID 	5
+#elif defined(SDKV500)
+	// demux id 0 to 6
+	#define HIPORT_TUNER_ID 	HI_UNF_DMX_PORT_TSI_0
+	#define HIDEMUX_OSCAM_ID 	0
+#else
+	#define HIPORT_TUNER_ID 	1
+	#define HIDEMUX_OSCAM_ID	0	// 3
+#endif
+
+
+#define NUM_HIREGION			3
+#define NUM_HIPERREGION			32
+#define MAX_HICHANNEL			(NUM_HIREGION*NUM_HIPERREGION)	// DMX_TOTALCHAN_CNT
+#define MAX_HIFILTERS			(NUM_HIREGION*NUM_HIPERREGION)	// DMX_TOTALFILTER_CNT
+#define NUM_HIFILACQUIRES		32		// 3
+#define NUM_HIFLTDEPTH			16		// DMX_FILTER_MAX_DEPTH
+#define DVB_HIFLTBYTES			8		// DMX_FILTER_MAX_DEPTH
+#define MAX_HIBUFFERSIZE		(64 * 1024)
+#define INVALID_HIFILTER		-1
+#define INVALID_HIHANDLE		HI_INVALID_HANDLE
+
+#define IS_INVALID_PID(x)			((x)>=0x1fff)
+#define IS_INVALID_HIFILTERS(x)	((x)>MAX_HIFILTERS-1 || (x)<0)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#define HIAPI_ISDEMUXINIT() \
+	if (g_DemuxIniz == HI_FALSE) { \
+		cs_log("mydemux:demux none...\n"); \
+		return HI_FAILURE; \
+	}
+
+#define HIAPI_CHECKFILTERID(id) \
+	if ((id) >= MAX_HIFILTERS) { \
+		cs_log("mydemux:invalid filterid(%d)\n", (id)); \
+		return HI_FAILURE; \
+	}
+
+
+#define HIAPI_FILTERREGION(dmxid,region) \
+	if ((dmxid) == 0)      { (region) = 0; } \
+	else if ((dmxid) == 4) { (region) = 2; } \
+	else                   { (region) = 1; }
+
+#if 0
+#define HIAPI_CHECKERROR(hiReturn,FUNC)	do {} while (0);
+#else
+#define HIAPI_CHECKERROR(hiReturn,FUNC)	\
+	if (hiReturn != HI_SUCCESS) { \
+		cs_log("mydemux:%s.%s.error(%x)\n",__FUNCTION__,#FUNC, hiReturn); \
+	}
+#endif
+
+#define HIFLT_REVERSE_MASK(mask) 	(HI_U8)(~(mask))
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/*************************** Structure Definition **********************/
+/* Transparent transmission mode, only the data to reach the internal buffer of events and timeout events, not a copy of the data does not appear to copy data to an external buffer event
+	In copy mode, in addition to the data reaches the internal buffer of events and timeout events, there will be a copy of the data to the external buffer events.
+	However, in the copy mode, when the reach the data of the external buffer event, the user via the callback function's return value to confirm whether to continue copying, in order to discard the unwanted duplicate data.
+	At this point, the return value of 0 means copy a copy, and direct release.
+*/
+
+typedef struct hidemux_attrib
+{
+	HI_S32		dmuxid;
+	HI_S32		fltnum;
+
+	HI_U32		u32TUNERID;	/* TUNER ID ,0-1*/
+	HI_U32		u32DMXID;	/* DMX ID ,0-4*/
+	HI_U32		u32PID;		/* TS PID */
+
+	HI_S32		u32Type;	/* task type 1 - TYPE_ECM  2- TYPE_EMM */
+	HI_U32		u32FilterType;	/* section type 0 - SECTION  1- PES  2 - ECM/EMM */
+	HI_U32		u32CrcFlag;	/* crc check flag,0 - close crc check 1-force crc check 2-crc check by sytax*/
+	HI_U32		u32TimeOutMs;	/* time out in ms,0 stand for not timeout,otherwise when timeout,the user can receive the envent*/
+
+	HI_U32		u32FilterDepth;	/* Filter Depth*/
+	HI_U8			u8Match	[NUM_HIFLTDEPTH];
+	HI_U8			u8Mask	[NUM_HIFLTDEPTH];
+	HI_U8			u8Negate	[NUM_HIFLTDEPTH];
+} HIDEMUX_ATTRIB;
+
+typedef struct hidemux_filters
+{
+	HIDEMUX_ATTRIB fltAttr;
+	HI_S32		uFiltype;
+	HI_U32		u32UseFlag;	/*use flag :0- available,1-busy*/
+	HI_U32		u32EnableFlag;	/*enable flag :0- enable,1-disable*/
+
+	HI_HANDLE	hChannel;	/*corresponding  channel of filter*/
+	HI_HANDLE	hFilter;	/*corresponding  hander of filter*/
+
+	HI_U32		u32TimerCount;	/*current value in timer of (ms)filter */
+} HIDEMUX_FILTERS;
+
+typedef struct hidemux_inform {
+	int32_t adapter;
+	int32_t dmuxid;
+	int32_t flnum;
+	int32_t hifltnum;
+	int32_t type;
+	int32_t pid;
+	bool activated;
+} HIDEMUX_INFORM;
+
+
+struct hidemux_thread_param
+{
+	int32_t id;
+//	int32_t flnum;
+	struct s_client *cli;
+};
+
+/********************** Global Variable declaration ********************/
+extern struct s_client *dvbapi_client;
+
+static HI_BOOL g_DemuxIniz = 0;
+static HI_BOOL g_DemuxRuning = HI_TRUE;
+static pthread_mutex_t g_FltMutex;
+static pthread_mutex_t g_FltLocks;
+static pthread_t g_FltEcmThread;
+static pthread_t g_FltEmmThread;
+
+static HIDEMUX_FILTERS g_HIFilters[MAX_HIFILTERS];
+static HIDEMUX_INFORM g_dmuxes[MAX_DEMUX][MAX_FILTER];
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//feedback data to filter by callback
+static HI_BOOL
+hifilter_SectionCallbacks(HIDEMUX_FILTERS *ChFilter, HI_U8 *pSection, HI_U32 uSecLen)
+{
+	HIDEMUX_ATTRIB *pFltAttr;
+	int k = 0;
+
+	if (!uSecLen ) return 0;
+	if (!pSection) return 0;
+	if (ChFilter->u32UseFlag == 0) return 0;
+	if (ChFilter->u32EnableFlag == 0) return 0;
+	pFltAttr = &(ChFilter->fltAttr);
+	if ((0 == pFltAttr->u32FilterType || 2 == pFltAttr->u32FilterType) && pFltAttr->u32FilterDepth != 0) /*section data,filter data by software*/
+	{
+		if (pFltAttr->u8Negate[0])
+		{
+			if ((pFltAttr->u8Match[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])) ==
+			  	 (pSection[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])))
+			{
+			  	return 0;
+			}
+		}
+		else
+		{
+			if ((pFltAttr->u8Match[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])) !=
+			  	 (pSection[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])))
+			{
+			  	return 0;
+			}
+		}
+
+		for (k = 1; k < (int)(pFltAttr->u32FilterDepth); k++)
+		{
+			if (pFltAttr->u8Negate[k])
+			{
+			  	if ((pFltAttr->u8Match[k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])) ==
+					 (pSection[2+k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])))
+			  	{
+					break;
+			  	}
+			}
+			else
+			{
+			  	if ((pFltAttr->u8Match[k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])) !=
+					 (pSection[2+k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])))
+			  	{
+					break;
+			  	}
+			}
+		}
+	}
+	else
+	{
+		k = pFltAttr->u32FilterDepth; /*do not filter pes*/
+	}
+
+	if (k == (int)(pFltAttr->u32FilterDepth)) /*get matched filter condition */
+	{
+		ChFilter->u32TimerCount = 0;
+//		if (ChFilter->uFiltype==TYPE_EMM) {
+//			myprintf("FILTER:%d, %d\n", uFilNum, i);
+//		}
+		dvbapi_process_input(pFltAttr->dmuxid, pFltAttr->fltnum, (void *)pSection, uSecLen, 0);
+		return 1;
+	}
+	return 0;
+}
+
+
+static void *
+hifilter_ThreadModules(void *param)
+{
+	struct hidemux_thread_param *para = (struct hidemux_thread_param *)param;
+	HI_UNF_DMX_DATA_S ChRcvBuf[NUM_HIFILACQUIRES];
+	HI_UNF_DMX_CHAN_STATUS_S channelstatus;
+//	HI_UNF_DMX_DATA_TYPE_E enDataType;
+//	HI_UNF_DMX_CHAN_ATTR_S stChAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	HI_HANDLE ChHandle;
+	HI_S32 	 ChTYPE;
+//	HI_U32 	 u32HandleNum = MAX_HICHANNEL;
+//	HI_HANDLE u32ChHandle[MAX_HICHANNEL];
+	HI_U32 u32AcqNum 	= 0;
+	HI_U32 u32BufLen 	= 0;
+	HI_U8  *pRecvBuff	= 0;
+	HI_S32 hiReturn = HI_FAILURE;
+	int f, ki = 0;
+
+	ChTYPE = para->id;
+	//pthread_setspecific(getclient, para->cli);
+	SAFE_SETSPECIFIC(getclient, para->cli);
+	while (g_DemuxRuning)
+	{
+//		usleep(10 * 1000);
+		cs_sleepms(20);
+//		memset((void *)u32ChHandle, 0, sizeof(HI_HANDLE) * MAX_HICHANNEL);
+//		u32HandleNum = MAX_HICHANNEL;
+//		hiReturn = HI_UNF_DMX_GetDataHandle(u32ChHandle, &u32HandleNum, 1000);	/* timeout 1000ms */
+//		if ((HI_SUCCESS != hiReturn) || (u32HandleNum == 0)) continue;
+		for (f = 0; f < MAX_HIFILTERS; f++)
+		{
+		  	ChFilter = &(g_HIFilters[f]);
+			if ( ChFilter->uFiltype != ChTYPE) continue;
+			if (!ChFilter->u32UseFlag || !ChFilter->u32EnableFlag) continue;
+			#if defined(SDKV500) || defined(SDKV600)
+				if (ChFilter->hChannel == 0) continue;
+			#else
+				if (ChFilter->hChannel < 0x150000 || ChFilter->hChannel > 0x200000) continue;
+			#endif
+
+			ChHandle = ChFilter->hChannel;
+			hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+			if ((HI_SUCCESS != hiReturn) || (HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus)) continue;
+
+			u32AcqNum = 0;
+			hiReturn  = HI_UNF_DMX_AcquireBuf(ChHandle, NUM_HIFILACQUIRES, &u32AcqNum, ChRcvBuf, 100);
+			if (hiReturn == HI_ERR_DMX_TIMEOUT ||
+				 hiReturn == HI_ERR_DMX_NOAVAILABLE_DATA ||
+				 u32AcqNum== 0) {
+				usleep(10 * 1000);
+				continue;
+			}
+			if (hiReturn == HI_FAILURE) break;
+			if (HI_SUCCESS != hiReturn)
+			{
+			 	cs_log("mydemux:hi_unf_dmx_acquirebuf.error(%x)\n", (HI_U32)hiReturn);
+			 	break;
+			}
+//			hiReturn = HI_UNF_DMX_GetChannelAttr(ChHandle, &stChAttr);
+//			if (HI_SUCCESS != hiReturn) continue;
+			if (u32AcqNum==NUM_HIFILACQUIRES)
+			{
+			 	cs_log("mydemux:max Acquire(%d)\n", u32AcqNum);
+			}
+//			else
+//			{
+//			 	cs_log("mydemux:acquire\n");
+//			}
+			for (ki = 0; ki < (int)u32AcqNum; ki++) /*process data package gradually*/
+			{
+				pRecvBuff  = ChRcvBuf[ki].pu8Data;
+				u32BufLen  = ChRcvBuf[ki].u32Size;
+// 			enDataType = ChRcvBuf[ki].enDataType;
+//				if (stChAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_POST)
+//				{
+//					pRecvBuff += 5;
+//					hifilter_SectionCallbacks(ChFilter, pRecvBuff, u32BufLen);
+//				}
+//				else
+				{
+				  	hifilter_SectionCallbacks(ChFilter, pRecvBuff, u32BufLen);
+				}
+			}
+
+			/*release message*/
+			hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+			if ((HI_SUCCESS != hiReturn) ||
+				((HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus) && (HI_SUCCESS == hiReturn)))
+			{
+			  	/*avoid reference ChRcvBuf after closing channel */
+			  	break;
+			}
+//				hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+//				if ((HI_SUCCESS != hiReturn) || (HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus)) continue;
+			hiReturn = HI_UNF_DMX_ReleaseBuf(ChHandle, u32AcqNum, ChRcvBuf);
+//				HIAPI_CHECKERROR(hiReturn,hi_unf_dmx_releasebuf);
+			usleep(10 * 1000);
+		}
+	}
+	return NULL;
+}
+
+static HI_S32
+hifilter_CheckFltAttr(HIDEMUX_ATTRIB *pFltAttr)
+{
+	if (!pFltAttr) return -1;
+	if ((pFltAttr->u32FilterType > 2))
+	{
+	  	cs_log("mydemux:hifilter_checkfltattr.error.type(%d)\n", pFltAttr->u32FilterType);
+	  	return -1;
+	}
+
+	if (pFltAttr->u32CrcFlag > 2)
+	{
+	  	cs_log("mydemux:hifilter_checkfltattr.error.crc(%d)\n", pFltAttr->u32CrcFlag);
+	  	return -1;
+	}
+
+	if (pFltAttr->u32FilterDepth > NUM_HIFLTDEPTH)
+	{
+	  	cs_log("mydemux:hifilter_checkfltattr.error.depth(%d)\n", pFltAttr->u32FilterDepth);
+	  	return -1;
+	}
+
+	return 0;
+}
+
+/*pu32FltId's value scope is 0-95 */
+static HI_S32
+hifilter_GetFreeFltId(HI_U32 u32DmxID, HI_U32 *pu32FltId)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	int i;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (ChFilter->u32UseFlag == 0)
+		{
+			*pu32FltId = (uRegionNum * NUM_HIPERREGION) + i;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static HI_U32
+hifilter_GetChnFltNum(HI_S32 u32DmxID, HI_HANDLE uChHandle)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	HI_U32 uFltNum = 0;
+	int i = 0;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (!ChFilter->u32UseFlag) continue;
+		if ( ChFilter->hChannel == 0 || ChFilter->hChannel == INVALID_HIHANDLE) continue;
+		if ( ChFilter->hChannel == uChHandle) uFltNum++;
+	}
+
+	return uFltNum;
+}
+
+/*get filter amount which channel is enable */
+static HI_U32
+hifilter_GetChnEnFltNum(HI_S32 u32DmxID, HI_HANDLE uChHandle)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	HI_U32 uFltNum = 0;
+	int i = 0;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (!ChFilter->u32UseFlag || !ChFilter->u32EnableFlag) continue;
+		if ( ChFilter->hChannel == 0 || ChFilter->hChannel == INVALID_HIHANDLE) continue;
+		if ( ChFilter->hChannel == uChHandle) uFltNum++;
+	}
+
+	return uFltNum;
+}
+
+static HI_S32
+hifilter_Create(HIDEMUX_ATTRIB *pFltAttr, HI_S32 *ps32FilterID)
+{
+	HI_UNF_DMX_FILTER_ATTR_S sFilterAttr;
+	HI_UNF_DMX_CHAN_ATTR_S stChAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	HI_HANDLE hFilter;
+	HI_HANDLE hChannel;
+	HI_U32 u32FltID;
+	int hiReturn;
+
+	cs_log("mydemux:call hifilter_create\n");
+	HIAPI_ISDEMUXINIT();
+	if (hifilter_CheckFltAttr(pFltAttr) != 0)
+	{
+		cs_log("mydemux:hifilter_checkfltattr.invalid param\n");
+		return HI_FAILURE;
+	}
+
+	if (hifilter_GetFreeFltId(pFltAttr->u32DMXID, &u32FltID) != 0)
+	{
+		cs_log("mydemux:hifilter_getfreefltid.no free\n");
+		return HI_FAILURE;
+	}
+
+	memset(&sFilterAttr, 0, sizeof(HI_UNF_DMX_FILTER_ATTR_S));
+	sFilterAttr.u32FilterDepth =  pFltAttr->u32FilterDepth;
+	memcpy(sFilterAttr.au8Mask, 	pFltAttr->u8Mask,  NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Match, 	pFltAttr->u8Match, NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Negate, pFltAttr->u8Negate,NUM_HIFLTDEPTH);
+	hiReturn = HI_UNF_DMX_CreateFilter(pFltAttr->u32DMXID, &sFilterAttr, &hFilter);
+	if (HI_SUCCESS != hiReturn)
+	{
+		cs_log("mydemux:hi_unf_dmx_createfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	hiReturn = HI_UNF_DMX_GetChannelHandle(pFltAttr->u32DMXID, pFltAttr->u32PID, &hChannel);
+	if ((HI_SUCCESS != hiReturn) && (HI_ERR_DMX_UNMATCH_CHAN != hiReturn))
+	{
+		cs_log("mydemux:hi_unf_dmx_getchannelhandle.error(%x)\n", hiReturn);
+		HI_UNF_DMX_DestroyFilter(hFilter);
+		return HI_FAILURE;
+	}
+
+	if ((HI_ERR_DMX_UNMATCH_CHAN == hiReturn) || (INVALID_HIHANDLE == hChannel))
+	{
+		/*do have channel for this PID,it need to create new channel */
+		hiReturn = HI_UNF_DMX_GetChannelDefaultAttr(&stChAttr);
+		if (HI_SUCCESS != hiReturn)
+		{
+			cs_log("mydemux:hi_unf_dmx_getchanneldefaultattr.error(%x)\n", hiReturn);
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			return HI_FAILURE;
+		}
+
+		if (pFltAttr->u32CrcFlag == 1)
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD;
+		}
+		else
+		if (pFltAttr->u32CrcFlag == 2)
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD;
+		}
+		else
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORBID;
+		}
+
+		if (pFltAttr->u32FilterType == 1)
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_PES;
+		}
+		else
+		if (pFltAttr->u32FilterType == 2)
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_ECM_EMM;
+		//	stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_POST;
+		}
+		else
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_SEC;
+		}
+
+		stChAttr.enOutputMode = HI_UNF_DMX_CHAN_OUTPUT_MODE_PLAY;
+		stChAttr.u32BufSize 	 = MAX_HIBUFFERSIZE; // not used, don't care
+
+		cs_log("mydemux:call hi_unf_dmx_createchannel\n");
+		hiReturn = HI_UNF_DMX_CreateChannel(pFltAttr->u32DMXID, &stChAttr, &hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			cs_log("mydemux:hi_unf_dmx_createchannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		hiReturn = HI_UNF_DMX_SetChannelPID(hChannel, pFltAttr->u32PID);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			HI_UNF_DMX_DestroyChannel(hChannel);
+			cs_log("mydemux:hi_unf_dmx_setchannelpid.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+
+	ChFilter = &g_HIFilters[u32FltID];
+	memset(ChFilter, 0, sizeof(HIDEMUX_FILTERS));
+	ChFilter->u32EnableFlag = 0;
+	ChFilter->u32TimerCount = 0;
+	ChFilter->hFilter  		= hFilter;
+	ChFilter->hChannel 		= hChannel;
+	ChFilter->u32UseFlag 	= 1;
+	ChFilter->uFiltype  		= pFltAttr->u32Type;
+	memcpy(&ChFilter->fltAttr, pFltAttr, sizeof(HIDEMUX_ATTRIB));
+
+	*ps32FilterID = u32FltID;
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Destroy(HI_S32 s32FilterID)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	cs_log("mydemux:call hifilter_destroy\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		cs_log("mydemux:hifilter_destroy.error\n");
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->u32EnableFlag)
+	{
+		hiReturn = HI_UNF_DMX_DetachFilter(ChFilter->hFilter, ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			cs_log("mydemux:hi_unf_dmx_detachfilter.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		ChFilter->u32EnableFlag = 0;
+	}
+
+	hiReturn = HI_UNF_DMX_DestroyFilter(ChFilter->hFilter);
+	if (HI_SUCCESS != hiReturn)
+	{
+		cs_log("mydemux:hi_unf_dmx_destroyfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32UseFlag = 0;
+	ChFilter->uFiltype   = 0;
+	/*if the channel did not attach filter,destroy the channel*/
+	if (!hifilter_GetChnFltNum(ChFilter->fltAttr.u32DMXID, ChFilter->hChannel))
+	{
+		cs_log("mydemux:call hi_unf_dmx_destroychannel\n");
+		hiReturn = HI_UNF_DMX_DestroyChannel(ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			cs_log("mydemux:hi_unf_dmx_destroychannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+
+	ChFilter->hChannel = INVALID_HIHANDLE;
+	ChFilter->hFilter  = INVALID_HIHANDLE;
+	ChFilter->u32TimerCount = 0;
+	return HI_SUCCESS;
+}
+
+/*static HI_S32
+hifilter_SetAttribute(HI_S32 s32FilterID, HIDEMUX_ATTRIB *pFltAttr)
+{
+	HI_UNF_DMX_FILTER_ATTR_S sFilterAttr;
+	HI_UNF_DMX_CHAN_ATTR_S sChanAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+	if (hifilter_CheckFltAttr(pFltAttr) != 0)
+	{
+		cs_log("mydemux:hifilter_checkfltattr.invalid param\n");
+		return HI_FAILURE;
+	}
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if (pFltAttr->u32FilterType != ChFilter->fltAttr.u32FilterType)
+	{
+		cs_log("mydemux:hifilter_setattr.error type\n");
+		return HI_FAILURE;
+	}
+
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		cs_log("mydemux:hifilter_setattr.error\n");
+		return HI_FAILURE;
+	}
+
+	memset(&sFilterAttr, 0, sizeof(HI_UNF_DMX_FILTER_ATTR_S));
+	sFilterAttr.u32FilterDepth = pFltAttr->u32FilterDepth;
+	memcpy(sFilterAttr.au8Mask,  pFltAttr->u8Mask,   NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Match, pFltAttr->u8Match,  NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Negate,pFltAttr->u8Negate, NUM_HIFLTDEPTH);
+	hiReturn = HI_UNF_DMX_SetFilterAttr(ChFilter->hFilter, &sFilterAttr);
+	if (HI_SUCCESS != hiReturn)
+	{
+		cs_log("mydemux:hi_unf_dmx_setfilterattr.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->fltAttr.u32CrcFlag != pFltAttr->u32CrcFlag)
+	{
+		hiReturn = HI_UNF_DMX_GetChannelAttr(ChFilter->hChannel, &sChanAttr);
+		if (HI_SUCCESS != hiReturn)
+		{
+			cs_log("mydemux:hi_unf_dmx_getchannelattr.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		if (sChanAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_SEC ||
+			 sChanAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_ECM_EMM)
+		{
+			if ((ChFilter->fltAttr.u32CrcFlag == 1)
+				&& (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+			else
+			if ((ChFilter->fltAttr.u32CrcFlag == 2) && (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+			else
+			if ((ChFilter->fltAttr.u32CrcFlag == 0) && (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_FORBID))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORBID;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+
+			if (HI_SUCCESS != hiReturn)
+			{
+				 cs_log("mydemux:hifilter_setattr.crc.error(%x)\n", hiReturn);
+				 return HI_FAILURE;
+			}
+		}
+	}
+
+	memcpy(&ChFilter->fltAttr, pFltAttr, sizeof(HIDEMUX_ATTRIB));
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_GetAttr(HI_S32 s32FilterID, HIDEMUX_ATTRIB *pFltAttr)
+{
+	HIDEMUX_FILTERS *ChFilter;
+
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+	if (!pFltAttr)
+	{
+		cs_log("mydemux:hifilter_getattr.null\n");
+		return HI_FAILURE;
+	}
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	memcpy(pFltAttr, &ChFilter->fltAttr, sizeof(HIDEMUX_ATTRIB));
+	return HI_SUCCESS;
+}*/
+
+static HI_S32
+hifilter_Start(HI_S32 s32FilterID)
+{
+	HI_UNF_DMX_CHAN_STATUS_S stStatus;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	cs_log("mydemux:call hifilter_start\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		cs_log("mydemux:hifilter_start.error\n");
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->u32EnableFlag)
+	{
+		cs_log("mydemux:hifilter_start.already\n");
+		return HI_SUCCESS;
+	}
+
+	hiReturn = HI_UNF_DMX_AttachFilter(ChFilter->hFilter, ChFilter->hChannel);
+	if (HI_SUCCESS != hiReturn)
+	{
+		cs_log("mydemux:hi_unf_dmx_attachfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32EnableFlag = 1;
+	ChFilter->u32TimerCount = 0;
+	hiReturn = HI_UNF_DMX_GetChannelStatus(ChFilter->hChannel, &stStatus);
+	if (HI_SUCCESS != hiReturn)
+	{
+		cs_log("mydemux:hi_unf_dmx_getchannelstatus.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	if (HI_UNF_DMX_CHAN_CLOSE == stStatus.enChanStatus)
+	{
+		hiReturn = HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			cs_log("mydemux:hi_unf_dmx_openchannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Stop(HI_S32 s32FilterID)
+{
+	HI_UNF_DMX_CHAN_STATUS_S stStatus;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	cs_log("mydemux:call hifilter_stop!\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		cs_log("mydemux:hifilter_stop.error\n");
+		return HI_FAILURE;
+	}
+
+	if (!ChFilter->u32EnableFlag)
+	{
+		cs_log("mydemux:hifilter_stop.already\n");
+		return HI_SUCCESS;
+	}
+
+	hiReturn = HI_UNF_DMX_DetachFilter(ChFilter->hFilter, ChFilter->hChannel);
+	if (HI_SUCCESS != hiReturn)
+	{
+		cs_log("mydemux:hi_unf_dmx_detachfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32EnableFlag = 0;
+	ChFilter->u32TimerCount = 0;
+	/*if the channel did not attach filter,close the channel*/
+	if (!hifilter_GetChnEnFltNum(ChFilter->fltAttr.u32DMXID, ChFilter->hChannel))
+	{
+		cs_log("mydemux:call hi_unf_dmx_closechannel\n");
+		hiReturn = HI_UNF_DMX_GetChannelStatus(ChFilter->hChannel, &stStatus);
+		if (HI_SUCCESS != hiReturn)
+		{
+			cs_log("mydemux:hi_unf_dmx_getchannelstatus.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		if (HI_UNF_DMX_CHAN_CLOSE != stStatus.enChanStatus)
+		{
+			hiReturn = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+			if (HI_SUCCESS != hiReturn)
+			{
+				cs_log("mydemux:hi_unf_dmx_closechannel.error(%x)\n", hiReturn);
+				return HI_FAILURE;
+			}
+		}
+	}
+	return HI_SUCCESS;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static int32_t
+hidemux_Start(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid, unsigned char *fltr, unsigned char *mask)
+{
+	HIDEMUX_ATTRIB FltAttr;
+	HI_S32 hifltnum = INVALID_HIFILTER;
+	int hiReturn;
+	int i;
+
+	FltAttr.dmuxid				= dmuxid;
+	FltAttr.fltnum				= n;
+	FltAttr.u32TUNERID		= TUNER0;
+	FltAttr.u32DMXID			= HIDEMUX_OSCAM_ID;
+	#if defined(SDKV600)
+		if (adapter==DEMUX_SECONDADAPTER) {
+			FltAttr.u32TUNERID= TUNER1;
+			FltAttr.u32DMXID	= HIDEMUX_OSCAM2_ID;
+		}
+	#endif
+	FltAttr.u32Type			= type;
+	FltAttr.u32FilterType 	= 0;	// Section/ECM.EMM
+	FltAttr.u32FilterType 	= (pid == CAT_PID) ? 0 : 2;
+	FltAttr.u32PID				= pid;
+	FltAttr.u32CrcFlag 		= 0;
+	FltAttr.u32TimeOutMs		= 9000;
+
+	memset(FltAttr.u8Match, 0x00,NUM_HIFLTDEPTH);
+	memset(FltAttr.u8Mask,  0xFF,NUM_HIFLTDEPTH);
+	memset(FltAttr.u8Negate,0x00,NUM_HIFLTDEPTH);
+	FltAttr.u8Match[0] 		= fltr[0];
+	FltAttr.u8Mask [0] 		= HIFLT_REVERSE_MASK(mask[0]);
+	FltAttr.u32FilterDepth	= DVB_HIFLTBYTES;
+	for (i=1; i<(int)FltAttr.u32FilterDepth; i++)
+	{
+		FltAttr.u8Match[i] 	= fltr[i];
+		FltAttr.u8Mask [i] 	= HIFLT_REVERSE_MASK(mask[i]);
+	}
+
+	cs_log_dbg(D_DVBAPI, "hifilter %d(%d) start(pid:%04X)", n, type, pid);
+	if (!IS_INVALID_PID(pid))
+	{
+		hiReturn = hifilter_Create(&FltAttr, &hifltnum);
+		if (HI_SUCCESS != hiReturn)
+		{
+			g_dmuxes[dmuxid][n].activated = 0;
+			cs_log("mydemux:hifilter %d(%d) failure", n, type);
+		}
+		else
+		{
+			hiReturn = hifilter_Start(hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				cs_log("mydemux:hifilter %d(%d) failure", n, type);
+			}
+			g_dmuxes[dmuxid][n].hifltnum  = hifltnum;
+			g_dmuxes[dmuxid][n].activated = 1;
+		}
+	}
+	cs_log("mydemux:hifilter_start{%d:%d:%d,%04X}{%2d:%02X%02X%02X%02X%02X%02X%02X%02X}\n",
+				dmuxid,
+				type, n, pid,
+				g_dmuxes[dmuxid][n].hifltnum,
+				fltr[0],fltr[1],fltr[2],fltr[3],fltr[4],fltr[5],fltr[6],fltr[7]);
+	g_dmuxes[dmuxid][n].adapter= adapter;
+	g_dmuxes[dmuxid][n].dmuxid = dmuxid;
+	g_dmuxes[dmuxid][n].pid	 	= pid;
+	g_dmuxes[dmuxid][n].type	= type;
+	g_dmuxes[dmuxid][n].flnum 	= n;
+	return (n+1);
+}
+
+static int32_t
+hidemux_Stop(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid)
+{
+	int hiReturn;
+
+	if (n > MAX_FILTER-1) return 0;
+	if (g_dmuxes[dmuxid][n].activated)
+	{
+		cs_log("mydemux:hifilter_stop{%d:%d:%d:%d,%04x}{%d}\n",
+					adapter,
+					dmuxid,
+					type, n, pid,
+					g_dmuxes[dmuxid][n].hifltnum);
+		g_dmuxes[dmuxid][n].activated = 0;
+//		if (g_dmuxes[dmuxid][n].dmuxid != dmuxid)
+//		{
+//			cs_log("mydemux:hidemux_filterclose dmuxid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].dmuxid, dmuxid);
+//			return 0;
+//		}
+//		if (pid  && g_dmuxes[dmuxid][n].pid != pid)
+//		{
+//			cs_log("mydemux:hidemux_filterclose pid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].pid, pid);
+//			return 0;
+//		}
+//		if (type && g_dmuxes[dmuxid][n].type != type)
+//		{
+//			cs_log("mydemux:hidemux_filterclose pid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].pid, pid);
+//			return 0;
+//		}
+		if (!IS_INVALID_HIFILTERS(g_dmuxes[dmuxid][n].hifltnum))
+		{
+			cs_log_dbg(D_DVBAPI, "hifilter %d(%d) stop(pid:%04X)", n, type, pid);
+			hiReturn = hifilter_Stop(g_dmuxes[dmuxid][n].hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				cs_log("hifilter_stop.failed\n");
+				cs_log_dbg(D_DVBAPI, "hifilter %d(%d) failure{%x}", n, type, hiReturn);
+			}
+
+			hiReturn = hifilter_Destroy(g_dmuxes[dmuxid][n].hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				cs_log("hifilter_destroy.failed\n");
+				cs_log_dbg(D_DVBAPI, "hifilter %d(%d) failure{%x}", n, type, hiReturn);
+			}
+		}
+	}
+	g_dmuxes[dmuxid][n].adapter	= -1;
+	g_dmuxes[dmuxid][n].dmuxid 	= -1;
+	g_dmuxes[dmuxid][n].type		=  0;
+	g_dmuxes[dmuxid][n].pid	 		=  0;
+	g_dmuxes[dmuxid][n].flnum  	= -1;
+	g_dmuxes[dmuxid][n].hifltnum 	= INVALID_HIFILTER;
+	return 1;
+}
+
+
+static int
+hidemux_Init(void)
+{
+	struct hidemux_thread_param *ecmpara, *emmpara;
+	pthread_attr_t attr;
+	SAFE_ATTR_INIT(&attr);
+	int hiReturn;
+	int ret;
+	int dmuxid, n, i;
+
+//	cs_log("mydemux:hidemux_init{%p,%p)\n", dvbapi_client, cur_client());
+	cs_log("mydemux:hidemux_init{%d)\n", MAX_HIFILTERS);
+
+	if (g_DemuxIniz) return 1;
+
+	hiReturn = HI_UNF_DMX_Init();
+	cs_log("HI_UNF_DMX_Init:(%x)\n", hiReturn);
+	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_Init);
+
+	#if defined(SDKV600)
+		#if 0
+			// use tvheadend...
+			/* 0,4 is PLAY DMX */
+			hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM1_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+			// TUNER 1
+			/* 0,4 is PLAY DMX */
+			hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM2_ID/*demux id*/, HIPORT_INTERNAL_ID/*port id*/); //for section
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+		#endif
+	#elif defined(SDKV500)
+		// tvheadend
+		#if 0
+			HI_UNF_DMX_PORT_ATTR_S PortAttr;
+			// TUNER 0
+			hiReturn = HI_UNF_DMX_GetTSPortAttr(HIPORT_TUNER_ID, &PortAttr);
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_GetTSPortAttr);
+			PortAttr.enPortType = HI_UNF_DMX_PORT_TYPE_SERIAL;
+			#if defined(Hi3719MV100)
+				PortAttr.u32SerialBitSelector = 1; //D0
+			#else
+				PortAttr.u32SerialBitSelector = 0; //D7
+			#endif
+			hiReturn = HI_UNF_DMX_SetTSPortAttr(HIPORT_TUNER_ID, &PortAttr);
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_SetTSPortAttr);
+		#endif
+
+		/* 0,4 is PLAY DMX */
+		hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+		HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+		// TUNER 1
+		//	hiReturn = HI_UNF_DMX_GetTSPortAttr(HI_UNF_DMX_PORT_TSI_3, &PortAttr);
+		//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_GetTSPortAttr);
+		//	PortAttr.enPortType = HI_UNF_DMX_PORT_TYPE_SERIAL;
+		//	PortAttr.u32SerialBitSelector = 0; //D7
+		//	hiReturn = HI_UNF_DMX_SetTSPortAttr(HI_UNF_DMX_PORT_TSI_3, &PortAttr);
+		//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_SetTSPortAttr);
+
+		/* 0,4 is PLAY DMX */
+	//	hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_DMX_ID2/*demux id*/, HI_UNF_DMX_PORT_TSI_3/*port id*/); //for section
+	//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+	#else
+		hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+		HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+	#endif
+
+	for (dmuxid=0; dmuxid<MAX_DEMUX; dmuxid++)
+	{
+		for (n=0; n<MAX_FILTER; n++)
+		{
+			g_dmuxes[dmuxid][n].dmuxid		= -1;
+			g_dmuxes[dmuxid][n].adapter	= -1;
+			g_dmuxes[dmuxid][n].type	 	= 0;
+			g_dmuxes[dmuxid][n].pid 	 	= 0;
+			g_dmuxes[dmuxid][n].flnum 	 	= -1;
+			g_dmuxes[dmuxid][n].hifltnum	= INVALID_HIFILTER;
+			g_dmuxes[dmuxid][n].activated = 0;
+		}
+	}
+	for (i=0; i<MAX_HIFILTERS; i++)
+	{
+		memset(&g_HIFilters[i], 0, sizeof(HIDEMUX_FILTERS));
+		g_HIFilters[i].hChannel = INVALID_HIHANDLE;
+		g_HIFilters[i].hFilter  = INVALID_HIHANDLE;
+	}
+
+	//pthread_attr_init(&attr);
+	//pthread_attr_setstacksize(&attr, PTHREAD_STACK_SIZE);
+
+	if (!cs_malloc(&ecmpara, sizeof(struct hidemux_thread_param))) return 0;
+//	ecmpara->flnum = HIDEMUX_OSCAM_ID;
+	ecmpara->id  	 = TYPE_ECM;
+	ecmpara->cli 	 = cur_client();
+	//ret = pthread_create(&g_FltEcmThread, NULL, hifilter_ThreadModules, (void *)ecmpara);
+	ret = start_thread("hifilter ThreadModules", hifilter_ThreadModules, (void *)ecmpara, NULL, 1, 0);
+	if (ret) {
+		//pthread_attr_destroy(&attr);
+		cs_log("hifilter_Init thread.errno(%d.%s)", ret, strerror(ret));
+		return 0;
+	}
+	/*else {
+		pthread_detach(g_FltEcmThread);
+	}*/
+
+	if (!cs_malloc(&emmpara, sizeof(struct hidemux_thread_param))) return 0;
+	emmpara->id  = TYPE_EMM;
+	emmpara->cli = cur_client();
+	ret = pthread_create(&g_FltEmmThread, NULL, hifilter_ThreadModules, (void *)emmpara);
+	ret = start_thread("hifilter ThreadModules", hifilter_ThreadModules, (void *)emmpara, NULL, 1, 0);
+	if (ret) {
+		//pthread_attr_destroy(&attr);
+		cs_log("hifilter_Init thread.errno(%d.%s)", ret, strerror(ret));
+		return 0;
+	}
+	/*else {
+		pthread_detach(g_FltEmmThread);
+	}
+	pthread_attr_destroy(&attr);*/
+	g_DemuxRuning = HI_TRUE;
+	if (hiReturn == HI_SUCCESS) g_DemuxIniz = 1;
+	return (g_DemuxIniz);
+}
+
+
+static int
+hidemux_DeInit(void)
+{
+	int hiReturn;
+	int dmuxid;
+	int n;
+
+	cs_log("mydemux:hidemux_close\n");
+	if (!g_DemuxIniz) return 1;
+
+	for (dmuxid=0;dmuxid<MAX_DEMUX;dmuxid++)
+	{
+		for (n=0;n<MAX_FILTER;n++)
+		{
+			hidemux_Stop(-1, dmuxid, 0, n, 0);
+		}
+	}
+	g_DemuxIniz = 0;
+	g_DemuxRuning = HI_FALSE;
+	usleep(100 * 1000);
+	//pthread_join(g_FltEcmThread, 0);
+	SAFE_THREAD_JOIN(g_FltEcmThread, 0);
+	//pthread_join(g_FltEmmThread, 0);
+	SAFE_THREAD_JOIN(g_FltEmmThread, 0);
+
+//	hiReturn = HI_UNF_DMX_DetachTSPort(HIPORT_TUNER_ID/*port id*/);
+//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+
+	hiReturn = HI_UNF_DMX_DeInit();
+	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_DeInit);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+int32_t
+hidemuxapi_AddFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid, uchar *flt, uchar *mask)
+{
+	int status;
+
+	if (!g_DemuxIniz) return -1;
+	//pthread_mutex_lock(&g_FltLocks);
+	SAFE_MUTEX_LOCK(&g_FltLocks);
+	status = hidemux_Start(adapter, dmuxid, type, n, pid, flt, mask);
+	//pthread_mutex_unlock(&g_FltLocks);
+	SAFE_MUTEX_UNLOCK(&g_FltLocks);
+	return status;
+}
+
+int32_t
+hidemuxapi_RemoveFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid)
+{
+	int status;
+
+	if (!g_DemuxIniz) return -1;
+	//pthread_mutex_lock(&g_FltLocks);
+	SAFE_MUTEX_LOCK(&g_FltLocks);
+	status = hidemux_Stop(adapter, dmuxid, type, n, pid);
+	//pthread_mutex_unlock(&g_FltLocks);
+	SAFE_MUTEX_UNLOCK(&g_FltLocks);
+	return status;
+}
+
+
+
+/* write cw to all demuxes in mask with passed index */
+int32_t
+hidemuxapi_Init(void)
+{
+	//pthread_mutex_init(&g_FltLocks, NULL);
+	SAFE_MUTEX_INIT(&g_FltLocks, NULL);
+	//pthread_mutex_init(&g_FltMutex, NULL);
+	SAFE_MUTEX_INIT(&g_FltMutex, NULL);
+	//
+	//
+	// link option -lhi_common
+	// for disable debug message
+	HI_SYS_Init();
+	#if defined(SDKV500) || defined(SDKV600)
+		HI_SYS_SetLogLevel(HI_ID_DEMUX,HI_LOG_LEVEL_ERROR);
+	#else
+		HI_SYS_SetLogLevel(HI_DEBUG_ID_DEMUX,HI_LOG_LEVEL_ERROR);
+	#endif
+	//
+	//
+	//
+	hidemux_Init();
+	atexit(hidemuxapi_Deinit);
+	return 1;
+}
+
+void
+hidemuxapi_Deinit(void)
+{
+	hidemux_DeInit();
+	//
+	//
+	//
+	HI_SYS_DeInit();
+	//
+	//
+	//
+	pthread_mutex_destroy(&g_FltLocks);
+	pthread_mutex_destroy(&g_FltMutex);
+}
+
+#endif	// #if defined(WITH_HISILICON)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+
Index: module-dvbapi-his.h
===================================================================
--- module-dvbapi-his.h	(nonexistent)
+++ module-dvbapi-his.h	(working copy)
@@ -0,0 +1,13 @@
+#ifndef _MODULE_HIAPI_H_
+#define _MODULE_HIAPI_H_
+
+#define DEMUX_MAINADAPTER 3
+#define DEMUX_SECONDADAPTER 2
+
+/* Local hiapi functions */
+int32_t hidemuxapi_Init(void);
+void hidemuxapi_Deinit(void);
+int32_t hidemuxapi_AddFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n,int32_t pid, uchar *flt, uchar *mask);
+int32_t hidemuxapi_RemoveFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid);
+
+#endif
Index: module-dvbapi.c
===================================================================
--- module-dvbapi.c	(revision 1587)
+++ module-dvbapi.c	(working copy)
@@ -11,6 +11,9 @@
 #include "module-dvbapi-coolapi.h"
 #include "module-dvbapi-stapi.h"
 #include "module-dvbapi-chancache.h"
+#if defined(WITH_HISILICON)
+#include "module-dvbapi-his.h"
+#endif
 #include "module-stat.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -261,7 +264,7 @@
 struct s_dvbapi_priority *dvbapi_priority;
 struct s_client *dvbapi_client;
 
-const char *boxdesc[] = { "none", "dreambox", "duckbox", "ufs910", "dbox2", "ipbox", "ipbox-pmt", "dm7000", "qboxhd", "coolstream", "neumo", "pc", "pc-nodmx", "samygo" };
+const char *boxdesc[] = { "none", "dreambox", "duckbox", "ufs910", "dbox2", "ipbox", "ipbox-pmt", "dm7000", "qboxhd", "coolstream", "neumo", "pc", "pc-nodmx", "samygo","hisky" };
 
 
 // when updating devices[BOX_COUNT] make sure to update these index defines
@@ -268,6 +271,7 @@
 #define BOX_INDEX_QBOXHD 0
 #define BOX_INDEX_DREAMBOX_DVBAPI3 1
 #define BOX_INDEX_COOLSTREAM 6
+#define BOX_INDEX_HISILICON 7
 
 static const struct box_devices devices[BOX_COUNT] =
 {
@@ -282,6 +286,7 @@
 	/* sh4      (stapi)*/       { "/dev/stapi/",            "stpti4_ioctl", "stpti4_ioctl", "/tmp/camd.socket", STAPI       },
 #endif
 	/* coolstream*/             { "/dev/cnxt/",             "null",         "null",         "/tmp/camd.socket", COOLAPI     },
+	/* HiSilicon*/              { "/dev/",                  "null",         "null",         "/var/camd.socket", HISILICONAPI },
 };
 
 static int32_t selected_box = -1;
@@ -289,7 +294,7 @@
 static int32_t maxfilter = MAX_FILTER;
 static int32_t dir_fd = -1;
 static uint16_t last_client_proto_version = 0;
-static char* last_client_name = NULL;
+static char* last_client_name = "hisilicon";
 
 static int32_t ca_fd[MAX_DEMUX]; // holds fd handle of each ca device 0 = not in use
 static LLIST * ll_activestreampids; // list of all enabled streampids on ca devices
@@ -729,6 +734,7 @@
 
 	for(i = 0; i < maxfilter && demux[demux_id].demux_fd[i].fd > 0; i++) { ; }
 
+	cs_log("mydvb:dvbapi_set_filter{%d:%d, %d,%04X,%06X:%04X}\n", demux_id, i, type, caid, provid, pid);
 	if(i >= maxfilter)
 	{
 		cs_log_dbg(D_DVBAPI, "no free filter");
@@ -817,6 +823,21 @@
 		ret = dvbapi_ioctl(filterfd, DMX_SET_FILTER1, &sFP1);
 
 		break;
+
+#if defined(WITH_HISILICON)
+	case HISILICONAPI:
+		//	demux[demux_id].demux_fd[n].fd = 1;
+		// sky(quad)
+		ret = hidemuxapi_AddFilters(demux[demux_id].adapter_index, demux[demux_id].demux_index, type, n, pid, filt, mask);
+		if (ret > 0) {
+			demux[demux_id].demux_fd[n].fd = ret;
+		}
+		else {
+			ret = -1; // error setting filter!
+		}
+		break;
+#endif
+
 #if defined(WITH_STAPI) || defined(WITH_STAPI5)
 	case STAPI:
 		ret = filterfd = stapi_set_filter(demux_id, pid, filt, mask, n, demux[demux_id].pmt_file);
@@ -868,7 +889,21 @@
 
 static int32_t dvbapi_detect_api(void)
 {
-#if defined WITH_COOLAPI || defined WITH_COOLAPI2
+#if defined(WITH_HISILICON)
+	selected_api = HISILICONAPI;
+	selected_box = BOX_INDEX_HISILICON;
+	disable_pmt_files  = 1;
+	cfg.dvbapi_boxtype = BOXTYPE_HISILICON;
+	cfg.dvbapi_listenport = 0; // TCP port to listen instead of camd.socket
+	cs_log("Detected Hisilicon API");
+	if (hidemuxapi_Init() == 0)
+	{
+		cs_log("ERROR: dvbiapi: setting up hisky failed.");
+		return 0;
+	}
+	cs_log("Hisilicon PMT Mode=%d.", cfg.dvbapi_pmtmode);
+	return 1;
+#elif defined WITH_COOLAPI || defined WITH_COOLAPI2
 	selected_api = COOLAPI;
 	selected_box = BOX_INDEX_COOLSTREAM;
 	disable_pmt_files = 1;
@@ -1052,6 +1087,11 @@
 		if(cfg.dvbapi_boxtype == BOXTYPE_SAMYGO)
 			{ num = 0; }
 
+#if defined(WITH_HISILICON)
+		if (cfg.dvbapi_boxtype==BOXTYPE_HISILICON)
+			{ num = 0; }
+#endif
+
 		snprintf(device_path2, sizeof(device_path2), devices[selected_box].ca_device, num + ca_offset);
 		snprintf(device_path, sizeof(device_path), devices[selected_box].path, adapter);
 
@@ -1058,7 +1098,7 @@
 		strncat(device_path, device_path2, sizeof(device_path) - strlen(device_path) - 1);
 	}
 
-	if (cfg.dvbapi_boxtype == BOXTYPE_SAMYGO) {
+	if (cfg.dvbapi_boxtype == BOXTYPE_SAMYGO || cfg.dvbapi_boxtype == BOXTYPE_HISILICON) {
 
 		if(type == 0)
 		{
@@ -1091,6 +1131,7 @@
 			ret = -1;
 		}
 	} else {
+		cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_open_device{%s}\n", device_path);
 		dmx_fd = ret = open(device_path, O_RDWR | O_NONBLOCK);
 	}
 
@@ -1150,6 +1191,7 @@
 	{
 		if(demux[demux_index].demux_fd[g].type == type)
 		{
+			cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_stop_filter{%s.%d}\n", (type==TYPE_ECM) ? "ecm":"emm", g);
 			if(dvbapi_stop_filternum(demux_index, g, msgid) == -1)
 			{
 				error = 1;
@@ -1214,12 +1256,27 @@
 				}
 				break;
 #endif
+#if defined(WITH_HISILICON)
+			case HISILICONAPI:
+		      cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_stop_filternum{%s:%d.%04X}\n",
+		      		(demux[demux_index].demux_fd[num].type==TYPE_ECM) ? "ecm":"emm" ,
+		      		num, demux[demux_index].demux_fd[num].pid);
+		      retfilter = hidemuxapi_RemoveFilters(demux[demux_index].adapter_index,
+				      				demux_index,
+								      demux[demux_index].demux_fd[num].type,
+								      num,
+								      demux[demux_index].demux_fd[num].pid);
+				if (retfilter < 1) retfilter = -1;
+				retfd = 0;
+				break;
+#endif
 			default:
 				break;
 			}
 			if(errno == 9) {retfilter = 0;} // no error on bad file descriptor
 		} while (retfilter < 0 && try < 10);
-
+#if defined(WITH_HISILICON)
+#else
 #if !defined WITH_COOLAPI && !defined WITH_COOLAPI2 // no fd close for coolapi and stapi, all others do close fd!
 		try = 0;
 		do
@@ -1264,6 +1321,7 @@
 	{
 		cs_log("ERROR: Demuxer %d could not close fd of Filter %d (fd=%d api:%d errno=%d %s)", demux_index, num + 1, fd,
 			selected_api, errno, strerror(errno));
+#endif
 		return retfd;
 	}
 
@@ -1685,7 +1743,9 @@
 
 void dvbapi_parse_cat(int32_t demux_id, uchar *buf, int32_t len)
 {
-#if defined WITH_COOLAPI  || defined WITH_COOLAPI2
+#if defined(WITH_HISILICON)
+	demux[demux_id].max_emm_filter = MAX_FILTER-1;
+#elif defined WITH_COOLAPI  || defined WITH_COOLAPI2
 	// driver sometimes reports error if too many emm filter
 	// but adding more ecm filter is no problem
 	// ... so ifdef here instead of limiting MAX_FILTER
@@ -1872,6 +1932,11 @@
 	case COOLAPI:
 		break;
 #endif
+#if defined(WITH_HISILICON)
+// unnecessariness(tvheadend)....
+		case HISILICONAPI:
+			break;
+#endif
 	default:
 		for(i = 0; i < MAX_DEMUX; i++)
 		{
@@ -2030,7 +2095,7 @@
 
 	demux[demux_id].pidindex = -1;
 	demux[demux_id].curindex = -1;
-	if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX)
+	if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && cfg.dvbapi_boxtype != BOXTYPE_HISILICON)
 		unlink(ECMINFO_FILE);
 	return;
 }
@@ -3189,7 +3254,7 @@
 		if (buffer[21]==0x84 && buffer[22]==0x02) *pmtpid = b2i(2, buffer+23);
 	}
 
-	if((cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_SAMYGO)
+	if((cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_SAMYGO || cfg.dvbapi_boxtype == BOXTYPE_HISILICON)
 		 && buffer[7] == 0x82 && buffer[8] == 0x02)
 	{
 		*demux_index = buffer[9]; // it is always 0 but you never know
@@ -3647,7 +3712,7 @@
 		if(demux[demux_id].emmstart.time == 1)   // irdeto fetch emm cat direct!
 		{
 			cs_ftime(&demux[demux_id].emmstart); // trick to let emm fetching start after 30 seconds to speed up zapping
-			dvbapi_start_filter(demux_id, demux[demux_id].pidindex, 0x001, 0x001, 0x01, 0x01, 0xFF, 0, TYPE_EMM); //CAT
+			dvbapi_start_filter(demux_id, demux[demux_id].pidindex, CAT_PID, 0x001, 0x01, 0x01, 0xFF, 0, TYPE_EMM); //CAT
 		}
 		else { cs_ftime(&demux[demux_id].emmstart); } // for all other caids delayed start!
 	}
@@ -4082,6 +4147,7 @@
 	// this will allow oscam to run as root if needed
 	// and still allow non root client to connect to the socket
 	chmod(devices[selected_box].cam_socket_path, S_IRWXU | S_IRWXG | S_IRWXO);
+	cs_log_dbg(D_DVBAPI, "camsocket:%s\n", devices[selected_box].cam_socket_path);
 
 	return listenfd;
 }
@@ -4854,6 +4920,7 @@
 	{
 		case DVBAPI_FILTER_DATA: // min 9 bytes
 		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) return 0;
 			if(mbuf_len < 9)
 			{
 				return 9 - mbuf_len;
@@ -4862,6 +4929,7 @@
 		}
 		case DVBAPI_CLIENT_INFO: // min 7 bytes
 		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) return 0;
 			if(mbuf_len < 7)
 			{
 				return 7 - mbuf_len;
@@ -5114,6 +5182,7 @@
 	{
 		case DVBAPI_FILTER_DATA:
 		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) break;
 			if(data_len < 1)
 			{
 				cs_log("Error: packet DVBAPI_FILTER_DATA is too short!");
@@ -5140,6 +5209,7 @@
 		}
 		case DVBAPI_CLIENT_INFO:
 		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) break;
 			uint16_t client_proto = b2i(2, mbuf + 4);
 
 			NULLFREE(last_client_name);
@@ -5263,7 +5333,11 @@
 	int32_t maxpfdsize = (MAX_DEMUX * maxfilter) + MAX_DEMUX + 2;
 	struct pollfd pfd2[maxpfdsize];
 	struct timeb start, end;  // start time poll, end time poll
+#if defined(WITH_HISILICON)
+#define PMT_SERVER_SOCKET "/var/.listen.camd.socket"
+#else
 #define PMT_SERVER_SOCKET "/tmp/.listen.camd.socket"
+#endif
 	struct sockaddr_un saddr;
 	saddr.sun_family = AF_UNIX;
 	strncpy(saddr.sun_path, PMT_SERVER_SOCKET, 107);
@@ -5449,7 +5523,7 @@
 			{
 				if(demux[i].demux_fd[g].fd <= 0) continue; // deny obvious invalid fd!
 
-				if(!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && selected_api != STAPI && selected_api != COOLAPI)
+				if(!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && selected_api != STAPI && selected_api != COOLAPI && selected_api != HISILICONAPI)
 				{
 					pfd2[pfdcount].fd = demux[i].demux_fd[g].fd;
 					pfd2[pfdcount].events = (POLLIN | POLLPRI);
@@ -5480,11 +5554,12 @@
 			{
 				gone = comp_timeb(&now, &demux[i].emmstart);
 
-				if(gone > 20*1000){
+				if(gone > 10*1000LL){
 
 					if(do_emm_start) {
 						cs_ftime(&demux[i].emmstart); // trick to let emm fetching start after 30 seconds to speed up zapping
-						dvbapi_start_filter(i, demux[i].pidindex, 0x001, 0x001, 0x01, 0x01, 0xFF, 0, TYPE_EMM); //CAT
+				   		dvbapi_stop_filter(demux[i].demux_index, TYPE_EMM, 0);
+						dvbapi_start_filter(i, demux[i].pidindex, CAT_PID, 0x001, 0x01, 0x01, 0xFF, 0, TYPE_EMM); //CAT
 					}
 				}
 
@@ -5508,7 +5583,7 @@
 				else
 				{
 					gone = comp_timeb(&now, &demux[i].emmstart);
-					if(gone > 30*1000)
+					if(gone > 10*1000)
 					{
 						demux[i].emmstart = now;
 						dvbapi_start_emm_filter(i); // start emmfiltering delayed if filters already were running
@@ -5799,8 +5874,16 @@
 							close(connfd);
 							connfd = -1;
 
-							if (!active_conn && (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)) //last connection closed
+							if (!active_conn && (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_HISILICON)) //last connection closed
 							{
+								last_client_proto_version = 0;
+								if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) {}
+								else if (last_client_name)
+								{
+									free(last_client_name);
+									last_client_name = NULL;
+								}
+
 								if (cfg.dvbapi_listenport)
 								{
 									//update webif data
@@ -5890,6 +5973,13 @@
 	memset(&ca_descr, 0, sizeof(ca_descr));
 	memset(&ca_descr_mode, 0, sizeof(ca_descr_mode_t));
 
+	cs_log_dbg(D_DVBAPI, "mydvb:dvbapi_write_cw{%d,%04X,%d, %04X}{%02X%02X...%02X%02X}\n",
+			demux_id,
+			demux[demux_id].ca_mask,
+			demux[demux_id].adapter_index,
+			pid,
+			cw[0], cw[7], cw[8], cw[15]);
+
 	if(memcmp(demux[demux_id].lastcw[0], nullcw, 8) == 0
 			&& memcmp(demux[demux_id].lastcw[1], nullcw, 8) == 0)
 		{ cwEmpty = 1; } // to make sure that both cws get written on constantcw
@@ -5907,6 +5997,7 @@
 			&& (memcmp(cw + (n * 8), nullcw, 8) != 0 || demux[demux_id].ECMpids[pid].CAID == 0x2600))
 		{
 			ca_index_t idx = dvbapi_ca_setpid(demux_id, pid, stream_id, (algo == CA_ALGO_DES), msgid);  // prepare ca
+			cs_log_dbg(D_DVBAPI, "mydvb:dvbapi_write_cw{idx=%d}\n", idx);
 			if (idx == INDEX_INVALID) return; // return on no index!
 
 #if defined WITH_COOLAPI || defined WITH_COOLAPI2
@@ -5954,6 +6045,11 @@
 							}
 						}
 					}
+					if(cfg.dvbapi_boxtype == BOXTYPE_HISILICON)
+					{ 
+					write_cw = 1;
+					usedidx= idx;
+					}
 					if(!write_cw) { continue; } // no need to write the cw since this ca isnt using it!
 
 					lastidx = usedidx;
@@ -6026,6 +6122,11 @@
 {
 	int32_t i, j, k, handled = 0;
 
+	cs_log_dbg(D_DVBAPI, "mydvb:dvbapi_send_dcw{%d}{%04X:%06X,%d}{%04x}.%s\n",
+			 er->rc,
+			 er->caid, er->prid, er->srvid, er->pid,
+			(er->selected_reader) ? er->selected_reader->label : "unk");
+
 	for(i = 0; i < MAX_DEMUX; i++)
 	{
 		uint32_t nocw_write = 0; // 0 = write cw, 1 = dont write cw to hardware demuxer
@@ -6637,6 +6738,11 @@
 		return 0;
 	}
 
+	if (selected_api == HISILICONAPI)
+	{
+		return 0;
+	}
+
 	if(selected_api != DVBAPI_3 && selected_api != DVBAPI_1 && selected_api != STAPI)   // only valid for dvbapi3, dvbapi1 and STAPI
 	{
 		return 0;
@@ -6840,7 +6946,10 @@
 		break;
 	}
 	#endif
-
+#ifdef WITH_HISILICON
+		case HISILICONAPI:
+			break;
+#endif
 	default:
 		break;
 	}
Index: module-dvbapi.h
===================================================================
--- module-dvbapi.h	(revision 1587)
+++ module-dvbapi.h	(working copy)
@@ -10,11 +10,15 @@
 #define TYPE_PAT 4
 #define TYPE_PMT 5
 
+
+#define CAT_PID  0x1
+
 //api
 #define DVBAPI_3    0
 #define DVBAPI_1    1
 #define STAPI       2
 #define COOLAPI     3
+#define HISILICONAPI 4
 
 #ifdef __CYGWIN__
 #define TMPDIR  "./"
@@ -21,10 +25,16 @@
 #define STANDBY_FILE    "./.pauseoscam"
 #define ECMINFO_FILE    "./ecm.info"
 #else
+#if defined(WITH_HISILICON)
+#define TMPDIR			"/var/"
+#define STANDBY_FILE		"/var/.pauseoscam"
+#define ECMINFO_FILE		"/var/ecm.info"
+#else
 #define TMPDIR  "/tmp/"
 #define STANDBY_FILE    "/tmp/.pauseoscam"
 #define ECMINFO_FILE    "/tmp/ecm.info"
 #endif
+#endif
 
 #define MAX_DEMUX 16
 #define MAX_CAID 50
@@ -37,7 +47,7 @@
 #define MAX_STREAM_INDICES 1
 #endif
 
-#define BOX_COUNT 7
+#define BOX_COUNT 8
 
 #define BOXTYPE_DREAMBOX    1
 #define BOXTYPE_DUCKBOX 2
@@ -52,7 +62,8 @@
 #define BOXTYPE_PC      11
 #define BOXTYPE_PC_NODMX    12
 #define BOXTYPE_SAMYGO  13
-#define BOXTYPES        13
+#define BOXTYPE_HISILICON 14
+#define BOXTYPES        14
 #define DMXMD5HASHSIZE  16  // use MD5() 
 
 // we store the results of remove_streampid_from_list()
Index: oscam-config-global.c
===================================================================
--- oscam-config-global.c	(revision 1587)
+++ oscam-config-global.c	(working copy)
@@ -1277,7 +1277,11 @@
 	DEF_OPT_SAVE_FUNC(dvbapi_should_save_fn),
 	DEF_OPT_INT8("enabled"		, OFS(dvbapi_enabled),		0),
 	DEF_OPT_INT8("au"		, OFS(dvbapi_au),		0),
+#ifdef WITH_HISILICON
+	DEF_OPT_INT8("pmt_mode"		, OFS(dvbapi_pmtmode),		1),
+#else
 	DEF_OPT_INT8("pmt_mode"		, OFS(dvbapi_pmtmode),		0),
+#endif
 	DEF_OPT_INT8("request_mode"	, OFS(dvbapi_requestmode),	0),
 	DEF_OPT_INT32("listen_port"	, OFS(dvbapi_listenport),	0),
 	DEF_OPT_INT32("delayer"		, OFS(dvbapi_delayer),		0),
Index: oscam-ecm.c
===================================================================
--- oscam-ecm.c	(revision 1587)
+++ oscam-ecm.c	(working copy)
@@ -1531,7 +1531,13 @@
 
 int32_t write_ecm_answer(struct s_reader *reader, ECM_REQUEST *er, int8_t rc, uint8_t rcEx, uint8_t *cw, char *msglog, uint16_t used_cardtier, EXTENDED_CW* cw_ex)
 {
-	if(!reader || !er || !er->tps.time) { return 0; }
+	if (!er) return 0;
+	if (!er->tps.time) return 0;
+	if (!reader) return 0;
+	cs_log_dbg(D_TRACE, "myecm:write_ecm_answer=%d,%d,%s{%c}",
+			 rc, rcEx,
+			(reader) ? reader->label : "unk",
+			(er->client) ? er->client->typ : 'x');
 
 	// drop too late answers, to avoid seg fault --> only answer until tps.time+((cfg.ctimeout+500)/1000+1) is accepted
 	time_t timeout = time(NULL) - ((cfg.ctimeout+500)/1000+1);
@@ -1553,16 +1559,33 @@
 
 		timeout = time(NULL) - ((cfg.ctimeout+500)/1000+1);
 		if(er->tps.time < timeout)
-			{ return 0; }
+		{
+			cs_log_dbg(D_TRACE, "myecm:--- ecm_answer.timeout");
+			return 0;
+		}
 	}
 
 	struct s_ecm_answer *ea = get_ecm_answer(reader, er);
-	if(!ea) { return 0; }
+	// sky(n)
+	if (!ea)
+	{
+		//if (!IS_ICS_READERS(reader)) return 0;
+		cs_log_dbg(D_TRACE, "myecm:--- ecm_answer.none");
+		if (!cs_malloc(&ea, sizeof(struct s_ecm_answer))) return 0;
+		er->matching_rdr = ea;
+		ea->reader 	= reader;
+		ea->er 		= er;
+		ea->rc 		= rc;
+		ea->rcEx 	= rcEx;
+		ea->status  = REQUEST_BYPASS;
+		ea->is_pending = 0;
+	}
 
 	cs_writelock(__func__, &ea->ecmanswer_lock);
 
 	if((ea->status & REQUEST_ANSWERED))
 	{
+		cs_log_dbg(D_READER, "myecm:--- ecm_answer.answered");
 		cs_log_dbg(D_READER, "Reader %s already answer, skip this ecm answer!", reader ? reader->label : "-");
 		cs_writeunlock(__func__, &ea->ecmanswer_lock);
 		return 0;
Index: oscam-files.c
===================================================================
--- oscam-files.c	(revision 1587)
+++ oscam-files.c	(working copy)
@@ -31,8 +31,12 @@
 		{ strcat(cs_tmpdir, "/"); }
 	strcat(cs_tmpdir, "_oscam");
 #else
+#if defined(WITH_HISILICON)
+	cs_strncpy(cs_tmpdir, "/var", sizeof(cs_tmpdir));
+#else
 	cs_strncpy(cs_tmpdir, "/tmp/.oscam", sizeof(cs_tmpdir));
 #endif
+#endif
 	mkdir(cs_tmpdir, S_IRWXU);
 	return cs_tmpdir;
 }
Index: oscam.c
===================================================================
--- oscam.c	(revision 1587)
+++ oscam.c	(working copy)
@@ -15,6 +15,9 @@
 #include "module-dvbapi-azbox.h"
 #include "module-dvbapi-mca.h"
 #include "module-dvbapi-chancache.h"
+#if defined(WITH_HISILICON)
+#include "module-dvbapi-his.h"
+#endif
 #include "module-gbox-sms.h"
 #include "module-ird-guess.h"
 #include "module-lcd.h"
@@ -165,8 +168,12 @@
 #if defined(__CYGWIN__)
 	printf("                         . Default: (OS-TMP)\n");
 #else
+#if defined(WITH_HISILICON)
+	printf("                         . Default: /var/.oscam\n");
+#else
 	printf("                         . Default: /tmp/.oscam\n");
 #endif
+#endif
 	printf("\n Startup:\n");
 #if defined(WITH_STAPI) || defined(WITH_STAPI5)
 	printf(" -f, --foreground        | Start in the foreground mode.\n");
@@ -414,6 +421,7 @@
 		write_conf(WITH_COOLAPI2, "DVB API with COOLAPI2 support");
 		write_conf(WITH_STAPI, "DVB API with STAPI support");
 		write_conf(WITH_STAPI5, "DVB API with STAPI5 support");
+		write_conf(WITH_HISILICON, "DVB API with HISKY support");
 		write_conf(WITH_NEUTRINO, "DVB API with NEUTRINO support");
 		write_conf(READ_SDT_CHARSETS, "DVB API read-sdt charsets");
 	}
@@ -646,6 +654,18 @@
 	fprintf(fp, "FATAL: Signal %d: %s Fault. Logged StackTrace:\n\n", sig, (sig == SIGSEGV) ? "Segmentation" : ((sig == SIGBUS) ? "Bus" : "Unknown"));
 	fclose(fp);
 
+#if defined(WITH_HISILICON)
+	FILE *cmd = fopen("/var/gdbcmd", "w");
+	fputs ("bt\n", cmd);
+	fputs ("thread apply all bt\n", cmd);
+	fclose(cmd);
+
+	snprintf(buf, sizeof(buf) - 1, "gdb %s %d -batch -x /var/gdbcmd >> oscam.crash", prog_name, getpid());
+	if (system(buf) == -1)
+		{ fprintf(stderr, "Fatal error on trying to start gdb process."); }
+
+	exit(-1);
+#else
 	FILE *cmd = fopen("/tmp/gdbcmd", "w");
 	fputs("bt\n", cmd);
 	fputs("thread apply all bt\n", cmd);
@@ -656,6 +676,7 @@
 		{ fprintf(stderr, "Fatal error on trying to start gdb process."); }
 
 	exit(-1);
+#endif
 }
 
 
@@ -823,6 +844,17 @@
 
 static void init_machine_info(void)
 {
+#if defined(WITH_HISILICON)
+		stb_boxtype = cs_strdup("HiSilicon");
+	#if defined(SDKV600)
+		stb_boxname = cs_strdup("quads");
+	#elif defined(SDKV500)
+		stb_boxname = cs_strdup("u4plus");
+	#else
+		stb_boxname = cs_strdup("u4");
+	#endif
+	cs_log("%s (%s)", stb_boxtype, stb_boxname);
+#endif
 	struct utsname buffer;
 	if (uname(&buffer) == 0)
 	{
