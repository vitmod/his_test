Index: Makefile
===================================================================
--- Makefile	(revision 1542)
+++ Makefile	(working copy)
@@ -35,8 +35,14 @@
 	override USE_LIBCRYPTO=1
 endif
 
-CONF_DIR = /usr/local/etc
+# sky
+# CONF_DIR = /usr/local/etc
+# CONF_DIR = /data/oscam
+# CONF_DIR = /sdcard/Android/data/org.xbmc.xbmc/files/.xbmc/userdata/Oscam
+CONF_DIR	  = /data/oscam
 
+#CONF_DIR = /usr/local/etc
+
 LIB_PTHREAD = -lpthread
 LIB_DL = -ldl
 
@@ -56,14 +62,19 @@
 
 # Compiler warnings
 CC_WARN = -W -Wall -Wshadow -Wredundant-decls -Wstrict-prototypes -Wold-style-definition
-
+# sky(n, -Wno-unused-but-set-variable)
+CC_WARN+= -Wno-unused-function -Wno-unused-parameter
 # Compiler optimizations
 CC_OPTS = -O2 -ggdb -pipe -ffunction-sections -fdata-sections
+# sky(PIE)
+CC_OPTS = -fPIE
 
 CC = $(CROSS_DIR)$(CROSS)gcc
 STRIP = $(CROSS_DIR)$(CROSS)strip
 
 LDFLAGS = -Wl,--gc-sections
+# sky(PIE)
+LDFLAGS = -fPIE -pie
 
 TARGETHELP := $(shell $(CC) --target-help 2>&1)
 ifneq (,$(findstring sse2,$(TARGETHELP)))
@@ -104,6 +115,10 @@
 DEFAULT_COOLAPI2_LIB = -llnxUKAL -llnxcssUsr -llnxscsUsr -llnxnotifyqUsr -llnxplatUsr -lrt
 DEFAULT_SU980_LIB = -lentropic -lrt
 DEFAULT_AZBOX_LIB = -Lextapi/openxcas -lOpenXCASAPI
+# sky(n)
+DEFAULT_HISKY_LIB = $(HISKY_LIB)
+DEFAULT_HISKY_FLAGS = $(HISKY_FLAGS)
+
 DEFAULT_LIBCRYPTO_LIB = -lcrypto
 DEFAULT_SSL_LIB = -lssl
 ifeq ($(uname_S),Linux)
@@ -170,6 +185,7 @@
 $(eval $(call prepare_use_flags,COOLAPI2,coolapi2))
 $(eval $(call prepare_use_flags,SU980,su980))
 $(eval $(call prepare_use_flags,AZBOX,azbox))
+$(eval $(call prepare_use_flags,HISKY,his))
 $(eval $(call prepare_use_flags,MCA,mca))
 $(eval $(call prepare_use_flags,SSL,ssl))
 $(eval $(call prepare_use_flags,LIBCRYPTO,))
@@ -213,7 +229,8 @@
 # These variables will be used to select only needed files for compilation
 -include $(OBJDIR)/config.mak
 
-OSCAM_BIN := $(BINDIR)/oscam-$(VER)$(SVN_REV)-$(subst cygwin,cygwin.exe,$(TARGET))
+#OSCAM_BIN := $(BINDIR)/oscam-$(VER)$(SVN_REV)-$(subst cygwin,cygwin.exe,$(TARGET))
+OSCAM_BIN := $(BINDIR)/oscam-$(VER).$(SVN_REV)
 TESTS_BIN := tests.bin
 LIST_SMARGO_BIN := $(BINDIR)/list_smargo-$(VER)$(SVN_REV)-$(subst cygwin,cygwin.exe,$(TARGET))
 
@@ -242,12 +259,15 @@
 SRC-y += cscrypt/md5.c
 SRC-$(CONFIG_LIB_RC6) += cscrypt/rc6.c
 SRC-$(CONFIG_LIB_SHA1) += cscrypt/sha1.c
-
+# sky(n)
+SRC-$(CONFIG_WITH_HISILICON)  	  += cscrypt/aes_ctx.c
+SRC-$(CONFIG_WITH_HISILICON)  	  += cscrypt/des_ssl.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/atr.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/icc_async.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/io_serial.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/protocol_t0.c
 SRC-$(CONFIG_WITH_CARDREADER) += csctapi/protocol_t1.c
+SRC-$(CONFIG_CARDREADER_INTERNAL_HISKY) += csctapi/ifd_hisky.c
 SRC-$(CONFIG_CARDREADER_INTERNAL_AZBOX) += csctapi/ifd_azbox.c
 SRC-$(CONFIG_CARDREADER_INTERNAL_COOLAPI) += csctapi/ifd_cool.c
 SRC-$(CONFIG_CARDREADER_INTERNAL_COOLAPI2) += csctapi/ifd_cool.c
@@ -301,6 +321,7 @@
 SRC-$(CONFIG_WITH_SU980) += module-dvbapi-coolapi.c
 SRC-$(CONFIG_WITH_STAPI) += module-dvbapi-stapi.c
 SRC-$(CONFIG_WITH_STAPI5) += module-dvbapi-stapi5.c
+SRC-$(CONFIG_WITH_HISILICON) += module-dvbapi-his.c
 SRC-$(CONFIG_HAVE_DVBAPI) += module-dvbapi-chancache.c
 SRC-$(CONFIG_HAVE_DVBAPI) += module-dvbapi.c
 SRC-$(CONFIG_MODULE_GBOX) += module-gbox-helper.c
@@ -446,13 +467,15 @@
 
 -include $(subst .o,.d,$(OBJ))
 
-tests:
-	@-$(MAKE) --no-print-directory BUILD_TESTS=1 OSCAM_BIN=$(TESTS_BIN)
-	@-touch oscam.c
-# The above is really hideous hack :-) If we don't force oscam.c recompilation
-# after we've build the tests binary, the next "normal" compilation would fail
-# because there would be no run_tests() function. So the touch is there to
-# ensure oscam.c would be recompiled.
+TESTS_SRC += oscam-array.c
+TESTS_SRC += oscam-conf-mk.c
+TESTS_SRC += oscam-conf-chk.c
+TESTS_SRC += oscam-string.c
+TESTS_SRC += oscam-llist.c
+ 
+tests: Makefile globals.h $(subst .c,.h,$(TESTS_SRC)) $(TESTS_SRC) tests.c
+	$(SAY) "BUILD	$@"
+	$(Q)$(CC) $(STD_DEFS) $(CC_OPTS) $(CC_WARN) $(CFLAGS) $(LDFLAGS) $(TESTS_SRC) tests.c -o $@
 
 config:
 	$(SHELL) ./config.sh --gui
@@ -472,7 +495,7 @@
 	@-$(SHELL) ./config.sh --restore
 
 clean:
-	@-for FILE in $(BUILD_DIR)/* $(TESTS_BIN) $(TESTS_BIN).debug; do \
+	@-for FILE in $(BUILD_DIR)/* tests; do \
 		echo "RM	$$FILE"; \
 		rm -rf $$FILE; \
 	done
@@ -649,6 +672,14 @@
                      In order for USE_SU980 to work you have to have libentropic.a\n\
                      library in your cross compilation toolchain.\n\
 \n\
+   USE_HISKY=1    - Request support for HISKY (android)\n\
+                    box. The variables that control the build are:\n\
+                     HISKY_FLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_CFLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_LDFLAGS='$(DEFAULT_HISKY_FLAGS)'\n\
+                     HISKY_LIB='$(DEFAULT_HISKY_LIB)'\n\
+                     Using USE_HISKY=1 adds to '-hisky' to PLUS_TARGET.\n\
+\n\
    USE_AZBOX=1    - Request support for AZBOX (openxcas)\n\
                     box. The variables that control the build are:\n\
                          AZBOX_FLAGS='$(DEFAULT_AZBOX_FLAGS)'\n\
@@ -772,7 +803,7 @@
     make static-ssl    - Builds OSCam with SSL support linked statically\n\
 \n\
  Developer targets:\n\
-    make tests         - Builds '$(TESTS_BIN)' binary\n\
+    make tests         - Builds 'tests' binary\n\
 \n\
  Examples:\n\
    Build OSCam for SH4 (the compilers are in the path):\n\
@@ -789,6 +820,8 @@
      make CROSS=arm-cx2450x-linux-gnueabi- USE_COOLAPI=1\n\n\
    Build OSCam for ARM with COOLAPI2 (coolstream aka NeutrinoHD):\n\
      make CROSS=arm-pnx8400-linux-uclibcgnueabi- USE_COOLAPI2=1\n\n\
+   Build OSCam for ARM ANDROID with HISKY support:\n\
+     make CROSS=arm-linux-android- USE_HISKY=1\n\n\
    Build OSCam for MIPSEL with AZBOX support:\n\
      make CROSS=mipsel-linux-uclibc- USE_AZBOX=1\n\n\
    Build OSCam for ARM with MCA support:\n\
Index: Makefile.extra
===================================================================
--- Makefile.extra	(revision 1542)
+++ Makefile.extra	(working copy)
@@ -294,6 +294,14 @@
 		CROSS=arm-linux-androideabi- \
 		$(MAKEFLAGS)
 
+android-arm-hisky:
+	$(MAKE) --no-print-directory \
+		LIB_RT= \
+		LIB_PTHREAD= \
+		CROSS=arm-linux-androideabi- \
+		USE_HISKY=1 \
+		$(MAKEFLAGS)
+
 uclinux:
 	$(MAKE) --no-print-directory \
 		LIB_DL= STRIP=true \
Index: config.h
===================================================================
--- config.h	(revision 1542)
+++ config.h	(working copy)
@@ -12,7 +12,7 @@
 #endif
 //#define WITH_NEUTRINO 1
 #define READ_SDT_CHARSETS 1
-#define CLOCKFIX 1
+//#define CLOCKFIX 1
 #define IRDETO_GUESSING 1
 #define CS_ANTICASC 1
 #define WITH_DEBUG 1
@@ -56,14 +56,14 @@
 #define READER_GRIFFIN 1
 #define READER_DGCRYPT 1
 
-#define CARDREADER_PHOENIX 1
+//#define CARDREADER_PHOENIX 1
 #define CARDREADER_INTERNAL 1
-#define CARDREADER_MP35 1
-#define CARDREADER_SC8IN1 1
-#define CARDREADER_SMARGO 1
-#define CARDREADER_DB2COM 1
-#define CARDREADER_STINGER 1
-#define CARDREADER_DRECAS 1
+//#define CARDREADER_MP35 1
+//#define CARDREADER_SC8IN1 1
+//#define CARDREADER_SMARGO 1
+//#define CARDREADER_DB2COM 1
+//#define CARDREADER_STINGER 1
+//#define CARDREADER_DRECAS 1
 
 #ifdef WITH_PCSC
 #define CARDREADER_PCSC 1
@@ -73,9 +73,11 @@
 #define CARDREADER_SMART 1
 #endif
 
-// CARDREADER_INTERNAL_{AZBOX,COOLAPI,SCI} are internal variables
+// CARDREADER_INTERNAL_{HISKY,AZBOX,COOLAPI,SCI} are internal variables
 // do not touch them
-#if (defined(CARDREADER_INTERNAL) && defined(WITH_AZBOX))
+#if (defined(CARDREADER_INTERNAL) && defined(WITH_HISILICON))
+#define CARDREADER_INTERNAL_HISKY 	1
+#elif (defined(CARDREADER_INTERNAL) && defined(WITH_AZBOX))
 #define CARDREADER_INTERNAL_AZBOX 1
 #elif (defined(CARDREADER_INTERNAL) && (defined(WITH_COOLAPI) || defined(WITH_SU980)))
 #define CARDREADER_INTERNAL_COOLAPI 1
@@ -86,11 +88,11 @@
 #endif
 
 #ifdef WITH_STAPI
-#define CARDREADER_STAPI 1
+//#define CARDREADER_STAPI 1
 #endif
 
 #ifdef WITH_STAPI5
-#define CARDREADER_STAPI5 1
+//#define CARDREADER_STAPI5 1
 #endif
 
 #ifdef READER_DRE
Index: config.sh
===================================================================
--- config.sh	(revision 1542)
+++ config.sh	(working copy)
@@ -311,6 +311,7 @@
 	have_flag USE_COOLAPI && echo "CONFIG_WITH_COOLAPI=y" || echo "# CONFIG_WITH_COOLAPI=n"
 	have_flag USE_COOLAPI2 && echo "CONFIG_WITH_COOLAPI2=y" || echo "# CONFIG_WITH_COOLAPI2=n"
 	have_flag USE_SU980 && echo "CONFIG_WITH_SU980=y" || echo "# CONFIG_WITH_SU980=n"
+	have_flag USE_HISKY && echo "CONFIG_WITH_HISILICON=y" || echo "# CONFIG_WITH_HISILICON=n"
 	have_flag USE_AZBOX && echo "CONFIG_WITH_AZBOX=y" || echo "# CONFIG_WITH_AZBOX=n"
 	have_flag USE_MCA && echo "CONFIG_WITH_MCA=y" || echo "# CONFIG_WITH_MCA=n"
 	have_flag USE_LIBCRYPTO && echo "CONFIG_WITH_LIBCRYPTO=y" || echo "# CONFIG_WITH_LIBCRYPTO=n"
@@ -323,10 +324,11 @@
 		if [ $OPT = CARDREADER_INTERNAL ]
 		then
 			# Internal card reader is actually three different readers depending on USE flags
+			enabled $OPT && have_flag USE_HISKY && echo "CONFIG_${OPT}_HISKY=y" || echo "# CONFIG_${OPT}_HISKY=n"
 			enabled $OPT && have_flag USE_AZBOX && echo "CONFIG_${OPT}_AZBOX=y" || echo "# CONFIG_${OPT}_AZBOX=n"
 			enabled $OPT && have_any_flags USE_COOLAPI USE_SU980 && echo "CONFIG_${OPT}_COOLAPI=y" || echo "# CONFIG_${OPT}_COOLAPI=n"
 			enabled $OPT && have_flag USE_COOLAPI2 && echo "CONFIG_${OPT}_COOLAPI2=y" || echo "# CONFIG_${OPT}_COOLAPI2=n"
-			enabled $OPT && not_have_all_flags USE_AZBOX USE_COOLAPI USE_COOLAPI2 USE_SU980 && echo "CONFIG_${OPT}_SCI=y" || echo "# CONFIG_${OPT}_SCI=n"
+			enabled $OPT && not_have_all_flags USE_HISKY USE_AZBOX USE_COOLAPI USE_COOLAPI2 USE_SU980 && echo "CONFIG_${OPT}_SCI=y" || echo "# CONFIG_${OPT}_SCI=n"
 			continue
 		fi
 		if [ $OPT = CARDREADER_STAPI ]
@@ -525,7 +527,7 @@
 menu_card_readers() {
 	${DIALOG} --checklist "\nChoose card reader drivers:\n " $height $width $listheight \
 		CARDREADER_PHOENIX	"Phoenix/mouse"					$(check_test "CARDREADER_PHOENIX") \
-		CARDREADER_INTERNAL	"Internal (Sci,Azbox,Cool)"		$(check_test "CARDREADER_INTERNAL") \
+		CARDREADER_INTERNAL	"Internal (Hisky,Sci,Azbox,Cool)"		$(check_test "CARDREADER_INTERNAL") \
 		CARDREADER_SC8IN1	"SC8in1"						$(check_test "CARDREADER_SC8IN1") \
 		CARDREADER_MP35		"AD-Teknik MP 3.6/USB Phoenix"	$(check_test "CARDREADER_MP35") \
 		CARDREADER_SMARGO	"Argolis Smargo Smartreader"	$(check_test "CARDREADER_SMARGO") \
@@ -698,12 +700,7 @@
 		break
 	;;
 	'-r'|'--oscam-revision')
-		revision=`(svnversion -n . 2>/dev/null || printf 0) | sed 's/.*://; s/[^0-9]*$//; s/^$/0/'`
-		if [ "$revision" = "0" ] 
-		then
-			which git > /dev/null 2>&1 && revision=`git log -10 --pretty=%B | grep git-svn-id | head -n 1 | sed -n -e 's/^.*trunk@\([0-9]*\) .*$/\1/p'`
-		fi
-		echo $revision
+		echo "$OSCAM_VERSION_NUMBER"
 		break
 	;;
 	'-O'|'--detect-osx-sdk-version')
Index: cscrypt/aes_ctx.c
===================================================================
--- cscrypt/aes_ctx.c	(nonexistent)
+++ cscrypt/aes_ctx.c	(working copy)
@@ -0,0 +1,742 @@
+// sky(n)
+#if !defined(WITH_LIBCRYPTO)
+//FIXME Not checked on threadsafety yet; after checking please remove this line
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "aes_ctx.h"
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+// -- -AES -------------------------------------------------------------
+// uncomment the following line to use pre-computed tables
+// otherwise the tables will be generated at the first run
+
+#if !defined(AES_FIXED_TABLES)
+
+// forward S-box & tables
+static unsigned int FSb[256];
+static unsigned int FT0[256];
+static unsigned int FT1[256];
+static unsigned int FT2[256];
+static unsigned int FT3[256];
+
+// reverse S-box & tables
+static unsigned int RSb[256];
+static unsigned int RT0[256];
+static unsigned int RT1[256];
+static unsigned int RT2[256];
+static unsigned int RT3[256];
+
+// round constants
+static unsigned int RCON[10];
+
+// tables generation flag
+static int do_init = 1;
+
+// tables generation routine
+#define ROTR8(x)		(((x << 24) & 0xFFFFFFFF) | ((x & 0xFFFFFFFF) >>  8))
+#define XTIME(x)		 ((x <<  1) ^ ((x & 0x80) ? 0x1B : 0x00))
+#define AES_MUL(x,y)	 ((x &&  y) ? powK[(log[x] + logK[y]) % 255] : 0)
+
+void
+AES_gen_tables(void)
+{
+	int i;
+	unsigned char x, y, powK[256], logK[256];
+
+	/* compute pow and log tables over GF(2^8) */
+	for (i = 0, x = 1; i < 256; i++, x ^= XTIME(x))
+	{
+		powK[i] = x;
+		logK[x] = i;
+	}
+
+	/* calculate the round constants */
+	for (i = 0, x = 1; i < 10; i++, x = XTIME(x))
+		RCON[i] = (unsigned int) x << 24;
+
+	/* generate the forward and reverse S-boxes */
+	FSb[0x00] = 0x63;
+	RSb[0x63] = 0x00;
+
+	for (i = 1; i < 256; i++)
+	{
+		x = powK[255 - logK[i]];
+
+		y = x;	y = (y << 1) | (y >> 7);
+		x ^= y; y = (y << 1) | (y >> 7);
+		x ^= y; y = (y << 1) | (y >> 7);
+		x ^= y; y = (y << 1) | (y >> 7);
+		x ^= y ^ 0x63;
+
+		FSb[i] = x;
+		RSb[x] = i;
+	}
+
+	/* generate the forward and reverse tables */
+	for (i = 0; i < 256; i++)
+	{
+		x = (unsigned char) FSb[i]; y = XTIME(x);
+
+		FT0[i] =   (unsigned int) (x ^ y) ^
+				 ((unsigned int) x <<  8) ^
+				 ((unsigned int) x << 16) ^
+				 ((unsigned int) y << 24);
+
+		FT0[i] &= 0xFFFFFFFF;
+
+		FT1[i] = ROTR8(FT0[i]);
+		FT2[i] = ROTR8(FT1[i]);
+		FT3[i] = ROTR8(FT2[i]);
+
+		y = (unsigned char) RSb[i];
+
+		RT0[i] = ((unsigned int) AES_MUL(0x0B, y)	  ) ^
+				 ((unsigned int) AES_MUL(0x0D, y) <<  8) ^
+				 ((unsigned int) AES_MUL(0x09, y) << 16) ^
+				 ((unsigned int) AES_MUL(0x0E, y) << 24);
+
+		RT0[i] &= 0xFFFFFFFF;
+
+		RT1[i] = ROTR8(RT0[i]);
+		RT2[i] = ROTR8(RT1[i]);
+		RT3[i] = ROTR8(RT2[i]);
+	}
+}
+#else
+
+/* forward S-box */
+
+static const unsigned int FSb[256] =
+{
+	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
+	0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
+	0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
+	0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
+	0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
+	0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
+	0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
+	0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
+	0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
+	0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
+	0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
+	0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
+	0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
+	0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
+	0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
+	0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
+	0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+};
+
+/* forward tables */
+
+#define FT \
+\
+	V(C6,63,63,A5), V(F8,7C,7C,84), V(EE,77,77,99), V(F6,7B,7B,8D), \
+	V(FF,F2,F2,0D), V(D6,6B,6B,BD), V(DE,6F,6F,B1), V(91,C5,C5,54), \
+	V(60,30,30,50), V(02,01,01,03), V(CE,67,67,A9), V(56,2B,2B,7D), \
+	V(E7,FE,FE,19), V(B5,D7,D7,62), V(4D,AB,AB,E6), V(EC,76,76,9A), \
+	V(8F,CA,CA,45), V(1F,82,82,9D), V(89,C9,C9,40), V(FA,7D,7D,87), \
+	V(EF,FA,FA,15), V(B2,59,59,EB), V(8E,47,47,C9), V(FB,F0,F0,0B), \
+	V(41,AD,AD,EC), V(B3,D4,D4,67), V(5F,A2,A2,FD), V(45,AF,AF,EA), \
+	V(23,9C,9C,BF), V(53,A4,A4,F7), V(E4,72,72,96), V(9B,C0,C0,5B), \
+	V(75,B7,B7,C2), V(E1,FD,FD,1C), V(3D,93,93,AE), V(4C,26,26,6A), \
+	V(6C,36,36,5A), V(7E,3F,3F,41), V(F5,F7,F7,02), V(83,CC,CC,4F), \
+	V(68,34,34,5C), V(51,A5,A5,F4), V(D1,E5,E5,34), V(F9,F1,F1,08), \
+	V(E2,71,71,93), V(AB,D8,D8,73), V(62,31,31,53), V(2A,15,15,3F), \
+	V(08,04,04,0C), V(95,C7,C7,52), V(46,23,23,65), V(9D,C3,C3,5E), \
+	V(30,18,18,28), V(37,96,96,A1), V(0A,05,05,0F), V(2F,9A,9A,B5), \
+	V(0E,07,07,09), V(24,12,12,36), V(1B,80,80,9B), V(DF,E2,E2,3D), \
+	V(CD,EB,EB,26), V(4E,27,27,69), V(7F,B2,B2,CD), V(EA,75,75,9F), \
+	V(12,09,09,1B), V(1D,83,83,9E), V(58,2C,2C,74), V(34,1A,1A,2E), \
+	V(36,1B,1B,2D), V(DC,6E,6E,B2), V(B4,5A,5A,EE), V(5B,A0,A0,FB), \
+	V(A4,52,52,F6), V(76,3B,3B,4D), V(B7,D6,D6,61), V(7D,B3,B3,CE), \
+	V(52,29,29,7B), V(DD,E3,E3,3E), V(5E,2F,2F,71), V(13,84,84,97), \
+	V(A6,53,53,F5), V(B9,D1,D1,68), V(00,00,00,00), V(C1,ED,ED,2C), \
+	V(40,20,20,60), V(E3,FC,FC,1F), V(79,B1,B1,C8), V(B6,5B,5B,ED), \
+	V(D4,6A,6A,BE), V(8D,CB,CB,46), V(67,BE,BE,D9), V(72,39,39,4B), \
+	V(94,4A,4A,DE), V(98,4C,4C,D4), V(B0,58,58,E8), V(85,CF,CF,4A), \
+	V(BB,D0,D0,6B), V(C5,EF,EF,2A), V(4F,AA,AA,E5), V(ED,FB,FB,16), \
+	V(86,43,43,C5), V(9A,4D,4D,D7), V(66,33,33,55), V(11,85,85,94), \
+	V(8A,45,45,CF), V(E9,F9,F9,10), V(04,02,02,06), V(FE,7F,7F,81), \
+	V(A0,50,50,F0), V(78,3C,3C,44), V(25,9F,9F,BA), V(4B,A8,A8,E3), \
+	V(A2,51,51,F3), V(5D,A3,A3,FE), V(80,40,40,C0), V(05,8F,8F,8A), \
+	V(3F,92,92,AD), V(21,9D,9D,BC), V(70,38,38,48), V(F1,F5,F5,04), \
+	V(63,BC,BC,DF), V(77,B6,B6,C1), V(AF,DA,DA,75), V(42,21,21,63), \
+	V(20,10,10,30), V(E5,FF,FF,1A), V(FD,F3,F3,0E), V(BF,D2,D2,6D), \
+	V(81,CD,CD,4C), V(18,0C,0C,14), V(26,13,13,35), V(C3,EC,EC,2F), \
+	V(BE,5F,5F,E1), V(35,97,97,A2), V(88,44,44,CC), V(2E,17,17,39), \
+	V(93,C4,C4,57), V(55,A7,A7,F2), V(FC,7E,7E,82), V(7A,3D,3D,47), \
+	V(C8,64,64,AC), V(BA,5D,5D,E7), V(32,19,19,2B), V(E6,73,73,95), \
+	V(C0,60,60,A0), V(19,81,81,98), V(9E,4F,4F,D1), V(A3,DC,DC,7F), \
+	V(44,22,22,66), V(54,2A,2A,7E), V(3B,90,90,AB), V(0B,88,88,83), \
+	V(8C,46,46,CA), V(C7,EE,EE,29), V(6B,B8,B8,D3), V(28,14,14,3C), \
+	V(A7,DE,DE,79), V(BC,5E,5E,E2), V(16,0B,0B,1D), V(AD,DB,DB,76), \
+	V(DB,E0,E0,3B), V(64,32,32,56), V(74,3A,3A,4E), V(14,0A,0A,1E), \
+	V(92,49,49,DB), V(0C,06,06,0A), V(48,24,24,6C), V(B8,5C,5C,E4), \
+	V(9F,C2,C2,5D), V(BD,D3,D3,6E), V(43,AC,AC,EF), V(C4,62,62,A6), \
+	V(39,91,91,A8), V(31,95,95,A4), V(D3,E4,E4,37), V(F2,79,79,8B), \
+	V(D5,E7,E7,32), V(8B,C8,C8,43), V(6E,37,37,59), V(DA,6D,6D,B7), \
+	V(01,8D,8D,8C), V(B1,D5,D5,64), V(9C,4E,4E,D2), V(49,A9,A9,E0), \
+	V(D8,6C,6C,B4), V(AC,56,56,FA), V(F3,F4,F4,07), V(CF,EA,EA,25), \
+	V(CA,65,65,AF), V(F4,7A,7A,8E), V(47,AE,AE,E9), V(10,08,08,18), \
+	V(6F,BA,BA,D5), V(F0,78,78,88), V(4A,25,25,6F), V(5C,2E,2E,72), \
+	V(38,1C,1C,24), V(57,A6,A6,F1), V(73,B4,B4,C7), V(97,C6,C6,51), \
+	V(CB,E8,E8,23), V(A1,DD,DD,7C), V(E8,74,74,9C), V(3E,1F,1F,21), \
+	V(96,4B,4B,DD), V(61,BD,BD,DC), V(0D,8B,8B,86), V(0F,8A,8A,85), \
+	V(E0,70,70,90), V(7C,3E,3E,42), V(71,B5,B5,C4), V(CC,66,66,AA), \
+	V(90,48,48,D8), V(06,03,03,05), V(F7,F6,F6,01), V(1C,0E,0E,12), \
+	V(C2,61,61,A3), V(6A,35,35,5F), V(AE,57,57,F9), V(69,B9,B9,D0), \
+	V(17,86,86,91), V(99,C1,C1,58), V(3A,1D,1D,27), V(27,9E,9E,B9), \
+	V(D9,E1,E1,38), V(EB,F8,F8,13), V(2B,98,98,B3), V(22,11,11,33), \
+	V(D2,69,69,BB), V(A9,D9,D9,70), V(07,8E,8E,89), V(33,94,94,A7), \
+	V(2D,9B,9B,B6), V(3C,1E,1E,22), V(15,87,87,92), V(C9,E9,E9,20), \
+	V(87,CE,CE,49), V(AA,55,55,FF), V(50,28,28,78), V(A5,DF,DF,7A), \
+	V(03,8C,8C,8F), V(59,A1,A1,F8), V(09,89,89,80), V(1A,0D,0D,17), \
+	V(65,BF,BF,DA), V(D7,E6,E6,31), V(84,42,42,C6), V(D0,68,68,B8), \
+	V(82,41,41,C3), V(29,99,99,B0), V(5A,2D,2D,77), V(1E,0F,0F,11), \
+	V(7B,B0,B0,CB), V(A8,54,54,FC), V(6D,BB,BB,D6), V(2C,16,16,3A)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static unsigned int FT0[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static unsigned int FT1[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static unsigned int FT2[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static unsigned int FT3[256] = { FT };
+#undef V
+
+#undef FT
+
+/* reverse S-box */
+
+static const unsigned int RSb[256] =
+{
+	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
+	0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
+	0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
+	0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
+	0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
+	0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
+	0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
+	0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
+	0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
+	0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
+	0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
+	0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
+	0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
+	0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
+	0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
+	0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
+	0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
+};
+
+/* reverse tables */
+
+#define RT \
+\
+	V(51,F4,A7,50), V(7E,41,65,53), V(1A,17,A4,C3), V(3A,27,5E,96), \
+	V(3B,AB,6B,CB), V(1F,9D,45,F1), V(AC,FA,58,AB), V(4B,E3,03,93), \
+	V(20,30,FA,55), V(AD,76,6D,F6), V(88,CC,76,91), V(F5,02,4C,25), \
+	V(4F,E5,D7,FC), V(C5,2A,CB,D7), V(26,35,44,80), V(B5,62,A3,8F), \
+	V(DE,B1,5A,49), V(25,BA,1B,67), V(45,EA,0E,98), V(5D,FE,C0,E1), \
+	V(C3,2F,75,02), V(81,4C,F0,12), V(8D,46,97,A3), V(6B,D3,F9,C6), \
+	V(03,8F,5F,E7), V(15,92,9C,95), V(BF,6D,7A,EB), V(95,52,59,DA), \
+	V(D4,BE,83,2D), V(58,74,21,D3), V(49,E0,69,29), V(8E,C9,C8,44), \
+	V(75,C2,89,6A), V(F4,8E,79,78), V(99,58,3E,6B), V(27,B9,71,DD), \
+	V(BE,E1,4F,B6), V(F0,88,AD,17), V(C9,20,AC,66), V(7D,CE,3A,B4), \
+	V(63,DF,4A,18), V(E5,1A,31,82), V(97,51,33,60), V(62,53,7F,45), \
+	V(B1,64,77,E0), V(BB,6B,AE,84), V(FE,81,A0,1C), V(F9,08,2B,94), \
+	V(70,48,68,58), V(8F,45,FD,19), V(94,DE,6C,87), V(52,7B,F8,B7), \
+	V(AB,73,D3,23), V(72,4B,02,E2), V(E3,1F,8F,57), V(66,55,AB,2A), \
+	V(B2,EB,28,07), V(2F,B5,C2,03), V(86,C5,7B,9A), V(D3,37,08,A5), \
+	V(30,28,87,F2), V(23,BF,A5,B2), V(02,03,6A,BA), V(ED,16,82,5C), \
+	V(8A,CF,1C,2B), V(A7,79,B4,92), V(F3,07,F2,F0), V(4E,69,E2,A1), \
+	V(65,DA,F4,CD), V(06,05,BE,D5), V(D1,34,62,1F), V(C4,A6,FE,8A), \
+	V(34,2E,53,9D), V(A2,F3,55,A0), V(05,8A,E1,32), V(A4,F6,EB,75), \
+	V(0B,83,EC,39), V(40,60,EF,AA), V(5E,71,9F,06), V(BD,6E,10,51), \
+	V(3E,21,8A,F9), V(96,DD,06,3D), V(DD,3E,05,AE), V(4D,E6,BD,46), \
+	V(91,54,8D,B5), V(71,C4,5D,05), V(04,06,D4,6F), V(60,50,15,FF), \
+	V(19,98,FB,24), V(D6,BD,E9,97), V(89,40,43,CC), V(67,D9,9E,77), \
+	V(B0,E8,42,BD), V(07,89,8B,88), V(E7,19,5B,38), V(79,C8,EE,DB), \
+	V(A1,7C,0A,47), V(7C,42,0F,E9), V(F8,84,1E,C9), V(00,00,00,00), \
+	V(09,80,86,83), V(32,2B,ED,48), V(1E,11,70,AC), V(6C,5A,72,4E), \
+	V(FD,0E,FF,FB), V(0F,85,38,56), V(3D,AE,D5,1E), V(36,2D,39,27), \
+	V(0A,0F,D9,64), V(68,5C,A6,21), V(9B,5B,54,D1), V(24,36,2E,3A), \
+	V(0C,0A,67,B1), V(93,57,E7,0F), V(B4,EE,96,D2), V(1B,9B,91,9E), \
+	V(80,C0,C5,4F), V(61,DC,20,A2), V(5A,77,4B,69), V(1C,12,1A,16), \
+	V(E2,93,BA,0A), V(C0,A0,2A,E5), V(3C,22,E0,43), V(12,1B,17,1D), \
+	V(0E,09,0D,0B), V(F2,8B,C7,AD), V(2D,B6,A8,B9), V(14,1E,A9,C8), \
+	V(57,F1,19,85), V(AF,75,07,4C), V(EE,99,DD,BB), V(A3,7F,60,FD), \
+	V(F7,01,26,9F), V(5C,72,F5,BC), V(44,66,3B,C5), V(5B,FB,7E,34), \
+	V(8B,43,29,76), V(CB,23,C6,DC), V(B6,ED,FC,68), V(B8,E4,F1,63), \
+	V(D7,31,DC,CA), V(42,63,85,10), V(13,97,22,40), V(84,C6,11,20), \
+	V(85,4A,24,7D), V(D2,BB,3D,F8), V(AE,F9,32,11), V(C7,29,A1,6D), \
+	V(1D,9E,2F,4B), V(DC,B2,30,F3), V(0D,86,52,EC), V(77,C1,E3,D0), \
+	V(2B,B3,16,6C), V(A9,70,B9,99), V(11,94,48,FA), V(47,E9,64,22), \
+	V(A8,FC,8C,C4), V(A0,F0,3F,1A), V(56,7D,2C,D8), V(22,33,90,EF), \
+	V(87,49,4E,C7), V(D9,38,D1,C1), V(8C,CA,A2,FE), V(98,D4,0B,36), \
+	V(A6,F5,81,CF), V(A5,7A,DE,28), V(DA,B7,8E,26), V(3F,AD,BF,A4), \
+	V(2C,3A,9D,E4), V(50,78,92,0D), V(6A,5F,CC,9B), V(54,7E,46,62), \
+	V(F6,8D,13,C2), V(90,D8,B8,E8), V(2E,39,F7,5E), V(82,C3,AF,F5), \
+	V(9F,5D,80,BE), V(69,D0,93,7C), V(6F,D5,2D,A9), V(CF,25,12,B3), \
+	V(C8,AC,99,3B), V(10,18,7D,A7), V(E8,9C,63,6E), V(DB,3B,BB,7B), \
+	V(CD,26,78,09), V(6E,59,18,F4), V(EC,9A,B7,01), V(83,4F,9A,A8), \
+	V(E6,95,6E,65), V(AA,FF,E6,7E), V(21,BC,CF,08), V(EF,15,E8,E6), \
+	V(BA,E7,9B,D9), V(4A,6F,36,CE), V(EA,9F,09,D4), V(29,B0,7C,D6), \
+	V(31,A4,B2,AF), V(2A,3F,23,31), V(C6,A5,94,30), V(35,A2,66,C0), \
+	V(74,4E,BC,37), V(FC,82,CA,A6), V(E0,90,D0,B0), V(33,A7,D8,15), \
+	V(F1,04,98,4A), V(41,EC,DA,F7), V(7F,CD,50,0E), V(17,91,F6,2F), \
+	V(76,4D,D6,8D), V(43,EF,B0,4D), V(CC,AA,4D,54), V(E4,96,04,DF), \
+	V(9E,D1,B5,E3), V(4C,6A,88,1B), V(C1,2C,1F,B8), V(46,65,51,7F), \
+	V(9D,5E,EA,04), V(01,8C,35,5D), V(FA,87,74,73), V(FB,0B,41,2E), \
+	V(B3,67,1D,5A), V(92,DB,D2,52), V(E9,10,56,33), V(6D,D6,47,13), \
+	V(9A,D7,61,8C), V(37,A1,0C,7A), V(59,F8,14,8E), V(EB,13,3C,89), \
+	V(CE,A9,27,EE), V(B7,61,C9,35), V(E1,1C,E5,ED), V(7A,47,B1,3C), \
+	V(9C,D2,DF,59), V(55,F2,73,3F), V(18,14,CE,79), V(73,C7,37,BF), \
+	V(53,F7,CD,EA), V(5F,FD,AA,5B), V(DF,3D,6F,14), V(78,44,DB,86), \
+	V(CA,AF,F3,81), V(B9,68,C4,3E), V(38,24,34,2C), V(C2,A3,40,5F), \
+	V(16,1D,C3,72), V(BC,E2,25,0C), V(28,3C,49,8B), V(FF,0D,95,41), \
+	V(39,A8,01,71), V(08,0C,B3,DE), V(D8,B4,E4,9C), V(64,56,C1,90), \
+	V(7B,CB,84,61), V(D5,32,B6,70), V(48,6C,5C,74), V(D0,B8,57,42)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static unsigned int RT0[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static unsigned int RT1[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static unsigned int RT2[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static unsigned int RT3[256] = { RT };
+#undef V
+
+#undef RT
+
+/* round constants */
+
+static const unsigned int RCON[10] =
+{
+	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+	0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	0x1B000000, 0x36000000
+};
+
+int do_init = 0;
+
+void
+AES_gen_tables(void)
+{
+}
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/* platform-independant 32-bit integer manipulation macros */
+#define GET_UINT32(n,b,i) {				   \
+	(n) = ((unsigned int) (b)[(i)	] << 24)	   \
+		| ((unsigned int) (b)[(i) + 1] << 16)	   \
+		| ((unsigned int) (b)[(i) + 2] <<  8)	   \
+		| ((unsigned int) (b)[(i) + 3]	   );	   \
+}
+
+#define PUT_UINT32(n,b,i) {				   \
+	(b)[(i)    ] = (unsigned char) ((n) >> 24);	   \
+	(b)[(i) + 1] = (unsigned char) ((n) >> 16);	   \
+	(b)[(i) + 2] = (unsigned char) ((n) >>  8);	   \
+	(b)[(i) + 3] = (unsigned char) ((n)	  );	   \
+}
+
+// decryption key schedule tables
+static int KT_init = 1;
+static unsigned int KT0[256];
+static unsigned int KT1[256];
+static unsigned int KT2[256];
+static unsigned int KT3[256];
+/* AES key scheduling routine */
+static int
+x_AES_CTX_Set_key(AES_CTX_t *ctx, unsigned char *key, int nbits)
+{
+	int i;
+	unsigned int *RK, *SK;
+
+
+	if (do_init)
+	{
+		AES_gen_tables();
+		do_init = 0;
+	}
+
+	switch (nbits)
+	{
+		case 128: ctx->nr = 10; break;
+		case 192: ctx->nr = 12; break;
+		case 256: ctx->nr = 14; break;
+		default : return(1);
+	}
+
+	RK = ctx->erk;
+
+	for (i = 0; i < (nbits >> 5); i++) GET_UINT32(RK[i], key, i * 4);
+
+	/* setup encryption round keys */
+	switch (nbits)
+	{
+	case 128:
+		for (i = 0; i < 10; i++, RK += 4)
+		{
+			RK[4]  = RK[0] ^ RCON[i] ^
+						(FSb[ (unsigned char) (RK[3] >> 16) ] << 24) ^
+						(FSb[ (unsigned char) (RK[3] >>  8) ] << 16) ^
+						(FSb[ (unsigned char) (RK[3]	   ) ] <<  8) ^
+						(FSb[ (unsigned char) (RK[3] >> 24) ]		);
+
+			RK[5]  = RK[1] ^ RK[4];
+			RK[6]  = RK[2] ^ RK[5];
+			RK[7]  = RK[3] ^ RK[6];
+		}
+		break;
+
+	case 192:
+		for (i = 0; i < 8; i++, RK += 6)
+		{
+			RK[6]  = RK[0] ^ RCON[i] ^
+						(FSb[ (unsigned char) (RK[5] >> 16) ] << 24) ^
+						(FSb[ (unsigned char) (RK[5] >>  8) ] << 16) ^
+						(FSb[ (unsigned char) (RK[5]	   ) ] <<  8) ^
+						(FSb[ (unsigned char) (RK[5] >> 24) ]		);
+
+			RK[7]  = RK[1] ^ RK[6];
+			RK[8]  = RK[2] ^ RK[7];
+			RK[9]  = RK[3] ^ RK[8];
+			RK[10] = RK[4] ^ RK[9];
+			RK[11] = RK[5] ^ RK[10];
+		}
+		break;
+
+	case 256:
+		for (i = 0; i < 7; i++, RK += 8)
+		{
+			RK[8]  = RK[0] ^ RCON[i] ^
+						(FSb[ (unsigned char) (RK[7] >> 16) ] << 24) ^
+						(FSb[ (unsigned char) (RK[7] >>  8) ] << 16) ^
+						(FSb[ (unsigned char) (RK[7]	   ) ] <<  8) ^
+						(FSb[ (unsigned char) (RK[7] >> 24) ]		);
+
+			RK[9]  = RK[1] ^ RK[8];
+			RK[10] = RK[2] ^ RK[9];
+			RK[11] = RK[3] ^ RK[10];
+
+			RK[12] = RK[4] ^
+						(FSb[ (unsigned char) (RK[11] >> 24) ] << 24) ^
+						(FSb[ (unsigned char) (RK[11] >> 16) ] << 16) ^
+						(FSb[ (unsigned char) (RK[11] >>  8) ] <<	8) ^
+						(FSb[ (unsigned char) (RK[11]		) ] 	 );
+
+			RK[13] = RK[5] ^ RK[12];
+			RK[14] = RK[6] ^ RK[13];
+			RK[15] = RK[7] ^ RK[14];
+		}
+		break;
+	}
+
+	/* setup decryption round keys */
+	if (KT_init)
+	{
+		unsigned int	fsb;
+
+		for (i = 0; i < 256; i++)
+		{
+			fsb = FSb[i];
+			KT0[i] = RT0[ fsb ];
+			KT1[i] = RT1[ fsb ];
+			KT2[i] = RT2[ fsb ];
+			KT3[i] = RT3[ fsb ];
+		}
+		KT_init = 0;
+	}
+
+	SK = ctx->drk;
+
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+
+	for (i = 1; i < ctx->nr; i++)
+	{
+		RK -= 8;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+
+		*SK++ = KT0[ (unsigned char) (*RK >> 24) ] ^
+				KT1[ (unsigned char) (*RK >> 16) ] ^
+				KT2[ (unsigned char) (*RK >>  8) ] ^
+				KT3[ (unsigned char) (*RK		) ]; RK++;
+	}
+
+	RK -= 8;
+
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+	*SK++ = *RK++;
+
+	return(0);
+}
+
+// AES 128-bit block encryption routine
+void
+AES_CTX_Encrypt(AES_CTX_t *ctx, unsigned char *input, unsigned char *output)
+{
+	unsigned int *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+	RK = ctx->erk;
+
+	GET_UINT32(X0, input,  0); X0 ^= RK[0];
+	GET_UINT32(X1, input,  4); X1 ^= RK[1];
+	GET_UINT32(X2, input,  8); X2 ^= RK[2];
+	GET_UINT32(X3, input, 12); X3 ^= RK[3];
+
+#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3) 	\
+{												\
+	RK += 4;									\
+												\
+	X0 = RK[0] ^ FT0[ (unsigned char) (Y0 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y1 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y2 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y3		) ];   \
+												\
+	X1 = RK[1] ^ FT0[ (unsigned char) (Y1 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y2 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y3 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y0		) ];   \
+												\
+	X2 = RK[2] ^ FT0[ (unsigned char) (Y2 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y3 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y0 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y1		) ];   \
+												\
+	X3 = RK[3] ^ FT0[ (unsigned char) (Y3 >> 24) ] ^  \
+				 FT1[ (unsigned char) (Y0 >> 16) ] ^  \
+				 FT2[ (unsigned char) (Y1 >>  8) ] ^  \
+				 FT3[ (unsigned char) (Y2		) ];   \
+}
+
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+
+    if ( ctx->nr > 10 )
+    {
+        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    }
+
+    if ( ctx->nr > 12 )
+    {
+        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
+        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
+    }
+
+	/* last round */
+	RK += 4;
+
+	X0 = RK[0] ^ (FSb[ (unsigned char) (Y0 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y1 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y2 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y3 	 ) ]	  );
+
+	X1 = RK[1] ^ (FSb[ (unsigned char) (Y1 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y2 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y3 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y0 	 ) ]	  );
+
+	X2 = RK[2] ^ (FSb[ (unsigned char) (Y2 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y3 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y0 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y1 	 ) ]	  );
+
+	X3 = RK[3] ^ (FSb[ (unsigned char) (Y3 >> 24) ] << 24) ^
+				 (FSb[ (unsigned char) (Y0 >> 16) ] << 16) ^
+				 (FSb[ (unsigned char) (Y1 >>	8) ] <<  8) ^
+				 (FSb[ (unsigned char) (Y2 	 ) ]	  );
+
+	PUT_UINT32(X0, output,	0);
+	PUT_UINT32(X1, output,	4);
+	PUT_UINT32(X2, output,	8);
+	PUT_UINT32(X3, output, 12);
+}
+
+/* AES 128-bit block decryption routine */
+void
+AES_CTX_Decrypt(AES_CTX_t *ctx, unsigned char *input, unsigned char *output)
+{
+	unsigned int *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+	RK = ctx->drk;
+
+	GET_UINT32(X0, input,  0); X0 ^= RK[0];
+	GET_UINT32(X1, input,  4); X1 ^= RK[1];
+	GET_UINT32(X2, input,  8); X2 ^= RK[2];
+	GET_UINT32(X3, input, 12); X3 ^= RK[3];
+
+#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3) 	\
+{												\
+	RK += 4;									\
+												\
+	X0 = RK[0] ^ RT0[ (unsigned char) (Y0 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y3 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y2 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y1		) ];   \
+												\
+	X1 = RK[1] ^ RT0[ (unsigned char) (Y1 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y0 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y3 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y2		) ];   \
+												\
+	X2 = RK[2] ^ RT0[ (unsigned char) (Y2 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y1 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y0 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y3		) ];   \
+												\
+	X3 = RK[3] ^ RT0[ (unsigned char) (Y3 >> 24) ] ^  \
+				 RT1[ (unsigned char) (Y2 >> 16) ] ^  \
+				 RT2[ (unsigned char) (Y1 >>  8) ] ^  \
+				 RT3[ (unsigned char) (Y0		) ];   \
+}
+
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 1 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 2 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 3 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 4 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 5 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 6 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 7 */
+	AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3); 	  /* round 8 */
+	AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3); 	  /* round 9 */
+
+	if (ctx->nr > 10)
+	{
+		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);   /* round 10 */
+		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);   /* round 11 */
+	}
+
+	if (ctx->nr > 12)
+	{
+		AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);   /* round 12 */
+		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);   /* round 13 */
+	}
+
+	/* last round */
+	RK += 4;
+
+	X0 = RK[0] ^ (RSb[ (unsigned char) (Y0 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y3 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y2 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y1 	 ) ]	  );
+
+	X1 = RK[1] ^ (RSb[ (unsigned char) (Y1 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y0 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y3 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y2 	 ) ]	  );
+
+	X2 = RK[2] ^ (RSb[ (unsigned char) (Y2 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y1 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y0 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y3 	 ) ]	  );
+
+	X3 = RK[3] ^ (RSb[ (unsigned char) (Y3 >> 24) ] << 24) ^
+				 (RSb[ (unsigned char) (Y2 >> 16) ] << 16) ^
+				 (RSb[ (unsigned char) (Y1 >>	8) ] <<  8) ^
+				 (RSb[ (unsigned char) (Y0 	 ) ]	  );
+
+	PUT_UINT32(X0, output,	0);
+	PUT_UINT32(X1, output,	4);
+	PUT_UINT32(X2, output,	8);
+	PUT_UINT32(X3, output, 12);
+}
+
+
+void
+AES_CTX_SetKey(AES_CTX_t *ctx_p, unsigned char *key)
+{
+	x_AES_CTX_Set_key(ctx_p, key, 128);
+}
+
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#endif	// #if !defined(WITH_LIBCRYPTO)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
Index: cscrypt/aes_ctx.h
===================================================================
--- cscrypt/aes_ctx.h	(nonexistent)
+++ cscrypt/aes_ctx.h	(working copy)
@@ -0,0 +1,19 @@
+// sky(n)
+#ifndef __AES_CTX_H
+#define __AES_CTX_H
+#if !defined(WITH_LIBCRYPTO)
+#define AES_FIXED_TABLES
+
+typedef struct
+{
+	unsigned int 	erk[64];	 /* encryption round keys */
+	unsigned int 	drk[64];	 /* decryption round keys */
+	unsigned char  	nr; 		 /* number of rounds	  */
+} AES_CTX_t;
+
+void	AES_CTX_SetKey	(AES_CTX_t *ctx_p, unsigned char *Aeskey_p);
+void	AES_CTX_Decrypt	(AES_CTX_t *ctx_p, unsigned char *In_p, unsigned char *Out_p);
+void	AES_CTX_Encrypt	(AES_CTX_t *ctx_p, unsigned char *In_p, unsigned char *Out_p);
+#endif	// #if !defined(WITH_LIBCRYPTO)
+#endif	// #ifndef __AES_CTX_H
+
Index: cscrypt/des_ssl.c
===================================================================
--- cscrypt/des_ssl.c	(nonexistent)
+++ cscrypt/des_ssl.c	(working copy)
@@ -0,0 +1,1440 @@
+// sky(n)
+#if !defined(WITH_LIBCRYPTO)
+//FIXME Not checked on threadsafety yet; after checking please remove this line
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "des_ssl.h"
+
+#define ITERATIONS 		16
+#define HALF_ITERATIONS 8
+
+
+#define c2l(c,l)		(l =((DES_LONG)(*((c)++)))    ,  \
+			 		 	 l|=((DES_LONG)(*((c)++)))<< 8L, \
+			 		 	 l|=((DES_LONG)(*((c)++)))<<16L, \
+					 	 l|=((DES_LONG)(*((c)++)))<<24L)
+
+/* NOTE - c is not incremented as per c2l */
+#define c2ln(c,l1,l2,n)	{ \
+							c+=n; \
+							l1=l2=0; \
+							switch (n) { \
+								case 8: l2 =((DES_LONG)(*(--(c))))<<24L; \
+								case 7: l2|=((DES_LONG)(*(--(c))))<<16L; \
+								case 6: l2|=((DES_LONG)(*(--(c))))<< 8L; \
+								case 5: l2|=((DES_LONG)(*(--(c))));      \
+								case 4: l1 =((DES_LONG)(*(--(c))))<<24L; \
+								case 3: l1|=((DES_LONG)(*(--(c))))<<16L; \
+								case 2: l1|=((DES_LONG)(*(--(c))))<< 8L; \
+								case 1: l1|=((DES_LONG)(*(--(c))));      \
+							} \
+						}
+
+#define l2c(l,c)		(*((c)++)=(unsigned char)(((l)     )&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>> 8L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>>16L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>>24L)&0xff))
+
+/* replacements for htonl and ntohl since I have no idea what to do
+* when faced with machines with 8 byte longs. */
+#define HDRSIZE 		4
+
+#define n2l(c,l)		(l =((DES_LONG)(*((c)++)))<<24L, \
+					 	 l|=((DES_LONG)(*((c)++)))<<16L, \
+					 	 l|=((DES_LONG)(*((c)++)))<< 8L, \
+					 	 l|=((DES_LONG)(*((c)++))))
+
+#define l2n(l,c)		(*((c)++)=(unsigned char)(((l)>>24L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>>16L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)>> 8L)&0xff), \
+					 	 *((c)++)=(unsigned char)(((l)     )&0xff))
+
+/* NOTE - c is not incremented as per l2c */
+#define l2cn(l1,l2,c,n)	{ \
+							c+=n; \
+							switch (n) { \
+								case 8: *(--(c))=(unsigned char)(((l2)>>24L)&0xff); \
+								case 7: *(--(c))=(unsigned char)(((l2)>>16L)&0xff); \
+								case 6: *(--(c))=(unsigned char)(((l2)>> 8L)&0xff); \
+								case 5: *(--(c))=(unsigned char)(((l2)     )&0xff); \
+								case 4: *(--(c))=(unsigned char)(((l1)>>24L)&0xff); \
+								case 3: *(--(c))=(unsigned char)(((l1)>>16L)&0xff); \
+								case 2: *(--(c))=(unsigned char)(((l1)>> 8L)&0xff); \
+								case 1: *(--(c))=(unsigned char)(((l1)     )&0xff); \
+							} \
+						}
+
+
+#ifndef ROTATE
+#define	ROTATE(a,n)		(((a)>>(n))+((a)<<(32-(n))))
+#endif
+
+/* Don't worry about the LOAD_DATA() stuff, that is used by
+* fcrypt() to add it's little bit to the front */
+
+#ifdef DES_FCRYPT
+
+#define LOAD_DATA_tmp(R,S,u,t,E0,E1) \
+						{ DES_LONG tmp; LOAD_DATA(R,S,u,t,E0,E1,tmp); }
+
+#define LOAD_DATA(R,S,u,t,E0,E1,tmp) \
+						t=R^(R>>16L); \
+						u=t&E0; t&=E1; \
+						tmp=(u<<16); u^=R^s[S  ]; u^=tmp; \
+						tmp=(t<<16); t^=R^s[S+1]; t^=tmp
+#else
+#define LOAD_DATA_tmp(a,b,c,d,e,f) LOAD_DATA(a,b,c,d,e,f,g)
+#define LOAD_DATA(R,S,u,t,E0,E1,tmp) \
+						u=R^s[S  ]; \
+						t=R^s[S+1]
+#endif
+
+/* The changes to this macro may help or hinder, depending on the
+* compiler and the architecture.  gcc2 always seems to do well :-).
+* Inspired by Dana How <how@isl.stanford.edu>
+* DO NOT use the alternative version on machines with 8 byte longs.
+* It does not seem to work on the Alpha, even when DES_LONG is 4
+* bytes, probably an issue of accessing non-word aligned objects :-( */
+#ifdef DES_PTR
+
+/* It recently occurred to me that 0^0^0^0^0^0^0 == 0, so there
+* is no reason to not xor all the sub items together.  This potentially
+* saves a register since things can be xored directly into L */
+
+#if defined(DES_RISC1) || defined(DES_RISC2)
+#ifdef DES_RISC1
+#define D_ENCRYPT(LL,R,S) { \
+			unsigned int u1,u2,u3; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0xfc; \
+			u2&=0xfc; \
+			t=ROTATE(t,4); \
+			u>>=16L; \
+			LL^= *(const DES_LONG *)(des_SP      +u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x200+u2); \
+			u3=(int)(u>>8L); \
+			u1=(int)u&0xfc; \
+			u3&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x400+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x600+u3); \
+			u2=(int)t>>8L; \
+			u1=(int)t&0xfc; \
+			u2&=0xfc; \
+			t>>=16L; \
+			LL^= *(const DES_LONG *)(des_SP+0x100+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x300+u2); \
+			u3=(int)t>>8L; \
+			u1=(int)t&0xfc; \
+			u3&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x500+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x700+u3); }
+#endif
+#ifdef DES_RISC2
+#define D_ENCRYPT(LL,R,S) { \
+			unsigned int u1,u2,s1,s2; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0xfc; \
+			u2&=0xfc; \
+			t=ROTATE(t,4); \
+			LL^= *(const DES_LONG *)(des_SP      +u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x200+u2); \
+			s1=(int)(u>>16L); \
+			s2=(int)(u>>24L); \
+			s1&=0xfc; \
+			s2&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x400+s1); \
+			LL^= *(const DES_LONG *)(des_SP+0x600+s2); \
+			u2=(int)t>>8L; \
+			u1=(int)t&0xfc; \
+			u2&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x100+u1); \
+			LL^= *(const DES_LONG *)(des_SP+0x300+u2); \
+			s1=(int)(t>>16L); \
+			s2=(int)(t>>24L); \
+			s1&=0xfc; \
+			s2&=0xfc; \
+			LL^= *(const DES_LONG *)(des_SP+0x500+s1); \
+			LL^= *(const DES_LONG *)(des_SP+0x700+s2); }
+#endif
+#else
+#define D_ENCRYPT(LL,R,S) { \
+			LOAD_DATA_tmp(R,S,u,t,E0,E1); \
+			t=ROTATE(t,4); \
+			LL^= \
+			*(const DES_LONG *)(des_SP      +((u     )&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x200+((u>> 8L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x400+((u>>16L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x600+((u>>24L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x100+((t     )&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x300+((t>> 8L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x500+((t>>16L)&0xfc))^ \
+			*(const DES_LONG *)(des_SP+0x700+((t>>24L)&0xfc)); }
+#endif
+
+#else /* original version */
+
+#if defined(DES_RISC1) || defined(DES_RISC2)
+#ifdef DES_RISC1
+#define D_ENCRYPT(LL,R,S) {\
+			unsigned int u1,u2,u3; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u>>=2L; \
+			t=ROTATE(t,6); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0x3f; \
+			u2&=0x3f; \
+			u>>=16L; \
+			LL^=DES_SPtrans[0][u1]; \
+			LL^=DES_SPtrans[2][u2]; \
+			u3=(int)u>>8L; \
+			u1=(int)u&0x3f; \
+			u3&=0x3f; \
+			LL^=DES_SPtrans[4][u1]; \
+			LL^=DES_SPtrans[6][u3]; \
+			u2=(int)t>>8L; \
+			u1=(int)t&0x3f; \
+			u2&=0x3f; \
+			t>>=16L; \
+			LL^=DES_SPtrans[1][u1]; \
+			LL^=DES_SPtrans[3][u2]; \
+			u3=(int)t>>8L; \
+			u1=(int)t&0x3f; \
+			u3&=0x3f; \
+			LL^=DES_SPtrans[5][u1]; \
+			LL^=DES_SPtrans[7][u3]; }
+#endif
+#ifdef DES_RISC2
+#define D_ENCRYPT(LL,R,S) {\
+			unsigned int u1,u2,s1,s2; \
+			LOAD_DATA(R,S,u,t,E0,E1,u1); \
+			u>>=2L; \
+			t=ROTATE(t,6); \
+			u2=(int)u>>8L; \
+			u1=(int)u&0x3f; \
+			u2&=0x3f; \
+			LL^=DES_SPtrans[0][u1]; \
+			LL^=DES_SPtrans[2][u2]; \
+			s1=(int)u>>16L; \
+			s2=(int)u>>24L; \
+			s1&=0x3f; \
+			s2&=0x3f; \
+			LL^=DES_SPtrans[4][s1]; \
+			LL^=DES_SPtrans[6][s2]; \
+			u2=(int)t>>8L; \
+			u1=(int)t&0x3f; \
+			u2&=0x3f; \
+			LL^=DES_SPtrans[1][u1]; \
+			LL^=DES_SPtrans[3][u2]; \
+			s1=(int)t>>16; \
+			s2=(int)t>>24L; \
+			s1&=0x3f; \
+			s2&=0x3f; \
+			LL^=DES_SPtrans[5][s1]; \
+			LL^=DES_SPtrans[7][s2]; }
+#endif
+
+#else
+
+#define D_ENCRYPT(LL,R,S) {\
+			LOAD_DATA_tmp(R,S,u,t,E0,E1); \
+			t=ROTATE(t,4); \
+			LL^=\
+			DES_SPtrans[0][(u>> 2L)&0x3f]^ \
+			DES_SPtrans[2][(u>>10L)&0x3f]^ \
+			DES_SPtrans[4][(u>>18L)&0x3f]^ \
+			DES_SPtrans[6][(u>>26L)&0x3f]^ \
+			DES_SPtrans[1][(t>> 2L)&0x3f]^ \
+			DES_SPtrans[3][(t>>10L)&0x3f]^ \
+			DES_SPtrans[5][(t>>18L)&0x3f]^ \
+			DES_SPtrans[7][(t>>26L)&0x3f]; }
+#endif
+#endif
+
+/* IP and FP
+* The problem is more of a geometric problem that random bit fiddling.
+0  1  2  3  4  5  6  7      62 54 46 38 30 22 14  6
+8  9 10 11 12 13 14 15      60 52 44 36 28 20 12  4
+16 17 18 19 20 21 22 23      58 50 42 34 26 18 10  2
+24 25 26 27 28 29 30 31  to  56 48 40 32 24 16  8  0
+
+32 33 34 35 36 37 38 39      63 55 47 39 31 23 15  7
+40 41 42 43 44 45 46 47      61 53 45 37 29 21 13  5
+48 49 50 51 52 53 54 55      59 51 43 35 27 19 11  3
+56 57 58 59 60 61 62 63      57 49 41 33 25 17  9  1
+
+The output has been subject to swaps of the form
+0 1 -> 3 1 but the odd and even bits have been put into
+2 3    2 0
+different words.  The main trick is to remember that
+t=((l>>size)^r)&(mask);
+r^=t;
+l^=(t<<size);
+can be used to swap and move bits between words.
+
+So l =  0  1  2  3  r = 16 17 18 19
+4  5  6  7      20 21 22 23
+8  9 10 11      24 25 26 27
+12 13 14 15      28 29 30 31
+becomes (for size == 2 and mask == 0x3333)
+t =   2^16  3^17 -- --   l =  0  1 16 17  r =  2  3 18 19
+6^20  7^21 -- --        4  5 20 21       6  7 22 23
+10^24 11^25 -- --        8  9 24 25      10 11 24 25
+14^28 15^29 -- --       12 13 28 29      14 15 28 29
+
+Thanks for hints from Richard Outerbridge - he told me IP&FP
+could be done in 15 xor, 10 shifts and 5 ands.
+When I finally started to think of the problem in 2D
+I first got ~42 operations without xors.  When I remembered
+how to use xors :-) I got it to its final state.
+*/
+
+#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
+					(b)^=(t),\
+					(a)^=((t)<<(n)))
+
+#define IP(l,r) 	\
+					{ \
+						register DES_LONG tt; \
+						PERM_OP(r,l,tt, 4,0x0f0f0f0fL); \
+						PERM_OP(l,r,tt,16,0x0000ffffL); \
+						PERM_OP(r,l,tt, 2,0x33333333L); \
+						PERM_OP(l,r,tt, 8,0x00ff00ffL); \
+						PERM_OP(r,l,tt, 1,0x55555555L); \
+					}
+
+#define FP(l,r) 	\
+					{ \
+						register DES_LONG tt; \
+						PERM_OP(l,r,tt, 1,0x55555555L); \
+						PERM_OP(r,l,tt, 8,0x00ff00ffL); \
+						PERM_OP(l,r,tt, 2,0x33333333L); \
+						PERM_OP(r,l,tt,16,0x0000ffffL); \
+						PERM_OP(l,r,tt, 4,0x0f0f0f0fL); \
+					}
+
+static const unsigned char odd_parity[256]={
+		1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
+		16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
+		32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
+		49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
+		64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
+		81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
+		97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
+		112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
+		128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
+		145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
+		161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
+		176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
+		193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
+		208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
+		224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
+		241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254};
+
+void DES_set_odd_parity(DES_cblock *key)
+{
+	unsigned int i;
+
+	for (i=0; i<DES_KEY_SZ; i++)
+		(*key)[i]=odd_parity[(*key)[i]];
+}
+
+int DES_check_key_parity(const_DES_cblock *key)
+{
+	unsigned int i;
+
+	for (i=0; i<DES_KEY_SZ; i++)
+	{
+		if ((*key)[i] != odd_parity[(*key)[i]])
+			return(0);
+	}
+	return(1);
+}
+
+/* Weak and semi week keys as take from
+* %A D.W. Davies
+* %A W.L. Price
+* %T Security for Computer Networks
+* %I John Wiley & Sons
+* %D 1984
+* Many thanks to smb@ulysses.att.com (Steven Bellovin) for the reference
+* (and actual cblock values).
+*/
+#define NUM_WEAK_KEY	16
+static DES_cblock weak_keys[NUM_WEAK_KEY]={
+	/* weak keys */
+	{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
+	{0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE},
+	{0x1F,0x1F,0x1F,0x1F,0x0E,0x0E,0x0E,0x0E},
+	{0xE0,0xE0,0xE0,0xE0,0xF1,0xF1,0xF1,0xF1},
+	/* semi-weak keys */
+	{0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE},
+	{0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01},
+	{0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1},
+	{0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E},
+	{0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1},
+	{0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01},
+	{0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE},
+	{0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E},
+	{0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E},
+	{0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01},
+	{0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE},
+	{0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1}};
+
+int DES_is_weak_key(const_DES_cblock *key)
+{
+	int i;
+
+	for (i=0; i<NUM_WEAK_KEY; i++)
+	/* Added == 0 to comparison, I obviously don't run
+	* this section very often :-(, thanks to
+	* engineering@MorningStar.Com for the fix
+	* eay 93/06/29
+	* Another problem, I was comparing only the first 4
+	* bytes, 97/03/18 */
+	if (memcmp(weak_keys[i],key,sizeof(DES_cblock)) == 0) return(1);
+	return(0);
+}
+
+/* NOW DEFINED IN des_local.h
+* See ecb_encrypt.c for a pseudo description of these macros.
+* #define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
+* 	(b)^=(t),\
+* 	(a)=((a)^((t)<<(n))))
+*/
+
+#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
+				(a)=(a)^(t)^(t>>(16-(n))))
+
+static const DES_LONG des_skb[8][64]={
+	{
+		/* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
+		0x00000000L,0x00000010L,0x20000000L,0x20000010L,
+		0x00010000L,0x00010010L,0x20010000L,0x20010010L,
+		0x00000800L,0x00000810L,0x20000800L,0x20000810L,
+		0x00010800L,0x00010810L,0x20010800L,0x20010810L,
+		0x00000020L,0x00000030L,0x20000020L,0x20000030L,
+		0x00010020L,0x00010030L,0x20010020L,0x20010030L,
+		0x00000820L,0x00000830L,0x20000820L,0x20000830L,
+		0x00010820L,0x00010830L,0x20010820L,0x20010830L,
+		0x00080000L,0x00080010L,0x20080000L,0x20080010L,
+		0x00090000L,0x00090010L,0x20090000L,0x20090010L,
+		0x00080800L,0x00080810L,0x20080800L,0x20080810L,
+		0x00090800L,0x00090810L,0x20090800L,0x20090810L,
+		0x00080020L,0x00080030L,0x20080020L,0x20080030L,
+		0x00090020L,0x00090030L,0x20090020L,0x20090030L,
+		0x00080820L,0x00080830L,0x20080820L,0x20080830L,
+		0x00090820L,0x00090830L,0x20090820L,0x20090830L,
+	},{
+	/* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
+		0x00000000L,0x02000000L,0x00002000L,0x02002000L,
+		0x00200000L,0x02200000L,0x00202000L,0x02202000L,
+		0x00000004L,0x02000004L,0x00002004L,0x02002004L,
+		0x00200004L,0x02200004L,0x00202004L,0x02202004L,
+		0x00000400L,0x02000400L,0x00002400L,0x02002400L,
+		0x00200400L,0x02200400L,0x00202400L,0x02202400L,
+		0x00000404L,0x02000404L,0x00002404L,0x02002404L,
+		0x00200404L,0x02200404L,0x00202404L,0x02202404L,
+		0x10000000L,0x12000000L,0x10002000L,0x12002000L,
+		0x10200000L,0x12200000L,0x10202000L,0x12202000L,
+		0x10000004L,0x12000004L,0x10002004L,0x12002004L,
+		0x10200004L,0x12200004L,0x10202004L,0x12202004L,
+		0x10000400L,0x12000400L,0x10002400L,0x12002400L,
+		0x10200400L,0x12200400L,0x10202400L,0x12202400L,
+		0x10000404L,0x12000404L,0x10002404L,0x12002404L,
+		0x10200404L,0x12200404L,0x10202404L,0x12202404L,
+	},{
+		/* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
+		0x00000000L,0x00000001L,0x00040000L,0x00040001L,
+		0x01000000L,0x01000001L,0x01040000L,0x01040001L,
+		0x00000002L,0x00000003L,0x00040002L,0x00040003L,
+		0x01000002L,0x01000003L,0x01040002L,0x01040003L,
+		0x00000200L,0x00000201L,0x00040200L,0x00040201L,
+		0x01000200L,0x01000201L,0x01040200L,0x01040201L,
+		0x00000202L,0x00000203L,0x00040202L,0x00040203L,
+		0x01000202L,0x01000203L,0x01040202L,0x01040203L,
+		0x08000000L,0x08000001L,0x08040000L,0x08040001L,
+		0x09000000L,0x09000001L,0x09040000L,0x09040001L,
+		0x08000002L,0x08000003L,0x08040002L,0x08040003L,
+		0x09000002L,0x09000003L,0x09040002L,0x09040003L,
+		0x08000200L,0x08000201L,0x08040200L,0x08040201L,
+		0x09000200L,0x09000201L,0x09040200L,0x09040201L,
+		0x08000202L,0x08000203L,0x08040202L,0x08040203L,
+		0x09000202L,0x09000203L,0x09040202L,0x09040203L,
+	},{
+	/* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
+		0x00000000L,0x00100000L,0x00000100L,0x00100100L,
+		0x00000008L,0x00100008L,0x00000108L,0x00100108L,
+		0x00001000L,0x00101000L,0x00001100L,0x00101100L,
+		0x00001008L,0x00101008L,0x00001108L,0x00101108L,
+		0x04000000L,0x04100000L,0x04000100L,0x04100100L,
+		0x04000008L,0x04100008L,0x04000108L,0x04100108L,
+		0x04001000L,0x04101000L,0x04001100L,0x04101100L,
+		0x04001008L,0x04101008L,0x04001108L,0x04101108L,
+		0x00020000L,0x00120000L,0x00020100L,0x00120100L,
+		0x00020008L,0x00120008L,0x00020108L,0x00120108L,
+		0x00021000L,0x00121000L,0x00021100L,0x00121100L,
+		0x00021008L,0x00121008L,0x00021108L,0x00121108L,
+		0x04020000L,0x04120000L,0x04020100L,0x04120100L,
+		0x04020008L,0x04120008L,0x04020108L,0x04120108L,
+		0x04021000L,0x04121000L,0x04021100L,0x04121100L,
+		0x04021008L,0x04121008L,0x04021108L,0x04121108L,
+	},{
+		/* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
+		0x00000000L,0x10000000L,0x00010000L,0x10010000L,
+		0x00000004L,0x10000004L,0x00010004L,0x10010004L,
+		0x20000000L,0x30000000L,0x20010000L,0x30010000L,
+		0x20000004L,0x30000004L,0x20010004L,0x30010004L,
+		0x00100000L,0x10100000L,0x00110000L,0x10110000L,
+		0x00100004L,0x10100004L,0x00110004L,0x10110004L,
+		0x20100000L,0x30100000L,0x20110000L,0x30110000L,
+		0x20100004L,0x30100004L,0x20110004L,0x30110004L,
+		0x00001000L,0x10001000L,0x00011000L,0x10011000L,
+		0x00001004L,0x10001004L,0x00011004L,0x10011004L,
+		0x20001000L,0x30001000L,0x20011000L,0x30011000L,
+		0x20001004L,0x30001004L,0x20011004L,0x30011004L,
+		0x00101000L,0x10101000L,0x00111000L,0x10111000L,
+		0x00101004L,0x10101004L,0x00111004L,0x10111004L,
+		0x20101000L,0x30101000L,0x20111000L,0x30111000L,
+		0x20101004L,0x30101004L,0x20111004L,0x30111004L,
+	},{
+		/* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
+		0x00000000L,0x08000000L,0x00000008L,0x08000008L,
+		0x00000400L,0x08000400L,0x00000408L,0x08000408L,
+		0x00020000L,0x08020000L,0x00020008L,0x08020008L,
+		0x00020400L,0x08020400L,0x00020408L,0x08020408L,
+		0x00000001L,0x08000001L,0x00000009L,0x08000009L,
+		0x00000401L,0x08000401L,0x00000409L,0x08000409L,
+		0x00020001L,0x08020001L,0x00020009L,0x08020009L,
+		0x00020401L,0x08020401L,0x00020409L,0x08020409L,
+		0x02000000L,0x0A000000L,0x02000008L,0x0A000008L,
+		0x02000400L,0x0A000400L,0x02000408L,0x0A000408L,
+		0x02020000L,0x0A020000L,0x02020008L,0x0A020008L,
+		0x02020400L,0x0A020400L,0x02020408L,0x0A020408L,
+		0x02000001L,0x0A000001L,0x02000009L,0x0A000009L,
+		0x02000401L,0x0A000401L,0x02000409L,0x0A000409L,
+		0x02020001L,0x0A020001L,0x02020009L,0x0A020009L,
+		0x02020401L,0x0A020401L,0x02020409L,0x0A020409L,
+	},{
+		/* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
+		0x00000000L,0x00000100L,0x00080000L,0x00080100L,
+		0x01000000L,0x01000100L,0x01080000L,0x01080100L,
+		0x00000010L,0x00000110L,0x00080010L,0x00080110L,
+		0x01000010L,0x01000110L,0x01080010L,0x01080110L,
+		0x00200000L,0x00200100L,0x00280000L,0x00280100L,
+		0x01200000L,0x01200100L,0x01280000L,0x01280100L,
+		0x00200010L,0x00200110L,0x00280010L,0x00280110L,
+		0x01200010L,0x01200110L,0x01280010L,0x01280110L,
+		0x00000200L,0x00000300L,0x00080200L,0x00080300L,
+		0x01000200L,0x01000300L,0x01080200L,0x01080300L,
+		0x00000210L,0x00000310L,0x00080210L,0x00080310L,
+		0x01000210L,0x01000310L,0x01080210L,0x01080310L,
+		0x00200200L,0x00200300L,0x00280200L,0x00280300L,
+		0x01200200L,0x01200300L,0x01280200L,0x01280300L,
+		0x00200210L,0x00200310L,0x00280210L,0x00280310L,
+		0x01200210L,0x01200310L,0x01280210L,0x01280310L,
+	},{
+	/* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
+		0x00000000L,0x04000000L,0x00040000L,0x04040000L,
+		0x00000002L,0x04000002L,0x00040002L,0x04040002L,
+		0x00002000L,0x04002000L,0x00042000L,0x04042000L,
+		0x00002002L,0x04002002L,0x00042002L,0x04042002L,
+		0x00000020L,0x04000020L,0x00040020L,0x04040020L,
+		0x00000022L,0x04000022L,0x00040022L,0x04040022L,
+		0x00002020L,0x04002020L,0x00042020L,0x04042020L,
+		0x00002022L,0x04002022L,0x00042022L,0x04042022L,
+		0x00000800L,0x04000800L,0x00040800L,0x04040800L,
+		0x00000802L,0x04000802L,0x00040802L,0x04040802L,
+		0x00002800L,0x04002800L,0x00042800L,0x04042800L,
+		0x00002802L,0x04002802L,0x00042802L,0x04042802L,
+		0x00000820L,0x04000820L,0x00040820L,0x04040820L,
+		0x00000822L,0x04000822L,0x00040822L,0x04040822L,
+		0x00002820L,0x04002820L,0x00042820L,0x04042820L,
+		0x00002822L,0x04002822L,0x00042822L,0x04042822L,
+	}};
+
+
+static const DES_LONG DES_SPtrans[8][64]={
+	{
+	/* nibble 0 */
+	0x02080800L, 0x00080000L, 0x02000002L, 0x02080802L,
+	0x02000000L, 0x00080802L, 0x00080002L, 0x02000002L,
+	0x00080802L, 0x02080800L, 0x02080000L, 0x00000802L,
+	0x02000802L, 0x02000000L, 0x00000000L, 0x00080002L,
+	0x00080000L, 0x00000002L, 0x02000800L, 0x00080800L,
+	0x02080802L, 0x02080000L, 0x00000802L, 0x02000800L,
+	0x00000002L, 0x00000800L, 0x00080800L, 0x02080002L,
+	0x00000800L, 0x02000802L, 0x02080002L, 0x00000000L,
+	0x00000000L, 0x02080802L, 0x02000800L, 0x00080002L,
+	0x02080800L, 0x00080000L, 0x00000802L, 0x02000800L,
+	0x02080002L, 0x00000800L, 0x00080800L, 0x02000002L,
+	0x00080802L, 0x00000002L, 0x02000002L, 0x02080000L,
+	0x02080802L, 0x00080800L, 0x02080000L, 0x02000802L,
+	0x02000000L, 0x00000802L, 0x00080002L, 0x00000000L,
+	0x00080000L, 0x02000000L, 0x02000802L, 0x02080800L,
+	0x00000002L, 0x02080002L, 0x00000800L, 0x00080802L,
+	},{
+	/* nibble 1 */
+	0x40108010L, 0x00000000L, 0x00108000L, 0x40100000L,
+	0x40000010L, 0x00008010L, 0x40008000L, 0x00108000L,
+	0x00008000L, 0x40100010L, 0x00000010L, 0x40008000L,
+	0x00100010L, 0x40108000L, 0x40100000L, 0x00000010L,
+	0x00100000L, 0x40008010L, 0x40100010L, 0x00008000L,
+	0x00108010L, 0x40000000L, 0x00000000L, 0x00100010L,
+	0x40008010L, 0x00108010L, 0x40108000L, 0x40000010L,
+	0x40000000L, 0x00100000L, 0x00008010L, 0x40108010L,
+	0x00100010L, 0x40108000L, 0x40008000L, 0x00108010L,
+	0x40108010L, 0x00100010L, 0x40000010L, 0x00000000L,
+	0x40000000L, 0x00008010L, 0x00100000L, 0x40100010L,
+	0x00008000L, 0x40000000L, 0x00108010L, 0x40008010L,
+	0x40108000L, 0x00008000L, 0x00000000L, 0x40000010L,
+	0x00000010L, 0x40108010L, 0x00108000L, 0x40100000L,
+	0x40100010L, 0x00100000L, 0x00008010L, 0x40008000L,
+	0x40008010L, 0x00000010L, 0x40100000L, 0x00108000L,
+	},{
+	/* nibble 2 */
+	0x04000001L, 0x04040100L, 0x00000100L, 0x04000101L,
+	0x00040001L, 0x04000000L, 0x04000101L, 0x00040100L,
+	0x04000100L, 0x00040000L, 0x04040000L, 0x00000001L,
+	0x04040101L, 0x00000101L, 0x00000001L, 0x04040001L,
+	0x00000000L, 0x00040001L, 0x04040100L, 0x00000100L,
+	0x00000101L, 0x04040101L, 0x00040000L, 0x04000001L,
+	0x04040001L, 0x04000100L, 0x00040101L, 0x04040000L,
+	0x00040100L, 0x00000000L, 0x04000000L, 0x00040101L,
+	0x04040100L, 0x00000100L, 0x00000001L, 0x00040000L,
+	0x00000101L, 0x00040001L, 0x04040000L, 0x04000101L,
+	0x00000000L, 0x04040100L, 0x00040100L, 0x04040001L,
+	0x00040001L, 0x04000000L, 0x04040101L, 0x00000001L,
+	0x00040101L, 0x04000001L, 0x04000000L, 0x04040101L,
+	0x00040000L, 0x04000100L, 0x04000101L, 0x00040100L,
+	0x04000100L, 0x00000000L, 0x04040001L, 0x00000101L,
+	0x04000001L, 0x00040101L, 0x00000100L, 0x04040000L,
+	},{
+	/* nibble 3 */
+	0x00401008L, 0x10001000L, 0x00000008L, 0x10401008L,
+	0x00000000L, 0x10400000L, 0x10001008L, 0x00400008L,
+	0x10401000L, 0x10000008L, 0x10000000L, 0x00001008L,
+	0x10000008L, 0x00401008L, 0x00400000L, 0x10000000L,
+	0x10400008L, 0x00401000L, 0x00001000L, 0x00000008L,
+	0x00401000L, 0x10001008L, 0x10400000L, 0x00001000L,
+	0x00001008L, 0x00000000L, 0x00400008L, 0x10401000L,
+	0x10001000L, 0x10400008L, 0x10401008L, 0x00400000L,
+	0x10400008L, 0x00001008L, 0x00400000L, 0x10000008L,
+	0x00401000L, 0x10001000L, 0x00000008L, 0x10400000L,
+	0x10001008L, 0x00000000L, 0x00001000L, 0x00400008L,
+	0x00000000L, 0x10400008L, 0x10401000L, 0x00001000L,
+	0x10000000L, 0x10401008L, 0x00401008L, 0x00400000L,
+	0x10401008L, 0x00000008L, 0x10001000L, 0x00401008L,
+	0x00400008L, 0x00401000L, 0x10400000L, 0x10001008L,
+	0x00001008L, 0x10000000L, 0x10000008L, 0x10401000L,
+	},{
+	/* nibble 4 */
+	0x08000000L, 0x00010000L, 0x00000400L, 0x08010420L,
+	0x08010020L, 0x08000400L, 0x00010420L, 0x08010000L,
+	0x00010000L, 0x00000020L, 0x08000020L, 0x00010400L,
+	0x08000420L, 0x08010020L, 0x08010400L, 0x00000000L,
+	0x00010400L, 0x08000000L, 0x00010020L, 0x00000420L,
+	0x08000400L, 0x00010420L, 0x00000000L, 0x08000020L,
+	0x00000020L, 0x08000420L, 0x08010420L, 0x00010020L,
+	0x08010000L, 0x00000400L, 0x00000420L, 0x08010400L,
+	0x08010400L, 0x08000420L, 0x00010020L, 0x08010000L,
+	0x00010000L, 0x00000020L, 0x08000020L, 0x08000400L,
+	0x08000000L, 0x00010400L, 0x08010420L, 0x00000000L,
+	0x00010420L, 0x08000000L, 0x00000400L, 0x00010020L,
+	0x08000420L, 0x00000400L, 0x00000000L, 0x08010420L,
+	0x08010020L, 0x08010400L, 0x00000420L, 0x00010000L,
+	0x00010400L, 0x08010020L, 0x08000400L, 0x00000420L,
+	0x00000020L, 0x00010420L, 0x08010000L, 0x08000020L,
+	},{
+	/* nibble 5 */
+	0x80000040L, 0x00200040L, 0x00000000L, 0x80202000L,
+	0x00200040L, 0x00002000L, 0x80002040L, 0x00200000L,
+	0x00002040L, 0x80202040L, 0x00202000L, 0x80000000L,
+	0x80002000L, 0x80000040L, 0x80200000L, 0x00202040L,
+	0x00200000L, 0x80002040L, 0x80200040L, 0x00000000L,
+	0x00002000L, 0x00000040L, 0x80202000L, 0x80200040L,
+	0x80202040L, 0x80200000L, 0x80000000L, 0x00002040L,
+	0x00000040L, 0x00202000L, 0x00202040L, 0x80002000L,
+	0x00002040L, 0x80000000L, 0x80002000L, 0x00202040L,
+	0x80202000L, 0x00200040L, 0x00000000L, 0x80002000L,
+	0x80000000L, 0x00002000L, 0x80200040L, 0x00200000L,
+	0x00200040L, 0x80202040L, 0x00202000L, 0x00000040L,
+	0x80202040L, 0x00202000L, 0x00200000L, 0x80002040L,
+	0x80000040L, 0x80200000L, 0x00202040L, 0x00000000L,
+	0x00002000L, 0x80000040L, 0x80002040L, 0x80202000L,
+	0x80200000L, 0x00002040L, 0x00000040L, 0x80200040L,
+	},{
+	/* nibble 6 */
+	0x00004000L, 0x00000200L, 0x01000200L, 0x01000004L,
+	0x01004204L, 0x00004004L, 0x00004200L, 0x00000000L,
+	0x01000000L, 0x01000204L, 0x00000204L, 0x01004000L,
+	0x00000004L, 0x01004200L, 0x01004000L, 0x00000204L,
+	0x01000204L, 0x00004000L, 0x00004004L, 0x01004204L,
+	0x00000000L, 0x01000200L, 0x01000004L, 0x00004200L,
+	0x01004004L, 0x00004204L, 0x01004200L, 0x00000004L,
+	0x00004204L, 0x01004004L, 0x00000200L, 0x01000000L,
+	0x00004204L, 0x01004000L, 0x01004004L, 0x00000204L,
+	0x00004000L, 0x00000200L, 0x01000000L, 0x01004004L,
+	0x01000204L, 0x00004204L, 0x00004200L, 0x00000000L,
+	0x00000200L, 0x01000004L, 0x00000004L, 0x01000200L,
+	0x00000000L, 0x01000204L, 0x01000200L, 0x00004200L,
+	0x00000204L, 0x00004000L, 0x01004204L, 0x01000000L,
+	0x01004200L, 0x00000004L, 0x00004004L, 0x01004204L,
+	0x01000004L, 0x01004200L, 0x01004000L, 0x00004004L,
+	},{
+	/* nibble 7 */
+	0x20800080L, 0x20820000L, 0x00020080L, 0x00000000L,
+	0x20020000L, 0x00800080L, 0x20800000L, 0x20820080L,
+	0x00000080L, 0x20000000L, 0x00820000L, 0x00020080L,
+	0x00820080L, 0x20020080L, 0x20000080L, 0x20800000L,
+	0x00020000L, 0x00820080L, 0x00800080L, 0x20020000L,
+	0x20820080L, 0x20000080L, 0x00000000L, 0x00820000L,
+	0x20000000L, 0x00800000L, 0x20020080L, 0x20800080L,
+	0x00800000L, 0x00020000L, 0x20820000L, 0x00000080L,
+	0x00800000L, 0x00020000L, 0x20000080L, 0x20820080L,
+	0x00020080L, 0x20000000L, 0x00000000L, 0x00820000L,
+	0x20800080L, 0x20020080L, 0x20020000L, 0x00800080L,
+	0x20820000L, 0x00000080L, 0x00800080L, 0x20020000L,
+	0x20820080L, 0x00800000L, 0x20800000L, 0x20000080L,
+	0x00820000L, 0x00020080L, 0x20020080L, 0x20800000L,
+	0x00000080L, 0x20820000L, 0x00820080L, 0x00000000L,
+	0x20000000L, 0x20800080L, 0x00020000L, 0x00820080L,
+	}};
+
+int	DES_check_key = 0;
+
+
+int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	if (DES_check_key)
+	{
+		return DES_set_key_checked(key, schedule);
+	}
+	else
+	{
+		DES_set_key_unchecked(key, schedule);
+		return 0;
+	}
+}
+
+/* return 0 if key parity is odd (correct),
+* return -1 if key parity error,
+* return -2 if illegal weak key.
+*/
+int DES_set_key_checked(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	if (!DES_check_key_parity(key))
+		return(-1);
+	if (DES_is_weak_key(key))
+		return(-2);
+	DES_set_key_unchecked(key, schedule);
+	return 0;
+}
+
+void DES_set_key_unchecked(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	static int shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
+	register DES_LONG c,d,t,s,t2;
+	register const unsigned char *in;
+	register DES_LONG *k;
+	register int i;
+
+#ifdef OPENBSD_DEV_CRYPTO
+	memcpy(schedule->key,key,sizeof schedule->key);
+	schedule->session=NULL;
+#endif
+	k = &schedule->ks->deslong[0];
+	in = &(*key)[0];
+
+	c2l(in,c);
+	c2l(in,d);
+
+	/* do PC1 in 47 simple operations :-)
+	* Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
+	* for the inspiration. :-) */
+	PERM_OP (d,c,t,4,0x0f0f0f0fL);
+	HPERM_OP(c,t,-2,0xcccc0000L);
+	HPERM_OP(d,t,-2,0xcccc0000L);
+	PERM_OP (d,c,t,1,0x55555555L);
+	PERM_OP (c,d,t,8,0x00ff00ffL);
+	PERM_OP (d,c,t,1,0x55555555L);
+	d=	(((d&0x000000ffL)<<16L)| (d&0x0000ff00L)     |
+		((d&0x00ff0000L)>>16L)|((c&0xf0000000L)>>4L));
+	c&=0x0fffffffL;
+
+	for (i=0; i<ITERATIONS; i++)
+	{
+		if (shifts2[i])
+		{ c=((c>>2L)|(c<<26L)); d=((d>>2L)|(d<<26L)); }
+		else
+		{ c=((c>>1L)|(c<<27L)); d=((d>>1L)|(d<<27L)); }
+		c&=0x0fffffffL;
+		d&=0x0fffffffL;
+		/* could be a few less shifts but I am to lazy at this
+		* point in time to investigate */
+		s=	des_skb[0][ (c    )&0x3f                ]|
+			des_skb[1][((c>> 6L)&0x03)|((c>> 7L)&0x3c)]|
+			des_skb[2][((c>>13L)&0x0f)|((c>>14L)&0x30)]|
+			des_skb[3][((c>>20L)&0x01)|((c>>21L)&0x06) |
+			((c>>22L)&0x38)];
+		t=	des_skb[4][ (d    )&0x3f                ]|
+			des_skb[5][((d>> 7L)&0x03)|((d>> 8L)&0x3c)]|
+			des_skb[6][ (d>>15L)&0x3f                ]|
+			des_skb[7][((d>>21L)&0x0f)|((d>>22L)&0x30)];
+
+		/* table contained 0213 4657 */
+		t2=((t<<16L)|(s&0x0000ffffL))&0xffffffffL;
+		*(k++)=ROTATE(t2,30)&0xffffffffL;
+
+		t2=((s>>16L)|(t&0xffff0000L));
+		*(k++)=ROTATE(t2,26)&0xffffffffL;
+	}
+}
+
+int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule)
+{
+	return(DES_set_key(key,schedule));
+}
+/*
+#undef des_fixup_key_parity
+void des_fixup_key_parity(des_cblock *key)
+{
+des_set_odd_parity(key);
+}
+*/
+
+
+
+void DES_encrypt1(DES_LONG *data, DES_key_schedule *ks, int enc)
+{
+	register DES_LONG l,r,t,u;
+#ifdef DES_PTR
+	register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
+#endif
+#ifndef DES_UNROLL
+	register int i;
+#endif
+	register DES_LONG *s;
+
+	r=data[0];
+	l=data[1];
+
+	IP(r,l);
+	/* Things have been modified so that the initial rotate is
+	* done outside the loop.  This required the
+	* DES_SPtrans values in sp.h to be rotated 1 bit to the right.
+	* One perl script later and things have a 5% speed up on a sparc2.
+	* Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+	* for pointing this out. */
+	/* clear the top bits on machines with 8byte longs */
+	/* shift left by 2 */
+	r=ROTATE(r,29)&0xffffffffL;
+	l=ROTATE(l,29)&0xffffffffL;
+
+	s=ks->ks->deslong;
+	/* I don't know if it is worth the effort of loop unrolling the
+	* inner loop */
+	if (enc)
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r, 0); /*  1 */
+		D_ENCRYPT(r,l, 2); /*  2 */
+		D_ENCRYPT(l,r, 4); /*  3 */
+		D_ENCRYPT(r,l, 6); /*  4 */
+		D_ENCRYPT(l,r, 8); /*  5 */
+		D_ENCRYPT(r,l,10); /*  6 */
+		D_ENCRYPT(l,r,12); /*  7 */
+		D_ENCRYPT(r,l,14); /*  8 */
+		D_ENCRYPT(l,r,16); /*  9 */
+		D_ENCRYPT(r,l,18); /*  10 */
+		D_ENCRYPT(l,r,20); /*  11 */
+		D_ENCRYPT(r,l,22); /*  12 */
+		D_ENCRYPT(l,r,24); /*  13 */
+		D_ENCRYPT(r,l,26); /*  14 */
+		D_ENCRYPT(l,r,28); /*  15 */
+		D_ENCRYPT(r,l,30); /*  16 */
+#else
+		for (i=0; i<32; i+=8)
+		{
+			D_ENCRYPT(l,r,i+0); /*  1 */
+			D_ENCRYPT(r,l,i+2); /*  2 */
+			D_ENCRYPT(l,r,i+4); /*  3 */
+			D_ENCRYPT(r,l,i+6); /*  4 */
+		}
+#endif
+	}
+	else
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r,30); /* 16 */
+		D_ENCRYPT(r,l,28); /* 15 */
+		D_ENCRYPT(l,r,26); /* 14 */
+		D_ENCRYPT(r,l,24); /* 13 */
+		D_ENCRYPT(l,r,22); /* 12 */
+		D_ENCRYPT(r,l,20); /* 11 */
+		D_ENCRYPT(l,r,18); /* 10 */
+		D_ENCRYPT(r,l,16); /*  9 */
+		D_ENCRYPT(l,r,14); /*  8 */
+		D_ENCRYPT(r,l,12); /*  7 */
+		D_ENCRYPT(l,r,10); /*  6 */
+		D_ENCRYPT(r,l, 8); /*  5 */
+		D_ENCRYPT(l,r, 6); /*  4 */
+		D_ENCRYPT(r,l, 4); /*  3 */
+		D_ENCRYPT(l,r, 2); /*  2 */
+		D_ENCRYPT(r,l, 0); /*  1 */
+#else
+		for (i=30; i>0; i-=8)
+		{
+			D_ENCRYPT(l,r,i-0); /* 16 */
+			D_ENCRYPT(r,l,i-2); /* 15 */
+			D_ENCRYPT(l,r,i-4); /* 14 */
+			D_ENCRYPT(r,l,i-6); /* 13 */
+		}
+#endif
+	}
+
+	/* rotate and clear the top bits on machines with 8byte longs */
+	l=ROTATE(l,3)&0xffffffffL;
+	r=ROTATE(r,3)&0xffffffffL;
+
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+	l=r=t=u=0;
+}
+
+void DES_encrypt2(DES_LONG *data, DES_key_schedule *ks, int enc)
+{
+	register DES_LONG l,r,t,u;
+#ifdef DES_PTR
+	register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
+#endif
+#ifndef DES_UNROLL
+	register int i;
+#endif
+	register DES_LONG *s;
+
+	r=data[0];
+	l=data[1];
+
+	/* Things have been modified so that the initial rotate is
+	* done outside the loop.  This required the
+	* DES_SPtrans values in sp.h to be rotated 1 bit to the right.
+	* One perl script later and things have a 5% speed up on a sparc2.
+	* Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+	* for pointing this out. */
+	/* clear the top bits on machines with 8byte longs */
+	r=ROTATE(r,29)&0xffffffffL;
+	l=ROTATE(l,29)&0xffffffffL;
+
+	s=ks->ks->deslong;
+	/* I don't know if it is worth the effort of loop unrolling the
+	* inner loop */
+	if (enc)
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r, 0); /*  1 */
+		D_ENCRYPT(r,l, 2); /*  2 */
+		D_ENCRYPT(l,r, 4); /*  3 */
+		D_ENCRYPT(r,l, 6); /*  4 */
+		D_ENCRYPT(l,r, 8); /*  5 */
+		D_ENCRYPT(r,l,10); /*  6 */
+		D_ENCRYPT(l,r,12); /*  7 */
+		D_ENCRYPT(r,l,14); /*  8 */
+		D_ENCRYPT(l,r,16); /*  9 */
+		D_ENCRYPT(r,l,18); /*  10 */
+		D_ENCRYPT(l,r,20); /*  11 */
+		D_ENCRYPT(r,l,22); /*  12 */
+		D_ENCRYPT(l,r,24); /*  13 */
+		D_ENCRYPT(r,l,26); /*  14 */
+		D_ENCRYPT(l,r,28); /*  15 */
+		D_ENCRYPT(r,l,30); /*  16 */
+#else
+		for (i=0; i<32; i+=8)
+		{
+			D_ENCRYPT(l,r,i+0); /*  1 */
+			D_ENCRYPT(r,l,i+2); /*  2 */
+			D_ENCRYPT(l,r,i+4); /*  3 */
+			D_ENCRYPT(r,l,i+6); /*  4 */
+		}
+#endif
+	}
+	else
+	{
+#ifdef DES_UNROLL
+		D_ENCRYPT(l,r,30); /* 16 */
+		D_ENCRYPT(r,l,28); /* 15 */
+		D_ENCRYPT(l,r,26); /* 14 */
+		D_ENCRYPT(r,l,24); /* 13 */
+		D_ENCRYPT(l,r,22); /* 12 */
+		D_ENCRYPT(r,l,20); /* 11 */
+		D_ENCRYPT(l,r,18); /* 10 */
+		D_ENCRYPT(r,l,16); /*  9 */
+		D_ENCRYPT(l,r,14); /*  8 */
+		D_ENCRYPT(r,l,12); /*  7 */
+		D_ENCRYPT(l,r,10); /*  6 */
+		D_ENCRYPT(r,l, 8); /*  5 */
+		D_ENCRYPT(l,r, 6); /*  4 */
+		D_ENCRYPT(r,l, 4); /*  3 */
+		D_ENCRYPT(l,r, 2); /*  2 */
+		D_ENCRYPT(r,l, 0); /*  1 */
+#else
+		for (i=30; i>0; i-=8)
+		{
+			D_ENCRYPT(l,r,i-0); /* 16 */
+			D_ENCRYPT(r,l,i-2); /* 15 */
+			D_ENCRYPT(l,r,i-4); /* 14 */
+			D_ENCRYPT(r,l,i-6); /* 13 */
+		}
+#endif
+	}
+	/* rotate and clear the top bits on machines with 8byte longs */
+	data[0]=ROTATE(l,3)&0xffffffffL;
+	data[1]=ROTATE(r,3)&0xffffffffL;
+	l=r=t=u=0;
+}
+
+void DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,
+	DES_key_schedule *ks2, DES_key_schedule *ks3)
+{
+	register DES_LONG l,r;
+
+	l=data[0];
+	r=data[1];
+	IP(l,r);
+	data[0]=l;
+	data[1]=r;
+	DES_encrypt2((DES_LONG *)data,ks1,_ENCRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks2,_DECRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks3,_ENCRYPT_);
+	l=data[0];
+	r=data[1];
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+}
+
+void DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,
+	DES_key_schedule *ks2, DES_key_schedule *ks3)
+{
+	register DES_LONG l,r;
+
+	l=data[0];
+	r=data[1];
+	IP(l,r);
+	data[0]=l;
+	data[1]=r;
+	DES_encrypt2((DES_LONG *)data,ks3,_DECRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks2,_ENCRYPT_);
+	DES_encrypt2((DES_LONG *)data,ks1,_DECRYPT_);
+	l=data[0];
+	r=data[1];
+	FP(r,l);
+	data[0]=l;
+	data[1]=r;
+}
+
+#ifndef DES_DEFAULT_OPTIONS
+
+#undef CBC_ENC_C__DONT_UPDATE_IV
+
+void DES_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,
+	long length, DES_key_schedule *ks1,
+	DES_key_schedule *ks2, DES_key_schedule *ks3,
+	DES_cblock *ivec, int enc)
+{
+	register DES_LONG tin0,tin1;
+	register DES_LONG tout0,tout1,xor0,xor1;
+	register const unsigned char *in;
+	unsigned char *out;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *iv;
+
+	in=input;
+	out=output;
+	iv = &(*ivec)[0];
+
+	if (enc)
+	{
+		c2l(iv,tout0);
+		c2l(iv,tout1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			tin0^=tout0;
+			tin1^=tout1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			l2c(tout0,out);
+			l2c(tout1,out);
+		}
+		if (l != -8)
+		{
+			c2ln(in,tin0,tin1,l+8);
+			tin0^=tout0;
+			tin1^=tout1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			l2c(tout0,out);
+			l2c(tout1,out);
+		}
+		iv = &(*ivec)[0];
+		l2c(tout0,iv);
+		l2c(tout1,iv);
+	}
+	else
+	{
+		register DES_LONG t0,t1;
+
+		c2l(iv,xor0);
+		c2l(iv,xor1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+
+			t0=tin0;
+			t1=tin1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			tout0^=xor0;
+			tout1^=xor1;
+			l2c(tout0,out);
+			l2c(tout1,out);
+			xor0=t0;
+			xor1=t1;
+		}
+		if (l != -8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+
+			t0=tin0;
+			t1=tin1;
+
+			tin[0]=tin0;
+			tin[1]=tin1;
+			DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+			tout0=tin[0];
+			tout1=tin[1];
+
+			tout0^=xor0;
+			tout1^=xor1;
+			l2cn(tout0,tout1,out,l+8);
+			xor0=t0;
+			xor1=t1;
+		}
+
+		iv = &(*ivec)[0];
+		l2c(xor0,iv);
+		l2c(xor1,iv);
+	}
+	tin0=tin1=tout0=tout1=xor0=xor1=0;
+	tin[0]=tin[1]=0;
+}
+
+#endif /* DES_DEFAULT_OPTIONS */
+
+
+
+void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output,
+	DES_key_schedule *ks, int enc)
+{
+	register DES_LONG l;
+	DES_LONG ll[2];
+	const unsigned char *in = &(*input)[0];
+	unsigned char *out = &(*output)[0];
+
+	c2l(in,l); ll[0]=l;
+	c2l(in,l); ll[1]=l;
+	DES_encrypt1(ll,ks,enc);
+	l=ll[0]; l2c(l,out);
+	l=ll[1]; l2c(l,out);
+	l=ll[0]=ll[1]=0;
+}
+
+void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,
+	DES_key_schedule *ks1, DES_key_schedule *ks2,
+	DES_key_schedule *ks3,
+	int enc)
+{
+	register DES_LONG l0,l1;
+	DES_LONG ll[2];
+	const unsigned char *in = &(*input)[0];
+	unsigned char *out = &(*output)[0];
+
+	c2l(in,l0);
+	c2l(in,l1);
+	ll[0]=l0;
+	ll[1]=l1;
+	if (enc)
+		DES_encrypt3(ll,ks1,ks2,ks3);
+	else
+		DES_decrypt3(ll,ks1,ks2,ks3);
+	l0=ll[0];
+	l1=ll[1];
+	l2c(l0,out);
+	l2c(l1,out);
+}
+
+
+
+DES_LONG DES_cbc_cksum(const unsigned char *in, DES_cblock *output,
+	long length, DES_key_schedule *schedule,
+	const_DES_cblock *ivec)
+{
+	register DES_LONG tout0,tout1,tin0,tin1;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *out = &(*output)[0];
+	const unsigned char *iv = &(*ivec)[0];
+
+	c2l(iv,tout0);
+	c2l(iv,tout1);
+	for (; l>0; l-=8)
+	{
+		if (l >= 8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+		}
+		else
+			c2ln(in,tin0,tin1,l);
+
+		tin0^=tout0; tin[0]=tin0;
+		tin1^=tout1; tin[1]=tin1;
+		DES_encrypt1((DES_LONG *)tin,schedule,_ENCRYPT_);
+		/* fix 15/10/91 eay - thanks to keithr@sco.COM */
+		tout0=tin[0];
+		tout1=tin[1];
+	}
+	if (out != NULL)
+	{
+		l2c(tout0,out);
+		l2c(tout1,out);
+	}
+	tout0=tin0=tin1=tin[0]=tin[1]=0;
+	/*
+	Transform the data in tout1 so that it will
+	match the return value that the MIT Kerberos
+	mit_des_cbc_cksum API returns.
+	*/
+	tout1 = ((tout1 >> 24L) & 0x000000FF)
+		| ((tout1 >> 8L)  & 0x0000FF00)
+		| ((tout1 << 8L)  & 0x00FF0000)
+		| ((tout1 << 24L) & 0xFF000000);
+	return(tout1);
+}
+
+
+#define	CBC_ENC_C__DONT_UPDATE_IV
+
+#ifdef CBC_ENC_C__DONT_UPDATE_IV
+void DES_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,
+	DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
+#else
+void DES_ncbc_encrypt(const unsigned char *in, unsigned char *out, long length,
+	DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
+#endif
+{
+	register DES_LONG tin0,tin1;
+	register DES_LONG tout0,tout1,xor0,xor1;
+	register long l=length;
+	DES_LONG tin[2];
+	unsigned char *iv;
+
+	iv = &(*ivec)[0];
+
+	if (enc)
+	{
+		c2l(iv,tout0);
+		c2l(iv,tout1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0);
+			c2l(in,tin1);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_ENCRYPT_);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+		}
+		if (l != -8)
+		{
+			c2ln(in,tin0,tin1,l+8);
+			tin0^=tout0; tin[0]=tin0;
+			tin1^=tout1; tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_ENCRYPT_);
+			tout0=tin[0]; l2c(tout0,out);
+			tout1=tin[1]; l2c(tout1,out);
+		}
+#ifndef CBC_ENC_C__DONT_UPDATE_IV
+		iv = &(*ivec)[0];
+		l2c(tout0,iv);
+		l2c(tout1,iv);
+#endif
+	}
+	else
+	{
+		c2l(iv,xor0);
+		c2l(iv,xor1);
+		for (l-=8; l>=0; l-=8)
+		{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_DECRYPT_);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2c(tout0,out);
+			l2c(tout1,out);
+			xor0=tin0;
+			xor1=tin1;
+		}
+		if (l != -8)
+		{
+			c2l(in,tin0); tin[0]=tin0;
+			c2l(in,tin1); tin[1]=tin1;
+			DES_encrypt1((DES_LONG *)tin,_schedule,_DECRYPT_);
+			tout0=tin[0]^xor0;
+			tout1=tin[1]^xor1;
+			l2cn(tout0,tout1,out,l+8);
+#ifndef CBC_ENC_C__DONT_UPDATE_IV
+			xor0=tin0;
+			xor1=tin1;
+#endif
+		}
+#ifndef CBC_ENC_C__DONT_UPDATE_IV
+		iv = &(*ivec)[0];
+		l2c(xor0,iv);
+		l2c(xor1,iv);
+#endif
+	}
+	tin0=tin1=tout0=tout1=xor0=xor1=0;
+	tin[0]=tin[1]=0;
+}
+
+
+/* HAS BUGS! DON'T USE - this is only present for use in des.c */
+void DES_3cbc_encrypt(DES_cblock *input, DES_cblock *output, int length,
+	DES_key_schedule ks1, DES_key_schedule ks2, DES_cblock *iv1,
+	DES_cblock *iv2, int enc)
+{
+	int  off=((int)length-1)/8;
+	long l8=((length+7)/8)*8;
+	DES_cblock niv1,niv2;
+
+	if (enc == _ENCRYPT_)
+	{
+		DES_cbc_encrypt((unsigned char*)input,
+			(unsigned char*)output,length,&ks1,iv1,enc);
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv1,output[off],sizeof(DES_cblock));
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,l8,&ks2,iv1,!enc);
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,l8,&ks1,iv2,enc);
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv2,output[off],sizeof(DES_cblock));
+	}
+	else
+	{
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv2,input[off],sizeof(DES_cblock));
+		DES_cbc_encrypt((unsigned char*)input,
+			(unsigned char*)output,l8,&ks1,iv2,enc);
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,l8,&ks2,iv1,!enc);
+		if (length >= (int)sizeof(DES_cblock))
+			memcpy(niv1,output[off],sizeof(DES_cblock));
+		DES_cbc_encrypt((unsigned char*)output,
+			(unsigned char*)output,length,&ks1,iv1,enc);
+	}
+	memcpy(*iv1,niv1,sizeof(DES_cblock));
+	memcpy(*iv2,niv2,sizeof(DES_cblock));
+}
+
+
+void
+DES_SSL_NA_3DES_Decrypt(unsigned char *Crypted_p, unsigned char *_3DES_KEY)
+{
+	DES_key_schedule ks0, ks1, ks2;
+
+	DES_set_key((DES_cblock *) &_3DES_KEY[ 0], &ks0);
+
+	DES_set_key((DES_cblock *) &_3DES_KEY[ 8], &ks1);
+	DES_set_key((DES_cblock *) &_3DES_KEY[16], &ks2);
+
+	DES_ecb3_encrypt((const_DES_cblock *)&Crypted_p[0], (DES_cblock *)&Crypted_p[0], &ks0, &ks1, &ks2, _DECRYPT_);
+	DES_ecb3_encrypt((const_DES_cblock *)&Crypted_p[8], (DES_cblock *)&Crypted_p[8], &ks0, &ks1, &ks2, _DECRYPT_);
+}
+
+
+
+
+void
+DES_drotate(unsigned char *out, unsigned char *in, int n)
+{
+	out += n;
+	do { *(--out)=*(in++); } while (--n);
+}
+
+void
+DES_rotate(unsigned char *in, int count)
+{
+	int j=count-1;
+	int i;
+	unsigned char temp;
+
+	count /= 2;
+	for (i=0; i<count ; i++,j--)
+	{
+		temp  = in[i];
+		in[i] = in[j];
+		in[j] = temp;
+	}
+}
+
+void
+DES_SSL_NA_CBC_Decrypt(unsigned char *Crypted_p, int Crypted_len, unsigned char *_i_KEY)
+{
+	int i;
+	unsigned char tmp[8];
+	DES_key_schedule ks0, ks1;
+
+	DES_drotate(tmp, &_i_KEY[0], 8);
+	DES_set_key((DES_cblock *)tmp, &ks0);
+
+	DES_drotate(tmp, &_i_KEY[8], 8);
+	DES_set_key((DES_cblock *)tmp, &ks1);
+
+	memset(tmp, 0, sizeof(tmp));
+
+	for (i=7; i>=0; i--) DES_rotate(Crypted_p+8*i, 8);
+
+	DES_ede2_cbc_encrypt(Crypted_p, Crypted_p, Crypted_len, &ks0, &ks1, (DES_cblock *)tmp, _DECRYPT_);
+
+	for (i=7; i>=0; i--) DES_rotate(Crypted_p+8*i, 8);
+}
+
+#endif	// #if !defined(WITH_LIBCRYPTO)
+
+
Index: cscrypt/des_ssl.h
===================================================================
--- cscrypt/des_ssl.h	(nonexistent)
+++ cscrypt/des_ssl.h	(working copy)
@@ -0,0 +1,234 @@
+// sky(n)
+/* crypto/des/des.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#if !defined(WITH_LIBCRYPTO)
+
+#ifndef __DES_SSL_H_
+#define __DES_SSL_H_
+
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+enum
+{
+	_DECRYPT_,
+	_ENCRYPT_
+};
+
+typedef unsigned long DES_LONG;
+typedef unsigned char DES_cblock[8];
+typedef unsigned char const_DES_cblock[8];
+/* With "const", gcc 2.8.1 on Solaris thinks that DES_cblock *
+ * and const_DES_cblock * are incompatible pointer types. */
+
+typedef struct DES_ks
+{
+    union
+	{
+		DES_cblock 	cblock;
+		/* make sure things are correct size on machines with
+		 * 8 byte longs */
+		DES_LONG 	deslong[2];
+	} ks[16];
+} DES_key_schedule;
+
+
+#define DES_KEY_SZ 		(sizeof(DES_cblock))
+#define DES_SCHEDULE_SZ (sizeof(DES_key_schedule))
+
+#define DES_ecb2_encrypt(i,o,k1,k2,e) \
+		DES_ecb3_encrypt((i),(o),(k1),(k2),(k1),(e))
+
+#define DES_ede2_cbc_encrypt(i,o,l,k1,k2,iv,e) \
+		DES_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(e))
+
+#define DES_ede2_cfb64_encrypt(i,o,l,k1,k2,iv,n,e) \
+		DES_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n),(e))
+
+#define DES_ede2_ofb64_encrypt(i,o,l,k1,k2,iv,n) \
+		DES_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n))
+
+
+void 	 DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,
+		      	DES_key_schedule *ks1,DES_key_schedule *ks2,
+		      	DES_key_schedule *ks3, int enc);
+DES_LONG DES_cbc_cksum(const unsigned char *input,DES_cblock *output,
+		       	long length,DES_key_schedule *schedule,
+		       	const_DES_cblock *ivec);
+/* DES_cbc_encrypt does not update the IV!  Use DES_ncbc_encrypt instead. */
+void 	 DES_cbc_encrypt(const unsigned char *input,unsigned char *output,
+		     	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		     	int enc);
+void 	 DES_ncbc_encrypt(const unsigned char *input,unsigned char *output,
+		      	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      	int enc);
+void 	 DES_xcbc_encrypt(const unsigned char *input,unsigned char *output,
+		      	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      	const_DES_cblock *inw,const_DES_cblock *outw,int enc);
+void 	 DES_cfb_encrypt(const unsigned char *in,unsigned char *out,int numbits,
+		     	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		     	int enc);
+void 	 DES_ecb_encrypt(const_DES_cblock *input,DES_cblock *output,
+		     	DES_key_schedule *ks,int enc);
+
+/* 	This is the DES encryption function that gets called by just about
+	every other DES routine in the library.  You should not use this
+	function except to implement 'modes' of DES.  I say this because the
+	functions that call this routine do the conversion from 'char *' to
+	long, and this needs to be done to make sure 'non-aligned' memory
+	access do not occur.  The characters are loaded 'little endian'.
+	Data is a pointer to 2 unsigned long's and ks is the
+	DES_key_schedule to use.  enc, is non zero specifies encryption,
+	zero if decryption. */
+void 	 DES_encrypt1(DES_LONG *data,DES_key_schedule *ks, int enc);
+
+/* 	This functions is the same as DES_encrypt1() except that the DES
+	initial permutation (IP) and final permutation (FP) have been left
+	out.  As for DES_encrypt1(), you should not use this function.
+	It is used by the routines in the library that implement triple DES.
+	IP() DES_encrypt2() DES_encrypt2() DES_encrypt2() FP() is the same
+	as DES_encrypt1() DES_encrypt1() DES_encrypt1() except faster :-). */
+void 	 DES_encrypt2(DES_LONG *data,DES_key_schedule *ks, int enc);
+
+void 	 DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,
+		  		DES_key_schedule *ks2, DES_key_schedule *ks3);
+void 	 DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,
+		  		DES_key_schedule *ks2, DES_key_schedule *ks3);
+void 	 DES_ede3_cbc_encrypt(const unsigned char *input,unsigned char *output,
+			  	long length,
+			  	DES_key_schedule *ks1,DES_key_schedule *ks2,
+			  	DES_key_schedule *ks3,DES_cblock *ivec,int enc);
+void 	 DES_ede3_cbcm_encrypt(const unsigned char *in,unsigned char *out,
+			   	long length,
+			   	DES_key_schedule *ks1,DES_key_schedule *ks2,
+			   	DES_key_schedule *ks3,
+			   	DES_cblock *ivec1,DES_cblock *ivec2,
+			   	int enc);
+void 	 DES_ede3_cfb64_encrypt(const unsigned char *in,unsigned char *out,
+			    long length,DES_key_schedule *ks1,
+			    DES_key_schedule *ks2,DES_key_schedule *ks3,
+			    DES_cblock *ivec,int *num,int enc);
+void 	 DES_ede3_cfb_encrypt(const unsigned char *in,unsigned char *out,
+			  	int numbits,long length,DES_key_schedule *ks1,
+			  	DES_key_schedule *ks2,DES_key_schedule *ks3,
+			  	DES_cblock *ivec,int enc);
+void 	 DES_ede3_ofb64_encrypt(const unsigned char *in,unsigned char *out,
+			    long length,DES_key_schedule *ks1,
+			    DES_key_schedule *ks2,DES_key_schedule *ks3,
+			    DES_cblock *ivec,int *num);
+
+void 	 DES_xwhite_in2out(const_DES_cblock *DES_key,const_DES_cblock *in_white,
+		       	DES_cblock *out_white);
+
+int 	 DES_enc_read(int fd,void *buf,int len,DES_key_schedule *sched,
+		 		DES_cblock *iv);
+int 	 DES_enc_write(int fd,const void *buf,int len,DES_key_schedule *sched,
+		  		DES_cblock *iv);
+char 	*DES_fcrypt(const char *buf,const char *salt, char *ret);
+char 	*DES_crypt(const char *buf,const char *salt);
+void 	 DES_ofb_encrypt(const unsigned char *in,unsigned char *out,int numbits,
+		     	long length,DES_key_schedule *schedule,DES_cblock *ivec);
+void 	 DES_pcbc_encrypt(const unsigned char *input,unsigned char *output,
+		      	long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      	int enc);
+DES_LONG DES_quad_cksum(const unsigned char *input,DES_cblock output[],
+				long length,int out_count,DES_cblock *seed);
+int 	 DES_random_key(DES_cblock *ret);
+void 	 DES_set_odd_parity(DES_cblock *key);
+int 	 DES_check_key_parity(const_DES_cblock *key);
+int 	 DES_is_weak_key(const_DES_cblock *key);
+/* DES_set_key (= set_key = DES_key_sched = key_sched) calls
+ * DES_set_key_checked if global variable DES_check_key is set,
+ * DES_set_key_unchecked otherwise. */
+int 	 DES_set_key(const_DES_cblock *key,DES_key_schedule *schedule);
+int 	 DES_key_sched(const_DES_cblock *key,DES_key_schedule *schedule);
+int 	 DES_set_key_checked(const_DES_cblock *key,DES_key_schedule *schedule);
+void 	 DES_set_key_unchecked(const_DES_cblock *key,DES_key_schedule *schedule);
+void 	 DES_string_to_key(const char *str,DES_cblock *key);
+void 	 DES_string_to_2keys(const char *str,DES_cblock *key1,DES_cblock *key2);
+void 	 DES_cfb64_encrypt(const unsigned char *in,unsigned char *out,long length,
+		       	DES_key_schedule *schedule,DES_cblock *ivec,int *num,
+		       int enc);
+void 	 DES_ofb64_encrypt(const unsigned char *in,unsigned char *out,long length,
+		       	DES_key_schedule *schedule,DES_cblock *ivec,int *num);
+
+int 	 DES_read_password(DES_cblock *key, const char *prompt, int verify);
+int 	 DES_read_2passwords(DES_cblock *key1, DES_cblock *key2, const char *prompt,
+				int verify);
+
+#define DES_fixup_key_parity DES_set_odd_parity
+
+
+#define DES_KEY_SCHED(k,s)       				DES_key_sched(k,&s)
+#define DES_ECB_ENCRYPT(c,o,s,d) 				DES_ecb_encrypt(c,o,&s,d)
+#define DES_EDE2_CBC_ENCRYPT(i,o,l,k1,k2,iv,e) 	DES_ede2_cbc_encrypt((i),(o),(l),&k1,&k2,(iv),(e))
+#define DES_ECB2_ENCRYPT(i,o,k1,k2,e) 			DES_ecb2_encrypt((DES_cblock *)(i),(DES_cblock *)(o),&k1,&k2,(e))
+
+
+void	DES_SSL_NA_3DES_Decrypt	(unsigned char *emm_data, unsigned char *_3DES_KEY);
+void	DES_SSL_NA_CBC_Decrypt	(unsigned char *Crypted_p, int Crypted_len, unsigned char *_i_KEY);
+
+#ifdef  __cplusplus
+}
+#endif
+#endif	// __DES_SSL_H_
+#endif	// #if !defined(WITH_LIBCRYPTO)
+
Index: csctapi/atr.c
===================================================================
--- csctapi/atr.c	(revision 1542)
+++ csctapi/atr.c	(working copy)
@@ -36,7 +36,7 @@
  * Exported variables definition
  */
 
-const uint32_t atr_f_table[16] = {372, 372, 558, 744, 1116, 1488, 1860, 0, 0, 512, 768, 1024, 1536, 2048, 0, 0};
+const uint32_t atr_f_table[16] = {372, 372, 612, 744, 1116, 1488, 1860, 0, 0, 512, 768, 1024, 1536, 2048, 0, 0};
 
 const double atr_d_table[16] = {0, 1, 2, 4, 8, 16, 32, 64, 12, 20, 0, 0, 0, 0, 0, 0};
 //const double atr_d_table[16] = {0, 1, 2, 4, 8, 16, 32, 64, 12, 20, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625};
Index: csctapi/cardreaders.h
===================================================================
--- csctapi/cardreaders.h	(revision 1542)
+++ csctapi/cardreaders.h	(working copy)
@@ -2,6 +2,7 @@
 #define CSCTAPI_CARDREADERS_H_
 
 extern const struct s_cardreader cardreader_db2com;
+extern const struct s_cardreader cardreader_internal_hisky;
 extern const struct s_cardreader cardreader_internal_sci;
 extern const struct s_cardreader cardreader_internal_cool;
 extern const struct s_cardreader cardreader_internal_azbox;
Index: csctapi/icc_async.c
===================================================================
--- csctapi/icc_async.c	(revision 1542)
+++ csctapi/icc_async.c	(working copy)
@@ -765,6 +765,11 @@
 				FI = req[2] >> 4;
 				unsigned char DI = req[2] & 0x0F;
 				D = atr_d_table[DI];
+#if defined(WITH_HISILICON)
+				if (IS_CARD_READER(reader)) {
+					if ((D == 32) || (D == 12) || (D == 20)) D = 0;
+				}
+#endif
 				uint32_t F = atr_f_table[FI];
 				PPS_success = 1;
 				rdr_log_dbg(reader, D_ATR, "PTS Succesfull, selected protocol: T%i, F=%d, D=%d, N=%d", reader->protocol_type, F, D, N);
@@ -814,7 +819,7 @@
 		D = ATR_DEFAULT_D;
 		rdr_log(reader, "Warning: D=0 is invalid, forcing D=%d", D);
 	}
-	rdr_log_dbg(reader, D_ATR, "Init card protocol T%i, FI=%d, F=%d, D=%d, N=%d", reader->protocol_type, FI, F, D, N);
+	rdr_log(reader, "Init{%d} card protocol T%i, FI=%d, F=%d, D=%d, N=%d", deprecated, reader->protocol_type, FI, F, D, N);
 	if(deprecated == 0)
 	{
 		return InitCard(reader, atr, FI, D, N, deprecated);
@@ -1212,6 +1217,10 @@
 		reader->worketu *= 2; // overclocked T14 needs this otherwise high ecm reponses
 	}
 
+#if defined(WITH_HISILICON)
+	reader->scideprecated = deprecated;
+#endif
+
 	struct s_cardreader_settings s =
 	{
 		.ETU = ETU,
Index: csctapi/ifd_hisky.c
===================================================================
--- csctapi/ifd_hisky.c	(nonexistent)
+++ csctapi/ifd_hisky.c	(working copy)
@@ -0,0 +1,1337 @@
+/*
+//	sky(n)
+	ifd_hisky.c
+	This module provides IFD handling functions for SCI internal reader.
+*/
+
+#include "../globals.h"
+
+#ifdef CARDREADER_INTERNAL_HISKY
+#include "atr.h"
+#include "ifd_hisky.h"
+//
+//
+//
+#if 1
+	#define	MYSCI_TRACE		myprintf
+#else
+	#define	MYSCI_TRACE(...)
+#endif
+//
+//
+// 	future test...
+#define __HIS_PPSNEGOTIATION__
+//
+//
+//
+#define HI_DEVICE_NAME	"hi_sci"
+#define MAX_TX_TIMEOUT			5000
+#define MAX_RX_TIMEOUT			12000
+#define SUCCESS					0
+#define OK							SUCCESS
+#define ERROR						1
+#define FAILURE 					2
+#define _IS_CARD_INSERTED_(s)	(((s) <= HI_UNF_SCI_STATUS_NOCARD) ? 0 : 1)
+
+#if 0
+static pthread_mutex_t			CUR_Mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+static int							SMC_Inserted  	= 0;
+static HI_UNF_SCI_PROTOCOL_E	SMC_Protocol;
+static int							SMC_Activated 	= FALSE;
+static struct s_reader *		SMC_Readerp  	= NULL;
+
+extern char  *strtoupper(char *s);
+//extern void   cs_sleep  (uint32_t msec);
+extern void   cs_sleepms(uint32_t msec);
+extern int    cs_save_cardinformation(struct s_reader *rdr);
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+uint16_t
+HISCIAPI_ChkCardstatus(struct s_reader *reader)
+{
+	uint16_t	scstatus = 0;
+
+	if (!reader) reader = SMC_Readerp;
+	if ( reader)
+	{
+//		mycs_log("CARDSTATUS:(%p) {%d, %d} {%d}", reader,
+//				reader->restarting, reader->card_status,
+//				SMC_Inserted);
+		if (reader->restarting)
+		{
+			scstatus = SMCSTATUS_RESTART;
+		}
+		else
+		{
+			switch (reader->card_status) {
+				case NO_CARD: 			scstatus = SMCSTATUS_NOCARD; 	break;
+				case CARD_NEED_INIT:	scstatus = SMCSTATUS_INIT; 	break;
+				case CARD_FAILURE:  	scstatus = SMCSTATUS_FAILURE; break;
+				case CARD_INSERTED:	scstatus = SMCSTATUS_OK;		break;
+				case UNKNOWN:
+				default:					scstatus = SMCSTATUS_RESTART;	break;
+			}
+		}
+	}
+	else
+	{
+//		mycs_log("Cardstatus:{%d}", SMC_Inserted);
+		scstatus = (SMC_Inserted) ? SMCSTATUS_DEACTIVE : SMCSTATUS_NOCARD;
+	}
+	return (scstatus);
+}
+
+char *
+HISCIAPI_ChkCardsystem(struct s_reader *reader)
+{
+	static char cards[1025] = {'\0'};
+
+	strcpy(cards, "");
+	if (!reader) reader = SMC_Readerp;
+	if (!reader) return (cards);
+	if ( reader->card_status == NO_CARD) {
+		strcpy(cards, "No smartcard");
+	}
+	else if (reader->card_status == CARD_NEED_INIT) {
+		strcpy(cards, "---");
+	}
+	else if (reader->csystem && reader->csystem->desc) {
+		strcpy(cards, reader->csystem->desc);
+		strtoupper(cards);
+	}
+	else {
+		strcpy(cards, "Unknown card");
+	}
+	return (cards);
+}
+
+bool
+HISCIAPI_SaveCardstatus(struct s_reader *reader)
+{
+	FILE *pf = NULL;
+	char szFile[256];
+
+	if (!reader) reader = SMC_Readerp;
+	strcpy(szFile,"/var/smartcard");
+	if ((pf = fopen(szFile, "w"))==NULL) return 0;
+	fprintf(pf,"status=%d\n", HISCIAPI_ChkCardstatus(reader));
+	fclose(pf);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static void
+HISCI_Msleep(int ms)
+{
+//	cs_sleepms(ms);
+	//cs_sleep(ms);
+	usleep(ms * 1000);
+}
+
+static int
+HISCI_IsAvailable(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+
+	if (!reader) return 0;
+	if ( reader->handle < 0) return 0;
+	enSciPort = reader->scinum;
+	if (enSciPort >= HI_UNF_SCI_PORT_BUTT)
+	{
+		mycs_trace(D_ADB, "hisci:error scinum{%d}", enSciPort);
+		return 0;
+	}
+	return 1;
+}
+
+static int
+HISCI_ChkInserted(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S   SciStatus;
+	HI_S32	Ret;
+	int		bInserted;
+
+	if (!HISCI_IsAvailable(reader)) return 0;
+	enSciPort = reader->scinum;
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.i{%08X}", Ret);
+		bInserted = 0;
+	}
+	else
+	{
+	//	MYSCI_TRACE("mycard:getstatus{%d}\n", SciStatus.enSciStatus);
+		bInserted = _IS_CARD_INSERTED_(SciStatus.enSciStatus);
+	}
+	SMC_Inserted = bInserted;
+	return (bInserted);
+}
+
+
+int32_t
+HISCI_Open(struct s_reader *reader, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 uFs)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_OPEN_S	SciOpen;
+	SCI_LEVEL_S	SciLevel;
+	HI_S32	Ret;
+
+//	MYSCI_TRACE("mycard:open{%d,%d}\n", enSciProtocol, uFs);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	SciOpen.enSciPort		= enSciPort;
+	SciOpen.enSciProtocol= enSciProtocol;
+	SciOpen.Frequency		= uFs;
+	Ret = ioctl(reader->handle, CMD_SCI_OPEN, &SciOpen);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+	//
+	//
+	//
+#if defined(SDKV500) || defined(SDKV600)
+	SCI_IO_OUTPUTTYPE_S SciClk;
+
+	SciClk.enSciPort = enSciPort;
+	SciClk.enIO = SCI_IO_CLK;
+	SciClk.enOutputType = HI_UNF_SCI_MODE_CMOS;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_MODE, &SciClk);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	SCI_IO_OUTPUTTYPE_S SciVcc;
+	SciVcc.enSciPort = enSciPort;
+	SciVcc.enIO = SCI_IO_VCC_EN;
+	SciVcc.enOutputType = HI_UNF_SCI_MODE_CMOS;
+//	SciVcc.enOutputType = HI_UNF_SCI_MODE_OD;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_MODE, &SciVcc);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	SCI_IO_OUTPUTTYPE_S SciReset;
+	SciReset.enSciPort = enSciPort;
+	SciReset.enIO = SCI_IO_RESET;
+	SciReset.enOutputType = HI_UNF_SCI_MODE_CMOS;
+//	SciReset.enOutputType = HI_UNF_SCI_MODE_OD;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_MODE, &SciReset);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+#else
+	SCI_CLK_S SciClk;
+	SciClk.enSciPort = enSciPort;
+//	SciClk.enClkMode = HI_UNF_SCI_CLK_MODE_OD;
+	SciClk.enClkMode = HI_UNF_SCI_CLK_MODE_CMOS;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_CLK_MODE, &SciClk);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+#endif
+
+	SciLevel.enSciPort	= enSciPort;
+	SciLevel.enSciLevel 	= HI_UNF_SCI_LEVEL_LOW;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_VCC, &SciLevel);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	SciLevel.enSciPort	= enSciPort;
+	SciLevel.enSciLevel 	= HI_UNF_SCI_LEVEL_LOW;
+//	SciLevel.enSciLevel 	= HI_UNF_SCI_LEVEL_HIGH;
+	Ret = ioctl(reader->handle, CMD_SCI_CONF_DETECT, &SciLevel);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.o{%08X}!", Ret);
+		return (ERROR);
+	}
+	SMC_Protocol = enSciProtocol;
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCI_Close(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32 Ret;;
+
+//	MYSCI_TRACE("mycard:close\n");
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	SMC_Activated = FALSE;
+	Ret = ioctl(reader->handle, CMD_SCI_CLOSE, &enSciPort);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.c{%08X}!", Ret);
+	}
+	return (Ret == HI_SUCCESS ? SUCCESS : ERROR);
+}
+
+
+int32_t
+HISCI_Deactivate(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32 Ret;
+
+	MYSCI_TRACE("mycard:deactivate\n");
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	Ret = ioctl(reader->handle, CMD_SCI_DEACTIVE, &enSciPort);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.d{%08X}!", Ret);
+	}
+	return (Ret == HI_SUCCESS ? SUCCESS : ERROR);
+}
+
+
+#if 0
+int32_t
+HISCI_SetProtocol(struct s_reader *reader, HI_UNF_SCI_PROTOCOL_E enSciProtocol)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_PROTOCOL_S SciProtocol;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setprotocol{%d}\n", enSciProtocol);
+	enSciPort = reader->scinum;
+	SciProtocol.enSciPort = enSciPort;
+	SciProtocol.enSciProtocol = enSciProtocol;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_PROTOCOL, &SciProtocol);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.p{%08X.%d}!", Ret, SciProtocol.enSciProtocol);
+	}
+	return (Ret == HI_SUCCESS ? SUCCESS : ERROR);
+}
+#endif
+
+
+static int32_t
+HISCI_ChkAtrCompleted(struct s_reader *reader)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	HI_S32	uResetTime;
+	HI_S32	Ret;
+
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort  = reader->scinum;
+	uResetTime = 0;
+	HISCI_Msleep(500);
+	while (1)
+	{
+		/*get SCI card status */
+		SciStatus.enSciPort = enSciPort;
+		Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+		if (Ret != HI_SUCCESS)
+		{
+			mycs_trace(D_ADB, "hisci:io error.a{%08X}!", Ret);
+			return (ERROR);
+		}
+		if (!_IS_CARD_INSERTED_(SciStatus.enSciStatus))
+		{
+			mycs_trace(D_ADB, "hisci:no card{%d}!", SciStatus.enSciStatus);
+			SMC_Inserted = 0;
+			return (ERROR);
+		}
+		if (SciStatus.enSciStatus >= HI_UNF_SCI_STATUS_READY)
+		{
+			/*reset Success*/
+			mycs_trace(D_ADB, "hisci:Atr success");
+			break;
+		}
+//		MYSCI_TRACE("hisci:Atr waiting{%d,%d}...\n", SciStatus.enSciStatus, uResetTime);
+		uResetTime += 1;
+
+		if (uResetTime > 30)
+		{
+			mycs_trace(D_ADB, "hisci:Atr failure");
+			return (FAILURE);
+		}
+		HISCI_Msleep(50);
+	}
+	HISCI_Msleep(100);
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCI_CardReset(struct s_reader *reader, HI_BOOL bWarmReset)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_RESET_S	SciReset;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:resetcard\n");
+	enSciPort = reader->scinum;
+	SciReset.enSciPort	= enSciPort;
+	SciReset.bWarmReset 	= bWarmReset;
+	Ret = ioctl(reader->handle, CMD_SCI_RESET, &SciReset);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.r{%08X}!", Ret);
+		return (ERROR);
+	}
+	Ret = HISCI_ChkAtrCompleted(reader);
+	return (Ret);
+}
+
+
+int32_t
+HISCI_CardSwitch(struct s_reader *reader, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 uFs)
+{
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:switchcard{%d,%d}\n", enSciProtocol, uFs);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	if (HI_UNF_SCI_PROTOCOL_T14 == enSciProtocol)
+	{
+		if ((uFs < 1000) || (uFs > 6000))
+		{
+			mycs_trace(D_ADB, "hisci:error para uFs is invalid{%d}", uFs);
+			return (ERROR);
+		}
+	}
+	else
+	{
+		if ((uFs < 1000) || (uFs > 5000))
+		{
+			mycs_trace(D_ADB, "hisci:error para uFs is invalid{%d}", uFs);
+			return (ERROR);
+		}
+	}
+
+#if 0
+	//	CMD_SCI_SET_PROTOCOL
+	SCI_OPEN_S	SciSwitch;
+	HI_UNF_SCI_PORT_E enSciPort = reader->scinum;
+
+	SciSwitch.enSciPort 	= enSciPort;
+	SciSwitch.enSciProtocol = enSciProtocol;
+	SciSwitch.Frequency 	= uFs;
+	Ret = ioctl(reader->handle, CMD_SCI_SWITCH, &SciSwitch);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.s{%08X}!", Ret);
+		return (ERROR);
+	}
+	Ret = HISCI_ChkAtrCompleted(reader);
+	return (Ret);
+#else
+	Ret = HISCI_Close(reader);
+	Ret = HISCI_Open(reader, enSciProtocol, uFs);
+	if (Ret != SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:open(%d) error!", Ret);
+		return (ERROR);
+	}
+	Ret = HISCI_CardReset(reader, HI_TRUE);
+	return (Ret);
+#endif
+}
+
+
+
+int32_t
+HISCI_GetParameters(struct s_reader *reader, HI_UNF_SCI_PARAMS_S_PTR pParams)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:getparameters\n");
+	enSciPort = reader->scinum;
+	if (!pParams) return (ERROR);
+	pParams->enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_PARAM, pParams);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.g{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetBaudrates(struct s_reader *reader, HI_U32 uClkFactor, HI_U32 uBaudFactor)
+{
+	HI_UNF_SCI_PARAMS_S	SciParams;
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_EXT_BAUD_S	SciBaud;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setbaudrate\n");
+	enSciPort = reader->scinum;
+	if (uClkFactor<372 || uClkFactor>2048)
+	{
+		mycs_trace(D_ADB, "hisci:u32ClkRate(%d) is invalid", uClkFactor);
+		return (ERROR);
+	}
+	if ((uBaudFactor< 1) ||
+		(uBaudFactor>32) ||
+		(1!=uBaudFactor  && (uBaudFactor%2)!=0))
+	{
+		mycs_trace(D_ADB, "hisci:u32BitRate(%d) is invalid", uBaudFactor);
+		return (ERROR);
+	}
+
+	Ret = HISCI_GetParameters(reader, &SciParams);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:getparameters error{%d}", Ret);
+		return (ERROR);
+	}
+	if (SciParams.Fi == uClkFactor && SciParams.Di == uBaudFactor)
+	{
+		mycs_trace(D_ADB, "hisci:setparameters same");
+		return (SUCCESS);
+	}
+
+	SciBaud.enSciPort = enSciPort;
+	SciBaud.ClkRate   = uClkFactor;
+	SciBaud.BitRate   = uBaudFactor;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_BAUD, &SciBaud);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.b{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetGuardTime(struct s_reader *reader, HI_U32 u32GuardTime)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_ADD_GUARD_S   GuardTime;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setguardtime\n");
+	enSciPort = reader->scinum;
+	if (u32GuardTime > 254)
+	{
+		mycs_trace(D_ADB, "hisci:u32GuardTime(%d) is invalid", u32GuardTime);
+		return (ERROR);
+	}
+	GuardTime.enSciPort = enSciPort;
+	GuardTime.AddCharGuard = u32GuardTime;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_CHGUARD, &GuardTime);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.gu{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetCharTimeout(struct s_reader *reader, HI_U32 MaxCharTime)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_CHARTIMEOUT_S Chtimeout;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setchartimeout\n");
+	enSciPort = reader->scinum;
+	if (HI_UNF_SCI_PROTOCOL_T1 == SMC_Protocol)
+	{
+		if (MaxCharTime<12 || MaxCharTime>32779)
+		{
+			mycs_trace(D_ADB, "hisci:MaxCharTime(%d) is invalid", MaxCharTime);
+			return (ERROR);
+		}
+	}
+	else
+	{
+		if (MaxCharTime<960 || MaxCharTime>244800)
+		{
+			mycs_trace(D_ADB, "hisci:MaxCharTime(%d) is invalid", MaxCharTime);
+			return (ERROR);
+		}
+	}
+	Chtimeout.enSciPort = enSciPort;
+	Chtimeout.enSciProtocol = SMC_Protocol;
+	Chtimeout.CharTimeouts	= MaxCharTime;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_CHARTIMEOUT, &Chtimeout);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.ct{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCI_SetBlockTimeout(struct s_reader *reader, HI_U32 MaxBlockTime)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_BLOCKTIMEOUT_S BlkTimeout;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:setblocktimeout\n");
+	enSciPort = reader->scinum;
+	if (MaxBlockTime<971 || MaxBlockTime>491531 )
+	{
+		mycs_trace(D_ADB, "hisci:MaxBlockTime(%d) is invalid", MaxBlockTime);
+		return (ERROR);
+	}
+	BlkTimeout.enSciPort = enSciPort;
+	BlkTimeout.BlockTimeouts = MaxBlockTime;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_BLOCKTIMEOUT, &BlkTimeout);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.bt{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+int32_t
+HISCI_SetTxRetries(struct s_reader *reader, HI_U32 TxRetryTimes)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_TXRETRY_S TxRetry;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:settxretries\n");
+	enSciPort = reader->scinum;
+	if (TxRetryTimes > 7)
+	{
+		mycs_trace(D_ADB, "hisci:TxRetryTimes(%d) is invalid", TxRetryTimes);
+		return (ERROR);
+	}
+	TxRetry.enSciPort = enSciPort;
+	TxRetry.TxRetryTimes = TxRetryTimes;
+	Ret = ioctl(reader->handle, CMD_SCI_SET_TXRETRY, &TxRetry);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.tr{%08X}!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+
+int32_t
+HISCI_ReadAtr(struct s_reader *reader, ATR *pAtr) // reads ATR on the fly: reading and some low levelchecking at the same time
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	HI_S32	   	Ret;
+	SCI_ATR_S  	SciAtr;
+	HI_U8 		Atrbuf[256];
+	int32_t statusreturn =0;
+
+	MYSCI_TRACE("mycard:read_atr\n");
+	enSciPort = reader->scinum;
+	SciAtr.enSciPort 	= enSciPort;
+	SciAtr.pAtrBuf	 	= Atrbuf;
+	SciAtr.BufSize	 	= 255;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_ATR, &SciAtr);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.ra{%08X}!", Ret);
+		return (ERROR);
+	}
+
+#if 0
+	statusreturn = ATR_InitFromArray(pAtr, SciAtr.pAtrBuf, SciAtr.DataLen); // n should be same as atrlength but in case of atr read error its less so do not use atrlenght here!
+	if (statusreturn == ATR_MALFORMED)
+	{
+		mycs_trace(D_ADB, "hisci:error ATR is malformed");
+	}
+	if (statusreturn == ERROR)
+	{
+		mycs_trace(D_ADB, "hisci:error ATR is invalid!");
+		return (ERROR);
+	}
+
+	HI_UNF_SCI_PARAMS_S	SciParams;
+	Ret = HISCI_GetParameters(reader, &SciParams);
+	if (Ret == HI_SUCCESS)
+	{
+		if (SciParams.enProtocolType != SMC_Protocol)
+		{
+			Ret = HISCI_SetProtocol(reader, SciParams.enProtocolType);
+		}
+	}
+#else
+	unsigned char buf[ATR_MAX_SIZE];
+	int32_t n = 0;
+	uint8_t recvlen = SciAtr.DataLen;
+	memcpy(buf, Atrbuf, ATR_MAX_SIZE);
+	rdr_log_dbg(reader, D_IFD, "received ATR length = %d", recvlen);
+
+	if (recvlen < 2)
+	{
+		rdr_log_dbg(reader, D_IFD, "ERROR: only 1 character found in ATR");
+		return ERROR;
+	}
+
+	if (buf[0] == 0x3F) // 3F: card is using inverse convention, 3B = card is using direct convention
+		rdr_log_dbg(reader, D_IFD, "This card uses inverse convention");
+	else
+		rdr_log_dbg(reader, D_IFD, "This card uses direct convention");
+	n++;
+
+	int32_t T0= buf[n];
+	int32_t historicalbytes = T0&0x0F; // num of historical bytes in lower nibble of T0 byte
+	rdr_log_dbg(reader, D_ATR, "ATR historicalbytes should be: %d", historicalbytes);
+	rdr_log_dbg(reader, D_ATR, "Fetching global interface characters for protocol T0"); // protocol T0 always aboard!
+	n++;
+
+	int32_t protocols=1, tck = 0, protocol, protocolnumber;	// protocols = total protocols on card, tck = checksum byte present, protocol = mandatory protocol
+	int32_t D = 0;												// protocolnumber = TDi uses protocolnumber
+	int32_t TDi = T0; // place T0 char into TDi for looped parsing.
+	while (n < recvlen)
+	{
+		if (TDi&0x10)
+		{  //TA Present: 							   //The value of TA(i) is always interpreted as XI || UI if i > 2 and T = 15 ='F'in TD(i?)
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;  //In this case, TA(i) contains the clock stop indicator XI, which indicates the logical
+																  //state the clockline must assume when the clock is stopped, and the class indicator UI,
+			rdr_log_dbg(reader, D_ATR, "TA%d: %02X",protocols,buf[n]);      //which specifies the supply voltage class.
+			if ((protocols >2) && ((TDi&0x0F)==0x0F)) {  // Protocol T15 does not exists, it means mandatory on all ATRs
+				if ((buf[n]&0xC0) == 0xC0) rdr_log_dbg(reader, D_ATR, "Clockline low or high on clockstop");
+				if ((buf[n]&0xC0) == 0x00) rdr_log_dbg(reader, D_ATR, "Clockline not supported on clockstop");
+				if ((buf[n]&0xC0) == 0x40) rdr_log_dbg(reader, D_ATR, "Clockline should be low on clockstop");
+				if ((buf[n]&0xC0) == 0x80) rdr_log_dbg(reader, D_ATR, "Clockline should be high on clockstop");
+				if ((buf[n]&0x3F) == 0x01) rdr_log_dbg(reader, D_ATR, "Voltage class A 4.5~5.5V");
+				if ((buf[n]&0x3F) == 0x02) rdr_log_dbg(reader, D_ATR, "Voltage class B 2.7~3.3V");
+				if ((buf[n]&0x3F) == 0x03) rdr_log_dbg(reader, D_ATR, "Voltage class A 4.5~5.5V and class B 2.7~3.3V");
+				if ((buf[n]&0x3F) == 0x04) rdr_log_dbg(reader, D_ATR, "Voltage RFU");
+			}
+			if ((protocols >2) && ((TDi&0x0F)==0x01)) {  // Protocol T1 specfic (There is always an obsolete T0 protocol!)
+				int32_t ifsc = buf[n];
+				if (ifsc == 0x00) ifsc = 32; //default is 32
+				rdr_log_dbg(reader, D_ATR, "Maximum information field length this card can receive is %d bytes (IFSC)", ifsc);
+			}
+
+			if (protocols < 2) {
+				int32_t FI = (buf[n]>>4); // FI is high nibble                  ***** work ETU = (1/D)*(Frequencydivider/cardfrequency) (in seconds!)
+				int32_t F  = atr_f_table[FI]; // lookup the frequency divider
+				float fmax = atr_fs_table[FI]; // lookup the max frequency      ***** initial ETU = 372 / initial frequency during atr  (in seconds!)
+
+				int32_t DI = (buf[n]&0x0F); // DI is low nibble
+				D = atr_d_table[DI]; // lookup the bitrate adjustment (yeah there are floats in it, but in iso only integers!?)
+				rdr_log_dbg(reader, D_ATR, "Advertised max cardfrequency is %.2f (Fmax), frequency divider is %d (F)", fmax/1000000L, F); // High nibble TA1 contains cardspeed
+				rdr_log_dbg(reader, D_ATR, "Bitrate adjustment is %d (D)", D); // Low nibble TA1 contains Bitrateadjustment
+				rdr_log_dbg(reader, D_ATR, "Work ETU = %.2f us", (double) ((1/(double)D)*((double)F/(double)fmax)*1000000)); // And display it...
+				rdr_log_dbg(reader, D_ATR, "Initial ETU = %.2f us", (double)372/(double)fmax*1000000); // And display it... since D=1 and frequency during ATR fetch might be different!
+			}
+			if (protocols > 1 && protocols <3) {
+				if ((buf[n]&0x80)==0x80) rdr_log_dbg(reader, D_ATR, "Switching between negotiable mode and specific mode is not possible");
+				else {
+					rdr_log_dbg(reader, D_ATR, "Switching between negotiable mode and specific mode is possible");
+					// int32_t PPS = 1; Stupid compiler, will need it later on eventually
+				}
+				if ((buf[n]&0x01)==0x01) rdr_log_dbg(reader, D_ATR, "Transmission parameters implicitly defined in the interface characters.");
+				else rdr_log_dbg(reader, D_ATR, "Transmission parameters explicitly defined in the interface characters.");
+
+				protocol = buf[n]&0x0F;
+				if (protocol) rdr_log_dbg(reader, D_ATR, "Protocol T = %d is to be used!", protocol);
+			}
+			n++; // next interface character
+		}
+		if (TDi&0x20)
+		{	 //TB Present
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+			rdr_log_dbg(reader, D_ATR, "TB%d: %02X",protocols,buf[n]);
+			if ((protocols >2) && ((TDi&0x0F)==0x01)) {  // Protocol T1 specfic (There is always an obsolete T0 protocol!)
+				int32_t CWI = (buf[n]&0x0F); // low nibble contains CWI code for the character waiting time CWT
+				int32_t BWI = (buf[n]>>4); // high nibble contains BWI code for the block waiting time BWT
+				int32_t CWT = (1<<CWI) + 11; // in work etu  *** 2^CWI + 11 work etu ***
+				rdr_log_dbg(reader, D_ATR, "Protocol T1: Character waiting time is %d work etu (CWT)", CWT);
+				int32_t BWT = (int) ((1<<BWI) * 960 * 372); // divided by frequency and add with 11 work etu *** 2^BWI*960*372/f + 11 work etu ***
+				rdr_log_dbg(reader, D_ATR, "Protocol T1: Block waiting time is %d divided by actual cardfrequency + 11 work etu (BWI)", BWI);
+				rdr_log_dbg(reader, D_ATR, "Protocol T1: BWT: %d", BWT);
+			}
+
+			n++; // next interface character
+		}
+		if (TDi&0x40)
+		{	 //TC Present
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+			rdr_log_dbg(reader, D_ATR, "TC%d: %02X",protocols, buf[n]);
+			if ((protocols > 1) && ((TDi&0x0F)==0x00)) {
+				int32_t WI = buf[n];
+				rdr_log_dbg(reader, D_ATR, "Protocol T0: work wait time is %d work etu (WWT)", (int) (960*D*WI));
+			}
+			if ((protocols > 1) && ((TDi&0x0F)==0x01)) {
+				if (buf[n]&0x01) rdr_log_dbg(reader, D_ATR, "Protocol T1: CRC is used to compute the error detection code");
+				else rdr_log_dbg(reader, D_ATR, "Protocol T1: LRC is used to compute the error detection code");
+			}
+			if ((protocols < 2) && (buf[n]<0xFF)) rdr_log_dbg(reader, D_ATR, "Extra guardtime of %d ETU (N)", (int) buf[n]);
+			if ((protocols < 2) && (buf[n]==0xFF)) rdr_log_dbg(reader, D_ATR, "Protocol T1: Standard 2 ETU guardtime is lowered to 1 ETU");
+
+			n++; // next interface character
+		}
+		if (TDi&0x80)
+		{	//TD Present? Get next TDi there will be a next protocol
+			//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+			rdr_log_dbg(reader, D_ATR, "TD%d %02X",protocols,buf[n]);
+			TDi = buf[n];
+			protocolnumber = TDi&0x0F;
+			if (protocolnumber == 0x00) tck = 0; // T0 protocol do not use tck byte  (TCK = checksum byte!)
+			if (protocolnumber == 0x0E) tck = 1; // T14 protocol tck byte should be present
+			if (protocolnumber == 0x01) tck = 1; // T1 protocol tck byte is mandatory, BTW: this code doesnt calculate if the TCK is valid jet...
+			rdr_log_dbg(reader, D_ATR, "Fetching global interface characters for protocol T%d:", (TDi&0x0F)); // lower nibble contains protocol number
+			protocols++; // there is always 1 protocol T0 in every ATR as per iso defined, max is 16 (numbered 0..15)
+
+			n++; // next interface character
+		}
+		else break;
+	}
+	int32_t atrlength = 0;
+	atrlength += n;
+	atrlength += historicalbytes;
+	rdr_log_dbg(reader, D_ATR, "Total ATR Length including %d historical bytes should be %d",historicalbytes,atrlength);
+	if (T0&0x80) protocols--;	// if bit 8 set there was a TD1 and also more protocols, otherwise this is a T0 card: substract 1 from total protocols
+	rdr_log_dbg(reader, D_ATR, "Total protocols in this ATR is %d",protocols);
+
+	while (n < atrlength + tck)
+	{ // read all the rest and mandatory tck byte if other protocol than T0 is used.
+		//if (IO_Serial_Read(reader, 0, timeout, 1, buf+n)) break;
+		n++;
+	}
+
+	if (n!=atrlength+tck) cs_log("Warning reader %s: Total ATR characters received is: %d instead of expected %d", reader->label, n, atrlength+tck);
+
+	if ((buf[0] != 0x3B) && (buf[0] != 0x3F) && (n>9 && !memcmp(buf+4, "IRDETO", 6))) //irdeto S02 reports FD as first byte on dreambox SCI, not sure about SH4 or phoenix
+		  buf[0]  = 0x3B;
+
+	statusreturn = ATR_InitFromArray (pAtr, buf, n); // n should be same as atrlength but in case of atr read error its less so do not use atrlenght here!
+
+	if (statusreturn == ATR_MALFORMED) cs_log("Warning reader %s: ATR is malformed, you better inspect it with a -d2 log!", reader->label);
+
+	if (statusreturn == ERROR) {
+		cs_log("Warning reader %s: ATR is invalid!", reader->label);
+		return ERROR;
+	}
+#endif
+	return (SUCCESS); // return (OK) but atr might be softfailing!
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+int32_t
+HISCIAPI_Initialize(struct s_reader *reader)
+{
+	HI_UNF_SCI_PROTOCOL_E enSciProtocol;
+	HI_U32	uFs;
+	HI_S32	Ret;
+
+	MYSCI_TRACE("mycard:initialize(%s)\n", HI_DEVICE_NAME);
+	reader->card_status	= NO_CARD;
+	reader->use_gpio 		= 0;
+	reader->resetcounter = 0;
+	reader->mhz 			= 9600;
+	SMC_Readerp = reader;
+	HISCIAPI_SaveCardstatus(reader);
+	cs_save_cardinformation(reader);
+
+	reader->scinum = HI_UNF_SCI_PORT0;
+	reader->handle = open("/dev/"HI_DEVICE_NAME, O_RDWR, 0);
+	if (reader->handle < 0)
+	{
+		mycs_trace(D_ADB, "hisci:error:%s", HI_DEVICE_NAME);
+		return (ERROR);
+	}
+	//
+	//
+	//
+	#if 1
+	uFs = 3570;
+//	uFs = 3692;
+	enSciProtocol = HI_UNF_SCI_PROTOCOL_T0;
+	#else
+	uFs = 6000;
+	enSciProtocol = HI_UNF_SCI_PROTOCOL_T14;
+	#endif
+	Ret = HISCI_Open(reader, enSciProtocol, uFs);
+	if (Ret != SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:open(%d) error!", Ret);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_Terminates(struct s_reader *reader)
+{
+	HI_S32 Ret;
+
+	MYSCI_TRACE("mycard:terminate(%s)\n", HI_DEVICE_NAME);
+	HISCIAPI_SaveCardstatus(reader);
+	cs_save_cardinformation(reader);
+	if (reader->handle < 0) return (ERROR);
+	HISCI_Close(reader);
+
+	Ret = close(reader->handle);
+//	pthread_mutex_destroy(&CUR_Mutex);
+	if (HI_SUCCESS != Ret)
+	{
+		mycs_trace(D_ADB, "hisci:close error{%d}!", Ret);
+		return (ERROR);
+	}
+	reader->handle = -1;
+	SMC_Readerp = NULL;
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_GetStatus(struct s_reader *reader, int32_t *status)
+{
+	*status = 0;
+	if (HISCI_ChkInserted(reader)) *status = 1;
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_DoReset(struct s_reader *UNUSED(reader), struct s_ATR *UNUSED(pAtr),
+	int32_t (*rdr_activate_card) (struct s_reader *, struct s_ATR *, uint16_t deprecated),
+	int32_t (*rdr_get_cardsystem)(struct s_reader *, struct s_ATR *))
+{
+	MYSCI_TRACE("mycard:doreset\n");
+	SMC_Activated = FALSE;
+	if (rdr_activate_card)
+	{
+	}
+	if (rdr_get_cardsystem)
+	{
+	}
+	return (SUCCESS);
+}
+
+#define	MAX_SWITCH_TRIES	4	// 2
+
+int32_t
+HISCIAPI_Activate(struct s_reader *reader, ATR *pAtr)
+{
+	HI_U32	uFs;
+	HI_S32	Ret;
+	HI_S32	uTries = 0;
+
+	MYSCI_TRACE("mycard:activate{%d,%d}\n", SMC_Protocol, SMC_Activated);
+	if (!HISCI_ChkInserted(reader))
+	{
+		mycs_trace(D_ADB, "hisci:card none");
+		return (ERROR);
+	}
+	if (reader->ins7e11_fast_reset)
+	{
+		rdr_log(reader, "Doing fast reset");
+		Ret = HISCI_CardReset(reader, HI_TRUE);
+		if (Ret == SUCCESS)
+		{
+			Ret = HISCI_ReadAtr(reader, pAtr);
+		}
+	}
+	else
+	if (!SMC_Activated)
+	{
+		Ret = HISCI_CardReset(reader, HI_FALSE);
+		if (Ret == FAILURE)
+		{
+			while (uTries++ < MAX_SWITCH_TRIES)
+			{
+				//	(T0,T1),T14
+				HISCI_Msleep(100);
+				SMC_Protocol = (SMC_Protocol == HI_UNF_SCI_PROTOCOL_T14) ? HI_UNF_SCI_PROTOCOL_T0 : HI_UNF_SCI_PROTOCOL_T14;
+				uFs = (SMC_Protocol == HI_UNF_SCI_PROTOCOL_T14) ? 6000 : 3570;
+				Ret = HISCI_CardSwitch(reader, SMC_Protocol, uFs);
+				if (Ret == SUCCESS) break;
+			}
+		}
+
+		if (Ret == SUCCESS)
+		{
+			Ret = HISCI_ReadAtr(reader, pAtr);
+		}
+		SMC_Activated = TRUE;
+	}
+	else
+	{
+		Ret = HISCI_CardReset(reader, HI_FALSE);
+		if (Ret == SUCCESS)
+		{
+			Ret = HISCI_ReadAtr(reader, pAtr);
+		}
+	}
+	return (Ret);
+}
+
+
+#if 0
+int32_t
+HISCIAPI_WriteSettings3(struct s_reader *reader,
+	uint32_t ETU, uint32_t WWT, uint32_t I)
+{
+	MYSCI_TRACE("mycard:write_settings3{%d,%d,%d}\n", ETU, WWT, I);
+	return (SUCCESS);
+}
+
+int32_t
+HISCIAPI_WriteSettings2(struct s_reader *reader,
+	uint16_t F, uint8_t D, uint32_t WWT, uint32_t EGT, uint32_t BGT)
+{
+	MYSCI_TRACE("mycard:write_settings2{%d,%d}\n", EGT, BGT);
+	return (SUCCESS);
+}
+#endif
+
+
+int32_t
+HISCIAPI_WriteSettings(struct s_reader *reader, struct s_cardreader_settings *s)
+{
+	if (reader->scideprecated)
+	{
+		// future test.
+		MYSCI_TRACE("mycard:writesettings(deprecated)\n");
+		return (SUCCESS);
+	}
+//	MYSCI_TRACE("mycard:writesettings{%d,%d} {%d,%d,%d, %d,%d}\n",
+//			Fi, Di, ETU, EGT, P, I, Ni);
+	mycs_trace(D_ADB, "mycard:writesettings{%d,%d}", s->Fi, s->Di);
+	if (s->Fi == 372) return (SUCCESS);
+	if (s->Fi == 612) return (SUCCESS);
+	HISCI_SetBaudrates(reader, s->Fi, s->Di);
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_Transmit(struct s_reader *reader, unsigned char *buffer, uint32_t size, uint32_t UNUSED(expectedlen), uint32_t UNUSED(delay), uint32_t timeout)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	SCI_DATA_S		SciData;
+	HI_U32	u32ActLen;
+	HI_S32	Ret;
+
+//	MYSCI_TRACE("mycard:transmit{%3d,%d}\n", size, timeout);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+   if (timeout < MAX_TX_TIMEOUT) timeout = MAX_TX_TIMEOUT;
+	enSciPort = reader->scinum;
+	if (!buffer)
+	{
+		mycs_trace(D_ADB, "hisci:error transmit buffer!");
+		return (ERROR);
+	}
+
+	if (!size)
+	{
+		mycs_trace(D_ADB, "hisci:transmit size?{%d}", size);
+		return (ERROR);
+	}
+
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.wstatus{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	if (SciStatus.enSciStatus < HI_UNF_SCI_STATUS_READY)
+	{
+		if (!_IS_CARD_INSERTED_(SciStatus.enSciStatus)) SMC_Inserted = 0;
+		mycs_trace(D_ADB, "hisci:current state cann't execute send opertaion");
+		return (ERROR);
+	}
+	SciData.enSciPort = enSciPort;
+	SciData.pDataBuf  = buffer;
+	SciData.BufSize   = size;
+	SciData.TimeoutMs = timeout;
+	Ret = ioctl(reader->handle, CMD_SCI_SEND_DATA, &SciData);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.w{%d.%08X, %d}!", size, Ret, timeout);
+		return (ERROR);
+	}
+	u32ActLen = SciData.DataLen;
+	if (u32ActLen < size)
+	{
+		mycs_trace(D_ADB, "hisci:transmit size error{%d,%d}!", u32ActLen, size);
+		return (ERROR);
+	}
+	return (SUCCESS);
+}
+
+
+int32_t
+HISCIAPI_Receive(struct s_reader *reader, unsigned char *buffer, uint32_t size, uint32_t UNUSED(delay), uint32_t timeout)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	SCI_DATA_S		SciData;
+	HI_U32	u32ActLen;
+	HI_S32	Ret;
+
+//	MYSCI_TRACE("mycard:receive.{%3d,%d}\n", size, timeout);
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	timeout = MAX_RX_TIMEOUT;
+	enSciPort = reader->scinum;
+	if (!buffer)
+	{
+		mycs_trace(D_ADB, "hisci:error receive buffer!");
+		return (ERROR);
+	}
+	if (!size)
+	{
+		mycs_trace(D_ADB, "hisci:receive size?{%d}", size);
+		return (SUCCESS);
+	}
+
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.rstatus{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	if (SciStatus.enSciStatus < HI_UNF_SCI_STATUS_READATR)
+	{
+		if (!_IS_CARD_INSERTED_(SciStatus.enSciStatus)) SMC_Inserted = 0;
+		mycs_trace(D_ADB, "hisci:current state cann't execute send opertaion");
+		return (ERROR);
+	}
+
+	SciData.enSciPort = enSciPort;
+	SciData.pDataBuf  = buffer;
+	SciData.BufSize   = size;
+	SciData.TimeoutMs = timeout;
+	Ret = ioctl(reader->handle, CMD_SCI_RECEIVE_DATA, &SciData);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.r{%08X}!", Ret);
+		return (ERROR);
+	}
+
+	u32ActLen = SciData.DataLen;
+	if (u32ActLen < size)
+	{
+		mycs_trace(D_ADB, "hisci:error receive size{%d,%d}!", u32ActLen, size);
+		return (ERROR);
+	}
+	return Ret;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#if defined(__HIS_PPSNEGOTIATION__)
+int32_t
+HISCIAPI_PpsExchange(struct s_reader *reader, unsigned char *params, unsigned *length, uint32_t lenrequest)
+{
+	HI_UNF_SCI_PORT_E enSciPort;
+	SCI_STATUS_S	SciStatus;
+	HI_S32	Ret;
+
+	if (!HISCI_IsAvailable(reader)) return (ERROR);
+	enSciPort = reader->scinum;
+	SciStatus.enSciPort = enSciPort;
+	Ret = ioctl(reader->handle, CMD_SCI_GET_STATUS, &SciStatus);
+	if (Ret != HI_SUCCESS)
+	{
+		mycs_trace(D_ADB, "hisci:io error.e{%08X}!", Ret);
+		return (ERROR);
+	}
+	if (!params) return (ERROR);
+	if (!length) return (ERROR);
+	if (!lenrequest) return (ERROR);
+
+	#if 0
+	{
+		SCI_PPS_S	SciPPS;
+
+		MYSCI_TRACE("mycard:ppsexchange{%d}\n", lenrequest);
+		memcpy((HI_U8 *)SciPPS.Send, params, lenrequest);
+		SciPPS.enSciPort= enSciPort;
+		SciPPS.SendLen	= lenrequest;
+		SciPPS.RecTimeouts = MAX_RX_TIMEOUT;
+		Ret = ioctl(reader->handle, CMD_SCI_SEND_PPS_DATA, &SciPPS);
+		if (Ret != HI_SUCCESS)
+		{
+			mycs_trace(D_ADB, "hisci:io error.e{%08X}!", Ret);
+			return (ERROR);
+		}
+
+		SciPPS.enSciPort = enSciPort;
+		Ret = ioctl(reader->handle, CMD_SCI_GET_PPS_DATA, &SciPPS);
+		if (Ret != HI_SUCCESS)
+		{
+			mycs_trace(D_ADB, "hisci:io error.e{%08X}!", Ret);
+			return (ERROR);
+		}
+		memcpy(params,(HI_U8 *)SciPPS.Receive, SciPPS.ReceiveLen);
+		*length = SciPPS.ReceiveLen;
+		if ((lenrequest != SciPPS.ReceiveLen) || (memcmp (params, SciPPS.Receive, lenrequest)))
+		{
+			mycs_trace(D_ADB, "hisci:pps error{%d,%d}!", lenrequest, SciPPS.ReceiveLen);
+			return (ERROR);
+		}
+		mycs_trace(D_ADB, "hisci:pts succesfull:FI=%d, DI=%d", params[2] >> 4, params[2] & 0x0F);
+	}
+	#else
+		MYSCI_TRACE("mycard:ppsexchange{none}\n");
+	#endif
+	return (SUCCESS);
+}
+#endif	// defined(__HIS_PPSNEGOTIATION__)
+
+void
+HISCIAPI_DisplayMessages(struct s_reader *reader, char *messages)
+{
+	if (!HISCI_IsAvailable(reader)) return;
+	if (!messages) return;
+	myprintf("mycard:displaymessages{%d}{%04X,%s}......\n",
+				 reader->restarting,
+ 				 reader->caid,
+ 				 messages);
+	reader->restarting = 0;
+}
+
+
+#if 0
+int32_t
+HISCIAPI_InitLocks(struct s_reader *reader)
+{
+//	UNAVAILABLE
+//	pthread_mutex_init(&CUR_Mutex, NULL);
+//	MYSCI_TRACE("mycard:initlocks......\n");
+	return (SUCCESS);
+}
+
+
+void
+HISCIAPI_Lock(struct s_reader *reader)
+{
+//	UNAVAILABLE
+//	MYSCI_TRACE("mycard:lock......\n");
+//	pthread_mutex_lock(&CUR_Mutex);
+}
+
+
+void
+HISCIAPI_Unlock(struct s_reader *reader)
+{
+//	UNAVAILABLE
+//	MYSCI_TRACE("mycard:unlock......\n");
+//	pthread_mutex_unlock(&CUR_Mutex);
+}
+
+
+int32_t
+HISCIAPI_SetParity(struct s_reader *reader, uchar parity)
+{
+//	UNAVAILABLE
+	MYSCI_TRACE("mycard:setparity{%d}......\n", parity);
+	return (SUCCESS);
+}
+
+int32_t
+HISCIAPI_SetBaudrate(struct s_reader *reader, uint32_t baudrate)
+{
+//	UNAVAILABLE
+	MYSCI_TRACE("mycard:setbaudrate{%d}......\n", baudrate);
+	return (SUCCESS);
+}
+
+void
+HISCIAPI_SetTransmitTimeout(struct s_reader *reader)
+{
+//	UNAVAILABLE
+	MYSCI_TRACE("mycard:settransmittimeout......\n");
+}
+
+
+bool
+HISCIAPI_SetDtsRts(struct s_reader *reader, int32_t *dtr, int32_t *rts)
+{
+	// UNAVAILABLE
+	MYSCI_TRACE("mycard:setdtsrts{%d,%d}......\n", *dtr, *rts);
+	return (SUCCESS);
+}
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//======================================================================
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+const struct s_cardreader cardreader_internal_hisky =
+{
+//	MYSCI_TRACE("CARDREADER_INTERNAL_HISKY......\n");
+	.desc					= "internal",
+	.typ					= R_INTERNAL,
+	.flush 				= 0,
+	.max_clock_speed	= 1,
+	.need_inverse		= 0,
+//	.timings_in_etu	= 1,
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+	.reader_init		= HISCIAPI_Initialize,
+	.get_status			= HISCIAPI_GetStatus,
+	.activate			= HISCIAPI_Activate,
+	.transmit			= HISCIAPI_Transmit,
+	.receive				= HISCIAPI_Receive,
+	.close 				= HISCIAPI_Terminates,
+	.write_settings	= HISCIAPI_WriteSettings,
+//	.write_settings2	= HISCIAPI_WriteSettings2,
+//	.write_settings3	= HISCIAPI_WriteSettings3,
+	.do_reset			= HISCIAPI_DoReset,
+	#if defined(__HIS_PPSNEGOTIATION__)
+	.set_protocol		= HISCIAPI_PpsExchange,
+	#endif	// defined(__HIS_PPSNEGOTIATION__)
+	//------------------------------------------------------------------
+	//------------------------------------------------------------------
+//	.lock_init 			= HISCIAPI_InitLocks,
+//	.lock					= HISCIAPI_Lock,
+//	.unlock				= HISCIAPI_Unlock,
+//	.set_parity			= HISCIAPI_SetParity,
+//	.set_baudrate		= HISCIAPI_SetBaudrate,
+//	.set_transmit_timeout	= HISCIAPI_SetTransmitTimeout,
+//	.set_DTS_RTS		= HISCIAPI_SetDtsRts,
+	.display_msg		= HISCIAPI_DisplayMessages,
+};
+
+#endif
Index: csctapi/ifd_hisky.h
===================================================================
--- csctapi/ifd_hisky.h	(nonexistent)
+++ csctapi/ifd_hisky.h	(working copy)
@@ -0,0 +1,309 @@
+#ifndef _ifd_hisky_h_
+#define _ifd_hisky_h_
+
+#if defined(SDKV600)
+#define	CHIP_TYPE_hi3796mv100
+#include "drv_sci_ioctl.h"
+#elif defined(SDKV500)
+#define	CHIP_TYPE_hi3716cv200
+#include "drv_sci_ioctl.h"
+#else
+//
+//
+//	#define	__HISCI_IOCTL_AVAILABLE__
+//
+//
+// $ANDROID_BUILD_TOP/device/hisilicon/godbox/driver/sdk/msp_base
+// $ANDROID_BUILD_TOP/device/hisilicon/godbox/driver/sdk/msp_base/ecs/include
+// $ANDROID_BUILD_TOP/device/hisilicon/godbox/driver/sdk/msp_base/common/include
+typedef unsigned char       HI_U8;
+typedef unsigned char       HI_UCHAR;
+typedef unsigned short      HI_U16;
+typedef unsigned int        HI_U32;
+
+typedef char                HI_S8;
+typedef short               HI_S16;
+typedef int                 HI_S32;
+
+typedef char                HI_CHAR;
+typedef char*               HI_PCHAR;
+
+typedef float               HI_FLOAT;
+typedef double              HI_DOUBLE;
+typedef void                HI_VOID;
+typedef unsigned int	    	 HI_HANDLE;
+
+typedef unsigned long       HI_SIZE_T;
+typedef unsigned long       HI_LENGTH_T;
+
+typedef int                 STATUS;
+
+#ifndef WIN32
+typedef unsigned long long  HI_U64;
+typedef long long           HI_S64;
+typedef unsigned long long  HI_PTS_TIME;
+#else
+typedef __int64             HI_U64;
+typedef __int64             HI_S64;
+typedef __int64             HI_PTS_TIME;
+#endif
+
+#if 0
+#define _IOC_NRBITS 		8
+#define _IOC_TYPEBITS 		8
+#define _IOC_SIZEBITS 		14
+#define _IOC_DIRBITS 		2
+
+#define _IOC_NRMASK 		((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK 		((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK 		((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK 		((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT 		0
+#define _IOC_TYPESHIFT 		(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT 		(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT 		(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+#define _IOC_NONE 			0U
+#define _IOC_WRITE 			1U
+#define _IOC_READ 			2U
+
+#define _IOC(dir,type,nr,size)   (((dir) << _IOC_DIRSHIFT) | ((type) << _IOC_TYPESHIFT) | ((nr) << _IOC_NRSHIFT) |   ((size) << _IOC_SIZESHIFT))
+#define _IOC_TYPECHECK(t)   	((sizeof(t) == sizeof(t[1]) && sizeof(t) < (1 << _IOC_SIZEBITS)) ?   sizeof(t) : __invalid_size_argument_for_IOC)
+
+#define _IO(type,nr) 			_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size) 		_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOW(type,nr,size) 		_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOWR(type,nr,size) 	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOR_BAD(type,nr,size) 	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW_BAD(type,nr,size) 	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR_BAD(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+#endif
+
+typedef enum
+{
+    HI_FALSE    = 0,
+    HI_TRUE     = 1
+} HI_BOOL;
+
+#define HI_SUCCESS 			0
+#define HI_FAILURE      	(-1)
+
+
+/* constants */
+#define HI_ID_SCI				0x45
+
+/**Output configuration of the smart card interface clock (SCICLK) pin*/
+/**CNcomment:SCICLK????????????*/
+typedef enum  hiUNF_SCI_CLK_MODE_E
+{
+    HI_UNF_SCI_CLK_MODE_CMOS = 0,   /**<Complementary metal-oxide semiconductor (CMOS) output*/   /**<CNcomment:CMOS????*/
+    HI_UNF_SCI_CLK_MODE_OD,         /**<Open drain (OD) output*/                                  /**<CNcomment:OD????*/
+    HI_UNF_SCI_CLK_MODE_BUTT
+}HI_UNF_SCI_CLK_MODE_E;
+
+/**SCI port*/
+/**CNcomment:SCI ?˿? */
+typedef enum hiUNF_SCI_PORT_E
+{
+    HI_UNF_SCI_PORT0,      /**< SCI port 0*/  /**<CNcomment:SCI?˿?0*/
+    HI_UNF_SCI_PORT1,      /**< SCI port 1*/  /**<CNcomment:SCI?˿?1*/
+    HI_UNF_SCI_PORT_BUTT
+}HI_UNF_SCI_PORT_E;
+
+/**Status of the SCI card*/
+/**CNcomment:???ܿ?״̬ */
+typedef enum hiUNF_SCI_STATUS_E
+{
+    HI_UNF_SCI_STATUS_UNINIT     = 0,   /**<The SCI card is not initialized.*/               /**<CNcomment: SCIδ??ʼ?? */
+    HI_UNF_SCI_STATUS_FIRSTINIT,        /**<The SCI card is being initialized.*/             /**<CNcomment:SCI??ʼ????????*/
+    HI_UNF_SCI_STATUS_NOCARD,           /**<There is no SCI card.*/                          /**<CNcomment:?޿? */
+    HI_UNF_SCI_STATUS_INACTIVECARD,     /**<The SCI card is not activated (unavailable).*/   /**<CNcomment:??δ???ɼ??????Ч?? */
+ //   HI_UNF_SCI_STATUS_CARDFAULT,		  /**<The SCI card is faulty.*/                        /**<CNcomment:??????*/
+    HI_UNF_SCI_STATUS_WAITATR,          /**<The SCI card is waiting for the ATR data.*/      /**<CNcomment:?ȴ?ATR*/
+    HI_UNF_SCI_STATUS_READATR,          /**<The SCI card is receiving the ATR data.*/        /**<CNcomment:???ڽ???ATR*/
+    HI_UNF_SCI_STATUS_READY,            /**<The SCI card is available (activated).*/         /**<CNcomment:??????ʹ?ã?????? */
+    HI_UNF_SCI_STATUS_RX,               /**<The SCI card is busy receiving data.*/           /**<CNcomment:??æ???????????У? */
+    HI_UNF_SCI_STATUS_TX                /**<The SCI card is busy transmitting data.*/        /**<CNcomment:??æ???????????У? */
+} HI_UNF_SCI_STATUS_E;
+
+/**SCI protocol*/
+/**CNcomment:SCI Э?? */
+typedef enum hiUNF_SCI_PROTOCOL_E
+{
+    HI_UNF_SCI_PROTOCOL_T0,    /**<7816 T0 protocol*/   /**<CNcomment:7816 T0 Э?? */
+    HI_UNF_SCI_PROTOCOL_T1,    /**<7816 T1 protocol*/   /**<CNcomment:7816 T1 Э?? */
+    HI_UNF_SCI_PROTOCOL_T14 ,  /**<7816 T14 protocol*/  /**<CNcomment:7816 T14 Э?? */
+    HI_UNF_SCI_PROTOCOL_BUTT
+}HI_UNF_SCI_PROTOCOL_E;
+
+/**SCI active level*/
+/**CNcomment:SCI??Ч??ƽ*/
+typedef enum hiUNF_SCI_LEVEL_E
+{
+    HI_UNF_SCI_LEVEL_LOW,    /**<Active low*/   /**<CNcomment:?͵?ƽ??Ч */
+    HI_UNF_SCI_LEVEL_HIGH,   /**<Active high*/  /**<CNcomment:?ߵ?ƽ??Ч */
+    HI_UNF_SCI_LEVEL_BUTT
+}HI_UNF_SCI_LEVEL_E ;
+
+/**SCI system parameters*/
+/**CNcomment:SCI ϵͳ???? */
+typedef struct hiUNF_SCI_PARAMS_S
+{
+	HI_UNF_SCI_PORT_E enSciPort;		      /**<SCI port ID*/                                          	/**<CNcomment:SCI ?˿ں? */
+	HI_UNF_SCI_PROTOCOL_E enProtocolType; /**<Used protocol type*/                                    /**<CNcomment:ʹ?õ?Э?????? */
+	HI_U32 ActalClkRate;	                /**<Actual clock rate conversion factor F*/	                /**<CNcomment:ʵ?ʵ?F ֵʱ??ת?????? */
+	HI_U32 ActalBitRate;                	/**<Actual bit rate conversion factor D*/	                  /**<CNcomment:ʵ?ʵ?D ֵ??????ת?????? */
+	HI_U32 Fi;			                      /**<Clock factor returned by the answer to reset (ATR)*/  	/**<CNcomment:ATR ???ص?ʱ?????? */
+	HI_U32 Di;			                      /**<Bit rate factor returned by the ATR*/                 	/**<CNcomment:ATR ???صı????????? */
+	HI_U32 GuardDelay;	                  /**<Extra guard time N*/	                                  /**<CNcomment:N ֵ???????ӵı???ʱ??*/
+	HI_U32 CharTimeouts;	                /**<Character timeout of T0 or T1*/                       	/**<CNcomment:T0 ??T1???ַ???ʱʱ??*/
+	HI_U32 BlockTimeouts;	                /**<Block timeout of T1 */                                  /**<CNcomment:T1?Ŀ鳬ʱʱ??*/
+	HI_U32 TxRetries;			                /**<Number of transmission retries*/                      	/**<CNcomment:???????Դ???*/
+}HI_UNF_SCI_PARAMS_S,*HI_UNF_SCI_PARAMS_S_PTR;
+
+
+
+typedef struct hiSCI_OPEN_S
+{
+    HI_UNF_SCI_PORT_E      enSciPort;
+    HI_UNF_SCI_PROTOCOL_E  enSciProtocol;
+    HI_U32                 Frequency;
+}SCI_OPEN_S;
+
+typedef struct hiSCI_RESET_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+    HI_BOOL              bWarmReset;
+}SCI_RESET_S;
+
+typedef struct hiSCI_ATR_S
+{
+    HI_UNF_SCI_PORT_E  enSciPort;
+	HI_U8              *pAtrBuf;
+	HI_U32             BufSize;
+	HI_U8              DataLen;
+}SCI_ATR_S;
+
+typedef struct hiSCI_STATUS_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+	HI_UNF_SCI_STATUS_E  enSciStatus;
+}SCI_STATUS_S;
+
+typedef struct hiSCI_DATA_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+	HI_U8                *pDataBuf;
+    HI_U32               BufSize;
+    HI_U32               DataLen;
+    HI_U32               TimeoutMs;
+}SCI_DATA_S;
+
+typedef struct hiSCI_LEVEL_S
+{
+    HI_UNF_SCI_PORT_E    enSciPort;
+	HI_UNF_SCI_LEVEL_E   enSciLevel;
+}SCI_LEVEL_S;
+
+typedef struct hiSCI_CLK_S
+{
+    HI_UNF_SCI_PORT_E      enSciPort;
+    HI_UNF_SCI_CLK_MODE_E  enClkMode;
+}SCI_CLK_S;
+
+typedef struct hiSCI_DEV_STATE_S
+{
+    HI_BOOL         bSci0;
+    HI_BOOL         bSci1;
+}SCI_DEV_STATE_S;
+
+typedef struct hiSCI_EXT_BAUD_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32 ClkRate;
+	HI_U32 BitRate;
+}SCI_EXT_BAUD_S;
+
+typedef struct hiSCI_ADD_GUARD_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32	AddCharGuard;
+}SCI_ADD_GUARD_S;
+
+typedef struct hiSCI_PPS_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U8  	Send[6];
+	HI_U8  	Receive[6];
+	HI_U32  SendLen;
+	HI_U32  ReceiveLen;
+	HI_U32	RecTimeouts;
+}SCI_PPS_S;
+
+typedef struct hiSCI_CHARTIMEOUT_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_UNF_SCI_PROTOCOL_E  enSciProtocol;
+	HI_U32	CharTimeouts;
+}SCI_CHARTIMEOUT_S;
+
+typedef struct hiSCI_BLOCKTIMEOUT_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32	BlockTimeouts;
+}SCI_BLOCKTIMEOUT_S;
+
+typedef struct hiSCI_TXRETRY_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_U32	TxRetryTimes;
+}SCI_TXRETRY_S;
+
+// sky(n)
+typedef struct hiSCI_PROTOCOL_S
+{
+	HI_UNF_SCI_PORT_E	   enSciPort;
+	HI_UNF_SCI_PROTOCOL_E  enSciProtocol;
+}SCI_PROTOCOL_S;
+
+
+#define CMD_SCI_OPEN              	_IOW(HI_ID_SCI,  0x1, SCI_OPEN_S)
+#define CMD_SCI_CLOSE             	_IOW(HI_ID_SCI,  0x2, HI_UNF_SCI_PORT_E)
+#define CMD_SCI_RESET             	_IOW(HI_ID_SCI,  0x3, SCI_RESET_S)
+#define CMD_SCI_DEACTIVE         	_IOW(HI_ID_SCI,  0x4, HI_UNF_SCI_PORT_E)
+#define CMD_SCI_GET_ATR           	_IOWR(HI_ID_SCI, 0x5, SCI_ATR_S)
+#define CMD_SCI_GET_STATUS        	_IOWR(HI_ID_SCI, 0x6, SCI_STATUS_S)
+#define CMD_SCI_CONF_VCC         	_IOW(HI_ID_SCI,  0x7, SCI_LEVEL_S)
+#define CMD_SCI_CONF_DETECT       	_IOW(HI_ID_SCI,  0x8, SCI_LEVEL_S)
+#define CMD_SCI_CONF_CLK_MODE     	_IOW(HI_ID_SCI,  0x9, SCI_CLK_S)
+#define CMD_SCI_SEND_DATA         	_IOWR(HI_ID_SCI, 0xa, SCI_DATA_S)
+#define CMD_SCI_RECEIVE_DATA      	_IOWR(HI_ID_SCI, 0xb, SCI_DATA_S)
+#define CMD_SCI_SWITCH            	_IOW(HI_ID_SCI,  0xc, SCI_OPEN_S)
+#define CMD_SCI_SET_BAUD          	_IOW(HI_ID_SCI,  0xd, SCI_EXT_BAUD_S)
+#define CMD_SCI_SET_CHGUARD       	_IOW(HI_ID_SCI,  0xe, SCI_ADD_GUARD_S)
+#define CMD_SCI_SEND_PPS_DATA     	_IOW(HI_ID_SCI,  0xF, SCI_PPS_S)
+#define CMD_SCI_GET_PPS_DATA	  		_IOWR(HI_ID_SCI, 0x10, SCI_PPS_S)
+#define CMD_SCI_GET_PARAM				_IOWR(HI_ID_SCI, 0x11, HI_UNF_SCI_PARAMS_S)
+#define CMD_SCI_SET_CHARTIMEOUT     _IOW(HI_ID_SCI,  0x12, SCI_CHARTIMEOUT_S)
+#define CMD_SCI_SET_BLOCKTIMEOUT    _IOW(HI_ID_SCI,  0x13, SCI_BLOCKTIMEOUT_S)
+#define CMD_SCI_SET_TXRETRY       	_IOW(HI_ID_SCI,  0x14, SCI_TXRETRY_S)
+#define CMD_SCI_SET_PROTOCOL        _IOW(HI_ID_SCI,  0x15, SCI_PROTOCOL_S)
+
+#define HI_ERR_SCI_OPEN_ERR     			(HI_S32)(0x80450001)
+#define HI_ERR_SCI_CLOSE_ERR    			(HI_S32)(0x80450002)
+#define HI_ERR_SCI_NOT_INIT       		(HI_S32)(0x80450003)
+#define HI_ERR_SCI_INVALID_PARA     	(HI_S32)(0x80450004)
+#define HI_ERR_SCI_NULL_PTR           	(HI_S32)(0x80450005)
+#define HI_ERR_SCI_INVALID_OPT     		(HI_S32)(0x80450006)
+#define HI_ERR_SCI_SEND_ERR      		(HI_S32)(0x80450007)
+#define HI_ERR_SCI_RECEIVE_ERR        	(HI_S32)(0x80450008)
+#define HI_ERR_SCI_NO_ATR           	(HI_S32)(0x80450009)
+#define HI_ERR_SCI_PPS_PTYPE_ERR     	(HI_S32)(0x8045000A)
+#define HI_ERR_SCI_PPS_FACTOR_ERR    	(HI_S32)(0x8045000B)
+#define HI_ERR_SCI_PPS_NOTSUPPORT_ERR	(HI_S32)(0x8045000C)
+
+#endif // defined(SDKV500)
+#endif /* End of #ifndef _ifd_hisky_h_*/
+
+
Index: csctapi/protocol_t0.c
===================================================================
--- csctapi/protocol_t0.c	(revision 1542)
+++ csctapi/protocol_t0.c	(working copy)
@@ -550,6 +550,9 @@
 	memcpy(buffer + 8 + recved, buffer + 2, 2);
 	*lr = recved + 2;
 	memcpy(rsp, buffer + 8, *lr);
+#if defined(WITH_HISILICON)
+	cs_sleepms(100); //FIXME why wait?
+#endif
 	return OK;
 }
 #endif
Index: devtools/check_config_tables.sh
===================================================================
--- devtools/check_config_tables.sh	(revision 1542)
+++ devtools/check_config_tables.sh	(working copy)
@@ -49,3 +49,9 @@
 do
 	grep -w $VAR globals.h | grep -vw uint8_t | grep -w --color $VAR
 done
+# sky(add)
+echo "== Checking DEF_OPT_HEXA (arrays) -> Var type must be uint8_t[x]"
+for VAR in `cat $FILES | grep DEF_OPT_HEXA | grep OFS | awk '{print $3}' | sed "s|OFS(||;s|)||;s|,||"`
+do
+	grep -w $VAR globals.h | grep -vw uint8_t | grep -w --color $VAR
+done
Index: globals.h
===================================================================
--- globals.h	(revision 1542)
+++ globals.h	(working copy)
@@ -112,6 +112,13 @@
 typedef unsigned char uchar;
 #endif
 
+#ifndef FALSE
+#define FALSE		(0)
+#endif
+#ifndef TRUE
+#define TRUE		(!FALSE)
+#endif
+
 #ifdef IPV6SUPPORT
 #define IN_ADDR_T struct in6_addr
 #define SOCKADDR sockaddr_storage
@@ -124,22 +131,27 @@
 #define DEFAULT_AF AF_INET
 #endif
 
+// sky(n)
+#if defined(WITH_HISILICON)
+#define NO_ENDIAN_H
+#endif
+
 #ifndef NO_ENDIAN_H
-#if defined(__APPLE__)
-#include <machine/endian.h>
-#define __BYTE_ORDER __DARWIN_BYTE_ORDER
-#define __BIG_ENDIAN    __DARWIN_BIG_ENDIAN
-#define __LITTLE_ENDIAN __DARWIN_LITTLE_ENDIAN
-#elif defined(__FreeBSD__) || defined(__OpenBSD__)
-#include <sys/endian.h>
-#define __BYTE_ORDER _BYTE_ORDER
-#define __BIG_ENDIAN    _BIG_ENDIAN
-#define __LITTLE_ENDIAN _LITTLE_ENDIAN
-#else
-#include <endian.h>
-#include <byteswap.h>
+	#if defined(__APPLE__)
+		#include <machine/endian.h>
+		#define __BYTE_ORDER 	__DARWIN_BYTE_ORDER
+		#define __BIG_ENDIAN    __DARWIN_BIG_ENDIAN
+		#define __LITTLE_ENDIAN __DARWIN_LITTLE_ENDIAN
+	#elif defined(__FreeBSD__) || defined(__OpenBSD__)
+		#include <sys/endian.h>
+		#define __BYTE_ORDER 	_BYTE_ORDER
+		#define __BIG_ENDIAN    _BIG_ENDIAN
+		#define __LITTLE_ENDIAN _LITTLE_ENDIAN
+	#else
+		#include <endian.h>
+		#include <byteswap.h>
+	#endif
 #endif
-#endif
 
 /* ===========================
  *         macros
@@ -146,9 +158,12 @@
  * =========================== */
 // Prevent use of unsafe functions (doesn't work for MacOSX)
 #if !defined(__APPLE__)
+// sky(!)
+#ifndef __ANDROID__
 #define strcpy(a,b) UNSAFE_STRCPY_USE_CS_STRNCPY_INSTEAD()
 #define sprintf(a,...) UNSAFE_SPRINTF_USE_SNPRINTF_INSTEAD()
 #define strtok(a,b,c) UNSAFE_STRTOK_USE_STRTOK_R_INSTEAD()
+#endif
 #define gmtime(a) UNSAFE_GMTIME_NOT_THREADSAFE_USE_CS_GMTIME_R()
 #define localtime(a) UNSAFE_LOCALTIME_NOT_THREADSAFE_USE_LOCALTIME_R()
 #define asctime(a) UNSAFE_ASCTIME_NOT_THREADSAFE_USE_ASCTIME_R()
@@ -229,6 +244,67 @@
 //checking if (X) free(X) unneccessary since freeing a null pointer doesnt do anything
 #define NULLFREE(X) {if (X) {void *tmpX=X; X=NULL; free(tmpX); }}
 
+#if defined(__HISILICON_MANUFACTORY__)
+	#undef  MODULE_CAMD33
+	#undef  MODULE_CAMD35
+	#undef  MODULE_CAMD35_TCP
+	#undef  MODULE_NEWCAMD
+	#undef  MODULE_CCCAM
+	#undef  MODULE_CCCSHARE
+	#undef  MODULE_GBOX
+	#undef  MODULE_RADEGAST
+	#undef  MODULE_SERIAL
+	#undef  MODULE_CONSTCW
+	#undef  MODULE_PANDORA
+	#undef  MODULE_GHTTP
+	#undef  MODULE_SCAM
+#endif
+
+#if defined(WITH_HISILICON)
+	#define __ADB_TRACE__	0
+	// sky(quad)
+	#if (__ADB_TRACE__==1)
+		#define myprintf(format,args...)			 printf(format,##args)
+		#define mystrace(format,args...)			 printf(format,##args)
+		#define myprdump(s,data,size)				 cs_prdump(s,data,size)
+		#define myascdump(s,data,size)			 cs_ascdump(s,data,size)
+		#define mycs_trace(x,format,args...)	 printf(format"\n",##args)
+		#define mycs_log(format,args...)			 printf(format"\n",##args)
+		#define mycs_debug(x,format,args...)	 printf(format"\n",##args)
+		#define myrdr_log(r,format,args...)		 printf(format"\n",##args)
+		#define myrdr_debug(r,x,format,args...) printf(format"\n",##args)
+		#define myrdr_debug_mask(r,x,format,args...) printf(format"\n",##args)
+	#elif (__ADB_TRACE__==2)
+		#define myprintf(format,args...)			 cs_log(format,##args)
+		#define mystrace(format,args...)			 cs_log(format,##args)
+		#define myprdump(s,data,size)				 cs_prdump(s,data,size)
+		#define myascdump(s,data,size)			 cs_ascdump(s,data,size)
+		#define mycs_trace(x,format,args...)	 cs_log(format,##args)
+		#define mycs_log(format,args...)			 cs_log(format,##args)
+		#define mycs_debug(x,format,args...)	 cs_log_dbg(x,format,##args)
+		#define myrdr_log(r,format,args...)		 rdr_log(r,format,##args)
+		#define myrdr_debug(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+		#define myrdr_debug_mask(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+	#else
+		#define myprintf(format,args...)			 /* none */
+		#define mystrace(format,args...)			 /* none */
+		#define myprdump(s,data,size)				 /* none */
+		#define myascdump(s,data,size)			 /* none */
+		#define mycs_trace(x,format,args...)	 /* cs_log_dbg(x,format,##args) */
+		#define mycs_log(format,args...)			 cs_log(format,##args)
+		#define mycs_debug(x,format,args...)	 cs_log_dbg(x,format,##args)
+		#define myrdr_log(r,format,args...)		 rdr_log(r,format,##args)
+		#define myrdr_debug(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+		#define myrdr_debug_mask(r,x,format,args...) rdr_log_dbg(r,x,format,##args)
+	#endif
+#else
+	#define myprintf(format,args...)
+	#define mycs_log(format,args...)
+	#define mycs_debug(x,format,args...)
+	#define mycs_trace(x,format,args...)
+	#define myprdump(x,data,size)
+#endif
+
 #ifdef __CYGWIN__
 #define cs_recv(a,b,c,d) cygwin_recv(a,b,c,d)
 #else
@@ -238,6 +314,11 @@
 //safe wrappers to pthread functions
 #define fprintf_stderr(fmt, params...)	fprintf(stderr, fmt, ##params)
 
+#ifndef PTHREAD_STACK_MIN
+	#define PTHREAD_STACK_MIN 	64000
+#endif
+#define PTHREAD_STACK_SIZE 	PTHREAD_STACK_MIN+32768
+
 #define SAFE_PTHREAD_1ARG(a, b, c) { \
 	int32_t pter = a(b); \
 	if(pter != 0) \
@@ -361,20 +442,58 @@
 /* ===========================
  *         constants
  * =========================== */
-#define CS_VERSION    "1.20_svn"
+#define CS_VERSION    "1.20.sky"	/* "1.20_svn" */
 #ifndef CS_SVN_VERSION
 #   define CS_SVN_VERSION "test"
 #endif
 #ifndef CS_TARGET
-#   define CS_TARGET "unknown"
+#   define CS_TARGET "sky"	/* "unknown" */
 #endif
+#if defined(SDK3798C)
+	#define CS_OSCAMDIR			CS_CONFDIR
+#elif defined(SDKV600)
+	#define CS_OSCAMDIR			"/system/oscam"
+#else
+	#define CS_OSCAMDIR			"/system/oscamdata"
+	#define CS_XBMCUSERDIR		"/data/data/org.xbmc.xbmc/cache/apk/assets/userdata/Oscam"
+#endif
+
 #ifndef CS_CONFDIR
-#define CS_CONFDIR    "/usr/local/etc"
+	#if defined(WITH_HISILICON)
+	// /system/Oscam
+	//
+	// usbcopy #cp /mnt/sda/sda1/oscam-1.20 /data/data/org.xbmc.xbmc/cache/apk/assets/userdata
+
+	// #mount -t ext4 -o remount /dev/block/mmcblk0p5 /system
+	// #mount -t ext4 -o remount /dev/block/platform/hi_mci.1/by-name/system /system
+	// #mount -o remount,rw /dev/block/mmcblk0p5 /system
+	//	SD_USER   = /sdcard/Android/data/org.xbmc.xbmc/files/.xbmc/userdata
+	//	SD_USER   = /sdcard/Oscam
+	//	DATA_USER = /data/data/org.xbmc.xbmc/cache/apk/assets/userdata
+	//
+	// // SD_USER(Oscam.sh)
+		#if defined(SDKV600)
+			#define CS_CONFDIR	"/data/oscam"
+		#elif defined(SDKV500)
+			#define CS_CONFDIR	"/sdcard/Oscam"
+		#else
+			#define CS_CONFDIR	"/sdcard/Oscam"
+		#endif
+	#else
+		#define CS_CONFDIR		"/usr/local/etc"
+	#endif
 #endif
+
 #ifndef CS_LOGFILE
-#define CS_LOGFILE    "/var/log/oscam.log"
+	#if defined(WITH_HISILICON)
+		#define CS_LOGFILE		"/var/oscam.log"
+	#else
+		#define CS_LOGFILE		"/var/log/oscam.log"
+	#endif
 #endif
+
 #define CS_QLEN       128 // size of request queue
+#define CS_MAXCAIDTAB 			32  	// max. caid-defs/user
 #define CS_MAXPROV    32
 #define CS_MAXPORTS   32  // max server ports
 #define CS_CLIENT_HASHBUCKETS 32
@@ -384,7 +503,7 @@
 #define CS_EMMSTORESIZE   16  // use MD5()
 #define CS_CLIENT_TIMEOUT 5000
 #define CS_CLIENT_MAXIDLE 120
-#define CS_BIND_TIMEOUT   120
+#define CS_BIND_TIMEOUT   10	// 120(sky)
 #define CS_DELAY          0
 #define CS_ECM_RINGBUFFER_MAX 0x10 // max size for ECM last responsetimes ringbuffer. Keep this set to power of 2 values!
 
@@ -453,6 +572,7 @@
 #define is_network_reader(__X) (__X->typ & R_IS_NETWORK)
 #define is_cascading_reader(__X) (__X->typ & R_IS_CASCADING)
 #define is_smargo_reader(__X) (__X->crdr && strcmp(__X->crdr->desc, "smargo") == 0)
+#define IS_CARD_READER(__X) (__X && (__X->typ == R_INTERNAL))
 
 //ECM rc codes:
 #define E_FOUND         0
@@ -518,8 +638,33 @@
 #define CARD_INSERTED         2
 #define CARD_FAILURE          3
 #define NO_CARD               4
-#define READER_DEVICE_ERROR   5
+#define CARD_UNREGISTER       5
+#define READER_DEVICE_ERROR   6
 
+// sky(n)
+#define READERSTATUS_DISABLED	0
+#define READERSTATUS_DISCONNECT	1
+#define READERSTATUS_FAILURE	2
+#define READERSTATUS_OK		3
+#define READERSTATUS_UNKNOWN	9
+#define READERSTATUS_NOTSUPPORT	99
+
+#define SMCSTATUS_NOCARD      	0
+#define SMCSTATUS_INIT 		1
+#define SMCSTATUS_FAILURE   	2
+#define SMCSTATUS_OK  		3
+#define SMCSTATUS_DEACTIVE	8
+#define SMCSTATUS_RESTART	9
+#ifdef HAVE_DVBAPI
+#define DEFAULT_DVBAPI		1
+#else
+#define DEFAULT_DVBAPI		0
+#endif
+#define DEFAULT_LOGHISTORYSIZE  	4096 // 8192  /* 4096 */
+#define DEFAULT_MINLOGHISTORYSIZE 	1024
+#define DEFAULT_MAXLOGHISTORYSIZE 	16384
+
+
 // moved from stats
 #define DEFAULT_REOPEN_SECONDS 30
 #define DEFAULT_MIN_ECM_COUNT 5
@@ -630,8 +775,9 @@
 
 // Return MPEG section length
 #define SCT_LEN(sct) (3+((sct[1]&0x0f)<<8)+sct[2])
-// Used by readers
-#define MAX_LEN      256
+#define SCT_DATLEN(sct) (((sct[1]&0x0f)<<8)+sct[2])
+// (sky)Used by readers
+#define MAX_LEN      288	/* 256 */
 
 #define NO_CAID_VALUE  0xfffe
 #define NO_PROVID_VALUE  0xfffffe
@@ -689,6 +835,37 @@
 	CAIDVALUETAB_DATA	*cvdata;
 } CAIDVALUETAB;
 
+// sky(n)
+#define CS_MAX_ECMTAB 	16
+typedef struct s_csecmtab
+{
+	int32_t		num;
+	uint16_t		caids	[CS_MAX_ECMTAB];
+	uint32_t		prids	[CS_MAX_ECMTAB];
+} CSECMTAB;
+
+typedef struct s_cschsets {
+	uint16_t		muxid;
+	uint16_t		degree;
+	uint16_t		frequency;
+	uint16_t		srvid;
+	uint16_t		vpid;
+	CSECMTAB		castab;
+} CSCHSETS;
+
+typedef struct s_cschannel {
+	uint16_t		muxid;
+	uint16_t		degree;
+	uint16_t		frequency;
+	uint16_t		srvid;
+	uint16_t		vpid;
+	uint16_t		casid;
+	uint32_t		provid;
+	CSECMTAB		castab;
+	uint32_t		adultMovie;
+} CSCHANNEL;
+
+
 typedef struct s_classtab
 {
 	uchar           an;
@@ -859,6 +1036,8 @@
 	uint32_t        class;              // the class needed for some systems
 	time_t          start;              // startdate
 	time_t          end;                // enddate
+// sky(oscam.smartcard)
+	char		comments[64];
 #ifdef WITH_EMU
 	bool            isKey;
 	bool            isData;
@@ -874,7 +1053,7 @@
 struct s_ecm_answer ;
 struct demux_s ;
 
-#define DEFAULT_MODULE_BUFSIZE 1024
+#define DEFAULT_MODULE_BUFSIZE 1288  /* sky(1024) */
 
 struct s_module
 {
@@ -909,6 +1088,8 @@
 	int32_t (*c_cache_push)(struct s_client *, struct ecm_request_t *);         //Cache push
 	int32_t (*c_cache_push_chk)(struct s_client *, struct ecm_request_t *);         //Cache push Node Check, 0=no push
 #endif
+	int32_t		(*c_ChCloser)(struct s_client *, int muxid);
+	int32_t		(*c_Cleanup)(struct s_client *);
 	int32_t         c_port;
 	PTAB            ptab;
 	int32_t         num;
@@ -1012,7 +1193,9 @@
 
 typedef struct ecm_request_t
 {
+	uint16_t	dmuxid;	// sky(powervu)
 	uchar           ecm[MAX_ECM_SIZE];
+	bool		ecm_bypass;
 	uchar           cw[16];
 	EXTENDED_CW     cw_ex;
 	uchar           ecmd5[CS_ECMSTORESIZE];
@@ -1029,6 +1212,8 @@
 	uint16_t        pid;
 	uint16_t        idx;
 	uint32_t        prid;
+	int16_t		constAfterwards;
+	CSCHSETS	chSets;
 	struct s_reader *selected_reader;
 	struct s_ecm_answer *matching_rdr;      //list of matching readers
 	const struct s_reader   *fallback;      //fallback is the first fallback reader in the list matching_rdr
@@ -1243,6 +1428,7 @@
 	int32_t         emmok;              // count EMM ok
 	int32_t         emmnok;             // count EMM nok
 	int8_t          pending;            // number of ECMs pending
+	int8_t		emmsento;	// sky(a)
 #ifdef CS_CACHEEX
 	int32_t         cwcacheexpush;      // count pushed ecms/cws
 	int32_t         cwcacheexgot;       // count got ecms/cws
@@ -1276,6 +1462,11 @@
 	void            *cc;
 #endif
 
+#if defined(WITH_HISILICON)
+	uint32_t	frameAcquire;
+	CSCHANNEL	ch_ics;
+#endif
+
 #ifdef MODULE_GBOX
 	void            *gbox;
 	uint16_t		gbox_peer_id;
@@ -1591,6 +1782,8 @@
 	int8_t          ncd_proto;
 	int8_t          currenthops;                    // number of hops (cccam & gbox)
 	int8_t          sh4_stb;                        // to set sh4 type box used to identify sci type.
+// sky(n)
+	int32_t		ch_descramble;
 #ifdef MODULE_CCCAM
 	char            cc_version[7];                  // cccam version
 	char            cc_build[7];                    // cccam build number
@@ -1674,6 +1867,10 @@
 	unsigned char	VgCountryC[3];
 	unsigned char   VgRegionC[8];
 	unsigned char	VgLastPayload[6];
+#if defined(WITH_HISILICON)
+	int32_t		scinum;
+	int32_t		scideprecated;
+#endif
 #ifdef WITH_LB
 	int32_t         lb_weight;                      //loadbalance weight factor, if unset, weight=100. The higher the value, the higher the usage-possibility
 	int8_t          lb_force_fallback;				//force this reader as fallback if fallback or fallback_percaid paramters set
@@ -1761,6 +1958,16 @@
 	uint8_t         dre56_force_group;
 #endif
 	uint8_t cnxlastecm; // == 0 - las ecm has not been paired ecm, > 0 last ecm has been paired ecm
+// sky(oscam.smartcard)
+	int8_t		DRE_type; 		// sky
+	int8_t		DRE_cass; 		// sky
+	int8_t		DRE_3s; 		// sky
+	int8_t 		restarting;
+	uint16_t 	acs;
+	char     	country_code[3];	// irdeto country code.
+	char		ascserial[64];
+	uint16_t	cardver;
+
 	LLIST           *emmstat; //emm stats
 	CS_MUTEX_LOCK   emmstat_lock;
 	struct s_reader *next;
@@ -2403,6 +2610,9 @@
 // These are used pretty much everywhere
 extern struct s_config cfg;
 extern uint16_t cs_dblevel;
+//extern int32_t cs_timefaults;	// sky(a)
+extern bool g_smartcard_supported;	// sky(sim)
+extern bool g_factoy_products;	// sky(sim)
 
 #include "oscam-log.h"
 #include "oscam-log-reader.h"
@@ -2431,6 +2641,8 @@
 char *get_provider(uint32_t provid, uint16_t caid, char *buf, uint32_t buflen);
 char *get_providername(uint32_t provid, uint16_t caid, char *buf, uint32_t buflen);
 char *get_providername_or_null(uint32_t provid, uint16_t caid, char *buf, uint32_t buflen);
+// sky(oscam.smartcard)
+char *get_provider_existnace(uint16_t caid, uint32_t provid, char *buf, uint32_t buflen);
 void add_provider(uint16_t caid, uint32_t provid, const char *name, const char *sat, const char *lang);
 const char *get_cl_lastprovidername(struct s_client *cl);
 bool boxtype_is(const char *boxtype);
Index: module-anticasc.c
===================================================================
--- module-anticasc.c	(revision 1542)
+++ module-anticasc.c	(working copy)
@@ -82,7 +82,8 @@
 	for(client = first_client; client; client = client->next)
 	{
 		if(client->typ != 'c') { continue; }
-
+		// sky(2016,powervu)
+		if (!strcmp(client->account->usr, "dvbapi"))  { continue; }
 		struct s_acasc *ac_stat = &client->account->ac_stat;
 		struct s_acasc_shm *acasc = &client->acasc;
 
Index: module-constcw.c
===================================================================
--- module-constcw.c	(revision 1542)
+++ module-constcw.c	(working copy)
@@ -3,13 +3,128 @@
 //FIXME Not checked on threadsafety yet; after checking please remove this line
 #include "globals.h"
 #ifdef MODULE_CONSTCW
+#include "oscam-conf.h"
 #include "oscam-client.h"
+#include "oscam-chk.h"
 #include "oscam-ecm.h"
 #include "oscam-net.h"
 #include "oscam-string.h"
+#include "oscam-array.h"
+#include "module-dvbapi.h"
+#include "module-constcw.h"
 
+
+struct xconst_keydata
+{
+	int16_t	found;
+	uint16_t	caid;
+	uint32_t	ppid;
+	uint32_t	freq;
+	uint32_t	ecmpid;
+	uint32_t	pmtpid;
+	uint32_t	vpid;
+	uint32_t	srvid;
+	uint8_t	constcw[16];
+};
+struct xconst_keydata g_xconst[MAX_DEMUX];
+
 static int32_t pserver;
+static int16_t	cFTA_Maxes = 0;
 
+static bool
+constcw_analyser(struct s_client *client)
+{
+	// CAID:PROVIDER:SID:VPID:ECMPID::XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+	// CAID:PROVIDER:SID:PMTPID:ECMPID:VPID:XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+	FILE 	*fp;
+	char 	 token[512];
+//	uint32_t frequency, degree;
+	uint32_t caid, provid, srvid, vidpid, pmtpid, ecmpid;
+	uint32_t cwiv[16];
+	int32_t  counter = 0;
+	CAIDTAB_DATA xcts[CS_MAXCAIDTAB];
+	int numcaids = 0;
+	int rcval;
+	int i;
+
+	cFTA_Maxes = 0;
+	caidtab_clear(&client->reader->ctab);
+	fp = open_config_file(client->reader->device);
+	if (!fp) return 0;
+
+	while (fgets(token, sizeof(token), fp))
+	{
+		if (counter > MAX_FTABISS-1) break;
+		if (token[0]=='#') continue;
+		if (token[0]=='<') continue;
+		if (token[0]==' ') continue;
+		caid  = provid = srvid = vidpid = ecmpid = pmtpid = 0;
+		memset(cwiv, 0, sizeof(cwiv));
+		rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x::%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &srvid, &vidpid, &ecmpid,
+							&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+							&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+
+		if (rcval != 13 && rcval != 21) {
+			rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x:%4x:%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &srvid, &pmtpid, &ecmpid, &vidpid,
+				   		&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+				   		&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+			if (rcval != 14 && rcval != 22) continue;
+		}
+//		frequency = cs_BCD2i(provid);
+//		degree = cs_BCD2i(ecmpid);
+/*		if ((caid_is_biss(caid)) &&
+			 (srvid)  &&
+			 (frequency && (frequency > 950 && frequency < 15000)) &&
+			 (degree < 3600) &&
+			 (vidpid && vidpid < 0x1fff))
+		{
+			cs_log_dbg(D_DVBAPI, "myconst:f.constcw.%04X:%06X:%04X:%04X:%04X\n",
+					caid, provid, srvid, vidpid, ecmpid);
+			cFTA_Biss[counter].caid   = caid;
+			cFTA_Biss[counter].srvid  = srvid;
+			cFTA_Biss[counter].pfid   = provid;
+			cFTA_Biss[counter].vidpid = vidpid;
+			cFTA_Biss[counter].edgrid = ecmpid;
+			counter++;
+		}*/
+
+		for (i=0; i<numcaids; i++)	{
+			if (xcts[i].caid == caid) break;
+		}
+		if (i==numcaids)
+		{
+			if (numcaids>(CS_MAXCAIDTAB-1)) {
+				cs_log_dbg(D_DVBAPI, "xcaskey:CA{%04X} CS_MAXCAIDTAB exceed\n", caid);
+				break;
+			}
+			cs_log_dbg(D_DVBAPI, "constcw:ctab.caid:%04X\n", caid);
+			xcts[numcaids].mask = 0xffff;
+			xcts[numcaids].cmap = 0x0;
+			xcts[numcaids].caid = caid;
+			caidtab_add(&client->reader->ctab, &xcts[numcaids]);
+			numcaids++;
+		}
+	}
+	fclose(fp);
+	cFTA_Maxes = counter;
+	return (counter);
+}
+
+static int32_t
+constcw_available(struct s_client *client)
+{
+	FILE *fp;
+
+	if (!client) return 0;
+//	fp = fopen(client->reader->device, "r");
+	fp = open_config_file(client->reader->device);
+	if (!fp) return 0;
+	fclose(fp);
+	return 1;
+}
+
 int32_t constcw_file_available(void)
 {
 	FILE *fp;
@@ -72,6 +187,7 @@
 	fclose(fp);
 	return 0;
 }
+
 //************************************************************************************************************************
 //* client/server common functions
 //************************************************************************************************************************
@@ -102,6 +218,7 @@
 	client->udp_fd = fdp[0];
 	pserver = fdp[1];
 
+	memset(&g_xconst,0, sizeof(g_xconst));
 	memset((char *) &client->udp_sa, 0, sizeof(client->udp_sa));
 	SIN_GET_FAMILY(client->udp_sa) = AF_INET;
 
@@ -112,37 +229,174 @@
 
 	client->pfd = client->udp_fd;
 
-	if(constcw_file_available())
+	if(constcw_available(client))
 	{
+		constcw_analyser(client);
 		client->reader->tcp_connected = 2;
 		client->reader->card_status = CARD_INSERTED;
 	}
+	client->reader->tcp_ito = 0;
+	client->reader->last_s = client->reader->last_g = time(NULL);
+	return 0;	
+}
 
-	return (0);
+static void
+constcw_clidle(void)
+{
+	struct s_client *client = cur_client();
+	time_t  now;
+	int32_t time_diff;
+
+	if (!client) return;
+	if (!client->reader) return;
+	if (!client->reader->enable) return;
+	if ( client->reader->ch_descramble) return;
+
+	time(&now);
+	time_diff = now - client->reader->last_s;
+	if (time_diff > 12)
+	{
+#if defined(WITH_HISILICON)
+		if (chk_av_descrambling(client)) {
+			client->reader->ch_descramble = 1;
+			client->reader->tcp_ito = 0;
+			//mycs_debug(D_ADB, "constcw:descrambling");
+		}
+		else {
+			//mycs_debug(D_ADB, "constcw:scrambled");
+			dvbapi_constcw_afterwards(R_CONSTCW, client->ch_ics.muxid, 1);
+		}
+#endif
+	}
 }
 
+static int32_t
+constcw_search(struct s_client *client, ECM_REQUEST *er, uchar *dcw)
+{
+	// CAID:PROVIDER:SID:VPID:ECMPID::XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+	// CAID:PROVIDER:SID:PMTPID:ECMPID:VPID:XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
+	struct xconst_keydata *pxconst;
+	FILE 	*fp;
+	char 	 token[512];
+	uint32_t caid, provid, sid, vpid, pmtpid, ecmpid;
+	uint32_t cwiv[16];
+	int32_t  cwfound = 0;
+	int32_t  dmuxid;
+
+	if (!er) return 0;
+	if (!client) return 0;
+	//MYCONST_TRACE("myconst:searching constcw.%04X:%06X:%04X:%04X:%04X\n",
+	//		er->caid, er->prid, er->srvid, er->vpid, er->pid);
+	dmuxid  = er->dmuxid % MAX_DEMUX;
+	pxconst = &g_xconst[dmuxid];
+	if (pxconst->caid == er->caid && pxconst->srvid == er->srvid && pxconst->ecmpid == er->pid && pxconst->vpid == er->vpid)
+	{
+		if (!pxconst->found) return 0;
+		memcpy(dcw, pxconst->constcw, 16);
+		//MYCONST_TRACE("myconst:CONSTANT:%04X.%5d:%02X...%02X\n", er->caid, er->srvid, dcw[0], dcw[7]);
+		return 1;
+	}
+	pxconst->caid   = er->caid;
+	pxconst->ppid   = er->prid;
+	pxconst->freq	 = er->chSets.frequency;
+	pxconst->srvid  = er->srvid;
+	pxconst->pmtpid = er->pmtpid;
+	pxconst->ecmpid = er->pid;
+	pxconst->vpid   = er->vpid;
+	pxconst->found  = 0;
+
+//	fp = fopen(cur_client()->reader->device, "r");
+	fp = open_config_file(client->reader->device);
+	if (!fp) return 0;
+
+	while (fgets(token, sizeof(token), fp))
+	{
+		int rcval;
+		int singly = 0;
+		int i;
+
+		if (token[0]=='#') continue;
+		if (token[0]=='<') continue;
+		if (token[0]==' ') continue;
+		singly= 0;
+		caid  = provid = sid = vpid = ecmpid = pmtpid = 0;
+		memset(cwiv, 0, sizeof(cwiv));
+		rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x::%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &sid, &vpid, &ecmpid,
+							&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+							&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+//		MYCONST_TRACE("rcval: %d\n", rcval);
+		if (rcval == 13) singly = 1;
+		if (rcval != 13 && rcval != 21) {
+			rcval = sscanf(token, "%4x:%6x:%4x:%4x:%4x:%4x:%2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x",
+							&caid, &provid, &sid, &pmtpid, &ecmpid, &vpid,
+				   		&cwiv[0], &cwiv[1], &cwiv[ 2], &cwiv[ 3], &cwiv[ 4], &cwiv[ 5], &cwiv[ 6], &cwiv[ 7],
+				   		&cwiv[8], &cwiv[9], &cwiv[10], &cwiv[11], &cwiv[12], &cwiv[13], &cwiv[14], &cwiv[15]);
+			if (rcval == 14) singly = 1;
+			if (rcval != 14 && rcval != 22) continue;
+		}
+
+//		MYCONST_TRACE("Line found: %s", token);
+		uint32_t freqid = cs_BCD2i(provid);
+		if (( er->caid == caid) &&
+			 ( er->srvid== sid)  &&
+			 ( er->chSets.frequency==freqid || er->chSets.frequency==freqid-1 || er->chSets.frequency==freqid+1 || er->prid==provid) &&
+		/*	 (!ecmpid || !er->pid || er->pid==ecmpid) && */
+			 (!pmtpid || !er->pmtpid || er->pmtpid==pmtpid) &&
+			 (!vpid   || !er->vpid || er->vpid==vpid))
+		{
+			for (i=0; i<16;i++) dcw[i] = cwiv[i];
+			if (singly) memcpy(&dcw[8], &dcw[0], 8);
+			cs_log("Entry found: %04X:%06X:%04X:%04X:%04X::%s",
+					caid, provid, sid, vpid, ecmpid,
+					cs_hexdump(1, dcw, 16, token, sizeof(token)));
+			pxconst->found = 1;
+			memcpy(pxconst->constcw, dcw, 16);
+			//MYCONST_TRACE("myconst:constcw.%04X:%06X:%04X:%04X:%04X::%02X...%02X:%02X...%02X\n",
+					//caid, provid, sid, vpid, ecmpid,
+					//dcw[0], dcw[7], dcw[8], dcw[15]);
+			cwfound = 1;
+			break;
+		}
+	}
+	fclose(fp);
+	return (cwfound);
+}
+
 static int32_t constcw_send_ecm(struct s_client *client, ECM_REQUEST *er)
 {
-	time_t t;
-	struct s_reader *rdr = client->reader;
-	uchar cw[16];
+	uint8_t cw[16];
+	int cwfound = 0;
 
-	t = time(NULL);
+	if (!er) return 0;
+	if (!client->reader) return 0;
+	if ( client->reader->card_status != CARD_INSERTED) return 0;
+	//MYCONST_TRACE("myconst:constcw_send_ecm...\n");
+	cs_log("searching constcw %04X:%06X:%04X:%04X", er->caid, er->prid, er->srvid, er->vpid);
 	// Check if DCW exist in the files
-	//cs_log("Searching ConstCW for ECM: %04X@%06X:%04X (%d)", er->caid, er->prid, er->srvid, er->l);
-
-	if(constcw_analyse_file(er->caid, er->prid, er->srvid, er->pmtpid, er->vpid, er->pid, cw) == 0)
+	cwfound = constcw_search(client, er, cw);
+	if (cwfound)
 	{
-		write_ecm_answer(rdr, er, E_NOTFOUND, (E1_READER << 4 | E2_SID), NULL, NULL, 0, NULL);
+		er->ecm_bypass = 1;
+		set_cw_checksum(cw, 16);
+		write_ecm_answer(client->reader, er, E_FOUND, 0, cw, NULL, 0, NULL);
 	}
 	else
 	{
-		write_ecm_answer(rdr, er, E_FOUND, 0, cw, NULL, 0, NULL);
+		//MYCONST_TRACE("myconst:constcw.none\n");
+	//	sky(!)
+	//	write_ecm_answer(client->reader, er, E_NOTFOUND, (E1_READER<<4 | E2_SID), NULL, NULL, NULL);
 	}
 
-	client->last = t;
-	rdr->last_g = t;
-	return (0);
+
+
+
+
+	time_t now = time(NULL);
+	client->last = now;
+	client->reader->last_s  = client->reader->last_g = now;
+	client->reader->tcp_ito = 10;
+	return 0;
 }
 
 static int32_t constcw_recv_chk(struct s_client *UNUSED(client), uchar *UNUSED(dcw), int32_t *rc, uchar *UNUSED(buf), int32_t UNUSED(n))
@@ -155,6 +409,26 @@
 	return (-1);
 }
 
+static int32_t constcw_ChCloser(struct s_client *client, int muxid)
+{
+	//MYCONST_TRACE("constcw:closer\n");
+	if (!client) return -1;
+	if (!client->reader) return -1;
+	client->reader->tcp_ito = 0;
+	client->reader->ch_descramble = 0;
+	return 1;
+}
+
+static int32_t constcw_Cleanup(struct s_client *client)
+{
+	//MYCONST_TRACE("constcw:cleanup\n");
+	if (!client) return -1;
+	if (!client->reader) return -1;
+	client->reader->tcp_ito = 0;
+	memset(&g_xconst,0, sizeof(g_xconst));
+	return 1;
+}
+
 void module_constcw(struct s_module *ph)
 {
 	ph->desc = "constcw";
@@ -163,8 +437,11 @@
 	ph->recv = constcw_recv;
 
 	ph->c_init = constcw_client_init;
+	ph->c_idle = constcw_clidle;
 	ph->c_recv_chk = constcw_recv_chk;
 	ph->c_send_ecm = constcw_send_ecm;
+	ph->c_Cleanup = constcw_Cleanup;
+	ph->c_ChCloser = constcw_ChCloser;
 	ph->num = R_CONSTCW;
 }
 #endif
Index: module-constcw.h
===================================================================
--- module-constcw.h	(nonexistent)
+++ module-constcw.h	(working copy)
@@ -0,0 +1,18 @@
+#ifndef MODULE_CONSTCW_H_
+#define MODULE_CONSTCW_H_
+#if defined(MODULE_CONSTCW)
+#define MAX_FTABISS	256
+
+typedef struct
+{
+	uint16_t caid;
+	uint32_t pfid;
+	uint16_t srvid;
+	uint16_t vidpid;
+	uint16_t edgrid;
+} FTA_BISTAB;
+
+bool CONSTCW_IsFtaBisses(struct s_reader *reader, uint16_t ccaid, uint32_t cpfid, uint16_t csrvid, uint16_t cvidpid, uint16_t cdgrid);
+#endif	// defined(MODULE_CONSTCW)
+#endif	// #ifndef MODULE_CONSTCW_H_
+
Index: module-dvbapi-chancache.c
===================================================================
--- module-dvbapi-chancache.c	(revision 1542)
+++ module-dvbapi-chancache.c	(working copy)
@@ -16,6 +16,9 @@
 
 void dvbapi_save_channel_cache(void)
 {
+
+#if defined(WITH_HISILICON)
+#else
 	if(boxtype_is("dbox2")) return; // dont save channelcache on these boxes, they lack resources and will crash!
 	
 	if (USE_OPENXCAS) // Why?
@@ -55,10 +58,13 @@
 
 	fclose(file);
 	cs_log("dvbapi channelcache saved to %s", fname);
+#endif
 }
 
 void dvbapi_load_channel_cache(void)
 {
+#if defined(WITH_HISILICON)
+#else
 	if(boxtype_is("dbox2")) return; // dont load channelcache on these boxes, they lack resources and will crash!
 	
 	if (USE_OPENXCAS) // Why?
@@ -121,6 +127,7 @@
 	}
 	fclose(file);
 	cs_log("dvbapi channelcache loaded from %s", fname);
+#endif
 }
 
 struct s_channel_cache *dvbapi_find_channel_cache(int32_t demux_id, int32_t pidindex, int8_t caid_and_prid_only)
Index: module-dvbapi-his.c
===================================================================
--- module-dvbapi-his.c	(nonexistent)
+++ module-dvbapi-his.c	(working copy)
@@ -0,0 +1,1232 @@
+/* Reversed from libhistream.so, this comes without any warranty */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include "globals.h"
+
+#if defined(WITH_HISILICON)
+
+#define DVBAPI_LOG_PREFIX 		1
+#include "module-dvbapi.h"
+#include "module-dvbapi-his.h"
+#include "oscam-string.h"
+#include "oscam-client.h"
+#include "oscam-time.h"
+
+#undef	UNUSED
+#include "hi_unf_demux.h"
+
+#if 1
+	#if (__ADB_TRACE__==1)
+	#define HIPRT_FATAL	myprintf
+	#else
+	#define HIPRT_FATAL	mycs_log
+	#endif
+#else
+	#define HIPRT_FATAL(...)
+#endif
+
+#if 1
+	#if (__ADB_TRACE__==1)
+	#define HIPRT_ERROR	myprintf
+	#else
+	#define HIPRT_ERROR	mycs_log
+	#endif
+#else
+	#define HIPRT_ERROR(...)
+#endif
+
+#if 1
+	#define HIPRT_WARN	myprintf
+#else
+	#define HIPRT_WARN(...)
+#endif
+
+#if 1
+	#define HIPRT_INFO	myprintf
+#else
+	#define HIPRT_INFO(...)
+#endif
+
+#if 1
+	#define HIPRT_TRACE	myprintf
+#else
+	#define HIPRT_TRACE(...)
+#endif
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/***************************** Macro Definition ************************/
+#define TUNER0	0
+#define TUNER1	1
+#if defined(SDKV600)
+	// demux id 0 to 6
+	#define HIPORT_TUNER_ID 	HI_UNF_DMX_PORT_TSI_0
+	#define HIPORT_INTERNAL_ID HI_UNF_DMX_PORT_TSI_1
+	#define HIDEMUX_OSCAM_ID 	0
+	#define HIDEMUX_OSCAM1_ID 	HIDEMUX_OSCAM_ID
+	#define HIDEMUX_OSCAM2_ID 	5
+#elif defined(SDKV500)
+	// demux id 0 to 6
+	#define HIPORT_TUNER_ID 	HI_UNF_DMX_PORT_TSI_0
+	#define HIDEMUX_OSCAM_ID 	0
+#else
+	#define HIPORT_TUNER_ID 	1
+	#define HIDEMUX_OSCAM_ID	0	// 3
+#endif
+
+
+#define NUM_HIREGION			3
+#define NUM_HIPERREGION			32
+#define MAX_HICHANNEL			(NUM_HIREGION*NUM_HIPERREGION)	// DMX_TOTALCHAN_CNT
+#define MAX_HIFILTERS			(NUM_HIREGION*NUM_HIPERREGION)	// DMX_TOTALFILTER_CNT
+#define NUM_HIFILACQUIRES		32		// 3
+#define NUM_HIFLTDEPTH			16		// DMX_FILTER_MAX_DEPTH
+#define DVB_HIFLTBYTES			8		// DMX_FILTER_MAX_DEPTH
+#define MAX_HIBUFFERSIZE		(64 * 1024)
+#define INVALID_HIFILTER		-1
+#define INVALID_HIHANDLE		HI_INVALID_HANDLE
+
+#define IS_INVALID_PID(x)			((x)>=0x1fff)
+#define IS_INVALID_HIFILTERS(x)	((x)>MAX_HIFILTERS-1 || (x)<0)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+#define HIAPI_ISDEMUXINIT() \
+	if (g_DemuxIniz == HI_FALSE) { \
+		HIPRT_FATAL("mydemux:demux none...\n"); \
+		return HI_FAILURE; \
+	}
+
+#define HIAPI_CHECKFILTERID(id) \
+	if ((id) >= MAX_HIFILTERS) { \
+		HIPRT_FATAL("mydemux:invalid filterid(%d)\n", (id)); \
+		return HI_FAILURE; \
+	}
+
+
+#define HIAPI_FILTERREGION(dmxid,region) \
+	if ((dmxid) == 0)      { (region) = 0; } \
+	else if ((dmxid) == 4) { (region) = 2; } \
+	else                   { (region) = 1; }
+
+#if 0
+#define HIAPI_CHECKERROR(hiReturn,FUNC)	do {} while (0);
+#else
+#define HIAPI_CHECKERROR(hiReturn,FUNC)	\
+	if (hiReturn != HI_SUCCESS) { \
+		HIPRT_ERROR("mydemux:%s.%s.error(%x)\n",__FUNCTION__,#FUNC, hiReturn); \
+	}
+#endif
+
+#define HIFLT_REVERSE_MASK(mask) 	(HI_U8)(~(mask))
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+/*************************** Structure Definition **********************/
+/* Transparent transmission mode, only the data to reach the internal buffer of events and timeout events, not a copy of the data does not appear to copy data to an external buffer event
+	In copy mode, in addition to the data reaches the internal buffer of events and timeout events, there will be a copy of the data to the external buffer events.
+	However, in the copy mode, when the reach the data of the external buffer event, the user via the callback function's return value to confirm whether to continue copying, in order to discard the unwanted duplicate data.
+	At this point, the return value of 0 means copy a copy, and direct release.
+*/
+
+typedef struct hidemux_attrib
+{
+	HI_S32		dmuxid;
+	HI_S32		fltnum;
+
+	HI_U32		u32TUNERID;	/* TUNER ID ,0-1*/
+	HI_U32		u32DMXID;	/* DMX ID ,0-4*/
+	HI_U32		u32PID;		/* TS PID */
+
+	HI_S32		u32Type;	/* task type 1 - TYPE_ECM  2- TYPE_EMM */
+	HI_U32		u32FilterType;	/* section type 0 - SECTION  1- PES  2 - ECM/EMM */
+	HI_U32		u32CrcFlag;	/* crc check flag,0 - close crc check 1-force crc check 2-crc check by sytax*/
+	HI_U32		u32TimeOutMs;	/* time out in ms,0 stand for not timeout,otherwise when timeout,the user can receive the envent*/
+
+	HI_U32		u32FilterDepth;	/* Filter Depth*/
+	HI_U8			u8Match	[NUM_HIFLTDEPTH];
+	HI_U8			u8Mask	[NUM_HIFLTDEPTH];
+	HI_U8			u8Negate	[NUM_HIFLTDEPTH];
+} HIDEMUX_ATTRIB;
+
+typedef struct hidemux_filters
+{
+	HIDEMUX_ATTRIB fltAttr;
+	HI_S32		uFiltype;
+	HI_U32		u32UseFlag;	/*use flag :0- available,1-busy*/
+	HI_U32		u32EnableFlag;	/*enable flag :0- enable,1-disable*/
+
+	HI_HANDLE	hChannel;	/*corresponding  channel of filter*/
+	HI_HANDLE	hFilter;	/*corresponding  hander of filter*/
+
+	HI_U32		u32TimerCount;	/*current value in timer of (ms)filter */
+} HIDEMUX_FILTERS;
+
+typedef struct hidemux_inform {
+	int32_t adapter;
+	int32_t dmuxid;
+	int32_t flnum;
+	int32_t hifltnum;
+	int32_t type;
+	int32_t pid;
+	bool activated;
+} HIDEMUX_INFORM;
+
+
+struct hidemux_thread_param
+{
+	int32_t id;
+//	int32_t flnum;
+	struct s_client *cli;
+};
+
+/********************** Global Variable declaration ********************/
+extern struct s_client *dvbapi_client;
+
+static HI_BOOL g_DemuxIniz = 0;
+static HI_BOOL g_DemuxRuning = HI_TRUE;
+static pthread_mutex_t g_FltMutex;
+static pthread_mutex_t g_FltLocks;
+static pthread_t g_FltEcmThread;
+static pthread_t g_FltEmmThread;
+
+static HIDEMUX_FILTERS g_HIFilters[MAX_HIFILTERS];
+static HIDEMUX_INFORM g_dmuxes[MAX_DEMUX][MAX_FILTER];
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//feedback data to filter by callback
+static HI_BOOL
+hifilter_SectionCallbacks(HIDEMUX_FILTERS *ChFilter, HI_U8 *pSection, HI_U32 uSecLen)
+{
+	HIDEMUX_ATTRIB *pFltAttr;
+	int k = 0;
+
+	if (!uSecLen ) return 0;
+	if (!pSection) return 0;
+	if (ChFilter->u32UseFlag == 0) return 0;
+	if (ChFilter->u32EnableFlag == 0) return 0;
+	pFltAttr = &(ChFilter->fltAttr);
+	if ((0 == pFltAttr->u32FilterType || 2 == pFltAttr->u32FilterType) && pFltAttr->u32FilterDepth != 0) /*section data,filter data by software*/
+	{
+		if (pFltAttr->u8Negate[0])
+		{
+			if ((pFltAttr->u8Match[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])) ==
+			  	 (pSection[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])))
+			{
+			  	return 0;
+			}
+		}
+		else
+		{
+			if ((pFltAttr->u8Match[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])) !=
+			  	 (pSection[0] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[0])))
+			{
+			  	return 0;
+			}
+		}
+
+		for (k = 1; k < (int)(pFltAttr->u32FilterDepth); k++)
+		{
+			if (pFltAttr->u8Negate[k])
+			{
+			  	if ((pFltAttr->u8Match[k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])) ==
+					 (pSection[2+k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])))
+			  	{
+					break;
+			  	}
+			}
+			else
+			{
+			  	if ((pFltAttr->u8Match[k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])) !=
+					 (pSection[2+k] & HIFLT_REVERSE_MASK(pFltAttr->u8Mask[k])))
+			  	{
+					break;
+			  	}
+			}
+		}
+	}
+	else
+	{
+		k = pFltAttr->u32FilterDepth; /*do not filter pes*/
+	}
+
+	if (k == (int)(pFltAttr->u32FilterDepth)) /*get matched filter condition */
+	{
+		ChFilter->u32TimerCount = 0;
+//		if (ChFilter->uFiltype==TYPE_EMM) {
+//			myprintf("FILTER:%d, %d\n", uFilNum, i);
+//		}
+		dvbapi_process_input(pFltAttr->dmuxid, pFltAttr->fltnum, (void *)pSection, uSecLen, 0);
+		return 1;
+	}
+	return 0;
+}
+
+
+static void *
+hifilter_ThreadModules(void *param)
+{
+	struct hidemux_thread_param *para = (struct hidemux_thread_param *)param;
+	HI_UNF_DMX_DATA_S ChRcvBuf[NUM_HIFILACQUIRES];
+	HI_UNF_DMX_CHAN_STATUS_S channelstatus;
+//	HI_UNF_DMX_DATA_TYPE_E enDataType;
+//	HI_UNF_DMX_CHAN_ATTR_S stChAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	HI_HANDLE ChHandle;
+	HI_S32 	 ChTYPE;
+//	HI_U32 	 u32HandleNum = MAX_HICHANNEL;
+//	HI_HANDLE u32ChHandle[MAX_HICHANNEL];
+	HI_U32 u32AcqNum 	= 0;
+	HI_U32 u32BufLen 	= 0;
+	HI_U8  *pRecvBuff	= 0;
+	HI_S32 hiReturn = HI_FAILURE;
+	int f, ki = 0;
+
+	ChTYPE = para->id;
+	pthread_setspecific(getclient, para->cli);
+	//SAFE_SETSPECIFIC(getclient, para->cli);
+	while (g_DemuxRuning)
+	{
+//		usleep(10 * 1000);
+		cs_sleepms(20);
+//		memset((void *)u32ChHandle, 0, sizeof(HI_HANDLE) * MAX_HICHANNEL);
+//		u32HandleNum = MAX_HICHANNEL;
+//		hiReturn = HI_UNF_DMX_GetDataHandle(u32ChHandle, &u32HandleNum, 1000);	/* timeout 1000ms */
+//		if ((HI_SUCCESS != hiReturn) || (u32HandleNum == 0)) continue;
+		for (f = 0; f < MAX_HIFILTERS; f++)
+		{
+		  	ChFilter = &(g_HIFilters[f]);
+			if ( ChFilter->uFiltype != ChTYPE) continue;
+			if (!ChFilter->u32UseFlag || !ChFilter->u32EnableFlag) continue;
+			#if defined(SDKV500) || defined(SDKV600)
+				if (ChFilter->hChannel == 0) continue;
+			#else
+				if (ChFilter->hChannel < 0x150000 || ChFilter->hChannel > 0x200000) continue;
+			#endif
+
+			ChHandle = ChFilter->hChannel;
+			hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+			if ((HI_SUCCESS != hiReturn) || (HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus)) continue;
+
+			u32AcqNum = 0;
+			hiReturn  = HI_UNF_DMX_AcquireBuf(ChHandle, NUM_HIFILACQUIRES, &u32AcqNum, ChRcvBuf, 100);
+			if (hiReturn == HI_ERR_DMX_TIMEOUT ||
+				 hiReturn == HI_ERR_DMX_NOAVAILABLE_DATA ||
+				 u32AcqNum== 0) {
+				usleep(10 * 1000);
+				continue;
+			}
+			if (hiReturn == HI_FAILURE) break;
+			if (HI_SUCCESS != hiReturn)
+			{
+			 	HIPRT_WARN("mydemux:hi_unf_dmx_acquirebuf.error(%x)\n", (HI_U32)hiReturn);
+			 	break;
+			}
+//			hiReturn = HI_UNF_DMX_GetChannelAttr(ChHandle, &stChAttr);
+//			if (HI_SUCCESS != hiReturn) continue;
+			if (u32AcqNum==NUM_HIFILACQUIRES)
+			{
+			 	HIPRT_WARN("mydemux:max Acquire(%d)\n", u32AcqNum);
+			}
+//			else
+//			{
+//			 	HIPRT_WARN("mydemux:acquire\n");
+//			}
+			for (ki = 0; ki < (int)u32AcqNum; ki++) /*process data package gradually*/
+			{
+				pRecvBuff  = ChRcvBuf[ki].pu8Data;
+				u32BufLen  = ChRcvBuf[ki].u32Size;
+// 			enDataType = ChRcvBuf[ki].enDataType;
+//				if (stChAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_POST)
+//				{
+//					pRecvBuff += 5;
+//					hifilter_SectionCallbacks(ChFilter, pRecvBuff, u32BufLen);
+//				}
+//				else
+				{
+				  	hifilter_SectionCallbacks(ChFilter, pRecvBuff, u32BufLen);
+				}
+			}
+
+			/*release message*/
+			hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+			if ((HI_SUCCESS != hiReturn) ||
+				((HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus) && (HI_SUCCESS == hiReturn)))
+			{
+			  	/*avoid reference ChRcvBuf after closing channel */
+			  	break;
+			}
+//				hiReturn = HI_UNF_DMX_GetChannelStatus(ChHandle, &channelstatus);
+//				if ((HI_SUCCESS != hiReturn) || (HI_UNF_DMX_CHAN_CLOSE == channelstatus.enChanStatus)) continue;
+			hiReturn = HI_UNF_DMX_ReleaseBuf(ChHandle, u32AcqNum, ChRcvBuf);
+//				HIAPI_CHECKERROR(hiReturn,hi_unf_dmx_releasebuf);
+			usleep(10 * 1000);
+		}
+	}
+	return NULL;
+}
+
+static HI_S32
+hifilter_CheckFltAttr(HIDEMUX_ATTRIB *pFltAttr)
+{
+	if (!pFltAttr) return -1;
+	if ((pFltAttr->u32FilterType > 2))
+	{
+	  	HIPRT_ERROR("mydemux:hifilter_checkfltattr.error.type(%d)\n", pFltAttr->u32FilterType);
+	  	return -1;
+	}
+
+	if (pFltAttr->u32CrcFlag > 2)
+	{
+	  	HIPRT_ERROR("mydemux:hifilter_checkfltattr.error.crc(%d)\n", pFltAttr->u32CrcFlag);
+	  	return -1;
+	}
+
+	if (pFltAttr->u32FilterDepth > NUM_HIFLTDEPTH)
+	{
+	  	HIPRT_ERROR("mydemux:hifilter_checkfltattr.error.depth(%d)\n", pFltAttr->u32FilterDepth);
+	  	return -1;
+	}
+
+	return 0;
+}
+
+/*pu32FltId's value scope is 0-95 */
+static HI_S32
+hifilter_GetFreeFltId(HI_U32 u32DmxID, HI_U32 *pu32FltId)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	int i;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (ChFilter->u32UseFlag == 0)
+		{
+			*pu32FltId = (uRegionNum * NUM_HIPERREGION) + i;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static HI_U32
+hifilter_GetChnFltNum(HI_S32 u32DmxID, HI_HANDLE uChHandle)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	HI_U32 uFltNum = 0;
+	int i = 0;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (!ChFilter->u32UseFlag) continue;
+		if ( ChFilter->hChannel == 0 || ChFilter->hChannel == INVALID_HIHANDLE) continue;
+		if ( ChFilter->hChannel == uChHandle) uFltNum++;
+	}
+
+	return uFltNum;
+}
+
+/*get filter amount which channel is enable */
+static HI_U32
+hifilter_GetChnEnFltNum(HI_S32 u32DmxID, HI_HANDLE uChHandle)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	HI_U32 uRegionNum;
+	HI_U32 uFltNum = 0;
+	int i = 0;
+
+	HIAPI_FILTERREGION(u32DmxID, uRegionNum);
+	for (i = 0; i < NUM_HIPERREGION; i++)
+	{
+		ChFilter = &(g_HIFilters[(uRegionNum * NUM_HIPERREGION) + i]);
+		if (!ChFilter->u32UseFlag || !ChFilter->u32EnableFlag) continue;
+		if ( ChFilter->hChannel == 0 || ChFilter->hChannel == INVALID_HIHANDLE) continue;
+		if ( ChFilter->hChannel == uChHandle) uFltNum++;
+	}
+
+	return uFltNum;
+}
+
+static HI_S32
+hifilter_Create(HIDEMUX_ATTRIB *pFltAttr, HI_S32 *ps32FilterID)
+{
+	HI_UNF_DMX_FILTER_ATTR_S sFilterAttr;
+	HI_UNF_DMX_CHAN_ATTR_S stChAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	HI_HANDLE hFilter;
+	HI_HANDLE hChannel;
+	HI_U32 u32FltID;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_create\n");
+	HIAPI_ISDEMUXINIT();
+	if (hifilter_CheckFltAttr(pFltAttr) != 0)
+	{
+		HIPRT_ERROR("mydemux:hifilter_checkfltattr.invalid param\n");
+		return HI_FAILURE;
+	}
+
+	if (hifilter_GetFreeFltId(pFltAttr->u32DMXID, &u32FltID) != 0)
+	{
+		HIPRT_ERROR("mydemux:hifilter_getfreefltid.no free\n");
+		return HI_FAILURE;
+	}
+
+	memset(&sFilterAttr, 0, sizeof(HI_UNF_DMX_FILTER_ATTR_S));
+	sFilterAttr.u32FilterDepth =  pFltAttr->u32FilterDepth;
+	memcpy(sFilterAttr.au8Mask, 	pFltAttr->u8Mask,  NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Match, 	pFltAttr->u8Match, NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Negate, pFltAttr->u8Negate,NUM_HIFLTDEPTH);
+	hiReturn = HI_UNF_DMX_CreateFilter(pFltAttr->u32DMXID, &sFilterAttr, &hFilter);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_createfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	hiReturn = HI_UNF_DMX_GetChannelHandle(pFltAttr->u32DMXID, pFltAttr->u32PID, &hChannel);
+	if ((HI_SUCCESS != hiReturn) && (HI_ERR_DMX_UNMATCH_CHAN != hiReturn))
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelhandle.error(%x)\n", hiReturn);
+		HI_UNF_DMX_DestroyFilter(hFilter);
+		return HI_FAILURE;
+	}
+
+	if ((HI_ERR_DMX_UNMATCH_CHAN == hiReturn) || (INVALID_HIHANDLE == hChannel))
+	{
+		/*do have channel for this PID,it need to create new channel */
+		hiReturn = HI_UNF_DMX_GetChannelDefaultAttr(&stChAttr);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_getchanneldefaultattr.error(%x)\n", hiReturn);
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			return HI_FAILURE;
+		}
+
+		if (pFltAttr->u32CrcFlag == 1)
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD;
+		}
+		else
+		if (pFltAttr->u32CrcFlag == 2)
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD;
+		}
+		else
+		{
+			stChAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORBID;
+		}
+
+		if (pFltAttr->u32FilterType == 1)
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_PES;
+		}
+		else
+		if (pFltAttr->u32FilterType == 2)
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_ECM_EMM;
+		//	stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_POST;
+		}
+		else
+		{
+			stChAttr.enChannelType = HI_UNF_DMX_CHAN_TYPE_SEC;
+		}
+
+		stChAttr.enOutputMode = HI_UNF_DMX_CHAN_OUTPUT_MODE_PLAY;
+		stChAttr.u32BufSize 	 = MAX_HIBUFFERSIZE; // not used, don't care
+
+		HIPRT_INFO("mydemux:call hi_unf_dmx_createchannel\n");
+		hiReturn = HI_UNF_DMX_CreateChannel(pFltAttr->u32DMXID, &stChAttr, &hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			HIPRT_ERROR("mydemux:hi_unf_dmx_createchannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		hiReturn = HI_UNF_DMX_SetChannelPID(hChannel, pFltAttr->u32PID);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HI_UNF_DMX_DestroyFilter(hFilter);
+			HI_UNF_DMX_DestroyChannel(hChannel);
+			HIPRT_ERROR("mydemux:hi_unf_dmx_setchannelpid.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+
+	ChFilter = &g_HIFilters[u32FltID];
+	memset(ChFilter, 0, sizeof(HIDEMUX_FILTERS));
+	ChFilter->u32EnableFlag = 0;
+	ChFilter->u32TimerCount = 0;
+	ChFilter->hFilter  		= hFilter;
+	ChFilter->hChannel 		= hChannel;
+	ChFilter->u32UseFlag 	= 1;
+	ChFilter->uFiltype  		= pFltAttr->u32Type;
+	memcpy(&ChFilter->fltAttr, pFltAttr, sizeof(HIDEMUX_ATTRIB));
+
+	*ps32FilterID = u32FltID;
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Destroy(HI_S32 s32FilterID)
+{
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_destroy\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_destroy.error\n");
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->u32EnableFlag)
+	{
+		hiReturn = HI_UNF_DMX_DetachFilter(ChFilter->hFilter, ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_detachfilter.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		ChFilter->u32EnableFlag = 0;
+	}
+
+	hiReturn = HI_UNF_DMX_DestroyFilter(ChFilter->hFilter);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_destroyfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32UseFlag = 0;
+	ChFilter->uFiltype   = 0;
+	/*if the channel did not attach filter,destroy the channel*/
+	if (!hifilter_GetChnFltNum(ChFilter->fltAttr.u32DMXID, ChFilter->hChannel))
+	{
+		HIPRT_INFO("mydemux:call hi_unf_dmx_destroychannel\n");
+		hiReturn = HI_UNF_DMX_DestroyChannel(ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_destroychannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+
+	ChFilter->hChannel = INVALID_HIHANDLE;
+	ChFilter->hFilter  = INVALID_HIHANDLE;
+	ChFilter->u32TimerCount = 0;
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_SetAttribute(HI_S32 s32FilterID, HIDEMUX_ATTRIB *pFltAttr)
+{
+	HI_UNF_DMX_FILTER_ATTR_S sFilterAttr;
+	HI_UNF_DMX_CHAN_ATTR_S sChanAttr;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+	if (hifilter_CheckFltAttr(pFltAttr) != 0)
+	{
+		HIPRT_ERROR("mydemux:hifilter_checkfltattr.invalid param\n");
+		return HI_FAILURE;
+	}
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if (pFltAttr->u32FilterType != ChFilter->fltAttr.u32FilterType)
+	{
+		HIPRT_ERROR("mydemux:hifilter_setattr.error type\n");
+		return HI_FAILURE;
+	}
+
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_setattr.error\n");
+		return HI_FAILURE;
+	}
+
+	memset(&sFilterAttr, 0, sizeof(HI_UNF_DMX_FILTER_ATTR_S));
+	sFilterAttr.u32FilterDepth = pFltAttr->u32FilterDepth;
+	memcpy(sFilterAttr.au8Mask,  pFltAttr->u8Mask,   NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Match, pFltAttr->u8Match,  NUM_HIFLTDEPTH);
+	memcpy(sFilterAttr.au8Negate,pFltAttr->u8Negate, NUM_HIFLTDEPTH);
+	hiReturn = HI_UNF_DMX_SetFilterAttr(ChFilter->hFilter, &sFilterAttr);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_setfilterattr.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->fltAttr.u32CrcFlag != pFltAttr->u32CrcFlag)
+	{
+		hiReturn = HI_UNF_DMX_GetChannelAttr(ChFilter->hChannel, &sChanAttr);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelattr.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		if (sChanAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_SEC ||
+			 sChanAttr.enChannelType == HI_UNF_DMX_CHAN_TYPE_ECM_EMM)
+		{
+			if ((ChFilter->fltAttr.u32CrcFlag == 1)
+				&& (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+			else
+			if ((ChFilter->fltAttr.u32CrcFlag == 2) && (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+			else
+			if ((ChFilter->fltAttr.u32CrcFlag == 0) && (sChanAttr.enCRCMode != HI_UNF_DMX_CHAN_CRC_MODE_FORBID))
+			{
+				sChanAttr.enCRCMode = HI_UNF_DMX_CHAN_CRC_MODE_FORBID;
+				hiReturn  = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+				hiReturn |= HI_UNF_DMX_SetChannelAttr(ChFilter->hChannel, &sChanAttr);
+				hiReturn |= HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+			}
+
+			if (HI_SUCCESS != hiReturn)
+			{
+				 HIPRT_ERROR("mydemux:hifilter_setattr.crc.error(%x)\n", hiReturn);
+				 return HI_FAILURE;
+			}
+		}
+	}
+
+	memcpy(&ChFilter->fltAttr, pFltAttr, sizeof(HIDEMUX_ATTRIB));
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_GetAttr(HI_S32 s32FilterID, HIDEMUX_ATTRIB *pFltAttr)
+{
+	HIDEMUX_FILTERS *ChFilter;
+
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+	if (!pFltAttr)
+	{
+		HIPRT_ERROR("mydemux:hifilter_getattr.null\n");
+		return HI_FAILURE;
+	}
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	memcpy(pFltAttr, &ChFilter->fltAttr, sizeof(HIDEMUX_ATTRIB));
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Start(HI_S32 s32FilterID)
+{
+	HI_UNF_DMX_CHAN_STATUS_S stStatus;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_start\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_start.error\n");
+		return HI_FAILURE;
+	}
+
+	if (ChFilter->u32EnableFlag)
+	{
+		HIPRT_ERROR("mydemux:hifilter_start.already\n");
+		return HI_SUCCESS;
+	}
+
+	hiReturn = HI_UNF_DMX_AttachFilter(ChFilter->hFilter, ChFilter->hChannel);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_attachfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32EnableFlag = 1;
+	ChFilter->u32TimerCount = 0;
+	hiReturn = HI_UNF_DMX_GetChannelStatus(ChFilter->hChannel, &stStatus);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelstatus.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	if (HI_UNF_DMX_CHAN_CLOSE == stStatus.enChanStatus)
+	{
+		hiReturn = HI_UNF_DMX_OpenChannel(ChFilter->hChannel);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_openchannel.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+	}
+	return HI_SUCCESS;
+}
+
+static HI_S32
+hifilter_Stop(HI_S32 s32FilterID)
+{
+	HI_UNF_DMX_CHAN_STATUS_S stStatus;
+	HIDEMUX_FILTERS *ChFilter;
+	int hiReturn;
+
+	HIPRT_INFO("mydemux:call hifilter_stop!\n");
+	HIAPI_ISDEMUXINIT();
+	HIAPI_CHECKFILTERID(s32FilterID);
+
+	ChFilter = &g_HIFilters[s32FilterID];
+	if ((INVALID_HIHANDLE == ChFilter->hFilter) || (INVALID_HIHANDLE == ChFilter->hChannel))
+	{
+		HIPRT_ERROR("mydemux:hifilter_stop.error\n");
+		return HI_FAILURE;
+	}
+
+	if (!ChFilter->u32EnableFlag)
+	{
+		HIPRT_ERROR("mydemux:hifilter_stop.already\n");
+		return HI_SUCCESS;
+	}
+
+	hiReturn = HI_UNF_DMX_DetachFilter(ChFilter->hFilter, ChFilter->hChannel);
+	if (HI_SUCCESS != hiReturn)
+	{
+		HIPRT_ERROR("mydemux:hi_unf_dmx_detachfilter.error(%x)\n", hiReturn);
+		return HI_FAILURE;
+	}
+
+	ChFilter->u32EnableFlag = 0;
+	ChFilter->u32TimerCount = 0;
+	/*if the channel did not attach filter,close the channel*/
+	if (!hifilter_GetChnEnFltNum(ChFilter->fltAttr.u32DMXID, ChFilter->hChannel))
+	{
+		HIPRT_INFO("mydemux:call hi_unf_dmx_closechannel\n");
+		hiReturn = HI_UNF_DMX_GetChannelStatus(ChFilter->hChannel, &stStatus);
+		if (HI_SUCCESS != hiReturn)
+		{
+			HIPRT_ERROR("mydemux:hi_unf_dmx_getchannelstatus.error(%x)\n", hiReturn);
+			return HI_FAILURE;
+		}
+
+		if (HI_UNF_DMX_CHAN_CLOSE != stStatus.enChanStatus)
+		{
+			hiReturn = HI_UNF_DMX_CloseChannel(ChFilter->hChannel);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_ERROR("mydemux:hi_unf_dmx_closechannel.error(%x)\n", hiReturn);
+				return HI_FAILURE;
+			}
+		}
+	}
+	return HI_SUCCESS;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+static int32_t
+hidemux_Start(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid, unsigned char *fltr, unsigned char *mask)
+{
+	HIDEMUX_ATTRIB FltAttr;
+	HI_S32 hifltnum = INVALID_HIFILTER;
+	int hiReturn;
+	int i;
+
+	FltAttr.dmuxid				= dmuxid;
+	FltAttr.fltnum				= n;
+	FltAttr.u32TUNERID		= TUNER0;
+	FltAttr.u32DMXID			= HIDEMUX_OSCAM_ID;
+	#if defined(SDKV600)
+		if (adapter==DEMUX_SECONDADAPTER) {
+			FltAttr.u32TUNERID= TUNER1;
+			FltAttr.u32DMXID	= HIDEMUX_OSCAM2_ID;
+		}
+	#endif
+	FltAttr.u32Type			= type;
+	FltAttr.u32FilterType 	= 0;	// Section/ECM.EMM
+	FltAttr.u32FilterType 	= (pid == CAT_PID) ? 0 : 2;
+	FltAttr.u32PID				= pid;
+	FltAttr.u32CrcFlag 		= 0;
+	FltAttr.u32TimeOutMs		= 9000;
+
+	memset(FltAttr.u8Match, 0x00,NUM_HIFLTDEPTH);
+	memset(FltAttr.u8Mask,  0xFF,NUM_HIFLTDEPTH);
+	memset(FltAttr.u8Negate,0x00,NUM_HIFLTDEPTH);
+	FltAttr.u8Match[0] 		= fltr[0];
+	FltAttr.u8Mask [0] 		= HIFLT_REVERSE_MASK(mask[0]);
+	FltAttr.u32FilterDepth	= DVB_HIFLTBYTES;
+	for (i=1; i<(int)FltAttr.u32FilterDepth; i++)
+	{
+		FltAttr.u8Match[i] 	= fltr[i];
+		FltAttr.u8Mask [i] 	= HIFLT_REVERSE_MASK(mask[i]);
+	}
+
+	cs_log_dbg(D_DVBAPI, "hifilter %d(%d) start(pid:%04X)", n, type, pid);
+	if (!IS_INVALID_PID(pid))
+	{
+		hiReturn = hifilter_Create(&FltAttr, &hifltnum);
+		if (HI_SUCCESS != hiReturn)
+		{
+			g_dmuxes[dmuxid][n].activated = 0;
+			HIPRT_ERROR("mydemux:hifilter %d(%d) failure", n, type);
+		}
+		else
+		{
+			hiReturn = hifilter_Start(hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_ERROR("mydemux:hifilter %d(%d) failure", n, type);
+			}
+			g_dmuxes[dmuxid][n].hifltnum  = hifltnum;
+			g_dmuxes[dmuxid][n].activated = 1;
+		}
+	}
+	HIPRT_INFO("mydemux:hifilter_start{%d:%d:%d,%04X}{%2d:%02X%02X%02X%02X%02X%02X%02X%02X}\n",
+				dmuxid,
+				type, n, pid,
+				g_dmuxes[dmuxid][n].hifltnum,
+				fltr[0],fltr[1],fltr[2],fltr[3],fltr[4],fltr[5],fltr[6],fltr[7]);
+	g_dmuxes[dmuxid][n].adapter= adapter;
+	g_dmuxes[dmuxid][n].dmuxid = dmuxid;
+	g_dmuxes[dmuxid][n].pid	 	= pid;
+	g_dmuxes[dmuxid][n].type	= type;
+	g_dmuxes[dmuxid][n].flnum 	= n;
+	return (n+1);
+}
+
+static int32_t
+hidemux_Stop(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid)
+{
+	int hiReturn;
+
+	if (n > MAX_FILTER-1) return 0;
+	if (g_dmuxes[dmuxid][n].activated)
+	{
+		HIPRT_INFO("mydemux:hifilter_stop{%d:%d:%d,%04x}{%d}\n",
+					dmuxid,
+					type, n, pid,
+					g_dmuxes[dmuxid][n].hifltnum);
+		g_dmuxes[dmuxid][n].activated = 0;
+//		if (g_dmuxes[dmuxid][n].dmuxid != dmuxid)
+//		{
+//			HIPRT_TRACE("mydemux:hidemux_filterclose dmuxid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].dmuxid, dmuxid);
+//			return 0;
+//		}
+//		if (pid  && g_dmuxes[dmuxid][n].pid != pid)
+//		{
+//			HIPRT_TRACE("mydemux:hidemux_filterclose pid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].pid, pid);
+//			return 0;
+//		}
+//		if (type && g_dmuxes[dmuxid][n].type != type)
+//		{
+//			HIPRT_TRACE("mydemux:hidemux_filterclose pid{%x,%x} invalid\n", g_dmuxes[dmuxid][n].pid, pid);
+//			return 0;
+//		}
+		if (!IS_INVALID_HIFILTERS(g_dmuxes[dmuxid][n].hifltnum))
+		{
+			cs_log_dbg(D_DVBAPI, "hifilter %d(%d) stop(pid:%04X)", n, type, pid);
+			hiReturn = hifilter_Stop(g_dmuxes[dmuxid][n].hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_INFO("hifilter_stop.failed\n");
+				cs_log_dbg(D_DVBAPI, "hifilter %d(%d) failure{%x}", n, type, hiReturn);
+			}
+
+			hiReturn = hifilter_Destroy(g_dmuxes[dmuxid][n].hifltnum);
+			if (HI_SUCCESS != hiReturn)
+			{
+				HIPRT_INFO("hifilter_destroy.failed\n");
+				cs_log_dbg(D_DVBAPI, "hifilter %d(%d) failure{%x}", n, type, hiReturn);
+			}
+		}
+	}
+	g_dmuxes[dmuxid][n].adapter	= -1;
+	g_dmuxes[dmuxid][n].dmuxid 	= -1;
+	g_dmuxes[dmuxid][n].type		=  0;
+	g_dmuxes[dmuxid][n].pid	 		=  0;
+	g_dmuxes[dmuxid][n].flnum  	= -1;
+	g_dmuxes[dmuxid][n].hifltnum 	= INVALID_HIFILTER;
+	return 1;
+}
+
+
+static int
+hidemux_Init(void)
+{
+	struct hidemux_thread_param *ecmpara, *emmpara;
+	pthread_attr_t attr;
+	//SAFE_ATTR_INIT(&attr);
+	int hiReturn;
+	int ret;
+	int dmuxid, n, i;
+
+	HIPRT_TRACE("mydemux:hidemux_init{%p,%p)\n", dvbapi_client, cur_client());
+	HIPRT_TRACE("mydemux:hidemux_init{%d)\n", MAX_HIFILTERS);
+
+	if (g_DemuxIniz) return 1;
+
+	hiReturn = HI_UNF_DMX_Init();
+	cs_log("HI_UNF_DMX_Init:(%x)\n", hiReturn);
+	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_Init);
+
+	#if defined(SDKV600)
+		#if 0
+			// use tvheadend...
+			/* 0,4 is PLAY DMX */
+			hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM1_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+			// TUNER 1
+			/* 0,4 is PLAY DMX */
+			hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM2_ID/*demux id*/, HIPORT_INTERNAL_ID/*port id*/); //for section
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+		#endif
+	#elif defined(SDKV500)
+		// tvheadend
+		#if 0
+			HI_UNF_DMX_PORT_ATTR_S PortAttr;
+			// TUNER 0
+			hiReturn = HI_UNF_DMX_GetTSPortAttr(HIPORT_TUNER_ID, &PortAttr);
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_GetTSPortAttr);
+			PortAttr.enPortType = HI_UNF_DMX_PORT_TYPE_SERIAL;
+			#if defined(Hi3719MV100)
+				PortAttr.u32SerialBitSelector = 1; //D0
+			#else
+				PortAttr.u32SerialBitSelector = 0; //D7
+			#endif
+			hiReturn = HI_UNF_DMX_SetTSPortAttr(HIPORT_TUNER_ID, &PortAttr);
+			HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_SetTSPortAttr);
+		#endif
+
+		/* 0,4 is PLAY DMX */
+		hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+		HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+		// TUNER 1
+		//	hiReturn = HI_UNF_DMX_GetTSPortAttr(HI_UNF_DMX_PORT_TSI_3, &PortAttr);
+		//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_GetTSPortAttr);
+		//	PortAttr.enPortType = HI_UNF_DMX_PORT_TYPE_SERIAL;
+		//	PortAttr.u32SerialBitSelector = 0; //D7
+		//	hiReturn = HI_UNF_DMX_SetTSPortAttr(HI_UNF_DMX_PORT_TSI_3, &PortAttr);
+		//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_SetTSPortAttr);
+
+		/* 0,4 is PLAY DMX */
+	//	hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_DMX_ID2/*demux id*/, HI_UNF_DMX_PORT_TSI_3/*port id*/); //for section
+	//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+	#else
+		hiReturn = HI_UNF_DMX_AttachTSPort(HIDEMUX_OSCAM_ID/*demux id*/, HIPORT_TUNER_ID/*port id*/); //for section
+		HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+	#endif
+
+	for (dmuxid=0; dmuxid<MAX_DEMUX; dmuxid++)
+	{
+		for (n=0; n<MAX_FILTER; n++)
+		{
+			g_dmuxes[dmuxid][n].dmuxid		= -1;
+			g_dmuxes[dmuxid][n].adapter	= -1;
+			g_dmuxes[dmuxid][n].type	 	= 0;
+			g_dmuxes[dmuxid][n].pid 	 	= 0;
+			g_dmuxes[dmuxid][n].flnum 	 	= -1;
+			g_dmuxes[dmuxid][n].hifltnum	= INVALID_HIFILTER;
+			g_dmuxes[dmuxid][n].activated = 0;
+		}
+	}
+	for (i=0; i<MAX_HIFILTERS; i++)
+	{
+		memset(&g_HIFilters[i], 0, sizeof(HIDEMUX_FILTERS));
+		g_HIFilters[i].hChannel = INVALID_HIHANDLE;
+		g_HIFilters[i].hFilter  = INVALID_HIHANDLE;
+	}
+
+	pthread_attr_init(&attr);
+	pthread_attr_setstacksize(&attr, PTHREAD_STACK_SIZE);
+
+	if (!cs_malloc(&ecmpara, sizeof(struct hidemux_thread_param))) return 0;
+//	ecmpara->flnum = HIDEMUX_OSCAM_ID;
+	ecmpara->id  	 = TYPE_ECM;
+	ecmpara->cli 	 = cur_client();
+	ret = pthread_create(&g_FltEcmThread, NULL, hifilter_ThreadModules, (void *)ecmpara);
+	//ret = start_thread("hifilter ThreadModules", hifilter_ThreadModules, (void *)ecmpara, NULL, 1, 0);
+	if (ret) {
+		pthread_attr_destroy(&attr);
+		HIPRT_TRACE("hifilter_Init thread.errno(%d.%s)", ret, strerror(ret));
+		return 0;
+	}
+	else {
+		pthread_detach(g_FltEcmThread);
+	}
+
+	if (!cs_malloc(&emmpara, sizeof(struct hidemux_thread_param))) return 0;
+	emmpara->id  = TYPE_EMM;
+	emmpara->cli = cur_client();
+	ret = pthread_create(&g_FltEmmThread, NULL, hifilter_ThreadModules, (void *)emmpara);
+	//ret = start_thread("hifilter ThreadModules", hifilter_ThreadModules, (void *)emmpara, NULL, 1, 0);
+	if (ret) {
+		pthread_attr_destroy(&attr);
+		HIPRT_TRACE("hifilter_Init thread.errno(%d.%s)", ret, strerror(ret));
+		return 0;
+	}
+	else {
+		pthread_detach(g_FltEmmThread);
+	}
+	pthread_attr_destroy(&attr);
+	g_DemuxRuning = HI_TRUE;
+	if (hiReturn == HI_SUCCESS) g_DemuxIniz = 1;
+	return (g_DemuxIniz);
+}
+
+
+static int
+hidemux_DeInit(void)
+{
+	int hiReturn;
+	int dmuxid;
+	int n;
+
+	HIPRT_TRACE("mydemux:hidemux_close\n");
+	if (!g_DemuxIniz) return 1;
+
+	for (dmuxid=0;dmuxid<MAX_DEMUX;dmuxid++)
+	{
+		for (n=0;n<MAX_FILTER;n++)
+		{
+			hidemux_Stop(-1, dmuxid, 0, n, 0);
+		}
+	}
+	g_DemuxIniz = 0;
+	g_DemuxRuning = HI_FALSE;
+	usleep(100 * 1000);
+	pthread_join(g_FltEcmThread, 0);
+	//SAFE_THREAD_JOIN(g_FltEcmThread, 0);
+	pthread_join(g_FltEmmThread, 0);
+	//SAFE_THREAD_JOIN(g_FltEmmThread, 0);
+
+//	hiReturn = HI_UNF_DMX_DetachTSPort(HIPORT_TUNER_ID/*port id*/);
+//	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_AttachTSPort);
+
+	hiReturn = HI_UNF_DMX_DeInit();
+	HIAPI_CHECKERROR(hiReturn,HI_UNF_DMX_DeInit);
+	return 1;
+}
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+int32_t
+hidemuxapi_AddFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid, uchar *flt, uchar *mask)
+{
+	int status;
+
+	if (!g_DemuxIniz) return -1;
+	pthread_mutex_lock(&g_FltLocks);
+	//SAFE_MUTEX_LOCK(&g_FltLocks);
+	status = hidemux_Start(adapter, dmuxid, type, n, pid, flt, mask);
+	pthread_mutex_unlock(&g_FltLocks);
+	//SAFE_MUTEX_UNLOCK(&g_FltLocks);
+	return status;
+}
+
+int32_t
+hidemuxapi_RemoveFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid)
+{
+	int status;
+
+	if (!g_DemuxIniz) return -1;
+	pthread_mutex_lock(&g_FltLocks);
+	//SAFE_MUTEX_LOCK(&g_FltLocks);
+	status = hidemux_Stop(adapter, dmuxid, type, n, pid);
+	pthread_mutex_unlock(&g_FltLocks);
+	//SAFE_MUTEX_UNLOCK(&g_FltLocks);
+	return status;
+}
+
+
+
+/* write cw to all demuxes in mask with passed index */
+int32_t
+hidemuxapi_Init(void)
+{
+	pthread_mutex_init(&g_FltLocks, NULL);
+	//SAFE_MUTEX_INIT(&g_FltLocks, NULL);
+	pthread_mutex_init(&g_FltMutex, NULL);
+	//SAFE_MUTEX_INIT(&g_FltMutex, NULL);
+	//
+	//
+	// link option -lhi_common
+	// for disable debug message
+	HI_SYS_Init();
+	#if defined(SDKV500) || defined(SDKV600)
+		HI_SYS_SetLogLevel(HI_ID_DEMUX,HI_LOG_LEVEL_ERROR);
+	#else
+		HI_SYS_SetLogLevel(HI_DEBUG_ID_DEMUX,HI_LOG_LEVEL_ERROR);
+	#endif
+	//
+	//
+	//
+	hidemux_Init();
+	atexit(hidemuxapi_Deinit);
+	return 1;
+}
+
+void
+hidemuxapi_Deinit(void)
+{
+	hidemux_DeInit();
+	//
+	//
+	//
+	HI_SYS_DeInit();
+	//
+	//
+	//
+	pthread_mutex_destroy(&g_FltLocks);
+	pthread_mutex_destroy(&g_FltMutex);
+}
+
+#endif	// #if defined(WITH_HISILICON)
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+//----------------------------------------------------------------------
+
Index: module-dvbapi-his.h
===================================================================
--- module-dvbapi-his.h	(nonexistent)
+++ module-dvbapi-his.h	(working copy)
@@ -0,0 +1,13 @@
+#ifndef _MODULE_HIAPI_H_
+#define _MODULE_HIAPI_H_
+
+#define DEMUX_MAINADAPTER 3
+#define DEMUX_SECONDADAPTER 2
+
+/* Local hiapi functions */
+int32_t hidemuxapi_Init(void);
+void hidemuxapi_Deinit(void);
+int32_t hidemuxapi_AddFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n,int32_t pid, uchar *flt, uchar *mask);
+int32_t hidemuxapi_RemoveFilters(int32_t adapter, int32_t dmuxid, int32_t type, int32_t n, int32_t pid);
+
+#endif
Index: module-dvbapi.c
===================================================================
--- module-dvbapi.c	(revision 1542)
+++ module-dvbapi.c	(working copy)
@@ -11,6 +11,9 @@
 #include "module-dvbapi-coolapi.h"
 #include "module-dvbapi-stapi.h"
 #include "module-dvbapi-chancache.h"
+#if defined(WITH_HISILICON)
+#include "module-dvbapi-his.h"
+#endif
 #include "module-stat.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -261,7 +264,7 @@
 struct s_dvbapi_priority *dvbapi_priority;
 struct s_client *dvbapi_client;
 
-const char *boxdesc[] = { "none", "dreambox", "duckbox", "ufs910", "dbox2", "ipbox", "ipbox-pmt", "dm7000", "qboxhd", "coolstream", "neumo", "pc", "pc-nodmx", "samygo" };
+const char *boxdesc[] = { "none", "dreambox", "duckbox", "ufs910", "dbox2", "ipbox", "ipbox-pmt", "dm7000", "qboxhd", "coolstream", "neumo", "pc", "pc-nodmx", "samygo","hisky" };
 
 
 // when updating devices[BOX_COUNT] make sure to update these index defines
@@ -268,6 +271,7 @@
 #define BOX_INDEX_QBOXHD 0
 #define BOX_INDEX_DREAMBOX_DVBAPI3 1
 #define BOX_INDEX_COOLSTREAM 6
+#define BOX_INDEX_HISILICON 7
 
 static const struct box_devices devices[BOX_COUNT] =
 {
@@ -282,6 +286,7 @@
 	/* sh4      (stapi)*/       { "/dev/stapi/",            "stpti4_ioctl", "stpti4_ioctl", "/tmp/camd.socket", STAPI       },
 #endif
 	/* coolstream*/             { "/dev/cnxt/",             "null",         "null",         "/tmp/camd.socket", COOLAPI     },
+	/* HiSilicon*/              { "/dev/",                  "null",         "null",         "/var/camd.socket", HISILICONAPI },
 };
 
 static int32_t selected_box = -1;
@@ -289,7 +294,7 @@
 static int32_t maxfilter = MAX_FILTER;
 static int32_t dir_fd = -1;
 static uint16_t last_client_proto_version = 0;
-static char* last_client_name = NULL;
+static char* last_client_name = "hisilicon";
 
 static int32_t ca_fd[MAX_DEMUX]; // holds fd handle of each ca device 0 = not in use
 static LLIST * ll_activestreampids; // list of all enabled streampids on ca devices
@@ -722,7 +727,7 @@
 	return 0;
 }
 
-int32_t dvbapi_set_filter(int32_t demux_id, int32_t api, uint16_t pid, uint16_t caid, uint32_t provid, uchar *filt, uchar *mask, int32_t timeout, int32_t pidindex, int32_t type,
+int32_t dvbapi_set_filter(int32_t demux_id, int32_t api, uint16_t pid, uint16_t caid, uint32_t provid, uchar *filt, uchar *mask, int32_t timeout, int32_t pidx, int32_t type,
 	int8_t add_to_emm_list)
 {
 	int32_t ret = -1, n = -1, i, filterfd = -1;
@@ -729,6 +734,7 @@
 
 	for(i = 0; i < maxfilter && demux[demux_id].demux_fd[i].fd > 0; i++) { ; }
 
+	cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_set_filter{%d:%d, %d,%04X,%06X:%04X}\n", demux_id, i, type, caid, provid, pid);
 	if(i >= maxfilter)
 	{
 		cs_log_dbg(D_DVBAPI, "no free filter");
@@ -740,11 +746,11 @@
 	{
 		if(type == TYPE_ECM)
 		{
-			openxcas_set_caid(demux[demux_id].ECMpids[pidindex].CAID);
+			openxcas_set_caid(demux[demux_id].ECMpids[pidx].CAID);
 			openxcas_set_ecm_pid(pid);
 		}
 		demux[demux_id].demux_fd[n].fd 		 = DUMMY_FD;
-		demux[demux_id].demux_fd[n].pidindex = pidindex;
+		demux[demux_id].demux_fd[n].pidindex = pidx;
 		demux[demux_id].demux_fd[n].pid      = pid;
 		demux[demux_id].demux_fd[n].caid     = caid;
 		demux[demux_id].demux_fd[n].provid   = provid;
@@ -817,6 +823,21 @@
 		ret = dvbapi_ioctl(filterfd, DMX_SET_FILTER1, &sFP1);
 
 		break;
+
+#if defined(WITH_HISILICON)
+	case HISILICONAPI:
+		//	demux[demux_id].demux_fd[n].fd = 1;
+		// sky(quad)
+		ret = hidemuxapi_AddFilters(demux[demux_id].adapter_index, demux[demux_id].demux_index, type, n, pid, filt, mask);
+		if (ret > 0) {
+			demux[demux_id].demux_fd[n].fd = ret;
+		}
+		else {
+			ret = -1; // error setting filter!
+		}
+		break;
+#endif
+
 #if defined(WITH_STAPI) || defined(WITH_STAPI5)
 	case STAPI:
 		ret = filterfd = stapi_set_filter(demux_id, pid, filt, mask, n, demux[demux_id].pmt_file);
@@ -846,7 +867,7 @@
 	{
 		// only register if filter was set successful
 		demux[demux_id].demux_fd[n].fd 		 = filterfd;
-		demux[demux_id].demux_fd[n].pidindex = pidindex;
+		demux[demux_id].demux_fd[n].pidindex = pidx;
 		demux[demux_id].demux_fd[n].pid      = pid;
 		demux[demux_id].demux_fd[n].caid     = caid;
 		demux[demux_id].demux_fd[n].provid   = provid;
@@ -868,7 +889,23 @@
 
 static int32_t dvbapi_detect_api(void)
 {
-#if defined WITH_COOLAPI || defined WITH_COOLAPI2
+#if defined(WITH_HISILICON)
+	selected_api = HISILICONAPI;
+	selected_box = BOX_INDEX_HISILICON;
+	disable_pmt_files  = 1;
+	cfg.dvbapi_pmtmode = 1;
+	cfg.dvbapi_boxtype = BOXTYPE_HISILICON;
+	cfg.dvbapi_listenport = 0; // TCP port to listen instead of camd.socket
+	cs_log("Detected Hisilicon API");
+	if (hidemuxapi_Init() == 0)
+	{
+		cs_log("ERROR: dvbiapi: setting up hisky failed.");
+		return 0;
+	}
+	cs_log("Detected Hisilicon{%d}.", cfg.dvbapi_pmtmode);
+	cs_log_dbg(D_DVBAPI,"mydvb:Hisilicon\n");
+	return 1;
+#elif defined WITH_COOLAPI || defined WITH_COOLAPI2
 	selected_api = COOLAPI;
 	selected_box = BOX_INDEX_COOLSTREAM;
 	disable_pmt_files = 1;
@@ -1024,8 +1061,9 @@
 
 int32_t dvbapi_open_device(int32_t type, int32_t num, int32_t adapter)
 {
-	int32_t dmx_fd, ret;
+	int32_t dmx_fd;
 	int32_t ca_offset = 0;
+	int32_t ret = 0;
 	char device_path[128], device_path2[128];
 
 	if(cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
@@ -1052,6 +1090,11 @@
 		if(cfg.dvbapi_boxtype == BOXTYPE_SAMYGO)
 			{ num = 0; }
 
+#if defined(WITH_HISILICON)
+		if (cfg.dvbapi_boxtype==BOXTYPE_HISILICON)
+			{ num = 0; }
+#endif
+
 		snprintf(device_path2, sizeof(device_path2), devices[selected_box].ca_device, num + ca_offset);
 		snprintf(device_path, sizeof(device_path), devices[selected_box].path, adapter);
 
@@ -1058,7 +1101,7 @@
 		strncat(device_path, device_path2, sizeof(device_path) - strlen(device_path) - 1);
 	}
 
-	if (cfg.dvbapi_boxtype == BOXTYPE_SAMYGO) {
+	if (cfg.dvbapi_boxtype == BOXTYPE_SAMYGO || cfg.dvbapi_boxtype == BOXTYPE_HISILICON) {
 
 		if(type == 0)
 		{
@@ -1091,6 +1134,7 @@
 			ret = -1;
 		}
 	} else {
+		cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_open_device{%s}\n", device_path);
 		dmx_fd = ret = open(device_path, O_RDWR | O_NONBLOCK);
 	}
 
@@ -1105,6 +1149,7 @@
 	return dmx_fd;
 }
 
+
 uint16_t tunemm_caid_map(uint8_t direct, uint16_t caid, uint16_t srvid)
 {
 	int32_t i;
@@ -1150,6 +1195,7 @@
 	{
 		if(demux[demux_index].demux_fd[g].type == type)
 		{
+			cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_stop_filter{%s.%d}\n", (type==TYPE_ECM) ? "ecm":"emm", g);
 			if(dvbapi_stop_filternum(demux_index, g, msgid) == -1)
 			{
 				error = 1;
@@ -1214,12 +1260,27 @@
 				}
 				break;
 #endif
+#if defined(WITH_HISILICON)
+			case HISILICONAPI:
+		      cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_stop_filternum{%s:%d.%04X}\n",
+		      		(demux[demux_index].demux_fd[num].type==TYPE_ECM) ? "ecm":"emm" ,
+		      		num, demux[demux_index].demux_fd[num].pid);
+		      retfilter = hidemuxapi_RemoveFilters(demux[demux_index].adapter_index,
+				      				demux_index,
+								      demux[demux_index].demux_fd[num].type,
+								      num,
+								      demux[demux_index].demux_fd[num].pid);
+				if (retfilter < 1) retfilter = -1;
+				retfd = 0;
+				break;
+#endif
 			default:
 				break;
 			}
 			if(errno == 9) {retfilter = 0;} // no error on bad file descriptor
 		} while (retfilter < 0 && try < 10);
-
+#if defined(WITH_HISILICON)
+#else
 #if !defined WITH_COOLAPI && !defined WITH_COOLAPI2 // no fd close for coolapi and stapi, all others do close fd!
 		try = 0;
 		do
@@ -1264,6 +1325,7 @@
 	{
 		cs_log("ERROR: Demuxer %d could not close fd of Filter %d (fd=%d api:%d errno=%d %s)", demux_index, num + 1, fd,
 			selected_api, errno, strerror(errno));
+#endif
 		return retfd;
 	}
 
@@ -1271,6 +1333,10 @@
 
 	if(demux[demux_index].demux_fd[num].type == TYPE_ECM)   //ecm filter stopped: reset index!
 	{
+
+#if defined(WITH_HISILICON)
+		demux[demux_index].ECMpids[demux[demux_index].demux_fd[num].pidindex].index[0] = 0;
+#else
 		int32_t oldpid = demux[demux_index].demux_fd[num].pidindex;
 		int32_t curpid = demux[demux_index].pidindex;
 
@@ -1347,6 +1413,7 @@
 				}
 			}
 		}
+#endif
 	}
 
 	if(demux[demux_index].demux_fd[num].type == TYPE_EMM)   // If emm type remove from emm filterlist
@@ -1358,7 +1425,7 @@
 	return 1; // all ok!
 }
 
-void dvbapi_start_filter(int32_t demux_id, int32_t pidindex, uint16_t pid, uint16_t caid, uint32_t provid, uchar table, uchar mask, int32_t timeout, int32_t type)
+void dvbapi_start_filter(int32_t demux_id, int32_t pidx, uint16_t pid, uint16_t caid, uint32_t provid, uchar table, uchar mask, int32_t timeout, int32_t type)
 {
 	int32_t o;
 	for(o = 0; o < maxfilter; o++)    // check if filter is present
@@ -1380,7 +1447,7 @@
 	filter[16] = mask;
 
 	cs_log_dbg(D_DVBAPI, "Demuxer %d try to start new filter for caid: %04X, provid: %06X, pid: %04X", demux_id, caid, provid, pid);
-	dvbapi_set_filter(demux_id, selected_api, pid, caid, provid, filter, filter + 16, timeout, pidindex, type, 0);
+	dvbapi_set_filter(demux_id, selected_api, pid, caid, provid, filter, filter + 16, timeout, pidx, type, 0);
 }
 
 void dvbapi_start_sdt_filter(int32_t demux_index)
@@ -1596,7 +1663,7 @@
 			demux_id, demux[demux_id].ECMpidcount, caid, ecmpid, provid, txt);
 		return;
 	}
-
+//	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].tableid = 0;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].ECM_PID = ecmpid;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].CAID = caid;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].PROVID = provid;
@@ -1603,11 +1670,11 @@
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].CHID = 0x10000; // reset CHID
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].checked = 0;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].status = 0;
-	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].tries = 0xFE;
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].tries = 0xfe;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].streams = 0; // reset streams!
-	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_curindex = 0xFE; // reset
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_curindex = 0xfe; // reset
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_maxindex = 0; // reset
-	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_cycle = 0xFE; // reset
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_cycle = 0xfe; // reset
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].table = 0;
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].cadata = cadata;
 
@@ -1686,7 +1753,9 @@
 
 void dvbapi_parse_cat(int32_t demux_id, uchar *buf, int32_t len)
 {
-#if defined WITH_COOLAPI  || defined WITH_COOLAPI2
+#if defined(WITH_HISILICON)
+	demux[demux_id].max_emm_filter = MAX_FILTER-1;
+#elif defined WITH_COOLAPI  || defined WITH_COOLAPI2
 	// driver sometimes reports error if too many emm filter
 	// but adding more ecm filter is no problem
 	// ... so ifdef here instead of limiting MAX_FILTER
@@ -1711,9 +1780,23 @@
 	}
 #endif
 	uint16_t i, k;
-
+	uint16_t sctlen = SCT_DATLEN(buf);
+	if (len != sctlen + 3) { // invalid CAT length
+		cs_log_dbg(D_DVBAPI, "[DVBAPI] Received an CAT with invalid length!");
+		return;
+	}
+ 
+ 	cs_log_dbg(D_DVBAPI,"mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CAT\n");
 	cs_log_dump_dbg(D_DVBAPI, buf, len, "cat:");
+	struct s_client *cl = cur_client();
+	if (!cl) return;
+	if (!cl->aureader_list)
+	{
+		mycs_trace(D_ADB,"mydvb:dvbapi_parse_cat(%c.aureader_list none)", cl->typ);
+		return;
+	}
 
+
 	for(i = 8; i < (b2i(2, buf + 1)&0xFFF) - 1; i += buf[i + 1] + 2)
 	{
 		if(buf[i] != 0x09) { continue; }
@@ -1873,6 +1956,11 @@
 	case COOLAPI:
 		break;
 #endif
+#if defined(WITH_HISILICON)
+// unnecessariness(tvheadend)....
+		case HISILICONAPI:
+			break;
+#endif
 	default:
 		for(i = 0; i < MAX_DEMUX; i++)
 		{
@@ -2031,42 +2119,81 @@
 
 	demux[demux_id].pidindex = -1;
 	demux[demux_id].curindex = -1;
-	if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX)
+	if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && cfg.dvbapi_boxtype != BOXTYPE_HISILICON)
 		unlink(ECMINFO_FILE);
 	return;
 }
 
-int32_t dvbapi_start_descrambling(int32_t demux_id, int32_t pid, int8_t checked, uint32_t msgid)
+int32_t dvbapi_constcw_afterwards(int32_t typ, int32_t demux_id, int16_t direction)
 {
+	ECM_REQUEST *er;
+	int16_t idx = demux[demux_id].curindex;
+
+	mycs_debug(D_DVBAPI, "dvbapi_constcw_afterwards(%x){%d, %d}\n", typ, idx, direction);
+	if (!demux[demux_id].ECMpids[idx].constcw) return 0;
+
+	if (!(er = get_ecmtask())) return 0;
+	er->dmuxid = demux_id;// sky(powervu)
+	er->srvid  = demux[demux_id].program_number;
+	er->caid   = demux[demux_id].ECMpids[idx].CAID;
+	er->pid    = demux[demux_id].ECMpids[idx].ECM_PID;
+	er->prid   = demux[demux_id].ECMpids[idx].PROVID;
+	er->vpid   = demux[demux_id].ECMpids[idx].VPID;
+	er->ecmlen = 13;
+	er->ecm[0] = 0x80;
+	er->ecm[1] = 0;
+	er->ecm[2] = 10;
+	i2b_buf(2, er->srvid, er->ecm+3);
+	i2b_buf(2, er->vpid,  er->ecm+5);
+	i2b_buf(2, demux[demux_id].cs_degree, er->ecm+7);
+	i2b_buf(2, demux[demux_id].cs_frequency, er->ecm+9);
+	i2b_buf(2, demux[demux_id].cs_subsequence, er->ecm+11);
+	if (direction) er->constAfterwards++;
+	else er->constAfterwards = 0;
+	er->chSets.muxid	 	= demux_id;
+	er->chSets.srvid  	= demux[demux_id].program_number;
+	er->chSets.degree		= demux[demux_id].cs_degree;
+	er->chSets.frequency = demux[demux_id].cs_frequency;
+	er->chSets.vpid	 	= demux[demux_id].cs_vidpid;
+
+	demux[demux_id].cs_subsequence++;
+	request_cw(dvbapi_client, er, demux_id, 0);
+	return 1;
+}
+
+int32_t dvbapi_start_descrambling(int32_t demux_id, int32_t pidx, int8_t checked, uint32_t msgid)
+{
 	int32_t started = 0; // in case ecmfilter started = 1
-	int32_t fake_ecm = 0;
+//	int32_t fake_ecm = 0;
 	ECM_REQUEST *er;
 	struct s_reader *rdr;
 	if(!(er = get_ecmtask())) { return started; }
-	demux[demux_id].ECMpids[pid].checked = checked + 1; // mark this pid as checked!
+	er->dmuxid = demux_id;// sky(powervu)
+	demux[demux_id].ECMpids[pidx].checked = checked + 1; // mark this pid as checked!
 
+	cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_start_descrambling{%d, %d}\n", pidx, demux[demux_id].curindex);
 	struct s_dvbapi_priority *p;
 	for(p = dvbapi_priority; p != NULL ; p = p->next)
 	{
 		if((p->type != 'p')
-				|| (p->caid && p->caid != demux[demux_id].ECMpids[pid].CAID)
-				|| (p->provid && p->provid != demux[demux_id].ECMpids[pid].PROVID)
-				|| (p->ecmpid && p->ecmpid != demux[demux_id].ECMpids[pid].ECM_PID)
+				|| (p->caid && p->caid != demux[demux_id].ECMpids[pidx].CAID)
+				|| (p->provid && p->provid != demux[demux_id].ECMpids[pidx].PROVID)
+				|| (p->ecmpid && p->ecmpid != demux[demux_id].ECMpids[pidx].ECM_PID)
 				|| (p->srvid && p->srvid != demux[demux_id].program_number)
-				|| (p->pidx && p->pidx-1 != pid)
-				|| (p->cadata && p->cadata != demux[demux_id].ECMpids[pid].cadata))
+				|| (p->pidx && p->pidx-1 != pidx)
+				|| (p->cadata && p->cadata != demux[demux_id].ECMpids[pidx].cadata))
 			{ continue; }
 		// if found chid and first run apply chid filter, on forced pids always apply!
-		if(p->type == 'p' && p->chid < 0x10000 && (demux[demux_id].ECMpids[pid].checked == 1 || (p && p->force)))
+		if(p->type == 'p' && p->chid < 0x10000 && (demux[demux_id].ECMpids[pidx].checked == 1 || (p && p->force)))
 		{
-			if(demux[demux_id].ECMpids[pid].CHID < 0x10000)   // channelcache delivered chid
+			if(demux[demux_id].ECMpids[pidx].CHID < 0x10000)   // channelcache delivered chid
 			{
-				er->chid = demux[demux_id].ECMpids[pid].CHID;
+				er->chid = demux[demux_id].ECMpids[pidx].CHID;
 			}
 			else
 			{
 				er->chid = p->chid; // no channelcache or no chid in use, so use prio chid
-				demux[demux_id].ECMpids[pid].CHID = p->chid;
+				demux[demux_id].ECMpids[pidx].CHID = p->chid;
 			}
 			//cs_log("********* CHID %04X **************", demux[demux_id].ECMpids[pid].CHID);
 			break; // we only accept one!
@@ -2073,26 +2200,32 @@
 		}
 		else
 		{
-			if(demux[demux_id].ECMpids[pid].CHID < 0x10000)   // channelcache delivered chid
+			if(demux[demux_id].ECMpids[pidx].CHID < 0x10000)   // channelcache delivered chid
 			{
-				er->chid = demux[demux_id].ECMpids[pid].CHID;
+				er->chid = demux[demux_id].ECMpids[pidx].CHID;
 			}
 			else   // no channelcache or no chid in use
 			{
 				er->chid = 0;
-				demux[demux_id].ECMpids[pid].CHID = 0x10000;
+				demux[demux_id].ECMpids[pidx].CHID = 0x10000;
 			}
 		}
 	}
+	er->dmuxid = demux_id;// sky(powervu)
 	er->srvid = demux[demux_id].program_number;
-	er->caid  = demux[demux_id].ECMpids[pid].CAID;
-	er->pid   = demux[demux_id].ECMpids[pid].ECM_PID;
-	er->prid  = demux[demux_id].ECMpids[pid].PROVID;
-	er->vpid  = demux[demux_id].ECMpids[pid].VPID;
+	er->caid  = demux[demux_id].ECMpids[pidx].CAID;
+	er->pid   = demux[demux_id].ECMpids[pidx].ECM_PID;
+	er->prid  = demux[demux_id].ECMpids[pidx].PROVID;
+	er->vpid  = demux[demux_id].ECMpids[pidx].VPID;
 	er->pmtpid  = demux[demux_id].pmtpid;
 	er->onid = demux[demux_id].onid;
 	er->tsid = demux[demux_id].tsid;
 	er->ens  = demux[demux_id].enigma_namespace;
+	er->chSets.muxid = demux_id;
+	er->chSets.srvid = demux[demux_id].program_number;
+	er->chSets.degree = demux[demux_id].cs_degree;
+	er->chSets.frequency = demux[demux_id].cs_frequency;
+	er->chSets.vpid = demux[demux_id].cs_vidpid;
 	er->msgid = msgid;
 
 #ifdef WITH_STAPI5
@@ -2127,7 +2260,7 @@
 		// BISS or FAKE CAID
 		// ecm stream pid is fake, so send out one fake ecm request
 		// special treatment: if we asked the cw first without starting a filter the cw request will be killed due to no ecmfilter started
-		if(caid_is_fake(demux[demux_id].ECMpids[pid].CAID) || caid_is_biss(demux[demux_id].ECMpids[pid].CAID))
+		if(caid_is_fake(demux[demux_id].ECMpids[pidx].CAID) || caid_is_biss(demux[demux_id].ECMpids[pidx].CAID))
 		{
 			int32_t j, n;
 			er->ecmlen = 7;
@@ -2136,6 +2269,9 @@
 			er->ecm[2] = 0x04;
 			i2b_buf(2, er->srvid, er->ecm + 3);
 			i2b_buf(2, er->pmtpid, er->ecm + 5);
+			i2b_buf(2, demux[demux_id].cs_degree, er->ecm+7);
+			i2b_buf(2, demux[demux_id].cs_frequency, er->ecm+9);
+			i2b_buf(2, demux[demux_id].cs_subsequence, er->ecm+11);
 
 			for(j = 0, n = 7; j < demux[demux_id].STREAMpidcount; j++, n += 2)
 			{
@@ -2154,18 +2290,18 @@
 			er->ecm[2] += 8;
 			er->ecmlen += 8;
 
-			cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pid,
-				   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
-				   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pid].VPID);
+			cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pidx,
+				   demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID,
+				   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pidx].VPID);
 
-			demux[demux_id].curindex = pid; // set current pid to the fresh started one
+			demux[demux_id].curindex = pidx; // set current pid to the fresh started one
 
-			dvbapi_start_filter(demux_id, pid, demux[demux_id].ECMpids[pid].ECM_PID, demux[demux_id].ECMpids[pid].CAID,
-								demux[demux_id].ECMpids[pid].PROVID, 0x80, 0xF0, 3000, TYPE_ECM);
+			dvbapi_start_filter(demux_id, pidx, demux[demux_id].ECMpids[pidx].ECM_PID, demux[demux_id].ECMpids[pidx].CAID,
+								demux[demux_id].ECMpids[pidx].PROVID, 0x80, 0xF0, 3000, TYPE_ECM);
 			started = 1;
 
 			request_cw(dvbapi_client, er, demux_id, 0); // do not register ecm since this try!
-			fake_ecm = 1;
+//			fake_ecm = 1;
 			break; // we started an ecmfilter so stop looking for next matching reader!
 		}
 		if(match)   // if matching reader found check for irdeto cas if local irdeto card check if it received emms in last 60 minutes
@@ -2173,39 +2309,39 @@
 
 			if(caid_is_irdeto(er->caid))   // irdeto cas init irdeto_curindex to wait for first index (00)
 			{
-				if(demux[demux_id].ECMpids[pid].irdeto_curindex == 0xFE) { demux[demux_id].ECMpids[pid].irdeto_curindex = 0x00; }
+				if(demux[demux_id].ECMpids[pidx].irdeto_curindex == 0xFE) { demux[demux_id].ECMpids[pidx].irdeto_curindex = 0x00; }
 			}
 
 			if(p && p->chid < 0x10000)  // do we prio a certain chid?
 			{
-				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X CHID %04X PMTPID %04X VPID %04X", demux_id, pid,
-					   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
-					   demux[demux_id].ECMpids[pid].CHID, demux[demux_id].pmtpid, demux[demux_id].ECMpids[pid].VPID);
+				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X CHID %04X PMTPID %04X VPID %04X", demux_id, pidx,
+					   demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID,
+					   demux[demux_id].ECMpids[pidx].CHID, demux[demux_id].pmtpid, demux[demux_id].ECMpids[pidx].VPID);
 			}
 			else
 			{
-				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pid,
-					   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID,
-					   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pid].VPID);
+				cs_log("Demuxer %d trying to descramble PID %d CAID %04X PROVID %06X ECMPID %04X ANY CHID PMTPID %04X VPID %04X", demux_id, pidx,
+					   demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID,
+					   demux[demux_id].pmtpid, demux[demux_id].ECMpids[pidx].VPID);
 			}
 
-			demux[demux_id].curindex = pid; // set current pid to the fresh started one
+			demux[demux_id].curindex = pidx; // set current pid to the fresh started one
 
-			dvbapi_start_filter(demux_id, pid, demux[demux_id].ECMpids[pid].ECM_PID, demux[demux_id].ECMpids[pid].CAID,
-								demux[demux_id].ECMpids[pid].PROVID, 0x80, 0xF0, 3000, TYPE_ECM);
+			dvbapi_start_filter(demux_id, pidx, demux[demux_id].ECMpids[pidx].ECM_PID, demux[demux_id].ECMpids[pidx].CAID,
+								demux[demux_id].ECMpids[pidx].PROVID, 0x80, 0xF0, 3000, TYPE_ECM);
 			started = 1;
 			break; // we started an ecmfilter so stop looking for next matching reader!
 		}
 	}
-	if(demux[demux_id].curindex != pid)
+	if(demux[demux_id].curindex != pidx)
 	{
-		cs_log("Demuxer %d impossible to descramble PID %d CAID %04X PROVID %06X ECMPID %04X PMTPID %04X (NO MATCHING READER)", demux_id, pid,
-			   demux[demux_id].ECMpids[pid].CAID, demux[demux_id].ECMpids[pid].PROVID, demux[demux_id].ECMpids[pid].ECM_PID, demux[demux_id].pmtpid);
-		demux[demux_id].ECMpids[pid].checked = 4; // flag this pid as checked
-		demux[demux_id].ECMpids[pid].status = -1; // flag this pid as unusable
-		dvbapi_edit_channel_cache(demux_id, pid, 0); // remove this pid from channelcache
+		cs_log("Demuxer %d impossible to descramble PID %d CAID %04X PROVID %06X ECMPID %04X PMTPID %04X (NO MATCHING READER)", demux_id, pidx,
+			   demux[demux_id].ECMpids[pidx].CAID, demux[demux_id].ECMpids[pidx].PROVID, demux[demux_id].ECMpids[pidx].ECM_PID, demux[demux_id].pmtpid);
+		demux[demux_id].ECMpids[pidx].checked = 4; // flag this pid as checked
+		demux[demux_id].ECMpids[pidx].status = -1; // flag this pid as unusable
+		dvbapi_edit_channel_cache(demux_id, pidx, 0); // remove this pid from channelcache
 	}
-	if(!fake_ecm) { NULLFREE(er); }
+//	if(!fake_ecm) { NULLFREE(er); }
 	return started;
 }
 
@@ -2242,7 +2378,7 @@
 	return NULL;
 }
 
-struct s_dvbapi_priority *dvbapi_check_prio_match(int32_t demux_id, int32_t pidindex, char type)
+struct s_dvbapi_priority *dvbapi_check_prio_match(int32_t demux_id, int32_t pidx, char type)
 {
 	if(!dvbapi_priority)
 	{
@@ -2249,7 +2385,7 @@
 		return NULL;
 	}
 	struct s_dvbapi_priority *p;
-	struct s_ecmpids *ecmpid = &demux[demux_id].ECMpids[pidindex];
+	struct s_ecmpids *ecmpid = &demux[demux_id].ECMpids[pidx];
 
 	for(p = dvbapi_priority; p != NULL; p = p->next)
 	{
@@ -2258,9 +2394,10 @@
 				|| (p->provid && p->provid != ecmpid->PROVID)
 				|| (p->ecmpid && p->ecmpid != ecmpid->ECM_PID)
 				|| (p->srvid && p->srvid != demux[demux_id].program_number)
-				|| (p->pidx && p->pidx-1 != pidindex)
+				|| (p->pidx && p->pidx-1 != pidx)
 				|| (p->chid < 0x10000 && p->chid != ecmpid->CHID))
 			{ continue; }
+		cs_log_dbg(D_DVBAPI,"mydvb:check_prio_matching\n");
 		return p;
 	}
 	return NULL;
@@ -2308,7 +2445,7 @@
 		}
 	}
 
-	do_emm(dvbapi_client, &epg);
+	 do_emm(dvbapi_client, &epg);
 }
 
 void dvbapi_read_priority(void)
@@ -2596,10 +2733,12 @@
 		for(n = 0; n < demux[demux_index].ECMpidcount; n++)
 		{
 			if(demux[demux_index].ECMpids[n].status == -1) continue; // skip ignores!
+			er->dmuxid = demux_index;// sky(powervu)
 			er->caid = er->ocaid = demux[demux_index].ECMpids[n].CAID;
 			er->prid = demux[demux_index].ECMpids[n].PROVID;
 			er->pid = demux[demux_index].ECMpids[n].ECM_PID;
 			er->srvid = demux[demux_index].program_number;
+			er->onid   = demux[demux_index].onid;
 			er->client = cur_client();
 			btun_caid = chk_on_btun(SRVID_MASK, er->client, er);
 			if(prio->type == 'p' && btun_caid)
@@ -2665,6 +2804,8 @@
 
 		int32_t nr;
 		SIDTAB *sidtab;
+		er->dmuxid = demux_index;// sky(powervu)
+		er->onid   = demux[demux_index].onid;
 		er->caid = er->ocaid = demux[demux_index].ECMpids[n].CAID;
 		er->prid = demux[demux_index].ECMpids[n].PROVID;
 		er->pid = demux[demux_index].ECMpids[n].ECM_PID;
@@ -2730,11 +2871,12 @@
 		int32_t count_matching_cacheex_reader = 0, count_matching_local_reader = 0;
 
 		if(demux[demux_index].ECMpids[n].status == -1) continue; // skip ignores!
-
+		er->dmuxid = demux_index;// sky(powervu)
 		er->caid = er->ocaid = demux[demux_index].ECMpids[n].CAID;
 		er->prid = demux[demux_index].ECMpids[n].PROVID;
 		er->pid = demux[demux_index].ECMpids[n].ECM_PID;
 		er->srvid = demux[demux_index].program_number;
+		er->onid   = demux[demux_index].onid;
 		er->client = cur_client();
 		btun_caid = chk_on_btun(SRVID_MASK, er->client, er);
 
@@ -2787,11 +2929,12 @@
 			{
 				cacheexprio = max_local_matching_reader+p_order+1;
 			}
-
+			er->dmuxid = demux_index;// sky(powervu)
 			er->caid = er->ocaid = demux[demux_index].ECMpids[n].CAID;
 			er->prid = demux[demux_index].ECMpids[n].PROVID;
 			er->pid = demux[demux_index].ECMpids[n].ECM_PID;
 			er->srvid = demux[demux_index].program_number;
+			er->onid   = demux[demux_index].onid;
 			er->client = cur_client();
 			btun_caid = chk_on_btun(SRVID_MASK, er->client, er);
 
@@ -2880,6 +3023,10 @@
 		}
 	}
 
+#if defined(WITH_HISILICON) //if defined(MODULE_XCAMD)
+	DVBICS_ChkEcmReaders(demux_index);
+#endif
+
 	int32_t max_status = 0;
 	int32_t highest_priopid = -1;
 
@@ -3059,8 +3206,15 @@
 	{
 		return;
 	}
+ 	cs_log_dbg(D_DVBAPI, "mydvb:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ECM{%02X.%d} {%02X:%06X,%04X(%02X.%04X)}\n",
+					er->ecm[0],
+					er->ecmlen,
+					er->caid,
+					er->prid,
+					er->pid,
+					er->ecm[4],
+					er->chid);
 
-
 	int32_t filternum = dvbapi_set_section_filter(demux_id, er, -1); // set ecm filter to odd -> even and visaversa
 	if(filternum < 0)
 	{
@@ -3113,6 +3267,7 @@
 
 	cs_log_dbg(D_DVBAPI, "Demuxer %d get controlword!", demux_id);
 	get_cw(client, er);
+	//if (!get_cw(client, er)) return;
 
 #ifdef WITH_DEBUG
 	char buf[ECM_FMT_LEN];
@@ -3190,7 +3345,7 @@
 		if (buffer[21]==0x84 && buffer[22]==0x02) *pmtpid = b2i(2, buffer+23);
 	}
 
-	if((cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_SAMYGO)
+	if((cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_SAMYGO || cfg.dvbapi_boxtype == BOXTYPE_HISILICON)
 		 && buffer[7] == 0x82 && buffer[8] == 0x02)
 	{
 		*demux_index = buffer[9]; // it is always 0 but you never know
@@ -3217,6 +3372,70 @@
 	}
 }
 
+#if defined(WITH_HISILICON)
+void
+DVBICS_csdescriptor_parse(int32_t demux_id, uint32_t pgminfosize, unsigned char *buffer)
+{
+	uint32_t descriptor_len=0;
+	uint32_t i;
+	short		longitude;
+	// tvheadend(WITH_HISILICON)
+	// 03 00 02 13 00 19 01
+	//	82 02 00 03
+	//	81 08 00 00 00 00 00 02 00 01
+	//	84 02 00 4E
+	//	09 04 06 11 E0 4E
+	// 01 00 85 00 06
+	if (pgminfosize<1) return;
+	if (buffer[0]==0x01)
+	{
+		buffer = buffer+1;
+		pgminfosize--;
+	}
+
+	for (i=0; i<pgminfosize; i+=(descriptor_len+2))
+	{
+		descriptor_len = buffer[i+1];
+		switch (buffer[i]) {
+			case 0x83:	// CAPMT_DESC_INFO
+				longitude = (short)(buffer[i+ 2] << 8 | buffer[i+ 3]);
+				if (longitude < 0) longitude = 3600 + (short)longitude;
+				demux[demux_id].cs_degree	  		= longitude;
+				demux[demux_id].cs_frequency 		= (buffer[i+ 4] << 8 | buffer[i+ 5]);
+				demux[demux_id].cs_vidpid 			= (buffer[i+ 6] << 8 | buffer[i+ 7]);
+				demux[demux_id].cs_symbolrate 	= (buffer[i+ 8] << 8 | buffer[i+ 9]);
+				demux[demux_id].cs_polarisation 	= (buffer[i+10] << 8 | buffer[i+11]);
+				mycs_trace(D_ADB, "mypmt:--- chiks:%d, %d.%d,%d, vpid:%04x",
+							demux[demux_id].cs_degree,
+							demux[demux_id].cs_frequency,
+							demux[demux_id].cs_symbolrate,
+							demux[demux_id].cs_polarisation,
+							demux[demux_id].cs_vidpid);
+				break;
+
+			case 0x84:	// CAPMT_DESC_PID
+				demux[demux_id].pmtpid = (buffer[i+2] << 8 | buffer[i+3]);
+				mycs_trace(D_ADB, "mypmt:--- pmtpid:%04x", demux[demux_id].pmtpid);
+				break;
+
+			case 0x81:	// CAPMT_DESC_PRIVATE
+				// parse private descriptor as used by enigma (4 bytes namespace, 2 tsid, 2 onid)
+				demux[demux_id].enigma_namespace=(buffer[i+2] << 24 | buffer[i+3] << 16 | buffer[i+4] << 8 | buffer[i+5]);
+				demux[demux_id].tsid = (buffer[i+6] << 8 | buffer[i+7]);
+				demux[demux_id].onid = (buffer[i+8] << 8 | buffer[i+9]);
+				mycs_trace(D_ADB, "mypmt:--- tsid:%04X, onid=%04X", demux[demux_id].tsid, demux[demux_id].tsid);
+				break;
+
+			case 0x09: return;
+			case 0x00: return;
+			default:
+				mycs_trace(D_ADB, "mypmt:--- type:%02X, len{%d}", buffer[i], descriptor_len);
+				break;
+		}
+	}
+}
+#endif // #if defined(WITH_HISILICON)
+
 int32_t dvbapi_parse_capmt(unsigned char *buffer, uint32_t length, int32_t connfd, char *pmtfile, int8_t is_real_pmt, uint16_t existing_demux_id, uint16_t client_proto_version, uint32_t msgid)
 {
 	uint32_t i = 0, start_descrambling = 0;
@@ -3231,13 +3450,29 @@
 	if(!is_real_pmt)
 	{
 
-#define LIST_MORE 0x00    //*CA application should append a 'MORE' CAPMT object to the list and start receiving the next object
-#define LIST_FIRST 0x01   //*CA application should clear the list when a 'FIRST' CAPMT object is received, and start receiving the next object
-#define LIST_LAST 0x02   //*CA application should append a 'LAST' CAPMT object to the list and start working with the list
-#define LIST_ONLY 0x03   //*CA application should clear the list when an 'ONLY' CAPMT object is received, and start working with the object
-#define LIST_ADD 0x04    //*CA application should append an 'ADD' CAPMT object to the current list and start working with the updated list
-#define LIST_UPDATE 0x05 //*CA application should replace an entry in the list with an 'UPDATE' CAPMT object, and start working with the updated list
+#define CAPMT_LIST_MORE 0x00	// append a 'MORE' CAPMT object the list and start receiving the next object
+#define CAPMT_LIST_FIRST 0x01	// clear the list when a 'FIRST' CAPMT object is received, and start receiving the next object
+#define CAPMT_LIST_LAST 0x02	// append a 'LAST' CAPMT object to the list and start working with the list
+#define CAPMT_LIST_ONLY 0x03 	// clear the list when an 'ONLY' CAPMT object is received, and start working with the object
+#define CAPMT_LIST_ADD 0x04	// append an 'ADD' CAPMT object to the current list and start working with the updated list
+#define CAPMT_LIST_UPDATE 0x05 	// replace an entry in the list with an 'UPDATE' CAPMT object, and start working with the updated list
+// ca_pmt_cmd_id values:
+#define CAPMT_CMD_OK_DESCRAMBLING 0x01  // start descrambling the service in this CAPMT object as soon as the list of CAPMT objects is complete
+#define CAPMT_CMD_OK_MMI 0x02  //
+#define CAPMT_CMD_QUERY 0x03  //
+#define CAPMT_CMD_NOT_SELECTED 0x04
+// ca_pmt_descriptor types
+#define CAPMT_DESC_PRIVATE 0x81
+#define CAPMT_DESC_DEMUX 0x82
+#define CAPMT_DESC_PID 0x84
 
+#define LIST_MORE CAPMT_LIST_MORE
+#define LIST_FIRST CAPMT_LIST_FIRST
+#define LIST_LAST CAPMT_LIST_LAST
+#define LIST_ONLY CAPMT_LIST_ONLY
+#define LIST_ADD CAPMT_LIST_ADD
+#define LIST_UPDATE CAPMT_LIST_UPDATE
+
 #if defined WITH_COOLAPI || defined WITH_COOLAPI2
 		int32_t ca_pmt_list_management = LIST_ONLY;
 #else
@@ -3245,15 +3480,17 @@
 #endif
 		program_number = b2i(2, buffer + 1);
 		program_info_length = b2i(2, buffer + 4) &0xFFF;
-
+		cs_log_dbg(D_DVBAPI,"mydvb:PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP CAPMT{%d}\n", program_number);
+		cs_log_dbg(D_DVBAPI,"mydvb:sends PMT(%d) command %d for channel %d\n", ca_pmt_list_management, cfg.dvbapi_pmtmode, program_number);
 		cs_log_dump_dbg(D_DVBAPI, buffer, length, "capmt:");
 		cs_log_dbg(D_DVBAPI, "Receiver sends PMT command %d for channel %04X", ca_pmt_list_management, program_number);
 
-		if(!pmt_stopmarking && (ca_pmt_list_management == LIST_FIRST || ca_pmt_list_management == LIST_ONLY))
+		if ((ca_pmt_list_management == LIST_FIRST || ca_pmt_list_management == LIST_ONLY))
 		{
 			for(i = 0; i < MAX_DEMUX; i++)
 			{
 				if(demux[i].program_number == 0) { continue; }  // skip empty demuxers
+				if (demux[i].ECMpidcount != 0 && demux[i].pidindex != -1 ) { demux[i].running = 1; }  // running channel changes from scrambled to fta
 				if(demux[i].socket_fd != connfd) { continue; }  // skip demuxers belonging to other ca pmt connection
 				if((demux[i].socket_fd == -1) && (pmtfile && strcmp(demux[i].pmt_file, pmtfile) != 0)) { continue; } // skip demuxers handled by other pmt files
 				demux[i].stopdescramble = 1; // Mark for deletion if not used again by following pmt objects.
@@ -3262,9 +3499,9 @@
 			pmt_stopmarking = 1; // only stop demuxing for first pmt record
 		}
 
-		getDemuxOptions(i, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
-		cs_log_dbg(D_DVBAPI,"Receiver wants to demux srvid %04X on adapter %04X camask %04X index %04X pmtpid %04X",
-			program_number, adapter_index, ca_mask, demux_index, pmtpid);
+		//getDemuxOptions(i, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
+		//cs_log_dbg(D_DVBAPI,"Receiver wants to demux srvid %04X on adapter %04X camask %04X index %04X pmtpid %04X",
+			//program_number, adapter_index, ca_mask, demux_index, pmtpid);
 
 		for(i = 0; i < MAX_DEMUX; i++)    // search current demuxers for running the same program as the one we received in this PMT object
 		{
@@ -3282,6 +3519,8 @@
 
 			if(matched)
 			{
+				cs_log_dbg(D_DVBAPI,"mydvb:capmt same.....\n");
+				getDemuxOptions(i, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
 				if (full_check) {
 					if (demux[i].adapter_index != adapter_index) continue; // perhaps next demuxer matches?
 					if (demux[i].ca_mask != ca_mask) continue; // perhaps next demuxer matches?
@@ -3292,11 +3531,13 @@
 				}
 
 				demux_id = i;
-
+#if defined(WITH_HISILICON)
+			dvbapi_stop_descrambling(i,0);
+#endif
 				cs_log("Demuxer %d continue decoding of SRVID %04X", i, demux[i].program_number);
-
+#if defined WITH_AZBOX || defined WITH_MCA
 				openxcas_set_sid(program_number);
-
+#endif
 				demux[i].stopdescramble = 0; // dont stop current demuxer!
 				break; // no need to explore other demuxers since we have a found!
 			}
@@ -3303,7 +3544,7 @@
 		}
 
 		// start using the new list
-		if(ca_pmt_list_management != LIST_FIRST && ca_pmt_list_management != LIST_MORE)
+		if ((ca_pmt_list_management == LIST_LAST) || (ca_pmt_list_management == LIST_ONLY))
 		{
 			for(j = 0; j < MAX_DEMUX; j++)
 			{
@@ -3318,18 +3559,44 @@
 		{
 			for(demux_id = 0; demux_id < MAX_DEMUX; demux_id++)
 			{
+#if defined(WITH_HISILICON)
+// multi-demux simulation
+				if (demux_id) {
+					cs_log_dbg(D_DVBAPI,"mydvb:demux_id strange{%d}.......\n", demux_id);
+					// sky(quad)
+					//	demux_id = 0;
+				}
+#endif
+				if (demux_id>=MAX_DEMUX)
+				{
+					cs_log_dbg(D_DVBAPI,"mydvb:No free id (MAX_DEMUX).......\n");
+					cs_log("ERROR: No free id (MAX_DEMUX)");
+					return -1;
+				}
+
 				if(demux[demux_id].program_number == 0)
 				{
 					demux[demux_id].program_number = program_number; // do this early since some prio items use them!
-					demux[demux_id].enigma_namespace = 0;
-					demux[demux_id].tsid = 0;
-					demux[demux_id].onid = 0;
+// CAPMT_DESC_PRIVATE
+					if (buffer[7]==0x81 && buffer[8]==0x08) {
+				// parse private descriptor as used by enigma (4 bytes namespace, 2 tsid, 2 onid)
+						demux[demux_id].enigma_namespace=(buffer[9] << 24 | buffer[10] << 16 | buffer[11] << 8 | buffer[12]);
+						demux[demux_id].tsid = (buffer[13] << 8 | buffer[14]);
+						demux[demux_id].onid = (buffer[15] << 8 | buffer[16]);
+					} else {
+						demux[demux_id].enigma_namespace = 0;
+						demux[demux_id].tsid = 0;
+						demux[demux_id].onid = 0;
+					}
 					demux[demux_id].pmtpid = pmtpid;
 					demux[demux_id].socket_fd = connfd;
 					demux[demux_id].adapter_index = adapter_index;
 					demux[demux_id].client_proto_version = client_proto_version;
 					demux[demux_id].sdt_filter = -1;
-
+/////////////////////////////////////////////////////////////////////////////////
+#if defined(WITH_HISILICON)
+	DVBICS_csdescriptor_parse(demux_id, program_info_length-1, buffer+7);
+#endif
 					if(pmtfile)
 					{
 						cs_strncpy(demux[demux_id].pmt_file, pmtfile, sizeof(demux[demux_id].pmt_file));
@@ -3384,6 +3651,11 @@
 	uint32_t es_info_length = 0, vpid = 0;
 	struct s_dvbapi_priority *addentry;
 
+#if defined(WITH_HISILICON)
+	vpid = demux[demux_id].cs_vidpid;
+#endif
+	cs_log_dbg(D_DVBAPI,"mydvb:program_info(%d, %d)\n", program_info_length, length);
+
 	// pid limiter for PowerVu
 	if(demux[demux_id].ECMpids[0].CAID >> 8 == 0x0E)
 	{
@@ -3406,7 +3678,9 @@
 
 			cs_log_dbg(D_DVBAPI,"Demuxer %d stream %s(type: %02x pid: %04x length: %d)", demux_id, get_streamtxt(stream_type), stream_type, elementary_pid,
 				es_info_length);
-
+#if defined(WITH_HISILICON)
+		// elementary_pid: tvheadend capmt sequence number.
+#else
 			// find and register videopid
 			if(!vpid &&
 				(stream_type == 0x01 || stream_type == 0x02 || stream_type == 0x10 || stream_type == 0x1B
@@ -3414,8 +3688,8 @@
 			{
 				vpid = elementary_pid;
 			}
-
-			if(es_info_length != 0 && es_info_length < length)
+#endif
+			if(es_info_length != 0 && (i+5+es_info_length) < length)
 			{
 				dvbapi_parse_descriptor(demux_id, es_info_length, buffer + i + 5, &is_audio);
 
@@ -3455,7 +3729,12 @@
 		demux[demux_id].adapter_index = adapter_index;
 		demux[demux_id].ca_mask = ca_mask;
 		demux[demux_id].rdr = NULL;
+	// sky(powervu)
+	#if defined(WITH_HISILICON)
+		demux[demux_id].demux_index = demux_id;
+	#else
 		demux[demux_id].demux_index = demux_index;
+	#endif
 		demux[demux_id].socket_fd = connfd;
 		demux[demux_id].client_proto_version = client_proto_version;
 
@@ -3494,6 +3773,15 @@
 
 	dvbapi_capmt_notify(&demux[demux_id]);
 
+// sky.futures(cas noinfromation)/////////////////
+#if defined(MODULE_CONSTCW)
+	DVBICS_ChDescrambled(demux_id, false);
+	if (demux[demux_id].ECMpidcount==0)
+	{
+		mycs_log("mydvb:fta{%d}", program_number);
+	}
+#endif
+
 	struct s_dvbapi_priority *xtraentry;
 	int32_t k, l, m, xtra_demux_id;
 
@@ -3529,7 +3817,12 @@
 			demux[xtra_demux_id].STREAMpidcount = 0;
 			demux[xtra_demux_id].program_number = demux[demux_id].program_number;
 			demux[xtra_demux_id].pmtpid = demux[demux_id].pmtpid;
-			demux[xtra_demux_id].demux_index = demux_index;
+			// sky(powervu)
+			#if defined(WITH_HISILICON)
+				demux[xtra_demux_id].demux_index = xtra_demux_id;
+			#else
+				demux[xtra_demux_id].demux_index = demux_index;
+			#endif
 			demux[xtra_demux_id].adapter_index = adapter_index;
 			demux[xtra_demux_id].ca_mask = ca_mask;
 			demux[xtra_demux_id].socket_fd = connfd;
@@ -3612,7 +3905,7 @@
 				cs_log_dbg(D_DVBAPI, "Demuxer %d/%d lets start descrambling (srvid = %04X fd = %d ecmpids = %d)", j, MAX_DEMUX,
 					demux[j].program_number, connfd, demux[j].ECMpidcount);
 				demux[j].running = 1;  // mark channel as running
-				openxcas_set_sid(demux[j].program_number);
+			//	openxcas_set_sid(demux[j].program_number);
 				demux[j].decodingtries = -1;
 				dvbapi_resort_ecmpids(j);
 				dvbapi_try_next_caid(j, 0, msgid);
@@ -3642,6 +3935,7 @@
 		}
 	#endif
 
+	myprintf("mydvb:start emmxxx{%d,%d}\n", demux[demux_id].running, (int)demux[demux_id].emmstart.time);
 	if(cfg.dvbapi_au > 0 && demux[demux_id].EMMpidcount == 0 && !DoNotStartEMM) // only do emm setup if au enabled and not running!
 	{
 		demux[demux_id].emm_filter = -1; // to register first run emmfilter start
@@ -3648,6 +3942,7 @@
 		if(demux[demux_id].emmstart.time == 1)   // irdeto fetch emm cat direct!
 		{
 			cs_ftime(&demux[demux_id].emmstart); // trick to let emm fetching start after 30 seconds to speed up zapping
+			myprintf("mydvb:start CAT\n");
 			dvbapi_start_filter(demux_id, demux[demux_id].pidindex, 0x001, 0x001, 0x01, 0x01, 0xFF, 0, TYPE_EMM); //CAT
 		}
 		else { cs_ftime(&demux[demux_id].emmstart); } // for all other caids delayed start!
@@ -4083,6 +4378,7 @@
 	// this will allow oscam to run as root if needed
 	// and still allow non root client to connect to the socket
 	chmod(devices[selected_box].cam_socket_path, S_IRWXU | S_IRWXG | S_IRWXO);
+	cs_log_dbg(D_DVBAPI, "camsocket:%s\n", devices[selected_box].cam_socket_path);
 
 	return listenfd;
 }
@@ -4138,7 +4434,7 @@
 
 	SAFE_MUTEX_LOCK(&event_handler_lock);
 
-	if(cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_SAMYGO)
+	if(cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_SAMYGO || cfg.dvbapi_boxtype == BOXTYPE_HISILICON)
 		{ pausecam = 0; }
 	else
 	{
@@ -4356,7 +4652,7 @@
 void dvbapi_process_input(int32_t demux_id, int32_t filter_num, uchar *buffer, int32_t len, uint32_t msgid)
 {
 	struct s_ecmpids *curpid = NULL;
-	int32_t pid = demux[demux_id].demux_fd[filter_num].pidindex;
+	int32_t pidx = demux[demux_id].demux_fd[filter_num].pidindex;
 	uint16_t filtertype = demux[demux_id].demux_fd[filter_num].type;
 	uint32_t sctlen = SCT_LEN(buffer);
 
@@ -4378,9 +4674,9 @@
 		return;
 	}
 
-	if(pid != -1 && filtertype == TYPE_ECM)
+	if(pidx != -1 && filtertype == TYPE_ECM)
 	{
-		curpid = &demux[demux_id].ECMpids[pid];
+		curpid = &demux[demux_id].ECMpids[pidx];
 	}
 
 	int32_t filt_match = filtermatch(buffer, filter_num, demux_id, sctlen); // acts on all filters (sdt/emm/ecm)
@@ -4399,10 +4695,10 @@
 		curpid->table = 0;
 		curpid->checked = 4; // flag ecmpid as checked
 		curpid->status = -1; // flag ecmpid as unusable
-		if(pid == demux[demux_id].pidindex)
+		if(pidx == demux[demux_id].pidindex)
 		{
 			demux[demux_id].pidindex = -1; // current pid delivered problems so this pid isnt being used to descramble any longer-> clear pidindex
-			dvbapi_edit_channel_cache(demux_id, pid, 0); // remove this pid from channelcache since we had no founds on any ecmpid!
+			dvbapi_edit_channel_cache(demux_id, pidx, 0); // remove this pid from channelcache since we had no founds on any ecmpid!
 		}
 		dvbapi_stop_filternum(demux_id, filter_num, msgid); // stop this ecm filter!
 		return;
@@ -4414,6 +4710,12 @@
 		int8_t pvu_skip = 0;
 		ECM_REQUEST *er;
 
+	myprintf("mtdvb:DVBAPI_PROCESS_INPUT(%d:%d, %d, %02X}\n", demux_id, filnum, demux[demux_id].demux_fd[filnum].type, buffer[0]);
+	if (len != SCT_LEN(buffer)) {
+		cs_log_dbg(D_DVBAPI, "[DVBAPI] Received an ECM with invalid length!");
+		return;
+	}
+
 		if(len != 0)  // len = 0 receiver encountered an internal bufferoverflow!
 		{
 			cs_log_dump_dbg(D_DVBAPI, buffer, sctlen, "Demuxer %d Filter %d fetched ECM data (ecmlength = 0x%03X):", demux_id, filter_num + 1, sctlen);
@@ -4460,7 +4762,8 @@
 				{
 					return;
 				}
-
+				er->dmuxid = demux_id;// sky(powervu)
+//				er->onid   = demux[demux_index].onid;
 				er->srvid = demux[demux_id].program_number;
 
 #ifdef WITH_STAPI5
@@ -4478,6 +4781,11 @@
 				er->vpid  = curpid->VPID;
 				er->ecmlen = sctlen;
 				memcpy(er->ecm, buffer, er->ecmlen);
+				er->chSets.muxid	 	= demux_id;
+				er->chSets.degree		= demux[demux_id].cs_degree;
+				er->chSets.frequency = demux[demux_id].cs_frequency;
+				er->chSets.vpid	 	= demux[demux_id].cs_vidpid;
+				er->chSets.srvid  	= demux[demux_id].program_number;
 				chid = get_subid(er); // fetch chid or fake chid
 				er->chid = chid;
 				er->msgid = msgid;
@@ -4486,6 +4794,8 @@
 				return;
 			}
 
+		   myprintf("ECM:%02X:%02X:%02X%02X{%08X}\n", buffer[0], buffer[4], buffer[6], buffer[7], crcval);
+
 			if(caid_is_irdeto(curpid->CAID))
 			{
 				// 80 70 39 53 04 05 00 88
@@ -4504,6 +4814,8 @@
 			return;
 		}
 
+		if (!(er = get_ecmtask())) return;
+		er->dmuxid = demux_id; // sky(powervu)
 		er->srvid = demux[demux_id].program_number;
 
 #ifdef WITH_STAPI5
@@ -4527,7 +4839,7 @@
 		uint32_t fixedprovid = chk_provid(er->ecm, er->caid);
 		if(fixedprovid && fixedprovid != er->prid)
 		{
-			cs_log_dbg(D_DVBAPI, "Fixing provid ecmpid %d from %06X -> %06X", pid, curpid->PROVID, fixedprovid);
+			cs_log_dbg(D_DVBAPI, "Fixing provid ecmpid %d from %06X -> %06X", pidx, curpid->PROVID, fixedprovid);
 			curpid->PROVID = fixedprovid;
 			if(!USE_OPENXCAS)
 			{
@@ -4587,7 +4899,7 @@
 
 				if((curpid->irdeto_cycle < 0xFE) && (curpid->irdeto_cycle == curpid->irdeto_curindex))   // if same: we cycled all indexes but no luck!
 				{
-					struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pid, 'p');
+					struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pidx, 'p');
 					if(!forceentry || !forceentry->force)   // forced pid? keep trying the forced ecmpid, no force kill ecm filter
 					{
 						if(curpid->checked == 2) { curpid->checked = 4; }
@@ -4613,7 +4925,7 @@
 			}
 			else  // all nonirdeto cas systems
 			{
-				struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pid, 'p');
+				struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_id, pidx, 'p');
 				curpid->table = 0;
 				dvbapi_set_section_filter(demux_id, er, filter_num); // set ecm filter to odd + even since this ecm doesnt match with current irdeto index
 				if(forceentry && forceentry->force)
@@ -4674,7 +4986,7 @@
 					|| (p->caid && p->caid != curpid->CAID)
 					|| (p->provid && p->provid != curpid->PROVID)
 					|| (p->ecmpid && p->ecmpid != curpid->ECM_PID)
-					|| (p->pidx && p->pidx-1 != pid)
+					|| (p->pidx && p->pidx-1 != pidx)
 					|| (p->srvid && p->srvid != demux[demux_id].program_number))
 				{ continue; }
 
@@ -4854,6 +5166,7 @@
 	{
 		case DVBAPI_FILTER_DATA: // min 9 bytes
 		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) return 0;
 			if(mbuf_len < 9)
 			{
 				return 9 - mbuf_len;
@@ -4862,6 +5175,7 @@
 		}
 		case DVBAPI_CLIENT_INFO: // min 7 bytes
 		{
+		if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) return 0;
 			if(mbuf_len < 7)
 			{
 				return 7 - mbuf_len;
@@ -5114,6 +5428,7 @@
 	{
 		case DVBAPI_FILTER_DATA:
 		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) break;
 			if(data_len < 1)
 			{
 				cs_log("Error: packet DVBAPI_FILTER_DATA is too short!");
@@ -5140,6 +5455,7 @@
 		}
 		case DVBAPI_CLIENT_INFO:
 		{
+			if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) break;
 			uint16_t client_proto = b2i(2, mbuf + 4);
 
 			NULLFREE(last_client_name);
@@ -5259,11 +5575,15 @@
 	SAFE_SETSPECIFIC(getclient, cli);
 
 	dvbapi_client = cli;
-
+	cs_log_dbg(D_DVBAPI,"mydvb:dvbapi_main_local{%d,%p}\n", cfg.dvbapi_pmtmode, dvbapi_client);
 	int32_t maxpfdsize = (MAX_DEMUX * maxfilter) + MAX_DEMUX + 2;
 	struct pollfd pfd2[maxpfdsize];
 	struct timeb start, end;  // start time poll, end time poll
+#if defined(WITH_HISILICON)
+#define PMT_SERVER_SOCKET "/var/.listen.camd.socket"
+#else
 #define PMT_SERVER_SOCKET "/tmp/.listen.camd.socket"
+#endif
 	struct sockaddr_un saddr;
 	saddr.sun_family = AF_UNIX;
 	strncpy(saddr.sun_path, PMT_SERVER_SOCKET, 107);
@@ -5449,7 +5769,7 @@
 			{
 				if(demux[i].demux_fd[g].fd <= 0) continue; // deny obvious invalid fd!
 
-				if(!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && selected_api != STAPI && selected_api != COOLAPI)
+				if(!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX && selected_api != STAPI && selected_api != COOLAPI && selected_api != HISILICONAPI)
 				{
 					pfd2[pfdcount].fd = demux[i].demux_fd[g].fd;
 					pfd2[pfdcount].events = (POLLIN | POLLPRI);
@@ -5508,7 +5828,7 @@
 				else
 				{
 					gone = comp_timeb(&now, &demux[i].emmstart);
-					if(gone > 30*1000)
+					if(gone > 10*1000LL)
 					{
 						demux[i].emmstart = now;
 						dvbapi_start_emm_filter(i); // start emmfiltering delayed if filters already were running
@@ -5521,7 +5841,10 @@
 			{
 
 				int32_t started = 0;
-
+#if defined(WITH_HISILICON)
+// test.futures
+				if (chk_av_descrambling(client)) continue;
+#endif
 				for(g = 0; g < demux[i].ECMpidcount; g++)  // avoid race: not all pids are asked and checked out yet!
 				{
 					if(demux[i].ECMpids[g].checked == 0 && demux[i].ECMpids[g].status >= 0)  // check if prio run is done
@@ -5799,8 +6122,16 @@
 							close(connfd);
 							connfd = -1;
 
-							if (!active_conn && (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)) //last connection closed
+							if (!active_conn && (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX || cfg.dvbapi_boxtype == BOXTYPE_HISILICON)) //last connection closed
 							{
+								last_client_proto_version = 0;
+								if (cfg.dvbapi_boxtype == BOXTYPE_HISILICON) {}
+								else if (last_client_name)
+								{
+									free(last_client_name);
+									last_client_name = NULL;
+								}
+
 								if (cfg.dvbapi_listenport)
 								{
 									//update webif data
@@ -5878,7 +6209,7 @@
 	return NULL;
 }
 
-void dvbapi_write_cw(int32_t demux_id, uchar *cw, int32_t pid, int32_t stream_id, enum ca_descr_algo algo, enum ca_descr_cipher_mode cipher_mode, uint32_t msgid)
+void dvbapi_write_cw(int32_t demux_id, uchar *cw, int32_t pidx, int32_t stream_id, enum ca_descr_algo algo, enum ca_descr_cipher_mode cipher_mode, uint32_t msgid)
 {
 	int32_t n;
 	int8_t cwEmpty = 0;
@@ -5904,9 +6235,9 @@
 
 		// check if already delivered and new cw part is valid but dont check for nullcw on Biss
 		if((memcmp(cw + (n * 8), demux[demux_id].lastcw[n], 8) != 0 || cwEmpty || stream_id >1)
-			&& (memcmp(cw + (n * 8), nullcw, 8) != 0 || demux[demux_id].ECMpids[pid].CAID == 0x2600))
+			&& (memcmp(cw + (n * 8), nullcw, 8) != 0 || demux[demux_id].ECMpids[pidx].CAID == 0x2600))
 		{
-			ca_index_t idx = dvbapi_ca_setpid(demux_id, pid, stream_id, (algo == CA_ALGO_DES), msgid);  // prepare ca
+			ca_index_t idx = dvbapi_ca_setpid(demux_id, pidx, stream_id, (algo == CA_ALGO_DES), msgid);  // prepare ca
 			if (idx == INDEX_INVALID) return; // return on no index!
 
 #if defined WITH_COOLAPI || defined WITH_COOLAPI2
@@ -5930,7 +6261,7 @@
 				for(j = 0; j < demux[demux_id].STREAMpidcount; j++)
 				{
 					write_cw = 0;
-					if(!demux[demux_id].ECMpids[pid].streams || ((demux[demux_id].ECMpids[pid].streams & (1 << j)) == (uint) (1 << j)))
+					if(!demux[demux_id].ECMpids[pidx].streams || ((demux[demux_id].ECMpids[pidx].streams & (1 << j)) == (uint) (1 << j)))
 					{
 						usedidx = is_ca_used(i, demux[demux_id].STREAMpids[j]);
 						if(usedidx != INDEX_INVALID)
@@ -6605,38 +6936,39 @@
 }
 
 
-void *dvbapi_start_handler(struct s_client *cl, uchar *UNUSED(mbuf), int32_t module_idx, void * (*_main_func)(void *))
+void *dvbapi_handler(struct s_client *cl, uchar* UNUSED(mbuf), int32_t module_idx)
 {
-	// cs_log("dvbapi loaded fd=%d", idx);
-	if(cfg.dvbapi_enabled == 1)
+//	cs_log("dvbapi loaded fd=%d", idx);
+	if (cfg.dvbapi_enabled == 1)
 	{
 		cl = create_client(get_null_ip());
 		cl->module_idx = module_idx;
 		cl->typ = 'c';
-		int32_t ret = start_thread("dvbapi handler", _main_func, (void *) cl, &cl->thread, 1, 0);
-		if(ret)
-		{
+		int32_t ret = pthread_create(&cl->thread, NULL, dvbapi_main_local, (void *) cl);
+		if (ret) {
+			cs_log("ERROR: Can't create dvbapi handler thread (errno=%d %s)", ret, strerror(ret));
 			return NULL;
 		}
+		else {
+			pthread_detach(cl->thread);
+		}
 	}
 
 	return NULL;
 }
 
-void *dvbapi_handler(struct s_client *cl, uchar *mbuf, int32_t module_idx)
-{
-	return dvbapi_start_handler(cl, mbuf, module_idx, dvbapi_main_local);
-}
-
 int32_t dvbapi_set_section_filter(int32_t demux_index, ECM_REQUEST *er, int32_t n)
 {
-	if(!er) { return -1; }
-
 	if(USE_OPENXCAS)
 	{
 		return 0;
 	}
 
+	if (selected_api == HISILICONAPI)
+	{
+		return 0;
+	}
+
 	if(selected_api != DVBAPI_3 && selected_api != DVBAPI_1 && selected_api != STAPI)   // only valid for dvbapi3, dvbapi1 and STAPI
 	{
 		return 0;
@@ -6647,6 +6979,8 @@
 		return 0;
 	}
 
+	if(!er) { return -1; }
+	mycs_trace(D_ADB, "mydvb:dvbapi_set_section_filter{%04X:%08X: %04x}(%d)", er->caid, er->prid, er->pid, er->rc);
 	if(n == -1)
 	{
 		n = dvbapi_get_filternum(demux_index, er, TYPE_ECM);
@@ -6663,10 +6997,10 @@
 	memset(mask, 0, 16);
 
 	struct s_ecmpids *curpid = NULL;
-	int32_t pid = demux[demux_index].demux_fd[n].pidindex;
-	if(pid != -1)
+	int32_t pidx = demux[demux_index].demux_fd[n].pidindex;
+	if(pidx != -1)
 	{
-		curpid = &demux[demux_index].ECMpids[pid];
+		curpid = &demux[demux_index].ECMpids[pidx];
 	}
 	if(curpid->table != er->ecm[0] && curpid->table != 0) { return -1; }  // if current ecmtype differs from latest requested ecmtype do not apply section filtering!
 	uint8_t ecmfilter = 0;
@@ -6690,7 +7024,7 @@
 	}
 	uint32_t offset = 0, extramask = 0xFF;
 
-	struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_index, pid, 'p');
+	struct s_dvbapi_priority *forceentry = dvbapi_check_prio_match(demux_index, pidx, 'p');
 	//cs_log("**** curpid->CHID %04X, checked = %d, er->chid = %04X *****", curpid->CHID, curpid->checked, er->chid);
 	// checked 4 to make sure we dont set chid filter and no such ecm in dvbstream except for forced pids!
 	if(curpid->CHID < 0x10000 && (curpid->checked == 4 || (forceentry && forceentry->force)))
@@ -6840,7 +7174,10 @@
 		break;
 	}
 	#endif
-
+#ifdef WITH_HISILICON
+		case HISILICONAPI:
+			break;
+#endif
 	default:
 		break;
 	}
@@ -6876,11 +7213,11 @@
 	if(memcmp(er->cw, nullcw, 8) == 0 && memcmp(er->cw+8, nullcw, 8) == 0 && er->caid !=0x2600) {return 5;}
 	struct s_ecmpids *curpid = NULL;
 
-	int32_t pid = demux[demux_index].demux_fd[filternum].pidindex;
+	int32_t pidx = demux[demux_index].demux_fd[filternum].pidindex;
 
-	if(pid !=-1)
+	if(pidx !=-1)
 	{
-		curpid = &demux[demux_index].ECMpids[pid];
+		curpid = &demux[demux_index].ECMpids[pidx];
 		if(curpid->table == 0) { return 3; }  // on change table act like ecm response is found
 	}
 
@@ -6892,7 +7229,7 @@
 
 int32_t dvbapi_get_filternum(int32_t demux_index, ECM_REQUEST *er, int32_t type)
 {
-	if(!er) { return -1; }
+	if(!er) { return -2; }
 
 	int32_t n;
 	int32_t fd = -1;
@@ -7469,8 +7806,58 @@
  *  protocol structure
  */
 
+void DVBICS_ChSettings(int32_t demux_id, int chstages)
+{
+	mycs_debug(D_TRACE, "myics:requests{%d}...", chstages);
+}
+
+void DVBICS_ChDescrambled(int32_t demux_id, int descramble)
+{
+	CSREADER_ChDescrambled(R_CONSTCW, descramble);
+}
+
+int32_t DVBICS_ChkEcmReaders(int32_t demux_index)
+{
+	ECM_REQUEST ere;
+	int32_t n;
+
+	for (n = 0; n < demux[demux_index].ECMpidcount; n++)
+	{
+		ere.dmuxid = demux_index;// sky(powervu)
+		ere.caid   = ere.ocaid = demux[demux_index].ECMpids[n].CAID;
+		ere.prid   = demux[demux_index].ECMpids[n].PROVID;
+		ere.pid    = demux[demux_index].ECMpids[n].ECM_PID;
+		ere.srvid  = demux[demux_index].program_number;
+		ere.onid   = demux[demux_index].onid;
+		ere.client = cur_client();	
+	}
+	return 0;
+}
+
+/*int32_t
+DVBICS_ChkEcmPids(int32_t demux_id, uint16_t srvid, uint16_t casid, uint32_t prid)
+{
+	int32_t n;
+
+	if (!casid) return 0;
+	if (demux[demux_id].program_number != srvid) return 0;
+	for (n=0; n<demux[demux_id].ECMpidcount; n++)
+	{
+		struct s_ecmpids *epids = &(demux[demux_id].ECMpids[n]);
+		if (epids->CAID == casid && epids->PROVID == prid)
+		{
+			demux[demux_id].cs_cwidx = n;
+			demux[demux_id].cs_ecmRequisite = n;
+			mycs_trace(D_ADB, "mydvb:--- ch.epid{%d.%04X}", n, epids->ECM_PID);
+			return 1;
+		}
+	}
+	return 0;
+}*/
+
 void module_dvbapi(struct s_module *ph)
 {
+	cs_log_dbg(D_DVBAPI,"module_dvbapi...\n");
 	ph->desc = "dvbapi";
 	ph->type = MOD_CONN_SERIAL;
 	ph->listenertype = LIS_DVBAPI;
Index: module-dvbapi.h
===================================================================
--- module-dvbapi.h	(revision 1542)
+++ module-dvbapi.h	(working copy)
@@ -9,12 +9,13 @@
 #define TYPE_SDT 3
 #define TYPE_PAT 4
 #define TYPE_PMT 5
-
+#define CAT_PID 0x1
 //api
 #define DVBAPI_3    0
 #define DVBAPI_1    1
 #define STAPI       2
 #define COOLAPI     3
+#define HISILICONAPI 4
 
 #ifdef __CYGWIN__
 #define TMPDIR  "./"
@@ -21,10 +22,16 @@
 #define STANDBY_FILE    "./.pauseoscam"
 #define ECMINFO_FILE    "./ecm.info"
 #else
+#if defined(WITH_HISILICON)
+#define TMPDIR				"/var/"
+#define STANDBY_FILE		"/var/.pauseoscam"
+#define ECMINFO_FILE		"/var/ecm.info"
+#else
 #define TMPDIR  "/tmp/"
 #define STANDBY_FILE    "/tmp/.pauseoscam"
 #define ECMINFO_FILE    "/tmp/ecm.info"
 #endif
+#endif
 
 #define MAX_DEMUX 16
 #define MAX_CAID 50
@@ -37,7 +44,7 @@
 #define MAX_STREAM_INDICES 1
 #endif
 
-#define BOX_COUNT 7
+#define BOX_COUNT 8
 
 #define BOXTYPE_DREAMBOX    1
 #define BOXTYPE_DUCKBOX 2
@@ -52,7 +59,8 @@
 #define BOXTYPE_PC      11
 #define BOXTYPE_PC_NODMX    12
 #define BOXTYPE_SAMYGO  13
-#define BOXTYPES        13
+#define BOXTYPE_HISILICON 14
+#define BOXTYPES        14
 #define DMXMD5HASHSIZE  16  // use MD5() 
 
 // we store the results of remove_streampid_from_list()
@@ -131,12 +139,13 @@
 	int8_t checked;
 	int8_t status;
 	uint8_t tries;
-	unsigned char table;
+	uint8_t table;
 	ca_index_t index[MAX_STREAM_INDICES];
 	int8_t useMultipleIndices;
 	uint32_t streams;
 	uint32_t cadata;
 	int16_t pvu_counter;
+	int8_t constcw;
 };
 
 typedef struct filter_s
@@ -200,8 +209,17 @@
 	uint16_t onid;
 	uint16_t tsid;
 	uint16_t pmtpid;
+
+	uint16_t cs_vidpid;
+	uint16_t cs_frequency;
+	uint16_t cs_symbolrate;
+	uint16_t cs_polarisation;
+	uint16_t cs_degree;
+	uint32_t cs_filtnum;
+	uint32_t cs_subsequence;
+
 	uint32_t enigma_namespace;
-	unsigned char lastcw[2][8];
+	uint8_t lastcw[2][8];
 	int8_t emm_filter;
 	int8_t sdt_filter;
 	uchar hexserial[8];
@@ -312,7 +330,7 @@
 {
 	uint32_t index;
 	uint32_t parity;    /* 0 == even, 1 == odd */
-	unsigned char cw[8];
+	uint8_t cw[8];
 } ca_descr_t;
 
 typedef struct ca_pid
@@ -353,7 +371,7 @@
 int32_t dvbapi_open_device(int32_t, int32_t, int);
 int32_t dvbapi_stop_filternum(int32_t demux_index, int32_t num, uint32_t msgid);
 int32_t dvbapi_stop_filter(int32_t demux_index, int32_t type, uint32_t msgid);
-struct s_dvbapi_priority *dvbapi_check_prio_match(int32_t demux_id, int32_t pidindex, char type);
+//struct s_dvbapi_priority *dvbapi_check_prio_match(int32_t demux_id, int32_t pidindex, char type);
 void dvbapi_send_dcw(struct s_client *client, ECM_REQUEST *er);
 void dvbapi_write_cw(int32_t demux_id, uchar *cw, int32_t pid, int32_t stream_id, enum ca_descr_algo algo, enum ca_descr_cipher_mode cipher_mode, uint32_t msgid);
 int32_t dvbapi_parse_capmt(unsigned char *buffer, uint32_t length, int32_t connfd, char *pmtfile, int8_t is_real_pmt, uint16_t existing_demux_id, uint16_t client_proto_version, uint32_t msgid);
@@ -374,12 +392,19 @@
 const char *dvbapi_get_client_name(void);
 void rotate_emmfilter(int32_t demux_id);
 int32_t filtermatch(uchar *buffer, int32_t filter_num, int32_t demux_id, int32_t len);
-void delayer(ECM_REQUEST *er, uint32_t delay);
+//void delayer(ECM_REQUEST *er, uint32_t delay);
 void check_add_emmpid(int32_t demux_index, uchar *filter, int32_t l, int32_t emmtype);
-void *dvbapi_start_handler(struct s_client *cl, uchar *mbuf, int32_t module_idx, void * (*_main_func)(void *));
+//void *dvbapi_start_handler(struct s_client *cl, uchar *mbuf, int32_t module_idx, void * (*_main_func)(void *));
 ca_index_t dvbapi_get_descindex(int32_t demux_index, int32_t pid, int32_t stream_id);
 void dvbapi_write_ecminfo_file(struct s_client *client, ECM_REQUEST *er, uint8_t* lastcw0, uint8_t* lastcw1);
 
+#if defined(MODULE_CONSTCW)
+void DVBICS_ChDescrambled(int32_t demux_id, int descramble);
+void DVBICS_ChSettings(int32_t demux_id, int chstages);
+int32_t DVBICS_ChkEcmReaders(int32_t demux_id);
+//int32_t	DVBICS_ChkEcmPids(int32_t demux_id, uint16_t srvid, uint16_t casid, uint32_t prid);
+#endif
+
 #if defined(WITH_AZBOX) || defined(WITH_MCA)
 #define USE_OPENXCAS 1
 extern int32_t openxcas_provid;
@@ -395,7 +420,7 @@
 static inline void openxcas_set_sid(uint16_t UNUSED(_sid)) { }
 static inline void openxcas_set_provid(uint32_t UNUSED(_provid)) { }
 #endif
-
+int32_t dvbapi_constcw_afterwards(int32_t typ, int32_t demux_id, int16_t direction);
 bool is_dvbapi_usr(char *usr);
 static inline bool module_dvbapi_enabled(void) { return cfg.dvbapi_enabled; }
 #else
Index: module-webif-tpl.c
===================================================================
--- module-webif-tpl.c	(revision 1542)
+++ module-webif-tpl.c	(working copy)
@@ -401,6 +401,7 @@
 											check_conf(WITH_CARDREADER, ptr2);
 											check_conf(CARDREADER_PHOENIX, ptr2);
 											check_conf(CARDREADER_DRECAS, ptr2);
+											check_conf(CARDREADER_INTERNAL_HISKY, ptr2);
 											check_conf(CARDREADER_INTERNAL_AZBOX, ptr2);
 											check_conf(CARDREADER_INTERNAL_COOLAPI, ptr2);
 											check_conf(CARDREADER_INTERNAL_SCI, ptr2);
Index: module-webif.c
===================================================================
--- module-webif.c	(revision 1542)
+++ module-webif.c	(working copy)
@@ -61,6 +61,11 @@
 static int8_t httpthread_running = 0;
 static pthread_t httpthread;
 static int32_t sock;
+// sky(n)
+#if defined(WITH_HISILICON)
+static char 		stRDR_status [256];
+static char 		stMYSKY_level[256];
+#endif
 enum refreshtypes { REFR_ACCOUNTS, REFR_READERS, REFR_CLIENTS, REFR_SERVER, REFR_ANTICASC, REFR_SERVICES };
 
 //initialize structs for calculating cpu-usage depending on time between refresh of status_page
@@ -81,7 +86,9 @@
 #define MNU_CACHEEX		8
 #define MNU_SCRIPT		9
 #define MNU_SHUTDOWN		10
-#define MNU_TOTAL_ITEMS 	11 // sum of items above
+// sky(n.11)
+#define MNU_MYSTATUS 		11
+#define MNU_TOTAL_ITEMS 	12 // sum of items above
 
 /* constants for config.html submenuactivating */
 #define MNU_CFG_GLOBAL 		0
@@ -136,9 +143,16 @@
 #define MNU_GBX_FEXPINF     	28
 #define MNU_GBX_INFOLOG     	29
 #define MNU_CFG_FSOFTCAMKEY	30
+#define MNU_CFG_FSMARTCARD	31
 
-#define MNU_CFG_TOTAL_ITEMS 	31 // sum of config or files items above. Use it for "All inactive" in function calls too.
+#define MNU_CFG_TOTAL_ITEMS 	32 // sum of config or files items above. Use it for "All inactive" in function calls too.
 
+#if defined(WITH_HISILICON)
+extern uint16_t HISCIAPI_ChkCardstatus (struct s_reader *reader);
+extern char *   HISCIAPI_ChkCardsystem (struct s_reader *reader);
+extern bool     HISCIAPI_SaveCardstatus(struct s_reader *reader);
+#endif
+
 static void set_status_info_var(struct templatevars *vars, char *varname, int no_data, char *fmt, double value) {
 	if (no_data)
 		tpl_addVar(vars, TPLADD, varname, "N/A");
@@ -4808,6 +4822,94 @@
 }
 #endif
 
+#if defined(WITH_HISILICON)
+static char *send_oscam_mystatus(struct templatevars *vars, struct uriparams *params, int32_t apicall)
+{
+	if (strcmp(strtolower(getParam(params, "action")), "cardstatus") == 0)
+	{
+		sprintf(stRDR_status, "CARDSTATUS: %d", HISCIAPI_ChkCardstatus(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "cardsystem") == 0)
+	{
+		sprintf(stRDR_status, "%s", HISCIAPI_ChkCardsystem(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "oscamversion") == 0)
+	{
+		#if defined(__HISILICON_MANUFACTORY__)
+			sprintf(stRDR_status, "v%s.Rev%s (f)\n", CS_VERSION, CS_SVN_VERSION);
+		#else
+			sprintf(stRDR_status, "v%s.Rev%s\n", CS_VERSION, CS_SVN_VERSION);
+		#endif
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "level") == 0)
+	{
+		sprintf(stMYSKY_level, "SKYLEVEL:%d", cs_dblevel);
+		return (stMYSKY_level);
+	}
+
+	char *mylvl = getParam(params, "level");
+	if (mylvl && strlen(mylvl) > 0)
+	{
+		int32_t dblvl = atoi(mylvl);
+		if (dblvl >= 0 && dblvl <= 65535) cs_dblevel = dblvl;
+		cs_log("%s debug_level=%d", "all", cs_dblevel);
+	}
+
+	//int i;
+	if (!apicall) setActiveMenu(vars, MNU_MYSTATUS);
+	if (cfg.loghistorylines)
+	{
+/*		char *t_loghistptr = loghistptr, *ptr1 = NULL;
+		if (loghistptr >= loghist + (cfg.loghistorylines) - 1) t_loghistptr = loghist;
+		int32_t d = 0, l1 = strlen(t_loghistptr+1) + 2;
+		char *lastpos = loghist + (cfg.loghistorylines)-1;
+
+		for (ptr1 = t_loghistptr + l1, i=0; i<200; i++, ptr1 = ptr1+l1) {
+			l1 = strlen(ptr1)+1;
+			if (!d && ((ptr1 >= lastpos) || (l1 < 2))) {
+				ptr1 = loghist;
+				l1 = strlen(ptr1)+1;
+				d++;
+			}
+
+			if (d && ((ptr1 >= t_loghistptr) || (l1 < 2))) break;
+
+			char p_usr[32];
+			size_t pos1 = strcspn(ptr1, "\t")+1;
+			cs_strncpy(p_usr, ptr1, pos1 > sizeof(p_usr) ? sizeof(p_usr) : pos1);
+
+			char *p_txt = ptr1 + pos1;
+
+			if (apicall == 0) {
+				if (p_txt[0]) {
+				//	myprintf("%3d! %s,%s", i, xml_encode(vars, p_usr), xml_encode(vars, p_txt));
+					tpl_printf(vars, TPLAPPEND, "LOGHISTORY",
+							   "\t\t<SPAN CLASS=\"%s\">%s\t\t</SPAN><BR>\n", xml_encode(vars, p_usr), xml_encode(vars, p_txt));
+				}
+			}
+			else
+			if (apicall == 1) {
+				if (strcmp(getParam(params, "appendlog"), "1") == 0) {
+				//	myprintf("%3d? %s", i, p_txt);
+					tpl_addVar(vars, TPLAPPEND, "LOGHISTORY", p_txt + 1);
+				}
+			}
+		}*/
+	}
+	else {
+		tpl_addVar(vars, TPLADD, "LOGHISTORY", "loghistorysize is set to 0 in your configuration<BR>\n");
+	}
+
+	if (apicall) {
+		return tpl_getTpl(vars, "APIMYSTATUS");
+	}
+	return tpl_getTpl(vars, "MYSTATUS");
+}
+#endif
+
 static char *send_oscam_status(struct templatevars * vars, struct uriparams * params, int32_t apicall)
 {
 	int32_t i;
@@ -6392,7 +6494,7 @@
 	tpl_addVar(vars, TPLADD, "FILTERFORM", tpl_getTpl(vars, "FILTERFORM"));
 }
 
-enum file_types { FTYPE_CONFIG, FTYPE_VERSION, FTYPE_ANTICASC, FTYPE_LOGFILE, FTYPE_USERFILE , FTYPE_GBOX };
+enum file_types { FTYPE_CONFIG, FTYPE_VERSION, FTYPE_ANTICASC, FTYPE_LOGFILE, FTYPE_USERFILE , FTYPE_GBOX, FTYPE_INFORMATION };
 
 struct files
 {
@@ -6455,6 +6557,10 @@
 #ifdef WITH_EMU
 		{ "SoftCam.Key",     MNU_CFG_FSOFTCAMKEY,FTYPE_CONFIG },  // id 30
 #endif
+// sky(n)
+#if defined(WITH_HISILICON)
+		{ cs_SMCINFORMATION, MNU_CFG_FSMARTCARD, FTYPE_INFORMATION },
+#endif
 		{ NULL, 0, 0 },
 	};
 
@@ -6527,6 +6633,10 @@
 				writable = 1;
 				get_config_filename(targetfile, sizeof(targetfile), entry->file);
 				break;
+			// sky(n)
+			 case FTYPE_INFORMATION:
+				   get_information_filename(targetfile, sizeof(targetfile), entry->file);
+				   break;
 			case FTYPE_VERSION:
 				get_tmp_dir_filename(targetfile, sizeof(targetfile), entry->file);
 				break;
@@ -7524,6 +7634,23 @@
 		}
 
 	}
+//	sky(n)
+#if defined(WITH_HISILICON)
+	else if (strcmp(getParam(params, "part"), "mystatus") == 0)
+	{
+		if ((strcmp(strtolower(getParam(params, "action")), "cardstatus") == 0) ||
+			 (strcmp(strtolower(getParam(params, "action")), "cardsystem") == 0) ||
+			 (strcmp(strtolower(getParam(params, "action")), "oscamversion") == 0) ||
+			 (strcmp(strtolower(getParam(params, "action")), "logstatus") == 0))
+		{
+			return send_oscam_mystatus(vars, params, 1);
+		}
+		else {
+			tpl_addVar(vars, TPLADD, "APIERRORMESSAGE", "missing parameter action");
+			return tpl_getTpl(vars, "APIERROR");
+		}
+	}
+#endif
 	else
 	{
 		tpl_addVar(vars, TPLADD, "APIERRORMESSAGE", "part not found");
@@ -7753,6 +7880,30 @@
 		else { return tpl_getTpl(vars, "PREAUTOCONF"); }   // something failed
 
 	}
+//sky(n)
+#if 0
+#if defined(WITH_HISILICON)
+	else if (strcmp(strtolower(getParam(params, "action")), "cardstatus") == 0)
+	{
+		sprintf(stRDR_status, "CARDSTATUS: %d", HISCIAPI_ChkCardstatus(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "cardsystem") == 0)
+	{
+		sprintf(stRDR_status, "%s", HISCIAPI_ChkCardsystem(NULL));
+		return (stRDR_status);
+	}
+	else if (strcmp(strtolower(getParam(params, "action")), "oscamversion") == 0)
+	{
+		#if defined(__HISILICON_MANUFACTORY__)
+			sprintf(stRDR_status, "v%s.Rev%s (f)\n", CS_VERSION, CS_SVN_VERSION);
+		#else
+			sprintf(stRDR_status, "v%s.Rev%s\n", CS_VERSION, CS_SVN_VERSION);
+		#endif
+		return (stRDR_status);
+	}
+#endif
+#endif
 	else
 	{
 		if(strlen(getParam(params, "token")) > 0)   // parse autoconf token
@@ -7834,6 +7985,10 @@
 
 static int8_t check_valid_origin(IN_ADDR_T addr)
 {
+	// sky(n)
+	if (check_LOCALHOST_ip(addr)) return 2;
+	// sky(sim)
+	if (g_factoy_products) return 0;
 
 	// check whether requesting IP is in allowed IP ranges
 	if(check_ip(cfg.http_allowed, addr))
@@ -7933,7 +8088,8 @@
 		bufsize += n;
 
 		//max request size 200kb
-		if(bufsize > 204800)
+		// sky(102400->196608(192kB))
+		if (bufsize>196608)
 		{
 			cs_log("error: too much data received from %s", cs_inet_ntoa(in));
 			NULLFREE(*result);
@@ -8434,6 +8590,11 @@
 				break;
 			//case 30: jquery.js
 #endif
+#if defined(WITH_HISILICON)
+			case 31:
+				result = send_oscam_mystatus(vars, &params, 0);
+			break;
+#endif
 			default:
 				result = send_oscam_status(vars, &params, 0);
 				break;
Index: oscam-chk.c
===================================================================
--- oscam-chk.c	(revision 1542)
+++ oscam-chk.c	(working copy)
@@ -1110,6 +1110,101 @@
 	return 1;
 }
 
+// sky(n)
+int32_t set_cw_checksum(uchar *cw, int ksize)
+{
+	uint8_t i, c;
+	int r = 1;
+
+	if (chk_is_null_CW(cw)) return 0;
+	for (i = 0; i < ksize; i += 4) {
+		c = ((cw[i] + cw[i+1] + cw[i+2]) & 0xff);
+		if (cw[i+3] != c) { cw[i+3] = c;	r = -1; }
+	}
+	return r;
+}
+int32_t chk_cw_violation(uchar *cw)
+{
+	uint8_t i, c;
+	if (chk_is_null_CW(cw)) return 1;
+	for (i = 0; i < 16; i += 4) {
+		c = ((cw[i] + cw[i+1] + cw[i+2]) & 0xff);
+		if (cw[i+3] != c) return 1;
+	}
+	return 0;
+}
+
+
+/*
+ *	Firmware: Frame Output(Firmware->VDEC):
+ *  	Acquire(Try/OK):  2442/2442
+ *  	Release(Try/OK):  2439/2439
+ */
+#if defined(WITH_HISILICON)
+int32_t chk_av_descrambling(struct s_client *client)
+{
+	#if defined(SDKV500) || defined(SDKV600)
+		if (access("/proc/msp/vdec00", F_OK) != 0) return 0;
+		return 1;
+	#else
+		FILE 	*fp;
+		char 	*token;
+		char 	*tmp;
+		char 	*pszval = 0;
+		char 	*pszframe = 0;
+		uint32_t frametries = 0, okframe = 0;
+
+		fp = fopen("/proc/msp/vdec00", "r");
+		if (!fp)
+		{
+			myprintf("mychk:vdec none\n");
+			if (client) client->frameAcquire = 0;
+			return 0;
+		}
+
+		if (!cs_malloc(&token, MAX_FILELINESIZE))
+		{
+			fclose(fp);
+			return 0;
+		}
+
+		while (fgets(token, MAX_FILELINESIZE, fp))
+		{
+			tmp = trim(token);
+			if (pszframe)
+			{
+				if (!tmp) break;
+				if ((pszval = strchr(tmp, ':'))==0) break;
+				while (*(++pszval) == ' ');
+				if (!pszval) break;
+				sscanf(pszval, "%d/%d", &frametries, &okframe);
+			//	myprintf("MYCHK:FRAME ACQUIRE{%d/%d}\n", frametries, okframe);
+				break;
+			}
+			else
+			{
+				pszframe = strstr((char*)tmp, "Frame Output");
+			}
+		}
+		fclose(fp);
+
+		if (client)
+		{
+			if (client->frameAcquire == okframe)
+			{
+			//	myprintf("MYCHK:vdec same{%d/%d,%d}\n", client->frameAcquire, frametries, okframe);
+				return 0;
+			}
+			client->frameAcquire = okframe;
+			cs_sleepms(10);
+		}
+		if (okframe==0) return 0;
+		return 1;
+	#endif
+}
+#endif
+
+
 //check if client structure is accessible
 bool check_client(struct s_client *cl)
 {
Index: oscam-chk.h
===================================================================
--- oscam-chk.h	(revision 1542)
+++ oscam-chk.h	(working copy)
@@ -5,6 +5,18 @@
 #define SRVID_ZERO  0 // srvid + 0000 (used for service-filter bypass)
 #define SRVID_MASK  1 // srvid + FFFF
 
+// sky(!)
+#define IS_IRDETO(x)			(((x)>>8)==0x06)
+#define IS_NDS(x)				(((x)>>8)==0x09)
+#define IS_VIACESS(x)		 ((x)==0x500)
+#define IS_SEKA(x)			 ((x)==0x100)
+#define IS_NAGRA(x)			(((x)>>8)==0x18)
+#define IS_CRYPTOWORKS(x)	(((x)>>8)==0x0d)
+#define IS_CONAX(x)			(((x)>>8)==0x0b)
+#define IS_BISS(x)			(((x)>>8)==0x26)
+// sky(2016)
+#define IS_POWERVU(x)		(((x)>>8)==0x0E)
+
 uint32_t get_fallbacktimeout(uint16_t caid);
 int32_t ecm_ratelimit_check(struct s_reader *reader, ECM_REQUEST *er, int32_t reader_mode);
 int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr);
@@ -36,6 +48,10 @@
 int8_t is_halfCW_er(ECM_REQUEST *er);
 int8_t chk_halfCW(ECM_REQUEST *er, uchar *cw);
 int32_t chk_is_null_nodeid(uint8_t node_id[], uint8_t len);
+#if defined(WITH_HISILICON)
+int32_t chk_av_descrambling(struct s_client *client);
+int32_t set_cw_checksum(uchar *cw, int ksize);
+#endif
 bool check_client(struct s_client *cl);
 uint16_t caidvaluetab_get_value(CAIDVALUETAB *cv, uint16_t caid, uint16_t default_value);
 int32_t chk_is_fakecw(uint8_t *cw);
Index: oscam-client.c
===================================================================
--- oscam-client.c	(revision 1542)
+++ oscam-client.c	(working copy)
@@ -479,6 +479,7 @@
 void cs_disconnect_client(struct s_client *client)
 {
 	char buf[32] = { 0 };
+	if (!client) return;
 	if(IP_ISSET(client->ip))
 		{ snprintf(buf, sizeof(buf), " from %s", cs_inet_ntoa(client->ip)); }
 	cs_log("%s disconnected%s", username(client), buf);
@@ -706,7 +707,7 @@
 		ll_destroy_data(&rdr->emmstat);
 		remove_reader_from_active(rdr);
 
-		cs_sleepms(1000); //just wait a bit that really really nobody is accessing client data
+		cs_sleepms(800); //just wait a bit that really really nobody is accessing client data
 
 		if(rdr->ph.cleanup)
 			{ rdr->ph.cleanup(cl); }
@@ -726,7 +727,7 @@
 		cl->last_srvid = NO_SRVID_VALUE;
 		cs_statistics(cl);
 
-		cs_sleepms(1000); //just wait a bit that really really nobody is accessing client data
+		cs_sleepms(800); //just wait a bit that really really nobody is accessing client data
 	}
 
 	struct s_module *module = get_module(cl);
@@ -757,8 +758,8 @@
     NULLFREE(cl->cltab.aclass);
  	NULLFREE(cl->cltab.bclass);
 
+	ll_destroy_data(&cl->ra_buf);
 	NULLFREE(cl->cw_rass);
-	ll_destroy_data(&cl->ra_buf);
 	NULLFREE(cl->aes_keys);
 
 #ifdef MODULE_CCCAM
Index: oscam-conf-chk.c
===================================================================
--- oscam-conf-chk.c	(revision 1542)
+++ oscam-conf-chk.c	(working copy)
@@ -333,7 +333,7 @@
 			continue;
 		}
 		ptr1 = caid_end_ptr + 1; // -> headers
-		char *ident_ptr, *saveident_ptr = NULL;
+		char *ident_ptr = NULL, *saveident_ptr = NULL;
 		for(ident_ptr = strtok_r(ptr1, ",", &saveident_ptr); ident_ptr && d.nprids < ARRAY_SIZE(d.prids); ident_ptr = strtok_r(NULL, ",", &saveident_ptr))
 		{
 			uint32_t ident = a2i(ident_ptr, 4);
@@ -401,7 +401,7 @@
 {
 	int32_t i, j, nfilts, ifilt, iport;
 	PTAB *newptab;
-	char *ptr1, *ptr2, *ptr3, *saveptr1 = NULL;
+	char *ptr1 = 0, *ptr2 = 0, *ptr3 = 0, *saveptr1 = NULL;
 	char *ptr[CS_MAXPORTS] = {0};
 	int32_t port[CS_MAXPORTS] = {0};
 	if(!cs_malloc(&newptab, sizeof(PTAB)))
@@ -441,6 +441,13 @@
 	{
 		newptab->ports[0].s_port = atoi(portasc);
 		newptab->nports = 1;
+		// sky(a)
+		if (newptab->ports[0].ncd) {
+			newptab->ports[0].ncd->ncd_ftab.filts[0].caid 	 = 0x0;
+			newptab->ports[0].ncd->ncd_ftab.filts[0].prids[0]= 0x0;
+			newptab->ports[0].ncd->ncd_ftab.filts[0].nprids  = 1;
+		}
+		nfilts = 0;
 	}
 
 	iport = ifilt = 0;
@@ -449,6 +456,7 @@
 		if(port[i] != 0)
 			{ iport = i; }
 		for(j = 0, ptr3 = strtok_r(ptr[i], ",", &saveptr1); (j < CS_MAXPROV) && (ptr3); ptr3 = strtok_r(NULL, ",", &saveptr1), j++)
+// bekelteni		for (j = 0, ptr3 = strtok_r(ptr[i], ",", &saveptr1); (j < CS_MAXPRFLT) && (ptr3); ptr3 = strtok_r(NULL, ",", &saveptr1), j++)
 		{
 			if((ptr2 = strchr(trim(ptr3), ':')))
 			{
Index: oscam-conf.c
===================================================================
--- oscam-conf.c	(revision 1542)
+++ oscam-conf.c	(working copy)
@@ -119,14 +119,28 @@
 			}
 			return 1;
 		}
-		case OPT_HEX_ARRAY:
-		{
+
+		// sky(iks)
+		case OPT_HEX_BYTES:
+		case OPT_HEX_ARRAY: {
 			uint8_t *hex_array = var;
-			if(!strlen(value))
-				{ memset(hex_array, 0, c->def.array_size); }
-			else if(key_atob_l(value, hex_array, c->def.array_size * 2))
-			{
+			uint8_t  hexakeep[256];
+			int 		keepsize  = c->def.array_size;
+			int 		preserved = 0;
+			if (strcasecmp(token, "iksregister") == 0) {
+				memcpy(hexakeep, hex_array, keepsize);
+				preserved = 1;
+			}
+			if (!strlen(value)) {
+				if (preserved) return 1;
 				memset(hex_array, 0, c->def.array_size);
+			}
+			else if (key_atob_l(value, hex_array, c->def.array_size * 2)) {
+				if (preserved) {
+					memcpy(hex_array, hexakeep, keepsize);
+					return 1;
+				}
+				memset(hex_array, 0, c->def.array_size);
 				fprintf(stderr, "WARNING: Config value for '%s' (%s, len=%zu) requires %d chars.\n",
 						token, value, strlen(value), c->def.array_size * 2);
 			}
@@ -237,6 +251,21 @@
 			}
 			continue;
 		}
+		// sky(!)
+		case OPT_HEX_BYTES: {
+			uint8_t *hex_array = var;
+			uint32_t ok = (hex_array && c->def.array_size) ? 1 : 0;
+			if (save_all || ok) {
+				fprintf_conf(f, c->config_name, "%s", ""); // it should not have \n at the end
+				if (ok) {
+					for (ok = 0; ok < c->def.array_size; ok++) {
+						fprintf(f, "%02X", hex_array[ok]);
+					}
+				}
+				fprintf(f, "\n");
+			}
+			continue;
+		}
 		case OPT_FUNC:
 		{
 			c->ops.process_fn((const char *)c->config_name, NULL, var, f);
@@ -326,6 +355,7 @@
 				{ cs_strncpy(scfg, c->def.d_char, c->str_size); }
 			break;
 		}
+		case OPT_HEX_BYTES:
 		case OPT_HEX_ARRAY:
 		{
 			uint8_t *hex_array = var;
@@ -530,3 +560,18 @@
 	}
 	return safe_overwrite_with_bak(dst_file, tmp_file, bak_file, cfg.http_overwrite_bak_file);
 }
+// sky(n)
+FILE *create_information_file(const char *information_filename)
+{
+	char information_file[256];
+	get_config_filename(information_file, sizeof(information_file), information_filename);
+	FILE *f = fopen(information_file, "w");
+	if (!f) {
+		cs_log("ERROR: Cannot create file \"%s\" (errno=%d %s)", information_file, errno, strerror(errno));
+		return NULL;
+	}
+	fprintf(f, "# %s generated automatically by Streamboard OSCAM %s SVN r%s\n",
+			information_filename, CS_VERSION, CS_SVN_VERSION);
+	setvbuf(f, NULL, _IOFBF, 16 * 1024);
+	return (f);
+}
Index: oscam-conf.h
===================================================================
--- oscam-conf.h	(revision 1542)
+++ oscam-conf.h	(working copy)
@@ -12,6 +12,7 @@
 	OPT_STRING,
 	OPT_SSTRING,
 	OPT_HEX_ARRAY,
+	OPT_HEX_BYTES,	// sky(n)
 	OPT_FUNC,
 	OPT_FUNC_EXTRA,
 	OPT_SAVE_FUNC,
@@ -98,6 +99,15 @@
 		.def.array_size	= __array_size \
 	}
 
+// sky()
+#define DEF_OPT_HEXA(__name, __var_ofs, __array_size) \
+	{ \
+		.opt_type		= OPT_HEX_BYTES, \
+		.config_name	= __name, \
+		.var_offset		= __var_ofs, \
+		.def.array_size= __array_size \
+	}
+
 #define DEF_OPT_FUNC(__name, __var_ofs, __process_fn, ...) \
 	{ \
 		.opt_type		= OPT_FUNC, \
@@ -169,5 +179,6 @@
 FILE *open_config_file_or_die(const char *conf_filename);
 FILE *create_config_file(const char *conf_filename);
 bool flush_config_file(FILE *f, const char *conf_filename);
-
+// sky(n)
+FILE *create_information_file(const char *information_filename);
 #endif
Index: oscam-config-global.c
===================================================================
--- oscam-config-global.c	(revision 1542)
+++ oscam-config-global.c	(working copy)
@@ -1277,7 +1277,7 @@
 	DEF_OPT_SAVE_FUNC(dvbapi_should_save_fn),
 	DEF_OPT_INT8("enabled"		, OFS(dvbapi_enabled),		0),
 	DEF_OPT_INT8("au"		, OFS(dvbapi_au),		0),
-	DEF_OPT_INT8("pmt_mode"		, OFS(dvbapi_pmtmode),		0),
+	DEF_OPT_INT8("pmt_mode"		, OFS(dvbapi_pmtmode),		1),
 	DEF_OPT_INT8("request_mode"	, OFS(dvbapi_requestmode),	0),
 	DEF_OPT_INT32("listen_port"	, OFS(dvbapi_listenport),	0),
 	DEF_OPT_INT32("delayer"		, OFS(dvbapi_delayer),		0),
@@ -1407,6 +1407,12 @@
 #ifdef HAVE_DVBAPI
 		cfg.dvbapi_enabled = 1;
 #endif
+#ifdef WITH_HISILICON
+		// Always
+		cfg.dvbapi_enabled = 1;
+		cfg.dvbapi_pmtmode = 1;
+		cfg.dvbapi_boxtype = BOXTYPE_HISILICON;
+#endif
 		return 0;
 	}
 
@@ -1464,6 +1470,23 @@
 	}
 	NULLFREE(token);
 	fclose(fp);
+// sky(a)
+#ifdef WEBIF
+	if (!cfg.http_port || !cfg.http_allowed) {
+		cfg.http_port = DEFAULT_HTTP_PORT;
+		chk_iprange(cs_strdup(DEFAULT_HTTP_ALLOW), &cfg.http_allowed);
+	}
+#endif
+
+#ifdef WITH_HISILICON
+	// Always
+	cfg.dvbapi_enabled = 1;
+	cfg.dvbapi_pmtmode = 1;
+	cfg.dvbapi_boxtype = BOXTYPE_HISILICON;
+#endif
+#if (__ADB_TRACE__)
+	cfg.logsvrsecrete  = 0;
+#endif
 	if(cur_section) { config_list_apply_fixups(cur_section->config, &cfg); }
 	return 0;
 }
Index: oscam-config-reader.c
===================================================================
--- oscam-config-reader.c	(revision 1542)
+++ oscam-config-reader.c	(working copy)
@@ -1171,6 +1171,33 @@
 	return count;
 }
 
+// sky(sim)
+static void inactivate_reader_for_factoy(struct s_reader *rdr)
+{
+	struct s_client *cl = rdr->client;
+	if (cl)
+		{ kill_thread(cl); }
+}
+
+int32_t free_reader_for_factoy_products(void)
+{
+	int count = 0;
+	if (g_factoy_products) {
+		struct s_reader *rdr;
+		LL_ITER itr = ll_iter_create(configured_readers);
+		while ((rdr = ll_iter_next(&itr))) {
+			if (is_cascading_reader(rdr)) {
+				inactivate_reader_for_factoy(rdr);
+				ll_remove(configured_readers, rdr);
+				free_reader(rdr);
+				count++;
+				cs_log("factoy-made{%s}\n", rdr->label);
+			}
+		}
+	}
+	return count;
+}
+
 int32_t write_server(void)
 {
 	FILE *f = create_config_file(cs_srvr);
Index: oscam-config.c
===================================================================
--- oscam-config.c	(revision 1542)
+++ oscam-config.c	(working copy)
@@ -12,6 +12,7 @@
 #include "oscam-lock.h"
 #include "oscam-string.h"
 #include "oscam-time.h"
+#include "oscam-reader.h"
 
 extern uint16_t len4caid[256];
 
@@ -36,6 +37,12 @@
 	return dest;
 }
 
+// sky(n)
+char *get_information_filename(char *dest, size_t destlen, const char *filename) {
+	snprintf(dest, destlen, "%s%s", CS_INFORMATIONDIR, filename);
+	return dest;
+}
+
 int32_t write_services(void)
 {
 	int32_t i;
Index: oscam-config.h
===================================================================
--- oscam-config.h	(revision 1542)
+++ oscam-config.h	(working copy)
@@ -2,6 +2,8 @@
 #define OSCAM_CONFIG_H_
 
 char *get_config_filename(char *dest, size_t destlen, const char *filename);
+// sky(n)
+char *get_information_filename(char *dest, size_t destlen, const char *filename);
 
 int32_t init_config(void);
 void    config_set(char *section, const char *token, char *value);
@@ -22,6 +24,8 @@
 int32_t free_readerdb(void);
 int32_t write_server(void);
 void    reload_readerdb(void);
+// sky(sim)
+int32_t free_reader_for_factoy_products(void);
 void    reader_fixups_fn(void *var);
 
 void    chk_sidtab(char *token, char *value, struct s_sidtab *sidtab);
Index: oscam-ecm.c
===================================================================
--- oscam-ecm.c	(revision 1542)
+++ oscam-ecm.c	(working copy)
@@ -1818,6 +1818,27 @@
 //chid calculation from module stat to here
 //to improve the quickfix concerning ecm chid info and extend it to all client requests wereby the chid is known in module stat
 
+// sky()
+uint32_t get_ecm_subid(uint8_t *ecm, uint16_t caid)
+{
+	if (!ecm) return 0;
+ 
+	uint32_t id = 0;
+	switch (caid>>8)
+	{
+		case 0x01: id = b2i(2, ecm+ 7); break; // seca
+		case 0x05: id = b2i(2, ecm+ 8); break; // viaccess
+		case 0x06: id = b2i(2, ecm+ 6); break; // irdeto
+		case 0x09: id = b2i(2, ecm+11); break; // videoguard
+		case 0x4A: // DRE-Crypt, Bulcrypt, Tongfang and others?
+			if (!(caid == 0x4AEE)) // Bulcrypt excluded for now
+				id = b2i(2, ecm+6);
+			break;
+	}
+	return id;
+}
+
+
 uint32_t get_subid(ECM_REQUEST *er)
 {
 	if(!er->ecmlen)
Index: oscam-ecm.h
===================================================================
--- oscam-ecm.h	(revision 1542)
+++ oscam-ecm.h	(working copy)
@@ -15,6 +15,8 @@
 uint32_t get_subid(ECM_REQUEST *er);
 uint32_t chk_provid(uint8_t *ecm, uint16_t caid);
 
+// sky()
+uint32_t get_ecm_subid(uint8_t *ecm, uint16_t caid);
 int32_t send_dcw(struct s_client *client, ECM_REQUEST *er);
 void free_ecm(ECM_REQUEST *ecm);
 void free_push_in_ecm(ECM_REQUEST *ecm);
Index: oscam-net.c
===================================================================
--- oscam-net.c	(revision 1542)
+++ oscam-net.c	(working copy)
@@ -156,6 +156,16 @@
 #endif
 }
 
+// sky(n)
+int32_t check_LOCALHOST_ip(IN_ADDR_T ip)
+{
+	IN_ADDR_T loip;
+
+	set_localhost_ip(&loip);
+	if (IP_EQUAL(loip, ip)) return 1;
+	return 0;
+}
+
 int32_t check_ip(struct s_ip *ip, IN_ADDR_T n)
 {
 	struct s_ip *p_ip;
@@ -180,6 +190,9 @@
 {
 	uint32_t result = 0;
 	//Resolve with gethostbyname:
+#if defined(WITH_HISILICON)
+	cfg.resolve_gethostbyname = 1;
+#endif
 	if(cfg.resolve_gethostbyname)
 	{
 		cs_writelock(__func__, &gethostbyname_lock);
@@ -430,6 +443,7 @@
 	int32_t rc;
 	struct pollfd pfd[1];
 
+	if (!fd) return 0; // sky(a)
 	pfd[0].fd = fd;
 	pfd[0].events = (POLLIN | POLLPRI);
 	rc = poll(pfd, 1, 0);
Index: oscam-net.h
===================================================================
--- oscam-net.h	(revision 1542)
+++ oscam-net.h	(working copy)
@@ -32,6 +32,8 @@
 void set_null_ip(IN_ADDR_T *ip);
 void set_localhost_ip(IN_ADDR_T *ip);
 int32_t check_ip(struct s_ip *ip, IN_ADDR_T n);
+// sky(n)
+int32_t check_LOCALHOST_ip(IN_ADDR_T n);
 uint32_t cs_getIPfromHost(const char *hostname);
 int set_socket_priority(int fd, int priority);
 void setTCPTimeouts(int32_t sock);
Index: oscam-reader.c
===================================================================
--- oscam-reader.c	(revision 1542)
+++ oscam-reader.c	(working copy)
@@ -1,10 +1,18 @@
 #define MODULE_LOG_PREFIX "reader"
 
 #include "globals.h"
+#include <sys/system_properties.h>
+#include <net/if.h>
+#include "cscrypt/md5.h"
 #include "module-cccam.h"
 #include "module-led.h"
 #include "module-stat.h"
 #include "module-dvbapi.h"
+#if defined(MODULE_CONSTCW)
+#include "module-constcw.h"
+#endif
+#include "oscam-conf.h"
+#include "oscam-files.h"
 #include "oscam-cache.h"
 #include "oscam-chk.h"
 #include "oscam-client.h"
@@ -24,6 +32,10 @@
 extern struct ecm_request_t *ecmcwcache;
 extern const struct s_cardsystem *cardsystems[];
 
+// sky(n)
+extern char  *entitlement_type[];
+extern struct s_client	*dvbapi_client;
+
 const char *RDR_CD_TXT[] =
 {
 	"cd", "dsr", "cts", "ring", "none",
@@ -277,6 +289,9 @@
 // Else just report if a free slot is available.
 {
 	// No rate limit set
+	if (!er) return OK;
+	// sky(a)
+	if ( er->ecm_bypass) return OK;
 	if(!reader->ratelimitecm)
 	{
 		return OK;
@@ -495,6 +510,7 @@
 const char *reader_get_type_desc(struct s_reader *rdr, int32_t extended)
 {
 	const char *desc = "unknown";
+	if (!rdr) return desc;
 	if(rdr->crdr && rdr->crdr->desc)
 		{ return rdr->crdr->desc; }
 	if(is_network_reader(rdr) || rdr->typ == R_SERIAL)
@@ -588,7 +604,7 @@
  * add or find one entitlement item to entitlements of reader
  * use add = 0 for find only, or add > 0 to find and add if not found 
  **/
-S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, uint8_t add)
+S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, char *comments, uint8_t add)
 {
 	if(!rdr->ll_entitlements)
 	{ 
@@ -628,6 +644,8 @@
 			item->end = end;
 			item->type = type;
 
+			item->comments[0] = 0;
+			if (comments) strcpy(item->comments, comments);
 			//add item
 			ll_append(rdr->ll_entitlements, item);
 			// cs_log_dbg(D_TRACE, "entitlement: Add caid %4X id %4X %s - %s ", item->caid, item->id, item->start, item->end);
@@ -642,6 +660,208 @@
 	return item;
 }
 
+// sky(oscam.smartcard)
+// sky(sim)
+extern int __system_property_set(const char *key, char *value);
+void cs_clean_cardinformation(void)
+{
+	char viewfile[256] = { 0 };
+
+	__system_property_set("service.sci.state", "");
+	get_information_filename(viewfile, sizeof(viewfile), cs_SMCINFORMATION);
+	if (file_exists(viewfile))	{
+		cs_log("removing scinformation %s", viewfile);
+		if (unlink(viewfile) < 0) {
+			cs_log("Error removing scinformation file %s (errno=%d %s)!", viewfile, errno, strerror(errno));
+		}
+	}
+}
+
+int cs_save_cardinformation(struct s_reader *rdr)
+{
+	char viewfile[256] = { 0 };
+	FILE *fp;
+	char tbuffer1[64], tbuffer2[64], buf[256] = { 0 }, tmpbuf[256] = { 0 }, valid_to[32] = { 0 };
+	char tmp[512];
+	uint16_t casysid;
+	int32_t  i;
+
+	get_information_filename(viewfile, sizeof(viewfile), cs_SMCINFORMATION);
+	fp = fopen(viewfile, "w");
+	if (!fp) {
+		cs_log("ERROR: Cannot create file \"%s\" (errno=%d %s)", viewfile, errno, strerror(errno));
+		return 0;
+	}
+	setvbuf(fp, NULL, _IOFBF, 4 * 1024);
+	fprintf(fp, "# smc information generated automatically by sky.\n");
+	fprintf(fp, "\n");
+	if (!rdr) {
+		fprintf(fp, "%s\n", "; Reader do not exist or it is not started.");
+		fclose (fp);
+		return 0;
+	}
+
+	casysid = rdr->caid & 0xff00;
+	fprintf(fp, "[INFORMATIONS]\n");
+	if (!rdr->enable) {
+		__system_property_set("service.sci.state", "disable");
+		fprintf(fp, "  status     : disabled\n");
+		fclose (fp);
+		return 0;
+	}
+	if (rdr->card_status == NO_CARD)
+	{
+		__system_property_set("service.sci.state", "nocard");
+		fprintf(fp, "  status     : no card\n");
+		fclose(fp);
+		return 0;
+	}
+
+	fprintf(fp, "  Reader     : %s\n",   rdr->label);
+	fprintf(fp, "  Cardsystem : %s\n",  (rdr->csystem && rdr->csystem->desc) ? rdr->csystem->desc : "unknown");
+	fprintf(fp, "  Casysid    : %04X\n", rdr->caid);
+	fprintf(fp, "  Serial     : %s\n",   rdr->ascserial);
+	if (casysid == 0x0600)
+	{
+		fprintf(fp, "  Acs        : %04X\n",   rdr->acs);
+		fprintf(fp, "  Nationality: %c%c%c\n", rdr->country_code[0],rdr->country_code[1],rdr->country_code[2]);
+	}
+	else
+	if (casysid == 0x0B00)
+	{
+		fprintf(fp, "  Ver.       : %02X\n", rdr->cardver);
+		fprintf(fp, "  Maturity   : %d\n",   rdr->maturity);
+	}
+	else
+	if (casysid == 0x0500)
+	{
+		fprintf(fp, "  Maturity   : %d\n",   rdr->maturity);
+	}
+	else
+	if (casysid == 0x0D00)
+	{
+		fprintf(fp, "  Maturity   : %d\n",   rdr->maturity);
+	}
+//	fprintf(fp, "  HexSerial  : %s\n", cs_hexdump(1, rdr->hexserial, 8, tbuffer2, sizeof(tbuffer2)));
+	fprintf(fp, "  ATR        : %s\n", (rdr->card_atr_length) ? cs_hexdump(1, rdr->card_atr, rdr->card_atr_length, buf, sizeof(buf)) : "?");
+	fprintf(fp, "\n");
+	//
+	//
+	//
+	if (casysid == 0x0100 || casysid == 0x0500 || casysid == 0x0b00 || casysid == 0x0d00)
+	{
+		fprintf(fp, "  Pincode    : %s\n", rdr->pincode);
+	}
+	if (casysid == 0x0900)
+	{
+		fprintf(fp, "  Boxid      : %08X\n", rdr->boxid);
+	}
+	if (casysid == 0x0600 || casysid == 0x1800)
+	{
+		fprintf(fp, "  Boxkey     : %s\n", cs_hexdump(0, rdr->boxkey, sizeof(rdr->boxkey), tmp, sizeof(tmp)));
+	}
+	if (casysid == 0x0600 || casysid == 0x1800 || casysid == 0xB00)
+	{
+		int32_t len = array_has_nonzero_byte(rdr->rsa_mod, 120);
+		if (len > 0) {
+			len = (len > 64) ? 120 : 64;
+			fprintf(fp, "  Rsakey     : %s\n", cs_hexdump(0, rdr->rsa_mod, len, tmp, sizeof(tmp)));
+		} else
+			fprintf(fp, "  Rsakey     : none\n");
+	}
+	fprintf(fp, "  Autoroll   : %s\n", (rdr->audisabled) ? "disable" : "enable" );
+	//
+	//
+	//
+	//
+	if (rdr->card_valid_to) {
+		struct tm vto_t;
+		localtime_r(&rdr->card_valid_to, &vto_t);
+		strftime(valid_to, sizeof(valid_to) - 1, "%Y-%m-%d", &vto_t);
+		fprintf(fp, "  ValidTo    : %s\n", valid_to);
+	}
+	if (rdr->card_status == CARD_FAILURE)
+	{
+		if (rdr->card_atr_length) {
+			__system_property_set("service.sci.state", "atr");
+		}
+		else {
+		   __system_property_set("service.sci.state", "ng");
+		}
+		fprintf(fp, "  status     : failure\n");
+		fprintf(fp, "\n");
+		fclose (fp);
+		return 0;
+	}
+	__system_property_set("service.sci.state", "ok");
+	if (casysid == 0x1800) {
+	//	fprintf(fp, "  status     : %s\n", rdr->nagra_negotiate ? "success" : "unsettled");
+	}
+	else {
+		fprintf(fp, "  status     : success\n");
+	}
+	fprintf(fp, "\n");
+
+	fprintf(fp, "[ENTITLEMENTS]\n");
+	if (rdr->ll_entitlements)
+	{
+		S_ENTITLEMENT *item;
+		LL_ITER itr = ll_iter_create(rdr->ll_entitlements);
+		time_t now = (time(NULL) / 84600) * 84600;
+
+		while ((item = ll_iter_next(&itr))) {
+			struct tm start_t, end_t;
+
+			localtime_r(&item->start, &start_t);
+			localtime_r(&item->end  , &end_t);
+			strftime(tbuffer1, sizeof(tbuffer1) - 1, "%d-%m-%Y", &start_t);
+			strftime(tbuffer2, sizeof(tbuffer2) - 1, "%d-%m-%Y", &end_t);
+
+			snprintf(tmpbuf, sizeof(tmpbuf) - 1, "%s:: %-9s: provid.%06X (%s ~ %s) ",
+					item->end > now ? "Active " : "Expired",
+					entitlement_type[item->type],
+					item->provid,
+					tbuffer1,
+					tbuffer2);
+			if (item->comments[0])
+			{
+				strcat(tmpbuf, item->comments);
+			}
+			else
+			{
+				char *entresname = get_tiername(item->id & 0xFFFF, item->caid, buf);
+				if (!entresname[0]) entresname = get_provider_existnace(item->caid, item->provid, buf, sizeof(buf));
+				if ( entresname[0]) {
+					strcat(tmpbuf, "Name: ");
+					strcat(tmpbuf, entresname);
+				}
+			}
+			fprintf(fp, "  %s\n", tmpbuf);
+		}
+	}
+	else
+	{
+		fprintf(fp, "; No entitlements.\n");
+	}
+
+	fprintf(fp, "\n");
+	fprintf(fp, "[PROVIDERS]\n");
+	if (rdr->nprov)
+	{
+		for (i= 0; i<rdr->nprov; i++)
+		{
+			fprintf(fp, "  %2d. %04X:%06X\n", i, rdr->caid, b2i(4, rdr->prid[i]));
+		}
+	}
+	else
+	{
+		fprintf(fp, "; No providers.\n");
+	}
+	fprintf(fp, "\n");
+	fclose(fp);
+	return 1;
+}
+
 /**
  * clears entitlements of reader.
  **/
@@ -746,6 +966,7 @@
 int32_t network_tcp_connection_open(struct s_reader *rdr)
 {
 	if(!rdr) { return -1; }
+	if (!rdr->client) return -1;
 	struct s_client *client = rdr->client;
 	struct SOCKADDR loc_sa;
 
@@ -1440,3 +1661,55 @@
 		return 1; // slots available!
 	}
 }
+
+#if defined(MODULE_CONSTCW)
+
+struct s_reader *
+CSREADER_ChkActive(int32_t typ)
+{
+	struct s_reader *rdr;
+
+	rdr = CSREADER_GetReaders(typ);
+	if (!rdr) return 0;
+	if (!rdr->enable) return 0;
+	if ( rdr->card_status != CARD_INSERTED) return 0;
+	if (!check_client(rdr->client)) return 0;
+	return (rdr);
+}
+
+struct s_reader *
+CSREADER_GetReaders(int32_t typ)
+{
+	struct s_reader *rdr;
+	for (rdr = first_active_reader; rdr; rdr = rdr->next)
+	{
+		if (rdr->typ == typ) return (rdr);
+	}
+	return (NULL);
+}
+
+uint32_t
+cs_i2BCD(uint32_t val)
+{
+	uint32_t result;
+	char asc2h[32];
+
+	sprintf(asc2h, "%08d", val);
+	result = cs_atoi(asc2h, 4, 1);
+	return (result);
+}
+
+
+
+void
+CSREADER_ChDescrambled(int32_t typ, int descramble)
+{
+	struct s_reader *rdr;
+
+	rdr = CSREADER_ChkActive(typ);
+	if (!rdr) return;
+	rdr->ch_descramble = descramble;
+}
+
+#endif
+
Index: oscam-reader.h
===================================================================
--- oscam-reader.h	(revision 1542)
+++ oscam-reader.h	(working copy)
@@ -1,6 +1,28 @@
 #ifndef _OSCAM_READER_H_
 #define _OSCAM_READER_H_
 
+// sky(n)
+#if defined(WITH_HISILICON)
+#define CS_INFORMATIONDIR		"/var/"
+#else
+#define CS_INFORMATIONDIR		"/tmp/"
+#endif
+#define cs_SMCINFORMATION		"oscam.smartcard"
+#define cs_XCAMDSERVICES		"oscam.ibservices"
+#define cs_MORECAMSERVICES		"oscam.imservices"
+#define cs_CASERVICES			"oscam.caservices"
+#define cs_OSCAMSERVER 			"oscam.server"
+
+
+#define IS_SOCKET_OK(s)			((s)> 0)
+#define IS_SOCKET_FAIL(s)		((s)<=0)
+#define IS_SOCKET_ERRORNO(e)	((errno)==(e))
+
+#define INET_TIMEOUT 			-1
+#define INET_DISCONNECTED 		-2
+#define IS_INET_OK(nstatus)	((nstatus)> 0)
+//
+
 const struct s_cardsystem *get_cardsystem_by_caid(uint16_t caid);
 struct s_reader *get_reader_by_label(char *lbl);
 const char *reader_get_type_desc(struct s_reader *rdr, int32_t extended);
@@ -9,8 +31,11 @@
 void hexserial_to_newcamd(uchar *source, uchar *dest, uint16_t caid);
 void newcamd_to_hexserial(uchar *source, uchar *dest, uint16_t caid);
 
-S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, uint8_t add);
+S_ENTITLEMENT *cs_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint64_t id, uint32_t class, time_t start, time_t end, uint8_t type, char *comments, uint8_t add);
 void cs_clear_entitlement(struct s_reader *rdr);
+// sky(oscam.smartcard)
+void 	cs_clean_cardinformation(void);
+int  	cs_save_cardinformation (struct s_reader *rdr);
 
 int32_t hostResolve(struct s_reader *reader);
 int32_t network_tcp_connection_open(struct s_reader *);
@@ -30,4 +55,11 @@
 void init_cardreader(void);
 void kill_all_readers(void);
 
+#if defined(MODULE_CONSTCW)
+struct s_reader *CSREADER_ChkActive(int32_t typ);
+struct s_reader *CSREADER_GetReaders(int32_t typ);
+
+void CSREADER_ChDescrambled(int32_t typ, int descramble);
 #endif
+
+#endif
Index: oscam-simples.c
===================================================================
--- oscam-simples.c	(revision 1542)
+++ oscam-simples.c	(working copy)
@@ -302,6 +302,38 @@
 	return (buf);
 }
 
+// sky(oscam.smartcard)
+char *get_provider_existnace(uint16_t caid, uint32_t provid, char *buf, uint32_t buflen)
+{
+	uint8_t found = 0;
+	int32_t i;
+	struct s_provid *this = cfg.provid;
+
+	if(!caid) {
+		buf[0] = '\0';
+		return (buf);
+	}
+
+	for(buf[0] = 0; this && !found; this = this->next)
+	{
+		if(this->caid == caid)
+		{
+			for(i=0; i<this->nprovid && !found; i++)
+			{
+				if(this->provid[i] == provid)
+				{
+					snprintf(buf, buflen, "%s%s%s%s%s", this->prov,
+							 *this->sat && this->sat[0] ? " / " : "", this->sat,
+							 this->lang[0] ? " / " : "", this->lang);
+					found = 1;
+				}
+			}
+		}
+	}
+	
+	return (buf);
+}
+
 char *__get_providername(uint32_t provid, uint16_t caid, char *buf, uint32_t buflen, bool return_unknown)
 {
 	uint8_t found = 0;
Index: oscam-string.c
===================================================================
--- oscam-string.c	(revision 1542)
+++ oscam-string.c	(working copy)
@@ -315,6 +315,21 @@
 	return b;
 }
 
+uint32_t cs_BCD2i(uint32_t bcd)
+{
+	uint32_t result;
+
+	result  =  ((bcd >> 28) & 0xf) * 10000000;
+	result +=  ((bcd >> 24) & 0xf) * 1000000;
+	result +=  ((bcd >> 20) & 0xf) * 100000;
+	result += (((bcd >> 16) & 0xf) * 10000);
+	result += (((bcd >> 12) & 0xf) * 1000);
+	result += (((bcd >>  8) & 0xf) * 100);
+	result += (((bcd >>  4) & 0xf) * 10);
+	result +=	(bcd & 0xf);
+	return (result);
+}
+
 void ull2b_buf(uint64_t i, uchar *b)
 {
 	b[0] = (i >> 56) & 0xff;
@@ -410,6 +425,71 @@
 	}
 }
 
+//
+// sky(n)
+// crc32table_be
+static const unsigned int dvb_crc_table[256] = {
+    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+    0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+    0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
+    0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
+    0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+    0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
+    0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
+    0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+    0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+    0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
+    0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+    0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
+    0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
+    0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+    0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
+    0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+    0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+    0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
+    0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
+    0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+    0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
+    0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
+    0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+    0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+    0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
+    0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+    0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
+    0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
+    0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+    0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
+    0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+    0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+    0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+
+uint32_t dvb_crc32(uint8_t *data, uint32_t lsize)
+{
+	uint32_t i;
+	uint32_t	crc = 0xffffffff;
+	uint8_t  *ptr = data;
+
+	for (i = 0; i < lsize; ++i)
+	{
+		crc = (crc << 8) ^ dvb_crc_table[((crc >> 24) ^ *ptr++) & 0xff];
+	}
+	return crc;
+}
+//
+//
+// crc32table_le
+
 static uint32_t crc_table[256] =
 {
 	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
@@ -480,6 +560,8 @@
 {
 	if(!buf)
 		{ return 0L; }
+	if (!len)
+		{ return 0L; }
 	crc = crc ^ 0xffffffffL;
 	while(len >= 8)
 	{
Index: oscam-string.h
===================================================================
--- oscam-string.h	(revision 1542)
+++ oscam-string.h	(working copy)
@@ -40,7 +40,9 @@
 uint32_t fletcher_crc32(uint8_t *data, uint32_t len);
 uint16_t ccitt_crc(uint8_t *data, size_t length, uint16_t seed, uint16_t final);
 uint32_t jhash(const char *key, size_t len);
-
+// sky(n)
+uint32_t dvb_crc32(uint8_t *data, uint32_t lsize);
+uint32_t cs_BCD2i(uint32_t bcd);
 char to_hex(char code);
 void char_to_hex(const unsigned char *p_array, uint32_t p_array_len, unsigned char *result);
 
Index: oscam-work.c
===================================================================
--- oscam-work.c	(revision 1542)
+++ oscam-work.c	(working copy)
@@ -15,6 +15,12 @@
 #include "module-cccshare.h"
 #include "oscam-time.h"
 
+#if 1
+	#define	MYWROKS_TRACE	myprintf
+#else
+	#define	MYWROKS_TRACE(...)
+#endif
+
 extern CS_MUTEX_LOCK system_lock;
 extern int32_t thread_pipe[2];
 
@@ -139,14 +145,16 @@
 				cl->work_mbuf = NULL; // Prevent free_client from freeing mbuf (->work_mbuf)
 				free_client(cl);
 				if(restart_reader)
-					{ restart_cardreader(reader, 0); }
+					{ restart_cardreader(reader, 1); }
 				NULLFREE(mbuf);
 				pthread_exit(NULL);
 				return NULL;
 			}
 
-			if(data && data->action != ACTION_READER_CHECK_HEALTH)
-				{ cs_log_dbg(D_TRACE, "data from add_job action=%d client %c %s", data->action, cl->typ, username(cl)); }
+			if (data &&
+				(data->action != ACTION_READER_CHECK_HEALTH && data->action != ACTION_READER_POLL_STATUS && data->action != ACTION_CLIENT_TIMEOUT)) {
+				cs_log_dbg(D_TRACE, "data from add_job action=%d client %c %s", data->action, cl->typ, username(cl));
+			}
 
 			if(!data)
 			{
@@ -230,7 +238,16 @@
 			}
 
 			if(data != &tmp_data)
-				{ cl->work_job_data = data; } // Track the current job_data
+				cl->work_job_data = data; // Track the current job_data
+			// sky(TEST)
+			if (data->action != ACTION_READER_IDLE &&
+				 data->action != ACTION_READER_REMOTE &&
+				 data->action != ACTION_READER_EMM &&
+				 data->action != ACTION_READER_POLL_STATUS &&
+				 data->action != ACTION_READER_CHECK_HEALTH)
+ 			{
+				MYWROKS_TRACE("ACTION=%d\n", data->action);
+			}
 			switch(data->action)
 			{
 			case ACTION_READER_IDLE:
@@ -344,7 +361,7 @@
 			case ACTION_CLIENT_INIT:
 				if(module->s_init)
 					{ module->s_init(cl); }
-				cl->is_udp = module->type == MOD_CONN_UDP;
+				cl->is_udp = (module->type == MOD_CONN_UDP) ? 1 : 0;
 				cl->init_done = 1;
 				break;
 			case ACTION_CLIENT_IDLE:
@@ -458,9 +475,12 @@
 		if(cl->thread_active == 2)
 			{ pthread_kill(cl->thread, OSCAM_SIGNAL_WAKEUP); }
 		SAFE_MUTEX_UNLOCK(&cl->thread_lock);
+		// sky(log)
+		if (action != ACTION_READER_POLL_STATUS /* && action!=ACTION_READER_IDLE */) {
 		cs_log_dbg(D_TRACE, "add %s job action %d queue length %d %s",
 					  action > ACTION_CLIENT_FIRST ? "client" : "reader", action,
 					  ll_count(cl->joblist), username(cl));
+		}
 		return 1;
 	}
 	
@@ -470,7 +490,7 @@
 	if(cl->typ != 'r' || !rdr || rdr->typ != R_PCSC)
 		{ modify_stacksize = 1; }
 
-	if(action != ACTION_READER_CHECK_HEALTH)
+	if (action != ACTION_READER_CHECK_HEALTH && action != ACTION_READER_POLL_STATUS && data->action != ACTION_CLIENT_TIMEOUT)
 	{
 		cs_log_dbg(D_TRACE, "start %s thread action %d",
 					  action > ACTION_CLIENT_FIRST ? "client" : "reader", action);
Index: oscam.c
===================================================================
--- oscam.c	(revision 1542)
+++ oscam.c	(working copy)
@@ -2,7 +2,7 @@
 
 #include "globals.h"
 #include <getopt.h>
-
+#include <sys/system_properties.h>
 #include "csctapi/cardreaders.h"
 #include "modules.h"
 #include "readers.h"
@@ -15,6 +15,9 @@
 #include "module-dvbapi-azbox.h"
 #include "module-dvbapi-mca.h"
 #include "module-dvbapi-chancache.h"
+#if defined(WITH_HISILICON)
+#include "module-dvbapi-his.h"
+#endif
 #include "module-gbox-sms.h"
 #include "module-ird-guess.h"
 #include "module-lcd.h"
@@ -100,9 +103,10 @@
 #else
 uint8_t cs_http_use_utf8 = 0;
 #endif
-static int8_t cs_capture_SEGV;
-static int8_t cs_dump_stack;
-static uint16_t cs_waittime = 60;
+static int8_t cs_capture_SEGV = 0;
+static int8_t cs_dump_stack = 0;
+int32_t cs_timefaults = 0;		// sky(A)
+static uint16_t cs_waittime = 1;	// sky(60)
 char  cs_tmpdir[200] = {0x00};
 CS_MUTEX_LOCK system_lock;
 CS_MUTEX_LOCK config_lock;
@@ -132,14 +136,41 @@
 int log_remove_sensitive = 1;
 
 static char *prog_name;
-static char *stb_boxtype;
-static char *stb_boxname;
+static char *stb_boxtype= NULL;
+static char *stb_boxname= NULL;
 
 static uint32_t oscam_stacksize = 0;
+bool g_smartcard_supported = true;
+bool g_factoy_products = false;
 
 /*****************************************************************************
         Statics
 *****************************************************************************/
+// sky(sim)
+bool chker_smartcard_enable(void)
+{
+	bool enabled = true;
+	char smcprop[PROP_VALUE_MAX] = {0};
+	if (__system_property_get("ro.buyer.sim",smcprop) > 0) {
+		if (!strcmp("irum", smcprop)) enabled = false;
+	}
+	if (__system_property_get("persist.sci.slot",smcprop) > 0) {
+		if (!strcmp("irum", smcprop)) enabled = false;
+		if (!strcmp("none", smcprop)) enabled = false;
+	}
+	g_smartcard_supported = enabled;
+	return enabled;
+}
+
+bool chker_factoy_products(void)
+{
+	char fabprop[PROP_VALUE_MAX] = {0};
+	g_factoy_products = false;
+	if (__system_property_get("persist.sys.product.mode",fabprop) > 0) {
+		if (!strcmp("true", fabprop)) g_factoy_products = true;
+	}
+	return g_factoy_products;
+}
 /* Prints usage information and information about the built-in modules. */
 static void show_usage(void)
 {
@@ -354,7 +385,7 @@
     fprintf(fp, "%-40s %s\n", text ":", config_enabled(CONFIG_VAR) ? "yes" : "no - no EMM support!")
 
 #define write_cardreaderconf(CONFIG_VAR, text) \
-    fprintf(fp, "%s%-29s %s\n", "cardreader_", text ":", config_enabled(CONFIG_VAR) ? "yes" : "no")
+    fprintf(fp, "%-40s %s\n", text ":", config_enabled(CONFIG_VAR) ? "yes" : "no")
 
 static void write_versionfile(bool use_stdout)
 {
@@ -376,7 +407,12 @@
 				st.tm_mday, st.tm_mon + 1, st.tm_year + 1900,
 				st.tm_hour, st.tm_min, st.tm_sec);
 	}
-
++	// sky(a)
++	// sky(sim)
+#if defined(__HISILICON_MANUFACTORY__)
+	fprintf(fp, "Version:        oscam-%s.%s(f)\n", CS_VERSION, CS_SVN_VERSION);
+	fprintf(fp, "ConfigDir:      %s\n", cs_confdir);
+#else
 	fprintf(fp, "Version:        oscam-%s-r%s\n", CS_VERSION, CS_SVN_VERSION);
 	fprintf(fp, "Compiler:       %s\n", CS_TARGET);
 	fprintf(fp, "Box type:       %s (%s)\n", boxtype_get(), boxname_get());
@@ -400,6 +436,14 @@
 #endif
 
 	fprintf(fp, "\n");
+	// sky(sim)
+	if (g_factoy_products) {
+		fprintf(fp, "Factory products\n");
+		if (!use_stdout) fclose(fp);
+		return;
+	}
+	// sky(sim)
+	fprintf(fp, "%-40s %s\n", "Smartcard support:", g_smartcard_supported ? "yes" : "no");
 	write_conf(WEBIF, "Web interface support");
 	write_conf(WEBIF_LIVELOG, "LiveLog support");
 	write_conf(WEBIF_JQUERY, "jQuery support intern");
@@ -408,6 +452,7 @@
 	write_conf(HAVE_DVBAPI, "DVB API support");
 	if(config_enabled(HAVE_DVBAPI))
 	{
+		write_conf(WITH_HISILICON, "DVB API with HISKY support");
 		write_conf(WITH_AZBOX, "DVB API with AZBOX support");
 		write_conf(WITH_MCA, "DVB API with MCA support");
 		write_conf(WITH_COOLAPI, "DVB API with COOLAPI support");
@@ -470,6 +515,7 @@
 		fprintf(fp, "\n");
 		write_cardreaderconf(CARDREADER_PHOENIX, "phoenix");
 		write_cardreaderconf(CARDREADER_DRECAS, "drecas");
+		write_cardreaderconf(CARDREADER_INTERNAL_HISKY, "Internal HISKY support");
 		write_cardreaderconf(CARDREADER_INTERNAL_AZBOX, "internal_azbox");
 		write_cardreaderconf(CARDREADER_INTERNAL_COOLAPI, "internal_coolapi");
 		write_cardreaderconf(CARDREADER_INTERNAL_COOLAPI2, "internal_coolapi2");
@@ -488,6 +534,7 @@
 	{
 		write_readerconf(WITH_CARDREADER, "Reader Support");
 	}
+#endif // defined(__HISILICON_MANUFACTORY__)
 	if(!use_stdout)
 		{ fclose(fp); }
 }
@@ -509,6 +556,8 @@
 
 static void do_report_emm_support(void)
 {
+#if defined(__HISILICON_MANUFACTORY__)
+#else
 	if(!config_enabled(WITH_CARDREADER))
 	{
 		cs_log("Binary without Cardreader Support! No EMM processing possible!");
@@ -529,6 +578,7 @@
 		report_emm_support(READER_GRIFFIN, "Griffin");
 		report_emm_support(READER_DGCRYPT, "DGCrypt");
 	}
+#endif // defined(__HISILICON_MANUFACTORY__)
 }
 #undef report_emm_support
 
@@ -646,6 +696,17 @@
 	fprintf(fp, "FATAL: Signal %d: %s Fault. Logged StackTrace:\n\n", sig, (sig == SIGSEGV) ? "Segmentation" : ((sig == SIGBUS) ? "Bus" : "Unknown"));
 	fclose(fp);
 
+#if defined(WITH_HISILICON)
+	FILE *cmd = fopen("/var/gdbcmd", "w");
+	fputs ("bt\n", cmd);
+	fputs ("thread apply all bt\n", cmd);
+	fclose(cmd);
+
+	snprintf(buf, sizeof(buf)-1, "gdb %s %d -batch -x /var/gdbcmd >> oscam.crash", prog_name, getpid());
+	if (system(buf) == -1)
+		fprintf(stderr, "Fatal error on trying to start gdb process.");
+	exit(-1);
+#else
 	FILE *cmd = fopen("/tmp/gdbcmd", "w");
 	fputs("bt\n", cmd);
 	fputs("thread apply all bt\n", cmd);
@@ -656,6 +717,7 @@
 		{ fprintf(stderr, "Fatal error on trying to start gdb process."); }
 
 	exit(-1);
+#endif
 }
 
 
@@ -823,6 +885,18 @@
 
 static void init_machine_info(void)
 {
+	#if defined(WITH_HISILICON)
+		#if defined(SDKV600)
+			stb_boxtype = cs_strdup("hisilicon");
+			stb_boxname = cs_strdup("quads");
+		#elif defined(SDKV500)
+			stb_boxtype = cs_strdup("hisilicon");
+			stb_boxname = cs_strdup("u4plus");
+		#else
+			stb_boxtype = cs_strdup("hisilicon");
+			stb_boxname = cs_strdup("u4");
+		#endif
+	#else
 	struct utsname buffer;
 	if (uname(&buffer) == 0)
 	{
@@ -927,6 +1001,7 @@
 		stb_boxtype = cs_strdup(boxtype);
 	else if (model[0])
 		stb_boxtype = cs_strdup(model);
+	#endif
 }
 
 const char *boxtype_get(void)
@@ -954,9 +1029,6 @@
 {
 	char *ptr = __DATE__;
 	int32_t month, year = atoi(ptr + strlen(ptr) - 4), day = atoi(ptr + 4);
-	if(day > 0 && day < 32 && year > 2010 && year < 9999)
-	{
-		struct tm timeinfo;
 		char months[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 		for(month = 0; month < 12; ++month)
 		{
@@ -963,25 +1035,42 @@
 			if(!strncmp(ptr, months[month], 3)) { break; }
 		}
 		if(month > 11) { month = 0; }
+	if (day > 0 && day < 32 && year > 2010 && year < 9999)
+	{
+		struct tm timeinfo;
 		memset(&timeinfo, 0, sizeof(timeinfo));
 		timeinfo.tm_mday = day;
 		timeinfo.tm_mon = month;
 		timeinfo.tm_year = year - 1900;
 		time_t builddate = mktime(&timeinfo) - 86400;
+
+#if defined(SDKV500) || defined(SDKV600)
+		if (time((time_t *)0) < builddate) {
+			cs_log("The current system time is smaller than the build date (%s).", ptr);
+			cs_timefaults = 1;
+		}
+		first_client->login = time((time_t *)0);
+#else
 		int32_t i = 0;
 		while(time((time_t *)0) < builddate)
 		{
-			if(i == 0) { cs_log("The current system time is smaller than the build date (%s). Waiting up to %d seconds for time to correct", ptr, cs_waittime); }
-			cs_sleepms(1000);
+			if (i == 0) {
+				cs_log("The current system time is smaller than the build date (%s).", ptr);
+				cs_log("Waiting up to %d seconds for time to correct", cs_waittime);
+			}
 			++i;
 			if(i > cs_waittime)
 			{
-				cs_log("Waiting was not successful. OSCam will be started but is UNSUPPORTED this way. Do not report any errors with this version.");
+				cs_log("Waiting was not successful. OSCam will be started but is UNSUPPORTED this way.");
++			//	cs_log("Do not report any errors with this version.");
++				cs_timefaults = 1;
 				break;
 			}
+			cs_sleepms(1000);
 		}
 		// adjust login time of first client
 		if(i > 0) { first_client->login = time((time_t *)0); }
+#endif
 	}
 }
 
@@ -1210,6 +1299,8 @@
 	pfd[pfdcount].events = POLLIN | POLLPRI;
 	cl_list[pfdcount] = NULL;
 
+	// main loop function
+	mycs_log("main process_clients...");
 	while(!exit_oscam)
 	{
 		pfdcount = 1;
@@ -1331,7 +1422,7 @@
 				{
 					//connection to remote proxy was closed
 					//oscam should check for rdr->tcp_connected and reconnect on next ecm request sent to the proxy
-					network_tcp_connection_close(rdr, "closed");
+					network_tcp_connection_close(rdr, "clients closed");
 					rdr_log_dbg(rdr, D_READER, "connection closed");
 				}
 				if(cl2->pfd && pfd[i].fd == cl2->pfd && (pfd[i].revents & (POLLIN | POLLPRI)))
@@ -1549,7 +1640,7 @@
 #endif
 }
 
-#ifdef BUILD_TESTS
+/*#ifdef BUILD_TESTS
 extern void run_all_tests(void);
 __attribute__ ((noreturn)) static void run_tests(void)
 {
@@ -1559,7 +1650,42 @@
 #else
 static void run_tests(void) { }
 #endif
+*/
+#if defined(WITH_HISILICON)
+static void cs_confs_existance(void)
+{
+	struct stat sb;
+	char srvfiles[256] = { 0 };
+	char commands[256] = { 0 };
 
+	if (!stat(cs_confdir, &sb)) {
+		snprintf(srvfiles, sizeof(srvfiles), "%s%s", cs_confdir, cs_OSCAMSERVER);
+		if (access(srvfiles, 0) == 0) {
+			myprintf("oscam:%s existance.\n", cs_OSCAMSERVER);
+			return;
+		}
+	}
+	else {
+		myprintf("oscam:mkdir %s\n", cs_confdir);
+		snprintf(commands, sizeof(commands), "mkdir -p %s", cs_confdir);
+		system(commands);
+	}
+	myprintf("oscam:confs copy...\n");
+	#if defined(SDKV600)
+		snprintf(commands, sizeof(commands), "cp -f %s/* %s", CS_OSCAMDIR, cs_confdir);
+	#else
+		if (access(CS_XBMCUSERDIR, F_OK)==0) {
+			snprintf(commands, sizeof(commands), "cp -f %s/* %s", CS_XBMCUSERDIR, cs_confdir);
+		}
+		else {
+			snprintf(commands, sizeof(commands), "cp -f %s/* %s", CS_OSCAMDIR, cs_confdir);
+		}
+		system(commands);
+	#endif
+}
+#endif
+
+
 const struct s_cardsystem *cardsystems[] =
 {
 #ifdef READER_NAGRA_MERLIN
@@ -1614,7 +1740,9 @@
 #ifdef CARDREADER_DB2COM
 	&cardreader_db2com,
 #endif
-#if defined(CARDREADER_INTERNAL_AZBOX)
+#if defined(CARDREADER_INTERNAL_HISKY)
+	&cardreader_internal_hisky,
+#elif defined(CARDREADER_INTERNAL_AZBOX)
 	&cardreader_internal_azbox,
 #elif defined(CARDREADER_INTERNAL_COOLAPI)
 	&cardreader_internal_cool,
@@ -1701,7 +1829,7 @@
 {
 	fix_stacksize();
 
-	run_tests();
+//	run_tests();
 	int32_t i, j;
 	prog_name = argv[0];
 	struct timespec start_ts;
@@ -1715,6 +1843,9 @@
 
 	void (*mod_def[])(struct s_module *) =
 	{
+		#ifdef HAVE_DVBAPI
+		   	 module_dvbapi,	// sky(move)
+		#endif
 #ifdef MODULE_MONITOR
 		module_monitor,
 #endif
@@ -1757,9 +1888,6 @@
 #ifdef MODULE_SERIAL
 		module_serial,
 #endif
-#ifdef HAVE_DVBAPI
-		module_dvbapi,
-#endif
 		0
 	};
 
@@ -1798,10 +1926,17 @@
 	cs_lock_create(__func__, &cwcycle_lock, "cwcycle_lock", 5000);
 	init_cache();
 	cacheex_init_hitcache();
+#if defined(WITH_HISILICON)
+	cs_confs_existance();
+#endif
+	init_machine_info();
 	init_config();
 	cs_init_log();
-	init_machine_info();
 	init_check();
+	// sky(sim)
+	chker_factoy_products();
+	chker_smartcard_enable();
+//	cs_clean_cardinformation(); // sky(n)
 	if(!oscam_pidfile && cfg.pidfile)
 		{ oscam_pidfile = cfg.pidfile; }
 	if(!oscam_pidfile)
@@ -1847,6 +1982,11 @@
 	led_init();
 	led_status_default();
 
+//	#if defined(WITH_HISILICON)
+//	for cur_client() != dvbapi_client
+//		hidemuxapi_Init();
+//	#endif
+
 	azbox_init();
 
 	mca_init();
@@ -1902,7 +2042,11 @@
 		if((module->type & MOD_CONN_SERIAL) && module->s_handler)
 			{ module->s_handler(NULL, NULL, i); }
 	}
-
+	//
+	// sky(sim)
+	if (g_factoy_products) {
+		free_reader_for_factoy_products();
+	}
 	// main loop function
 	process_clients();
 
Index: reader-bulcrypt.c
===================================================================
--- reader-bulcrypt.c	(revision 1542)
+++ reader-bulcrypt.c	(working copy)
@@ -242,6 +242,8 @@
 		if(!isdigit((uchar)card_serial[i]))
 			{ card_serial[i] = '*'; }
 	}
+	// sky(oscam.smartcard)
+	strcpy(reader->ascserial, card_serial);
 
 	// Write empty ECM, *FIXME* why are we doing this? To prepare the card somehow?
 	write_cmd(cmd_ecm_empty, NULL);
@@ -741,6 +743,7 @@
 								   last_upd_ts, /* start_ts */
 								   subs_end_ts, /* end_ts */
 								   4, /* type: Tier */
+								   NULL,
 								   1  /* add */
 								  );
 				cs_add_entitlement(reader, 0x5581,
@@ -750,6 +753,7 @@
 								   last_upd_ts, /* start_ts */
 								   subs_end_ts, /* end_ts */
 								   4, /* type: Tier */
+								   NULL,
 								   1  /* add */
 								  );
 				get_tiername(i, 0x4aee, tmp);
Index: reader-common.c
===================================================================
--- reader-common.c	(revision 1542)
+++ reader-common.c	(working copy)
@@ -2,6 +2,8 @@
 
 #ifdef WITH_CARDREADER
 
+#include "cscrypt/bn.h"
+#include "csctapi/icc_async.h"
 #include "module-gbox.h"
 #include "module-led.h"
 #include "oscam-chk.h"
@@ -14,12 +16,18 @@
 #include "oscam-reader.h"
 #include "reader-common.h"
 //#include "csctapi/atr.h"
-#include "csctapi/icc_async.h"
+//#include "csctapi/icc_async.h"
 #include "readers.h"
 
 extern const struct s_cardsystem *cardsystems[];
 extern char *RDR_CD_TXT[];
 
+#if defined(WITH_HISILICON)
+extern uint16_t HISCIAPI_ChkCardstatus (struct s_reader *reader);
+extern char *   HISCIAPI_ChkCardsystem (struct s_reader *reader);
+extern bool     HISCIAPI_SaveCardstatus(struct s_reader *reader);
+#endif
+
 int32_t check_sct_len(const uchar *data, int32_t off)
 {
 	int32_t len = SCT_LEN(data);
@@ -40,6 +48,8 @@
 	reader->caid = 0;
 	reader->nprov = 0;
 	cs_clear_entitlement(reader);
+// sky(n)
+	cs_clean_cardinformation();
 }
 
 int32_t reader_cmd2icc(struct s_reader *reader, const uchar *buf, const int32_t l, uchar *cta_res, uint16_t *p_cta_lr)
@@ -112,7 +122,7 @@
 	if(ret) { return (0); }
 
 	//  rdr_log("ATR: %s", cs_hexdump(1, atr, atr_size, tmp, sizeof(tmp)));//FIXME
-	cs_sleepms(1000);
+	cs_sleepms(800);
 	return (1);
 }
 
@@ -128,6 +138,8 @@
 		{
 			reader->csystem->card_info(reader);
 		}
+		// sky(oscam.smartcard)
+		cs_save_cardinformation(reader);
 	}
 }
 
@@ -233,6 +245,11 @@
 		rdr_log(reader, "card initializing error");
 		ICC_Async_DisplayMsg(reader, "AER");
 		led_status_card_activation_error();
+// sky(oscam.smartcard)
+#if defined(WITH_HISILICON)
+		HISCIAPI_SaveCardstatus(reader);
+#endif
+		cs_save_cardinformation(reader);
 	}
 	else
 	{
@@ -240,6 +257,10 @@
 		reader->card_status = CARD_INSERTED;
 		do_emm_from_file(reader);
 		ICC_Async_DisplayMsg(reader, "AOK");
+// sky(oscam.smartcard)
+#if defined(WITH_HISILICON)
+		HISCIAPI_SaveCardstatus(reader);
+#endif
 	}
 
 	return;
@@ -248,6 +269,10 @@
 static int32_t cardreader_device_init(struct s_reader *reader)
 {
 	int32_t rc = -1; //FIXME
+	reader->card_status = NO_CARD;
+#if defined(WITH_HISILICON)
+	HISCIAPI_SaveCardstatus(reader);
+#endif
 	if(ICC_Async_Device_Init(reader))
 		{ rdr_log(reader, "Cannot open device: %s", reader->device); }
 	else
@@ -257,6 +282,7 @@
 
 int32_t cardreader_do_checkhealth(struct s_reader *reader)
 {
+	if (!reader) return 0;
 	struct s_client *cl = reader->client;
 	if(reader_card_inserted(reader))
 	{
@@ -265,6 +291,9 @@
 			rdr_log(reader, "card detected");
 			led_status_card_detected();
 			reader->card_status = CARD_NEED_INIT;
+#if defined(WITH_HISILICON)
+			HISCIAPI_SaveCardstatus(reader);
+#endif
 			add_job(cl, ACTION_READER_RESET, NULL, 0);
 		}
 	}
@@ -284,6 +313,9 @@
 				cl->lastecm = 0;
 			}
 			led_status_card_ejected();
+#if defined(WITH_HISILICON)
+			HISCIAPI_SaveCardstatus(reader);
+#endif
 			gbx_local_card_changed();
 		}
 		reader->card_status = NO_CARD;
@@ -326,10 +358,16 @@
 	}
 	if (i >= 10)
 	{
+#if defined(WITH_HISILICON)
+		if (!IS_CARD_READER(reader))
+#endif
+		{
+			myprintf("cardreader_init.%s fail.\n", reader->label);
 		reader->card_status = READER_DEVICE_ERROR;
 		cardreader_close(reader);
 		reader->enable = 0;
 		return false;
+		}
 	}
 	else 
 	{
@@ -408,8 +446,8 @@
 					rdr_log(reader,"Reader sci internal, detected box type: %s", boxtype_get());
 			}
 		}
-		return true;
 	}
+	return true;
 }
 
 void cardreader_close(struct s_reader *reader)
Index: reader-common.h
===================================================================
--- reader-common.h	(revision 1542)
+++ reader-common.h	(working copy)
@@ -5,6 +5,8 @@
 #define SKIPPED 2
 #define OK      1
 #define ERROR   0
+// sky(n)
+#define RETRY   3
 
 #include "csctapi/atr.h"
 #include "oscam-string.h"
Index: reader-conax.c
===================================================================
--- reader-conax.c	(revision 1542)
+++ reader-conax.c	(working copy)
@@ -501,7 +501,7 @@
 								rdr_log(reader, "%s: %d, id: %04X%s, date: %s - %s, name: %s", txt[type], ++n, provid, chid, pdate, pdate + 16, trim(provname));
 
 								// add entitlements to list
-								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type + 1, 1);
+								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type + 1, provname, 1);
 
 								k = 0;
 								chid[0] = '\0';
@@ -520,7 +520,7 @@
 					rdr_log(reader, "%s: %d, id: %04X%s, date: %s - %s, name: %s", txt[type], ++n, provid, chid, pdate, pdate + 16, trim(provname));
 
 					// add entitlements to list
-					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type + 1, 1);
+					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), provid, cxclass, start_t, end_t, type + 1, provname, 1);
 				}
 			}
 		}
Index: reader-cryptoworks.c
===================================================================
--- reader-cryptoworks.c	(revision 1542)
+++ reader-cryptoworks.c	(working copy)
@@ -709,9 +709,9 @@
 					char ds[16], de[16];
 
 					// todo: add entitlements to list but produces a warning related to date variable
-					cs_add_entitlement(reader, reader->caid, reader->prid[i][3], b2i(2, cta_res + 6), 0,
+					cs_add_entitlement(reader, reader->caid, reader->prid[i][3], b2i(2, cta_res + 7), 0,
 									   chid_date(cta_res + 28, ds, sizeof(ds) - 1),
-									   chid_date(cta_res + 30, de, sizeof(de) - 1), 3, 1);
+									   chid_date(cta_res + 30, de, sizeof(de) - 1), 3, NULL, 1);
 
 					rdr_log(reader, "chid: %02X%02X, date: %s - %s, name: %s",
 							cta_res[6], cta_res[7], ds, de, trim((char *) cta_res + 10));
@@ -734,7 +734,7 @@
 					// todo: add entitlements to list but produces a warning related to date variable
 					cs_add_entitlement(reader, reader->caid, reader->prid[i][3], b2i(2, cta_res + 6), 0,
 									   chid_date(cta_res + 28, ds, sizeof(ds) - 1),
-									   chid_date(cta_res + 30, de, sizeof(de) - 1), 3, 1);
+									   chid_date(cta_res + 30, de, sizeof(de) - 1), 3, NULL, 1);
 
 					cta_res[27] = 0;
 					rdr_log(reader, "chid: %02X%02X, date: %s - %s, name: %s",
Index: reader-dre-cas.c
===================================================================
--- reader-dre-cas.c	(revision 1542)
+++ reader-dre-cas.c	(working copy)
@@ -364,7 +364,7 @@
 				int32_t endday = temp.tm_mday;
 				rdr_log(reader, "active package %i valid from %04i/%02i/%02i to %04i/%02i/%02i", i, startyear, startmonth, startday,
 						endyear, endmonth, endday);
-				cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, i, start, end, 5, 1);
+				cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, i, start, end, 5, NULL, 1);
 			}
 	}
 	
Index: reader-dre.c
===================================================================
--- reader-dre.c	(revision 1542)
+++ reader-dre.c	(working copy)
@@ -251,7 +251,7 @@
 				int32_t endday = temp.tm_mday;
 				rdr_log(reader, "active package %i valid from %04i/%02i/%02i to %04i/%02i/%02i", i+n, startyear, startmonth, startday,
 						endyear, endmonth, endday);
-				cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, i+n, start, end, 5, 1);
+				cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, i+n, start, end, 5, NULL, 1);
 			}
 	}
 	
Index: reader-irdeto.c
===================================================================
--- reader-irdeto.c	(revision 1542)
+++ reader-irdeto.c	(working copy)
@@ -1273,7 +1273,7 @@
 							end_t = chid_date(reader, date + cta_res[k + 4], t + 16, 16);
 
 							// todo: add entitlements to list but produces a warning related to date variable
-							cs_add_entitlement(reader, reader->caid, b2i(3, &reader->prid[i][1]), chid, 0, start_t, end_t, 3, 1);
+							cs_add_entitlement(reader, reader->caid, b2i(3, &reader->prid[i][1]), chid, 0, start_t, end_t, 3, NULL, 1);
 
 							if(first)
 							{
Index: reader-nagra.c
===================================================================
--- reader-nagra.c	(revision 1542)
+++ reader-nagra.c	(working copy)
@@ -633,6 +633,7 @@
 							   tier_date(b2i(2, cta_res + 20) - 0x7f7, ds, 15),
 							   tier_date(b2i(2, cta_res + 13) - 0x7f7 + offset, de, 15),
 							   4,
+							   NULL,
 							   1);
 
 
@@ -1001,7 +1002,7 @@
 							rdr_log(reader, "Activation     : ( %04X ) from %s to %s  (%3d euro) %s",
 									records[i].value, records[i].date1, records[i].date2, euro, get_tiername(records[i].value, reader->caid, tiername));
 						}
-						cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, 1);
+						cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, NULL, 1);
 					}
 					break;
 
@@ -1014,7 +1015,7 @@
 							rdr_log(reader, "Tier : %04X, expiry date: %s %s",
 									records[i].value, records[i].date2, get_tiername(records[i].value, reader->caid, tiername));
 						}
-						cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, 1);
+						cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, NULL, 1);
 					}
 					break;
 				}
Index: reader-seca.c
===================================================================
--- reader-seca.c	(revision 1542)
+++ reader-seca.c	(working copy)
@@ -121,7 +121,7 @@
 	}
 	else
 		// add entitlement info
-		{ cs_add_entitlement(reader, reader->caid, provid, get_pbm(reader, i), 0, 0, mktime(&lt), (i) ? 6 : 7, 1); }
+		{ cs_add_entitlement(reader, reader->caid, provid, get_pbm(reader, i), 0, 0, mktime(&lt), (i) ? 6 : 7, NULL, 1); }
 
 	return OK;
 }
Index: reader-viaccess.c
===================================================================
--- reader-viaccess.c	(revision 1542)
+++ reader-viaccess.c	(working copy)
@@ -151,7 +151,7 @@
 					tm.tm_mon = vd.month_e - 1; // january is 0 in tm_mon
 					tm.tm_mday = vd.day_e;
 					end_t = cs_timegm(&tm);
-					cs_add_entitlement(reader, reader->caid, provid, cls, cls, start_t, end_t, 5, 1);
+					cs_add_entitlement(reader, reader->caid, provid, cls, cls, start_t, end_t, 5, NULL, 1);
 				}
 			}
 }
@@ -171,7 +171,7 @@
 			{
 				uchar cls;
 				cls = (l - (j + 1)) * 8 + i;
-				if(cs_add_entitlement(reader, reader->caid, provid, cls, cls, 0, 0, 5, 0) == NULL && !add)
+				if(cs_add_entitlement(reader, reader->caid, provid, cls, cls, 0, 0, 5, NULL, 0) == NULL && !add)
 				{
 					rdr_log(reader, "provid %06X class %02X not found", provid, cls);
 					freshdate = 1;
@@ -198,7 +198,7 @@
 					tm.tm_mday = vd.day_e;
 					end_t = cs_timegm(&tm);
 					
-					if(cs_add_entitlement(reader, reader->caid, provid, cls, cls, start_t, end_t, 5, add) != NULL)
+					if(cs_add_entitlement(reader, reader->caid, provid, cls, cls, start_t, end_t, 5, NULL, add) != NULL)
 					{
 						if(!add)
 						{
@@ -2009,7 +2009,7 @@
 		if(!added)
 		{
 			// add entitlement info for provid without class
-			cs_add_entitlement(reader, reader->caid, l_provid, 0, 0, 0, 0, 5, 1);
+			cs_add_entitlement(reader, reader->caid, l_provid, 0, 0, 0, 0, 5, NULL, 1);
 		}
 
 		insac[4] = 0;
Index: reader-videoguard1.c
===================================================================
--- reader-videoguard1.c	(revision 1542)
+++ reader-videoguard1.c	(working copy)
@@ -90,7 +90,7 @@
 		memset(&timeinfo, 0, sizeof(struct tm));
 		rev_date_calc_tm(&cta_res[4], &timeinfo, csystem_data->card_baseyear);
 		char tiername[83];
-		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, 1);
+		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, NULL, 1);
 		rdr_log(reader, "tier: %04x, expiry date: %04d/%02d/%02d-%02d:%02d:%02d %s", tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 	}
 }
Index: reader-videoguard12.c
===================================================================
--- reader-videoguard12.c	(revision 1542)
+++ reader-videoguard12.c	(working copy)
@@ -88,7 +88,7 @@
 		struct tm timeinfo;
 		memset(&timeinfo, 0, sizeof(struct tm));
 		rev_date_calc_tm(&cta_res[4], &timeinfo, csystem_data->card_baseyear);
-		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, 1);
+		cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, NULL, 1);
 		char tiername[83];
 		rdr_log(reader, "tier: %04x, expiry date: %04d/%02d/%02d-%02d:%02d:%02d %s", tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 	}
Index: reader-videoguard2.c
===================================================================
--- reader-videoguard2.c	(revision 1542)
+++ reader-videoguard2.c	(working copy)
@@ -287,7 +287,7 @@
 							{
 								tier_id = 0;
 								tier_id = ((TierClass<<8) + (word<<3) + bitnum);
-								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, 1);
+								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, NULL, 1);
 								rdr_log(reader, "|-- %02x ---|-- %04x --| %04d/%02d/%02d-%02d:%02d:%02d | %s", TierClass, tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 							}
 							if((cta_res[word+1+2] >> bitnum) & 1)
@@ -294,7 +294,7 @@
 							{
 								tier_id = 0;
 								tier_id = ((TierClass<<8) + (word<<3) + bitnum + 8);
-								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, 1);
+								cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, TierClass, start_t, end_t, 4, NULL, 1);
 								rdr_log(reader, "|-- %02x ---|-- %04x --| %04d/%02d/%02d-%02d:%02d:%02d | %s", TierClass, tier_id, timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, get_tiername(tier_id, reader->caid, tiername));
 							}
 						}
@@ -371,7 +371,7 @@
 				struct tm timeinfo;
 				memset(&timeinfo, 0, sizeof(struct tm));
 				rev_date_calc_tm(&cta_res[4], &timeinfo, csystem_data->card_baseyear);
-				cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, 1);
+				cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), tier_id, 0, 0, mktime(&timeinfo), 4, NULL, 1);
 
 				if(!stopemptytier)
 				{
Index: webif/files/menu.html
===================================================================
--- webif/files/menu.html	(revision 1542)
+++ webif/files/menu.html	(working copy)
@@ -10,7 +10,7 @@
 		<LI CLASS="##CMENUACTIVE7##"><A HREF="files.html?file=logfile">logfile</A></LI>
 		<LI CLASS="##CMENUACTIVE8##"><A HREF="files.html?file=userfile">userfile</A></LI>
 ##TPLFILEMENUGBOX##		<!-- CMENUACTIVE19-29 -->
-		<LI CLASS="##CMENUACTIVE9## ##CMENUACTIVE10## ##CMENUACTIVE11## ##CMENUACTIVE12## ##CMENUACTIVE13## ##CMENUACTIVE14## ##CMENUACTIVE15## ##CMENUACTIVE16## ##CMENUACTIVE17## ##CMENUACTIVE18## ##CMENUACTIVE30##"><A HREF="#"  class="drop">other files<b class="subcaret"></b></A>
+		<LI CLASS="##CMENUACTIVE9## ##CMENUACTIVE10## ##CMENUACTIVE11## ##CMENUACTIVE12## ##CMENUACTIVE13## ##CMENUACTIVE14## ##CMENUACTIVE15## ##CMENUACTIVE16## ##CMENUACTIVE17## ##CMENUACTIVE18## ##CMENUACTIVE30## ##CMENUACTIVE31##"><A HREF="#"  class="drop">other files<b class="subcaret"></b></A>
 			<UL CLASS="dropdown_nav">
 				<LI CLASS="##CMENUACTIVE9##"><A HREF="files.html?file=oscam.services">oscam.services</A></LI>
 				<LI CLASS="##CMENUACTIVE10##"><A HREF="files.html?file=oscam.provid">oscam.provid</A></LI>
@@ -23,6 +23,7 @@
 ##TPLFILEMENUTWIN##		<!-- CMENUACTIVE17 -->
 ##TPLFILEMENUCONSTCW##  	<!-- CMENUACTIVE18 -->
 ##TPLFILEMENUSOFTCAMKEY##		<!-- CMENUACTIVE30 -->
+				<LI CLASS="##CMENUACTIVE31##"><A HREF="files.html?file=oscam.smartcard">smartcard.info</A></LI>
 			</UL>
 		</LI>
 	</UL>
